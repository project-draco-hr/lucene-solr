{
  final int docCountCutoff=(int)((docCountPercent / 100.) * reader.maxDoc());
  final int termCountLimit=Math.min(BooleanQuery.getMaxClauseCount(),termCountCutoff);
  final CutOffTermCollector col=new CutOffTermCollector(docCountCutoff,termCountLimit);
  collectTerms(reader,query,col);
  final int size=col.pendingTerms.size();
  if (col.hasCutOff) {
    return CONSTANT_SCORE_FILTER_REWRITE.rewrite(reader,query);
  }
 else   if (size == 0) {
    return new BooleanQuery(true);
  }
 else {
    final BooleanQuery bq=new BooleanQuery(true);
    final Term placeholderTerm=new Term(query.field);
    final BytesRefHash pendingTerms=col.pendingTerms;
    final int sort[]=pendingTerms.sort(col.termsEnum.getComparator());
    for (int i=0; i < size; i++) {
      bq.add(new TermQuery(placeholderTerm.createTerm(pendingTerms.get(sort[i],new BytesRef())),1),BooleanClause.Occur.SHOULD);
    }
    final Query result=new ConstantScoreQuery(new QueryWrapperFilter(bq));
    result.setBoost(query.getBoost());
    query.incTotalNumberOfTerms(size);
    return result;
  }
}
