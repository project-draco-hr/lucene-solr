{
  if (tvx != null) {
    if (state.numDocs > 0) {
      fill(state.numDocs);
    }
    tvx.flush();
    tvd.flush();
    tvf.flush();
    tvx.close();
    tvf.close();
    tvd.close();
    tvx=null;
    String idxName=IndexFileNames.segmentFileName(state.segmentName,"",IndexFileNames.VECTORS_INDEX_EXTENSION);
    if (4 + ((long)state.numDocs) * 16 != state.directory.fileLength(idxName))     throw new RuntimeException("after flush: tvx size mismatch: " + state.numDocs + " docs vs "+ state.directory.fileLength(idxName)+ " length in bytes of "+ idxName+ " file exists?="+ state.directory.fileExists(idxName));
    String fldName=IndexFileNames.segmentFileName(state.segmentName,"",IndexFileNames.VECTORS_FIELDS_EXTENSION);
    String docName=IndexFileNames.segmentFileName(state.segmentName,"",IndexFileNames.VECTORS_DOCUMENTS_EXTENSION);
    state.flushedFiles.add(idxName);
    state.flushedFiles.add(fldName);
    state.flushedFiles.add(docName);
    docWriter.removeOpenFile(idxName);
    docWriter.removeOpenFile(fldName);
    docWriter.removeOpenFile(docName);
    lastDocID=0;
  }
  for (  final TermsHashConsumerPerField field : fieldsToFlush.values()) {
    TermVectorsTermsWriterPerField perField=(TermVectorsTermsWriterPerField)field;
    perField.termsHashPerField.reset();
    perField.shrinkHash();
  }
}
