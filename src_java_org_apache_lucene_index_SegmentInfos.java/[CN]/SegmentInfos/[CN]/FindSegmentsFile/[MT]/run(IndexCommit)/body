{
  if (commit != null) {
    if (directory != commit.getDirectory())     throw new IOException("the specified commit does not match the specified Directory");
    return doBody(commit.getSegmentsFileName());
  }
  String segmentFileName=null;
  long lastGen=-1;
  long gen=0;
  int genLookaheadCount=0;
  IOException exc=null;
  boolean retry=false;
  int method=0;
  while (true) {
    if (0 == method) {
      String[] files=null;
      long genA=-1;
      files=directory.listAll();
      if (files != null)       genA=getCurrentSegmentGeneration(files);
      message("directory listing genA=" + genA);
      long genB=-1;
      for (int i=0; i < defaultGenFileRetryCount; i++) {
        IndexInput genInput=null;
        try {
          genInput=directory.openInput(IndexFileNames.SEGMENTS_GEN);
        }
 catch (        FileNotFoundException e) {
          message("segments.gen open: FileNotFoundException " + e);
          break;
        }
catch (        IOException e) {
          message("segments.gen open: IOException " + e);
        }
        if (genInput != null) {
          try {
            int version=genInput.readInt();
            if (version == FORMAT_LOCKLESS) {
              long gen0=genInput.readLong();
              long gen1=genInput.readLong();
              message("fallback check: " + gen0 + "; "+ gen1);
              if (gen0 == gen1) {
                genB=gen0;
                break;
              }
            }
          }
 catch (          IOException err2) {
          }
 finally {
            genInput.close();
          }
        }
        try {
          Thread.sleep(defaultGenFileRetryPauseMsec);
        }
 catch (        InterruptedException ie) {
          Thread.currentThread().interrupt();
          throw new RuntimeException(ie);
        }
      }
      message(IndexFileNames.SEGMENTS_GEN + " check: genB=" + genB);
      if (genA > genB)       gen=genA;
 else       gen=genB;
      if (gen == -1) {
        String s;
        if (files != null) {
          s="";
          for (int i=0; i < files.length; i++)           s+=" " + files[i];
        }
 else         s=" null";
        throw new FileNotFoundException("no segments* file found in " + directory + ": files:"+ s);
      }
    }
    if (1 == method || (0 == method && lastGen == gen && retry)) {
      method=1;
      if (genLookaheadCount < defaultGenLookaheadCount) {
        gen++;
        genLookaheadCount++;
        message("look ahead increment gen to " + gen);
      }
    }
    if (lastGen == gen) {
      if (retry) {
        throw exc;
      }
 else {
        retry=true;
      }
    }
 else     if (0 == method) {
      retry=false;
    }
    lastGen=gen;
    segmentFileName=IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,"",gen);
    try {
      Object v=doBody(segmentFileName);
      if (exc != null) {
        message("success on " + segmentFileName);
      }
      return v;
    }
 catch (    IOException err) {
      if (exc == null) {
        exc=err;
      }
      message("primary Exception on '" + segmentFileName + "': "+ err+ "'; will retry: retry="+ retry+ "; gen = "+ gen);
      if (!retry && gen > 1) {
        String prevSegmentFileName=IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,"",gen - 1);
        final boolean prevExists;
        prevExists=directory.fileExists(prevSegmentFileName);
        if (prevExists) {
          message("fallback to prior segment file '" + prevSegmentFileName + "'");
          try {
            Object v=doBody(prevSegmentFileName);
            if (exc != null) {
              message("success on fallback " + prevSegmentFileName);
            }
            return v;
          }
 catch (          IOException err2) {
            message("secondary Exception on '" + prevSegmentFileName + "': "+ err2+ "'; will retry");
          }
        }
      }
    }
  }
}
