{
  return new ConstantScoreWeight(this){
    @Override public void extractTerms(    Set<Term> terms){
    }
    @Override public Scorer scorer(    LeafReaderContext context,    Bits acceptDocs,    float score) throws IOException {
      final LeafReader reader=context.reader();
      BitDocIdSet.Builder builder=new BitDocIdSet.Builder(reader.maxDoc());
      final Fields fields=reader.fields();
      String lastField=null;
      Terms terms=null;
      TermsEnum termsEnum=null;
      PostingsEnum docs=null;
      TermIterator iterator=termData.iterator();
      for (BytesRef term=iterator.next(); term != null; term=iterator.next()) {
        String field=iterator.field();
        if (field != lastField) {
          terms=fields.terms(field);
          if (terms == null) {
            termsEnum=null;
          }
 else {
            termsEnum=terms.iterator();
          }
        }
        if (termsEnum != null && termsEnum.seekExact(term)) {
          docs=termsEnum.postings(acceptDocs,docs,PostingsEnum.NONE);
          builder.or(docs);
        }
      }
      BitDocIdSet result=builder.build();
      if (result == null) {
        return null;
      }
      final DocIdSetIterator disi=result.iterator();
      if (disi == null) {
        return null;
      }
      return new Scorer(this){
        @Override public float score() throws IOException {
          return score;
        }
        @Override public int freq() throws IOException {
          return 1;
        }
        @Override public int docID(){
          return disi.docID();
        }
        @Override public int nextDoc() throws IOException {
          return disi.nextDoc();
        }
        @Override public int advance(        int target) throws IOException {
          return disi.advance(target);
        }
        @Override public long cost(){
          return disi.cost();
        }
      }
;
    }
  }
;
}
