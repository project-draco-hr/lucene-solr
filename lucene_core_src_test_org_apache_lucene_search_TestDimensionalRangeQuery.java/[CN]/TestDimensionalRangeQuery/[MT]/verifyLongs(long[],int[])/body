{
  IndexWriterConfig iwc=newIndexWriterConfig();
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < values.length / 100) {
    iwc.setMaxBufferedDocs(values.length / 100);
  }
  iwc.setCodec(getCodec());
  Directory dir;
  if (values.length > 100000) {
    dir=noVirusChecker(newFSDirectory(createTempDir("TestRangeTree")));
  }
 else {
    dir=getDirectory();
  }
  int missingPct=random().nextInt(100);
  int deletedPct=random().nextInt(100);
  if (VERBOSE) {
    System.out.println("  missingPct=" + missingPct);
    System.out.println("  deletedPct=" + deletedPct);
  }
  BitSet missing=new BitSet();
  BitSet deleted=new BitSet();
  Document doc=null;
  int lastID=-1;
  RandomIndexWriter w=new RandomIndexWriter(random(),dir,iwc);
  for (int ord=0; ord < values.length; ord++) {
    int id;
    if (ids == null) {
      id=ord;
    }
 else {
      id=ids[ord];
    }
    if (id != lastID) {
      if (random().nextInt(100) < missingPct) {
        missing.set(id);
        if (VERBOSE) {
          System.out.println("  missing id=" + id);
        }
      }
      if (doc != null) {
        w.addDocument(doc);
        if (random().nextInt(100) < deletedPct) {
          int idToDelete=random().nextInt(id);
          w.deleteDocuments(new Term("id","" + idToDelete));
          deleted.set(idToDelete);
          if (VERBOSE) {
            System.out.println("  delete id=" + idToDelete);
          }
        }
      }
      doc=new Document();
      doc.add(newStringField("id","" + id,Field.Store.NO));
      doc.add(new NumericDocValuesField("id",id));
      lastID=id;
    }
    if (missing.get(id) == false) {
      doc.add(new DimensionalLongField("sn_value",values[id]));
      byte[] bytes=new byte[8];
      NumericUtils.longToBytes(values[id],bytes,0);
      doc.add(new DimensionalBinaryField("ss_value",bytes));
    }
  }
  w.addDocument(doc);
  if (random().nextBoolean()) {
    if (VERBOSE) {
      System.out.println("  forceMerge(1)");
    }
    w.forceMerge(1);
  }
  final IndexReader r=w.getReader();
  w.close();
  IndexSearcher s=newSearcher(r);
  int numThreads=TestUtil.nextInt(random(),2,5);
  if (VERBOSE) {
    System.out.println("TEST: use " + numThreads + " query threads; searcher="+ s);
  }
  List<Thread> threads=new ArrayList<>();
  final int iters=atLeast(100);
  final CountDownLatch startingGun=new CountDownLatch(1);
  final AtomicBoolean failed=new AtomicBoolean();
  for (int i=0; i < numThreads; i++) {
    Thread thread=new Thread(){
      @Override public void run(){
        try {
          _run();
        }
 catch (        Exception e) {
          failed.set(true);
          throw new RuntimeException(e);
        }
      }
      private void _run() throws Exception {
        startingGun.await();
        NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
        for (int iter=0; iter < iters && failed.get() == false; iter++) {
          Long lower=randomValue(true);
          Long upper=randomValue(true);
          if (lower != null && upper != null && upper < lower) {
            long x=lower;
            lower=upper;
            upper=x;
          }
          boolean includeLower=random().nextBoolean();
          boolean includeUpper=random().nextBoolean();
          Query query;
          if (VERBOSE) {
            System.out.println("\n" + Thread.currentThread().getName() + ": TEST: iter="+ iter+ " value="+ lower+ " (inclusive?="+ includeLower+ ") TO "+ upper+ " (inclusive?="+ includeUpper+ ")");
            byte[] tmp=new byte[8];
            if (lower != null) {
              NumericUtils.longToBytes(lower,tmp,0);
              System.out.println("  lower bytes=" + Arrays.toString(tmp));
            }
            if (upper != null) {
              NumericUtils.longToBytes(upper,tmp,0);
              System.out.println("  upper bytes=" + Arrays.toString(tmp));
            }
          }
          if (random().nextBoolean()) {
            query=DimensionalRangeQuery.new1DLongRange("sn_value",lower,includeLower,upper,includeUpper);
          }
 else {
            byte[] lowerBytes;
            if (lower == null) {
              lowerBytes=null;
            }
 else {
              lowerBytes=new byte[8];
              NumericUtils.longToBytes(lower,lowerBytes,0);
            }
            byte[] upperBytes;
            if (upper == null) {
              upperBytes=null;
            }
 else {
              upperBytes=new byte[8];
              NumericUtils.longToBytes(upper,upperBytes,0);
            }
            query=DimensionalRangeQuery.new1DBinaryRange("ss_value",lowerBytes,includeLower,upperBytes,includeUpper);
          }
          if (VERBOSE) {
            System.out.println(Thread.currentThread().getName() + ":  using query: " + query);
          }
          final BitSet hits=new BitSet();
          s.search(query,new SimpleCollector(){
            private int docBase;
            @Override public boolean needsScores(){
              return false;
            }
            @Override protected void doSetNextReader(            LeafReaderContext context) throws IOException {
              docBase=context.docBase;
            }
            @Override public void collect(            int doc){
              hits.set(docBase + doc);
            }
          }
);
          if (VERBOSE) {
            System.out.println(Thread.currentThread().getName() + ":  hitCount: " + hits.cardinality());
          }
          for (int docID=0; docID < r.maxDoc(); docID++) {
            int id=(int)docIDToID.get(docID);
            boolean expected=missing.get(id) == false && deleted.get(id) == false && matches(lower,includeLower,upper,includeUpper,values[id]);
            if (hits.get(docID) != expected) {
              fail(Thread.currentThread().getName() + ": iter=" + iter+ " id="+ id+ " docID="+ docID+ " value="+ values[id]+ " (range: "+ lower+ " TO "+ upper+ ") expected "+ expected+ " but got: "+ hits.get(docID)+ " deleted?="+ deleted.get(id)+ " query="+ query);
            }
          }
        }
      }
    }
;
    thread.setName("T" + i);
    thread.start();
    threads.add(thread);
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  IOUtils.close(r,dir);
}
