{
  int k=-1;
  int iters=1;
  if (args.length > ++k)   iters=Math.max(1,Integer.parseInt(args[k]));
  int runs=1;
  if (args.length > ++k)   runs=Math.max(1,Integer.parseInt(args[k]));
  String cmd="patluc";
  if (args.length > ++k)   cmd=args[k];
  boolean usePattern=cmd.indexOf("pat") >= 0;
  boolean useLucene=cmd.indexOf("luc") >= 0;
  int maxLetters=1;
  if (args.length > ++k)   maxLetters=Integer.parseInt(args[k]);
  int maxToLower=2;
  if (args.length > ++k)   maxToLower=Integer.parseInt(args[k]);
  int maxStops=2;
  if (args.length > ++k)   maxStops=Integer.parseInt(args[k]);
  File[] files=new File[]{new File("CHANGES.txt"),new File("LICENSE.txt")};
  if (args.length > ++k) {
    files=new File[args.length - k];
    for (int i=k; i < args.length; i++) {
      files[i - k]=new File(args[i]);
    }
  }
  for (int iter=0; iter < iters; iter++) {
    System.out.println("\n########### iteration=" + iter);
    long start=System.currentTimeMillis();
    long bytes=0;
    for (int i=0; i < files.length; i++) {
      File file=files[i];
      if (!file.exists() || file.isDirectory())       continue;
      bytes+=file.length();
      String text=toString(new FileInputStream(file),null);
      System.out.println("\n*********** FILE=" + file);
      for (int letters=0; letters < maxLetters; letters++) {
        boolean lettersOnly=letters == 0;
        for (int stops=0; stops < maxStops; stops++) {
          Set stopWords=null;
          if (stops != 0)           stopWords=StopAnalyzer.ENGLISH_STOP_WORDS_SET;
          for (int toLower=0; toLower < maxToLower; toLower++) {
            boolean toLowerCase=toLower != 0;
            for (int run=0; run < runs; run++) {
              TokenStream tokens1=null;
              TokenStream tokens2=null;
              try {
                if (usePattern)                 tokens1=patternTokenStream(text,lettersOnly,toLowerCase,stopWords);
                if (useLucene)                 tokens2=luceneTokenStream(text,lettersOnly,toLowerCase,stopWords);
                if (usePattern && useLucene) {
                  final TermAttribute termAtt1=tokens1.addAttribute(TermAttribute.class), termAtt2=tokens2.addAttribute(TermAttribute.class);
                  final OffsetAttribute offsetAtt1=tokens1.addAttribute(OffsetAttribute.class), offsetAtt2=tokens2.addAttribute(OffsetAttribute.class);
                  final PositionIncrementAttribute posincrAtt1=tokens1.addAttribute(PositionIncrementAttribute.class), posincrAtt2=tokens2.addAttribute(PositionIncrementAttribute.class);
                  while (tokens1.incrementToken()) {
                    assertTrue(tokens2.incrementToken());
                    assertEquals(termAtt1,termAtt2);
                    assertEquals(offsetAtt1,offsetAtt2);
                    assertEquals(posincrAtt1,posincrAtt2);
                  }
                  assertFalse(tokens2.incrementToken());
                  tokens1.end();
                  tokens1.close();
                  tokens2.end();
                  tokens2.close();
                }
              }
 catch (              Throwable t) {
                if (t instanceof OutOfMemoryError)                 t.printStackTrace();
                System.out.println("fatal error at file=" + file + ", letters="+ lettersOnly+ ", toLowerCase="+ toLowerCase+ ", stopwords="+ (stopWords != null ? "english" : "none"));
                throw t;
              }
            }
          }
        }
      }
      long end=System.currentTimeMillis();
      System.out.println("\nsecs = " + ((end - start) / 1000.0f));
      System.out.println("files/sec= " + (1.0f * runs * maxLetters* maxToLower* maxStops* files.length / ((end - start) / 1000.0f)));
      float mb=(1.0f * bytes * runs* maxLetters* maxToLower* maxStops) / (1024.0f * 1024.0f);
      System.out.println("MB/sec = " + (mb / ((end - start) / 1000.0f)));
    }
  }
  if (usePattern && useLucene)   System.out.println("No bug found. done.");
 else   System.out.println("Done benchmarking (without checking correctness).");
}
