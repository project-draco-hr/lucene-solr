{
  boolean ordered=true;
  int slop=1;
  IndexReaderContext topReaderContext=searcher.getTopReaderContext();
  AtomicReaderContext[] leaves=ReaderUtil.leaves(topReaderContext);
  int subIndex=ReaderUtil.subIndex(11,leaves);
  for (int i=0; i < leaves.length; i++) {
    final SimilarityProvider sim=new DefaultSimilarityProvider(){
      public Similarity get(      String field){
        return new DefaultSimilarity(){
          @Override public float sloppyFreq(          int distance){
            return 0.0f;
          }
        }
;
      }
    }
;
    final SimilarityProvider oldSim=searcher.getSimilarityProvider();
    Scorer spanScorer;
    try {
      searcher.setSimilarityProvider(sim);
      SpanNearQuery snq=new SpanNearQuery(new SpanQuery[]{makeSpanTermQuery("t1"),makeSpanTermQuery("t2")},slop,ordered);
      spanScorer=searcher.createNormalizedWeight(snq).scorer(leaves[i],true,false,leaves[i].reader().getLiveDocs());
    }
  finally {
      searcher.setSimilarityProvider(oldSim);
    }
    if (i == subIndex) {
      assertTrue("first doc",spanScorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
      assertEquals("first doc number",spanScorer.docID() + leaves[i].docBase,11);
      float score=spanScorer.score();
      assertTrue("first doc score should be zero, " + score,score == 0.0f);
    }
 else {
      assertTrue("no second doc",spanScorer.nextDoc() == DocIdSetIterator.NO_MORE_DOCS);
    }
  }
}
