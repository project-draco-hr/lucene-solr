{
  if (a.isEmpty()) {
    return new LightAutomaton();
  }
  a=BasicOperations.determinize(a);
  if (a.getNumTransitions(0) == 1) {
    LightAutomaton.Transition t=new LightAutomaton.Transition();
    a.getTransition(0,0,t);
    if (t.dest == 0 && t.min == Character.MIN_CODE_POINT && t.max == Character.MAX_CODE_POINT) {
      return a;
    }
  }
  a=a.totalize();
  final int[] sigma=a.getStartPoints();
  final int sigmaLen=sigma.length, statesLen=a.getNumStates();
  @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[][] reverse=(ArrayList<Integer>[][])new ArrayList[statesLen][sigmaLen];
  @SuppressWarnings({"rawtypes","unchecked"}) final HashSet<Integer>[] partition=(HashSet<Integer>[])new HashSet[statesLen];
  @SuppressWarnings({"rawtypes","unchecked"}) final ArrayList<Integer>[] splitblock=(ArrayList<Integer>[])new ArrayList[statesLen];
  final int[] block=new int[statesLen];
  final StateList[][] active=new StateList[statesLen][sigmaLen];
  final StateListNode[][] active2=new StateListNode[statesLen][sigmaLen];
  final LinkedList<IntPair> pending=new LinkedList<>();
  final BitSet pending2=new BitSet(sigmaLen * statesLen);
  final BitSet split=new BitSet(statesLen), refine=new BitSet(statesLen), refine2=new BitSet(statesLen);
  for (int q=0; q < statesLen; q++) {
    splitblock[q]=new ArrayList<>();
    partition[q]=new HashSet<>();
    for (int x=0; x < sigmaLen; x++) {
      active[q][x]=new StateList();
    }
  }
  for (int q=0; q < statesLen; q++) {
    final int j=a.isAccept(q) ? 0 : 1;
    partition[j].add(q);
    block[q]=j;
    for (int x=0; x < sigmaLen; x++) {
      final ArrayList<Integer>[] r=reverse[a.step(q,sigma[x])];
      if (r[x] == null) {
        r[x]=new ArrayList<>();
      }
      r[x].add(q);
    }
  }
  for (int j=0; j <= 1; j++) {
    for (int x=0; x < sigmaLen; x++) {
      for (      int q : partition[j]) {
        if (reverse[q][x] != null) {
          active2[q][x]=active[j][x].add(q);
        }
      }
    }
  }
  for (int x=0; x < sigmaLen; x++) {
    final int j=(active[0][x].size <= active[1][x].size) ? 0 : 1;
    pending.add(new IntPair(j,x));
    pending2.set(x * statesLen + j);
  }
  int k=2;
  while (!pending.isEmpty()) {
    final IntPair ip=pending.removeFirst();
    final int p=ip.n1;
    final int x=ip.n2;
    pending2.clear(x * statesLen + p);
    for (StateListNode m=active[p][x].first; m != null; m=m.next) {
      final ArrayList<Integer> r=reverse[m.q][x];
      if (r != null) {
        for (        int i : r) {
          if (!split.get(i)) {
            split.set(i);
            final int j=block[i];
            splitblock[j].add(i);
            if (!refine2.get(j)) {
              refine2.set(j);
              refine.set(j);
            }
          }
        }
      }
    }
    for (int j=refine.nextSetBit(0); j >= 0; j=refine.nextSetBit(j + 1)) {
      final ArrayList<Integer> sb=splitblock[j];
      if (sb.size() < partition[j].size()) {
        final HashSet<Integer> b1=partition[j];
        final HashSet<Integer> b2=partition[k];
        for (        int s : sb) {
          b1.remove(s);
          b2.add(s);
          block[s]=k;
          for (int c=0; c < sigmaLen; c++) {
            final StateListNode sn=active2[s][c];
            if (sn != null && sn.sl == active[j][c]) {
              sn.remove();
              active2[s][c]=active[k][c].add(s);
            }
          }
        }
        for (int c=0; c < sigmaLen; c++) {
          final int aj=active[j][c].size, ak=active[k][c].size, ofs=c * statesLen;
          if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {
            pending2.set(ofs + j);
            pending.add(new IntPair(j,c));
          }
 else {
            pending2.set(ofs + k);
            pending.add(new IntPair(k,c));
          }
        }
        k++;
      }
      refine2.clear(j);
      for (      int s : sb) {
        split.clear(s);
      }
      sb.clear();
    }
    refine.clear();
  }
  LightAutomaton result=new LightAutomaton();
  LightAutomaton.Transition t=new LightAutomaton.Transition();
  int[] stateMap=new int[statesLen];
  int[] stateRep=new int[k];
  result.createState();
  for (int n=0; n < k; n++) {
    boolean isInitial=false;
    for (    int q : partition[n]) {
      if (q == 0) {
        isInitial=true;
        break;
      }
    }
    int newState;
    if (isInitial) {
      newState=0;
    }
 else {
      newState=result.createState();
    }
    for (    int q : partition[n]) {
      stateMap[q]=newState;
      result.setAccept(newState,a.isAccept(q));
      stateRep[newState]=q;
    }
  }
  for (int n=0; n < k; n++) {
    int numTransitions=a.initTransition(stateRep[n],t);
    for (int i=0; i < numTransitions; i++) {
      a.getNextTransition(t);
      result.addTransition(n,stateMap[t.dest],t.min,t.max);
    }
  }
  result.finish();
  return BasicOperations.removeDeadTransitions(result);
}
