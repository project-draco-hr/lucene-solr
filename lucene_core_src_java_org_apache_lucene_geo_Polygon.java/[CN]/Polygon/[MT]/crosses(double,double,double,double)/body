{
  if (maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) {
    return false;
  }
  if (minLat <= this.minLat && maxLat >= this.maxLat && minLon <= this.minLon && maxLon >= this.maxLon) {
    return true;
  }
  for (  Polygon hole : holes) {
    if (hole.crosses(minLat,maxLat,minLon,maxLon)) {
      return true;
    }
  }
  final double[][] bbox=new double[][]{{minLon,minLat},{maxLon,minLat},{maxLon,maxLat},{minLon,maxLat},{minLon,minLat}};
  final int polyLength=polyLons.length - 1;
  double d, s, t, a1, b1, c1, a2, b2, c2;
  double x00, y00, x01, y01, x10, y10, x11, y11;
  for (short b=0; b < 4; ++b) {
    a1=bbox[b + 1][1] - bbox[b][1];
    b1=bbox[b][0] - bbox[b + 1][0];
    c1=a1 * bbox[b + 1][0] + b1 * bbox[b + 1][1];
    for (int p=0; p < polyLength; ++p) {
      a2=polyLats[p + 1] - polyLats[p];
      b2=polyLons[p] - polyLons[p + 1];
      d=a1 * b2 - a2 * b1;
      if (d != 0) {
        c2=a2 * polyLons[p + 1] + b2 * polyLats[p + 1];
        s=(1 / d) * (b2 * c1 - b1 * c2);
        t=(1 / d) * (a1 * c2 - a2 * c1);
        x00=Math.min(bbox[b][0],bbox[b + 1][0]) - ENCODING_TOLERANCE;
        x01=Math.max(bbox[b][0],bbox[b + 1][0]) + ENCODING_TOLERANCE;
        y00=Math.min(bbox[b][1],bbox[b + 1][1]) - ENCODING_TOLERANCE;
        y01=Math.max(bbox[b][1],bbox[b + 1][1]) + ENCODING_TOLERANCE;
        x10=Math.min(polyLons[p],polyLons[p + 1]) - ENCODING_TOLERANCE;
        x11=Math.max(polyLons[p],polyLons[p + 1]) + ENCODING_TOLERANCE;
        y10=Math.min(polyLats[p],polyLats[p + 1]) - ENCODING_TOLERANCE;
        y11=Math.max(polyLats[p],polyLats[p + 1]) + ENCODING_TOLERANCE;
        boolean touching=((x00 == s && y00 == t) || (x01 == s && y01 == t)) || ((x10 == s && y10 == t) || (x11 == s && y11 == t));
        if (!(touching || x00 > s || x01 < s || y00 > t || y01 < t || x10 > s || x11 < s || y10 > t || y11 < t)) {
          return true;
        }
      }
    }
  }
  return false;
}
