{
  match.start=off;
  match.len=0;
  int delta=0;
  int repl=0;
  insert(off,buf);
  int ref=hashPointer(buf,off);
  if (ref >= off - 4 && ref <= off && ref >= base) {
    if (readIntEquals(buf,ref,off)) {
      delta=off - ref;
      repl=match.len=MIN_MATCH + commonBytes(buf,ref + MIN_MATCH,off + MIN_MATCH,matchLimit);
      match.ref=ref;
    }
    ref=next(ref);
  }
  for (int i=0; i < MAX_ATTEMPTS; ++i) {
    if (ref < Math.max(base,off - MAX_DISTANCE + 1) || ref > off) {
      break;
    }
    if (buf[ref + match.len] == buf[off + match.len] && readIntEquals(buf,ref,off)) {
      final int matchLen=MIN_MATCH + commonBytes(buf,ref + MIN_MATCH,off + MIN_MATCH,matchLimit);
      if (matchLen > match.len) {
        match.ref=ref;
        match.len=matchLen;
      }
    }
    ref=next(ref);
  }
  if (repl != 0) {
    int ptr=off;
    final int end=off + repl - (MIN_MATCH - 1);
    while (ptr < end - delta) {
      chainTable[ptr & MASK]=(short)delta;
      ++ptr;
    }
    do {
      chainTable[ptr & MASK]=(short)delta;
      hashTable[hashHC(readInt(buf,ptr))]=ptr;
      ++ptr;
    }
 while (ptr < end);
    nextToUpdate=end;
  }
  return match.len != 0;
}
