{
  while (true) {
    final int shapeType=random().nextInt(4);
switch (shapeType) {
case 0:
{
        final int vertexCount=random().nextInt(3) + 3;
        final List<GeoPoint> geoPoints=new ArrayList<>();
        while (geoPoints.size() < vertexCount) {
          final GeoPoint gPt=new GeoPoint(PlanetModel.WGS84,toRadians(GeoTestUtil.nextLatitude()),toRadians(GeoTestUtil.nextLongitude()));
          geoPoints.add(gPt);
        }
        try {
          return GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84,geoPoints);
        }
 catch (        IllegalArgumentException e) {
          continue;
        }
      }
case 1:
{
      double lat=toRadians(GeoTestUtil.nextLatitude());
      double lon=toRadians(GeoTestUtil.nextLongitude());
      double angle=random().nextDouble() * Math.PI / 2.0;
      try {
        return GeoCircleFactory.makeGeoCircle(PlanetModel.WGS84,lat,lon,angle);
      }
 catch (      IllegalArgumentException iae) {
        continue;
      }
    }
case 2:
{
    double lat0=toRadians(GeoTestUtil.nextLatitude());
    double lat1=toRadians(GeoTestUtil.nextLatitude());
    if (lat1 < lat0) {
      double x=lat0;
      lat0=lat1;
      lat1=x;
    }
    double lon0=toRadians(GeoTestUtil.nextLongitude());
    double lon1=toRadians(GeoTestUtil.nextLongitude());
    if (lon1 < lon0) {
      double x=lon0;
      lon0=lon1;
      lon1=x;
    }
    return GeoBBoxFactory.makeGeoBBox(PlanetModel.WGS84,lat1,lat0,lon0,lon1);
  }
case 3:
{
  final int pointCount=random().nextInt(5) + 1;
  final double width=toRadians(random().nextInt(89) + 1);
  final GeoPoint[] points=new GeoPoint[pointCount];
  for (int i=0; i < pointCount; i++) {
    points[i]=new GeoPoint(PlanetModel.WGS84,toRadians(GeoTestUtil.nextLatitude()),toRadians(GeoTestUtil.nextLongitude()));
  }
  try {
    return GeoPathFactory.makeGeoPath(PlanetModel.WGS84,width,points);
  }
 catch (  IllegalArgumentException e) {
    continue;
  }
}
default :
throw new IllegalStateException("Unexpected shape type");
}
}
}
