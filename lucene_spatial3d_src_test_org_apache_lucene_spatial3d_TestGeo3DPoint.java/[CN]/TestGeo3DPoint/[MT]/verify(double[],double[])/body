{
  IndexWriterConfig iwc=newIndexWriterConfig();
  GeoPoint[] points=new GeoPoint[lats.length];
  for (int i=0; i < lats.length; i++) {
    if (Double.isNaN(lats[i]) == false) {
      points[i]=quantize(new GeoPoint(PlanetModel.WGS84,toRadians(lats[i]),toRadians(lons[i])));
    }
  }
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < points.length / 100) {
    iwc.setMaxBufferedDocs(points.length / 100);
  }
  iwc.setCodec(getCodec());
  Directory dir;
  if (points.length > 100000) {
    dir=newFSDirectory(createTempDir("TestBKDTree"));
  }
 else {
    dir=getDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < points.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    GeoPoint point=points[id];
    if (point != null) {
      doc.add(new Geo3DPoint("point",point.x,point.y,point.z));
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.err.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w);
  if (VERBOSE) {
    System.out.println("TEST: using reader " + r);
  }
  w.close();
  IndexSearcher s=newSearcher(r,false);
  final int iters=atLeast(100);
  NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
  for (int iter=0; iter < iters; iter++) {
    Query query=random3DQuery("point");
    if (VERBOSE) {
      System.err.println("  using query: " + query);
    }
    final FixedBitSet hits=new FixedBitSet(r.maxDoc());
    s.search(query,new SimpleCollector(){
      private int docBase;
      @Override public boolean needsScores(){
        return false;
      }
      @Override protected void doSetNextReader(      LeafReaderContext context) throws IOException {
        docBase=context.docBase;
      }
      @Override public void collect(      int doc){
        hits.set(docBase + doc);
      }
    }
);
    if (VERBOSE) {
      System.err.println("  hitCount: " + hits.cardinality());
    }
    for (int docID=0; docID < r.maxDoc(); docID++) {
      int id=(int)docIDToID.get(docID);
      GeoPoint point=points[id];
      if (point != null) {
        boolean expected=((deleted.contains(id) == false) && ((PointInGeo3DShapeQuery)query).getShape().isWithin(point));
        if (hits.get(docID) != expected) {
          StringBuilder b=new StringBuilder();
          if (expected) {
            b.append("FAIL: id=" + id + " should have matched but did not\n");
          }
 else {
            b.append("FAIL: id=" + id + " should not have matched but did\n");
          }
          b.append("  shape=" + ((PointInGeo3DShapeQuery)query).getShape() + "\n");
          b.append("  point=" + point + "\n");
          b.append("  docID=" + docID + " deleted?="+ deleted.contains(id)+ "\n");
          b.append("  query=" + query + "\n");
          b.append("  explanation:\n    " + explain("point",((PointInGeo3DShapeQuery)query).getShape(),point,r,docID).replace("\n","\n  "));
          fail(b.toString());
        }
      }
 else {
        assertFalse(hits.get(docID));
      }
    }
  }
  IOUtils.close(r,dir);
}
