{
  super(planetModel);
  if (maxY - minY < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("Y values in wrong order or identical");
  if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("Z values in wrong order or identical");
  final double worldMinX=planetModel.getMinimumXValue();
  final double worldMaxX=planetModel.getMaximumXValue();
  xPlane=new Plane(xUnitVector,-X);
  minYPlane=new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);
  maxYPlane=new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);
  minZPlane=new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);
  maxZPlane=new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);
  final GeoPoint[] XminY=xPlane.findIntersections(planetModel,minYPlane,maxYPlane,minZPlane,maxZPlane);
  final GeoPoint[] XmaxY=xPlane.findIntersections(planetModel,maxYPlane,minYPlane,minZPlane,maxZPlane);
  final GeoPoint[] XminZ=xPlane.findIntersections(planetModel,minZPlane,maxZPlane,minYPlane,maxYPlane);
  final GeoPoint[] XmaxZ=xPlane.findIntersections(planetModel,maxZPlane,minZPlane,minYPlane,maxYPlane);
  notableXPoints=glueTogether(XminY,XmaxY,XminZ,XmaxZ);
  final boolean XminYminZ=planetModel.pointOutside(X,minY,minZ);
  final boolean XminYmaxZ=planetModel.pointOutside(X,minY,maxZ);
  final boolean XmaxYminZ=planetModel.pointOutside(X,maxY,minZ);
  final boolean XmaxYmaxZ=planetModel.pointOutside(X,maxY,maxZ);
  final GeoPoint[] xEdges;
  if (X - worldMinX >= -Vector.MINIMUM_RESOLUTION && X - worldMaxX <= Vector.MINIMUM_RESOLUTION && minY < 0.0 && maxY > 0.0 && minZ < 0.0 && maxZ > 0.0 && XminYminZ && XminYmaxZ && XmaxYminZ && XmaxYmaxZ) {
    xEdges=new GeoPoint[]{xPlane.getSampleIntersectionPoint(planetModel,xVerticalPlane)};
  }
 else {
    xEdges=EMPTY_POINTS;
  }
  this.edgePoints=glueTogether(XminY,XmaxY,XminZ,XmaxZ,xEdges);
}
