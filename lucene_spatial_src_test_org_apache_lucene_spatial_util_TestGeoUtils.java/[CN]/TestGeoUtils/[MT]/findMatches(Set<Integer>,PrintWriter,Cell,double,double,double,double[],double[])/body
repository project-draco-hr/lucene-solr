{
  if (VERBOSE) {
    log.println("  root cell: " + root);
  }
  List<Cell> queue=new ArrayList<>();
  queue.add(root);
  int recurseDepth=RandomInts.randomIntBetween(random(),5,15);
  while (queue.size() > 0) {
    Cell cell=queue.get(queue.size() - 1);
    queue.remove(queue.size() - 1);
    if (VERBOSE) {
      log.println("  cycle: " + cell + " queue.size()="+ queue.size());
    }
    if (random().nextInt(10) == 7 || cell.splitCount > recurseDepth) {
      if (VERBOSE) {
        log.println("    leaf");
      }
      for (int docID=0; docID < docLons.length; docID++) {
        if (cell.contains(docLons[docID],docLats[docID])) {
          double distanceMeters=SloppyMath.haversinMeters(centerLat,centerLon,docLats[docID],docLons[docID]);
          if (distanceMeters <= radiusMeters) {
            if (VERBOSE) {
              log.println("    check doc=" + docID + ": match!");
            }
            hits.add(docID);
          }
 else {
            if (VERBOSE) {
              log.println("    check doc=" + docID + ": no match");
            }
          }
        }
      }
    }
 else {
      if (GeoRelationUtils.rectWithinCircle(cell.minLon,cell.minLat,cell.maxLon,cell.maxLat,centerLon,centerLat,radiusMeters)) {
        if (VERBOSE) {
          log.println("    circle fully contains cell: now addAll");
        }
        for (int docID=0; docID < docLons.length; docID++) {
          if (cell.contains(docLons[docID],docLats[docID])) {
            if (VERBOSE) {
              log.println("    addAll doc=" + docID);
            }
            hits.add(docID);
          }
        }
        continue;
      }
 else       if (GeoRelationUtils.rectWithin(root.minLon,root.minLat,root.maxLon,root.maxLat,cell.minLon,cell.minLat,cell.maxLon,cell.maxLat)) {
        if (VERBOSE) {
          log.println("    cell fully contains circle: keep splitting");
        }
      }
 else       if (GeoRelationUtils.rectCrossesCircle(cell.minLon,cell.minLat,cell.maxLon,cell.maxLat,centerLon,centerLat,radiusMeters)) {
        if (VERBOSE) {
          log.println("    cell overlaps circle: keep splitting");
        }
      }
 else {
        if (VERBOSE) {
          log.println("    no overlap: drop this cell");
          for (int docID=0; docID < docLons.length; docID++) {
            if (cell.contains(docLons[docID],docLats[docID])) {
              if (VERBOSE) {
                log.println("    skip doc=" + docID);
              }
            }
          }
        }
        continue;
      }
      if (random().nextBoolean()) {
        double splitValue=cell.minLon + (cell.maxLon - cell.minLon) * random().nextDouble();
        if (VERBOSE) {
          log.println("    now split on lon=" + splitValue);
        }
        Cell cell1=new Cell(cell,cell.minLon,cell.minLat,splitValue,cell.maxLat,cell.splitCount + 1);
        Cell cell2=new Cell(cell,splitValue,cell.minLat,cell.maxLon,cell.maxLat,cell.splitCount + 1);
        if (VERBOSE) {
          log.println("    split cell1: " + cell1);
          log.println("    split cell2: " + cell2);
        }
        queue.add(cell1);
        queue.add(cell2);
      }
 else {
        double splitValue=cell.minLat + (cell.maxLat - cell.minLat) * random().nextDouble();
        if (VERBOSE) {
          log.println("    now split on lat=" + splitValue);
        }
        Cell cell1=new Cell(cell,cell.minLon,cell.minLat,cell.maxLon,splitValue,cell.splitCount + 1);
        Cell cell2=new Cell(cell,cell.minLon,splitValue,cell.maxLon,cell.maxLat,cell.splitCount + 1);
        if (VERBOSE) {
          log.println("    split cells:\n      " + cell1 + "\n      "+ cell2);
        }
        queue.add(cell1);
        queue.add(cell2);
      }
    }
  }
}
