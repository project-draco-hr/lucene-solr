{
  int numDocs=atLeast(1000);
  boolean useSmallRanges=random().nextBoolean();
  if (VERBOSE) {
    System.out.println("TEST: " + numDocs + " docs useSmallRanges="+ useSmallRanges);
  }
  double[] docLons=new double[numDocs];
  double[] docLats=new double[numDocs];
  for (int docID=0; docID < numDocs; docID++) {
    docLons[docID]=randomLon(useSmallRanges);
    docLats[docID]=randomLat(useSmallRanges);
    if (VERBOSE) {
      System.out.println("  doc=" + docID + ": lon="+ docLons[docID]+ " lat="+ docLats[docID]);
    }
  }
  int iters=atLeast(10);
  iters=atLeast(50);
  for (int iter=0; iter < iters; iter++) {
    Cell.nextCellID=0;
    double centerLon=randomLon(useSmallRanges);
    double centerLat=randomLat(useSmallRanges);
    double radiusMeters;
    if (true || useSmallRanges) {
      radiusMeters=random().nextDouble() * 333000;
    }
 else {
      radiusMeters=random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;
    }
    StringWriter sw=new StringWriter();
    PrintWriter log=new PrintWriter(sw,true);
    if (VERBOSE) {
      log.println("\nTEST: iter=" + iter + " radiusMeters="+ radiusMeters+ " centerLon="+ centerLon+ " centerLat="+ centerLat);
    }
    GeoRect bbox=GeoUtils.circleToBBox(centerLon,centerLat,radiusMeters);
    Set<Integer> hits=new HashSet<>();
    if (bbox.maxLon < bbox.minLon) {
      log.println("  circle crosses dateline; first left query");
      double unwrappedLon=centerLon;
      if (unwrappedLon > bbox.maxLon) {
        unwrappedLon+=-360.0D;
      }
      findMatches(hits,log,new Cell(null,-180,bbox.minLat,bbox.maxLon,bbox.maxLat,0),unwrappedLon,centerLat,radiusMeters,docLons,docLats);
      log.println("  circle crosses dateline; now right query");
      if (unwrappedLon < bbox.maxLon) {
        unwrappedLon+=360.0D;
      }
      findMatches(hits,log,new Cell(null,bbox.minLon,bbox.minLat,180,bbox.maxLat,0),unwrappedLon,centerLat,radiusMeters,docLons,docLats);
    }
 else {
      findMatches(hits,log,new Cell(null,bbox.minLon,bbox.minLat,bbox.maxLon,bbox.maxLat,0),centerLon,centerLat,radiusMeters,docLons,docLats);
    }
    if (VERBOSE) {
      log.println("  " + hits.size() + " hits");
    }
    int failCount=0;
    for (int docID=0; docID < numDocs; docID++) {
      double distanceMeters=SloppyMath.haversinMeters(centerLat,centerLon,docLats[docID],docLons[docID]);
      final Boolean expected;
      final double percentError=Math.abs(distanceMeters - radiusMeters) / distanceMeters;
      if (percentError <= DISTANCE_PCT_ERR) {
        expected=null;
      }
 else {
        expected=distanceMeters <= radiusMeters;
      }
      boolean actual=hits.contains(docID);
      if (expected != null && actual != expected) {
        if (actual) {
          log.println("doc=" + docID + " matched but should not with distance error "+ percentError+ " on iteration "+ iter);
        }
 else {
          log.println("doc=" + docID + " did not match but should with distance error "+ percentError+ " on iteration "+ iter);
        }
        log.println("  lon=" + docLons[docID] + " lat="+ docLats[docID]+ " distanceMeters="+ distanceMeters+ " vs radiusMeters="+ radiusMeters);
        failCount++;
      }
    }
    if (failCount != 0) {
      System.out.print(sw.toString());
      fail(failCount + " incorrect hits (see above)");
    }
  }
}
