{
  int current;
  int nodeCount=getToCount();
  List path=new ArrayList();
  PathNode zeroPath=new PathNode();
  zeroPath.weight=0;
  zeroPath.preNode=0;
  path.add(zeroPath);
  for (current=1; current <= nodeCount; current++) {
    double weight;
    List edges=getToList(current);
    double minWeight=Double.MAX_VALUE;
    SegTokenPair minEdge=null;
    for (Iterator iter1=edges.iterator(); iter1.hasNext(); ) {
      SegTokenPair edge=(SegTokenPair)iter1.next();
      weight=edge.weight;
      PathNode preNode=(PathNode)path.get(edge.from);
      if (preNode.weight + weight < minWeight) {
        minWeight=preNode.weight + weight;
        minEdge=edge;
      }
    }
    PathNode newNode=new PathNode();
    newNode.weight=minWeight;
    newNode.preNode=minEdge.from;
    path.add(newNode);
  }
  int preNode, lastNode;
  lastNode=path.size() - 1;
  current=lastNode;
  List rpath=new ArrayList();
  List resultPath=new ArrayList();
  rpath.add(new Integer(current));
  while (current != 0) {
    PathNode currentPathNode=(PathNode)path.get(current);
    preNode=currentPathNode.preNode;
    rpath.add(new Integer(preNode));
    current=preNode;
  }
  for (int j=rpath.size() - 1; j >= 0; j--) {
    Integer idInteger=(Integer)rpath.get(j);
    int id=idInteger.intValue();
    SegToken t=(SegToken)segTokenList.get(id);
    resultPath.add(t);
  }
  return resultPath;
}
