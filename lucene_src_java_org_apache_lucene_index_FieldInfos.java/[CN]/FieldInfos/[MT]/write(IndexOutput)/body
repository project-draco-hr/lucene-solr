{
  output.writeVInt(FORMAT_CURRENT);
  output.writeVInt(size());
  for (int i=0; i < size(); i++) {
    FieldInfo fi=fieldInfo(i);
    byte bits=0x0;
    if (fi.isIndexed)     bits|=IS_INDEXED;
    if (fi.storeTermVector)     bits|=STORE_TERMVECTOR;
    if (fi.storePositionWithTermVector)     bits|=STORE_POSITIONS_WITH_TERMVECTOR;
    if (fi.storeOffsetWithTermVector)     bits|=STORE_OFFSET_WITH_TERMVECTOR;
    if (fi.omitNorms)     bits|=OMIT_NORMS;
    if (fi.storePayloads)     bits|=STORE_PAYLOADS;
    if (fi.omitTermFreqAndPositions)     bits|=OMIT_TERM_FREQ_AND_POSITIONS;
    output.writeString(fi.name);
    output.writeInt(fi.codecId);
    output.writeByte(bits);
    final byte b;
    if (fi.docValues == null) {
      b=0;
    }
 else {
switch (fi.docValues) {
case INTS:
        b=1;
      break;
case FLOAT_32:
    b=2;
  break;
case FLOAT_64:
b=3;
break;
case BYTES_FIXED_STRAIGHT:
b=4;
break;
case BYTES_FIXED_DEREF:
b=5;
break;
case BYTES_FIXED_SORTED:
b=6;
break;
case BYTES_VAR_STRAIGHT:
b=7;
break;
case BYTES_VAR_DEREF:
b=8;
break;
case BYTES_VAR_SORTED:
b=9;
break;
default :
throw new IllegalStateException("unhandled indexValues type " + fi.docValues);
}
}
output.writeByte(b);
}
}
