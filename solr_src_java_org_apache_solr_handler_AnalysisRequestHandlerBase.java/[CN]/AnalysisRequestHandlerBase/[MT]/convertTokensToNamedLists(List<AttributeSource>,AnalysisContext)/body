{
  final List<NamedList> tokensNamedLists=new ArrayList<NamedList>();
  final int[] positions=new int[tokens.size()];
  int position=0;
  for (int i=0, c=tokens.size(); i < c; i++) {
    AttributeSource token=tokens.get(i);
    position+=token.addAttribute(PositionIncrementAttribute.class).getPositionIncrement();
    positions[i]=position;
  }
  new SorterTemplate(){
    @Override protected void swap(    int i,    int j){
      final int p=positions[i];
      positions[i]=positions[j];
      positions[j]=p;
      Collections.swap(tokens,i,j);
    }
    @Override protected int compare(    int i,    int j){
      return positions[i] - positions[j];
    }
    @Override protected void setPivot(    int i){
      pivot=positions[i];
    }
    @Override protected int comparePivot(    int j){
      return pivot - positions[j];
    }
    private int pivot;
  }
.mergeSort(0,tokens.size() - 1);
  FieldType fieldType=context.getFieldType();
  final BytesRef rawBytes=new BytesRef();
  final CharArr textBuf=new CharArr();
  for (int i=0, c=tokens.size(); i < c; i++) {
    AttributeSource token=tokens.get(i);
    final NamedList<Object> tokenNamedList=new SimpleOrderedMap<Object>();
    token.getAttribute(TermToBytesRefAttribute.class).toBytesRef(rawBytes);
    textBuf.reset();
    fieldType.indexedToReadable(rawBytes,textBuf);
    final String text=textBuf.toString();
    tokenNamedList.add("text",text);
    if (token.hasAttribute(CharTermAttribute.class)) {
      final String rawText=token.getAttribute(CharTermAttribute.class).toString();
      if (!rawText.equals(text)) {
        tokenNamedList.add("raw_text",rawText);
      }
    }
    tokenNamedList.add("raw_bytes",rawBytes.toString());
    if (context.getTermsToMatch().contains(rawBytes)) {
      tokenNamedList.add("match",true);
    }
    tokenNamedList.add("position",positions[i]);
    token.reflectWith(new AttributeReflector(){
      public void reflect(      Class<? extends Attribute> attClass,      String key,      Object value){
        if (TermToBytesRefAttribute.class.isAssignableFrom(attClass))         return;
        if (CharTermAttribute.class.isAssignableFrom(attClass))         return;
        if (PositionIncrementAttribute.class.isAssignableFrom(attClass))         return;
        String k=attClass.getName() + '#' + key;
        if (ATTRIBUTE_MAPPING.containsKey(k)) {
          k=ATTRIBUTE_MAPPING.get(k);
        }
        if (value instanceof Payload) {
          final Payload p=(Payload)value;
          value=new BytesRef(p.getData()).toString();
        }
        tokenNamedList.add(k,value);
      }
    }
);
    tokensNamedLists.add(tokenNamedList);
  }
  return tokensNamedLists;
}
