{
  long count=0;
  long minValue=Long.MAX_VALUE;
  long maxValue=Long.MIN_VALUE;
  long gcd=0;
  boolean missing=false;
  HashSet<Long> uniqueValues=null;
  if (optimizeStorage) {
    uniqueValues=new HashSet<>();
    for (    Number nv : values) {
      final long v;
      if (nv == null) {
        v=0;
        missing=true;
      }
 else {
        v=nv.longValue();
      }
      if (gcd != 1) {
        if (v < Long.MIN_VALUE / 2 || v > Long.MAX_VALUE / 2) {
          gcd=1;
        }
 else         if (count != 0) {
          gcd=MathUtil.gcd(gcd,v - minValue);
        }
      }
      minValue=Math.min(minValue,v);
      maxValue=Math.max(maxValue,v);
      if (uniqueValues != null) {
        if (uniqueValues.add(v)) {
          if (uniqueValues.size() > 256) {
            uniqueValues=null;
          }
        }
      }
      ++count;
    }
  }
 else {
    for (    @SuppressWarnings("unused") Number nv : values) {
      ++count;
    }
  }
  final long delta=maxValue - minValue;
  final int format;
  if (uniqueValues != null && (PackedInts.bitsRequired(uniqueValues.size() - 1) < PackedInts.unsignedBitsRequired(delta)) && count <= Integer.MAX_VALUE) {
    format=TABLE_COMPRESSED;
  }
 else   if (gcd != 0 && gcd != 1) {
    format=GCD_COMPRESSED;
  }
 else {
    format=DELTA_COMPRESSED;
  }
  meta.writeVInt(field.number);
  meta.writeByte(Lucene45DocValuesFormat.NUMERIC);
  meta.writeVInt(format);
  if (missing) {
    meta.writeLong(data.getFilePointer());
    writeMissingBitset(values);
  }
 else {
    meta.writeLong(-1L);
  }
  meta.writeVInt(PackedInts.VERSION_CURRENT);
  meta.writeLong(data.getFilePointer());
  meta.writeVLong(count);
  meta.writeVInt(BLOCK_SIZE);
switch (format) {
case GCD_COMPRESSED:
    meta.writeLong(minValue);
  meta.writeLong(gcd);
final BlockPackedWriter quotientWriter=new BlockPackedWriter(data,BLOCK_SIZE);
for (Number nv : values) {
long value=nv == null ? 0 : nv.longValue();
quotientWriter.add((value - minValue) / gcd);
}
quotientWriter.finish();
break;
case DELTA_COMPRESSED:
final BlockPackedWriter writer=new BlockPackedWriter(data,BLOCK_SIZE);
for (Number nv : values) {
writer.add(nv == null ? 0 : nv.longValue());
}
writer.finish();
break;
case TABLE_COMPRESSED:
final Long[] decode=uniqueValues.toArray(new Long[uniqueValues.size()]);
final HashMap<Long,Integer> encode=new HashMap<>();
meta.writeVInt(decode.length);
for (int i=0; i < decode.length; i++) {
meta.writeLong(decode[i]);
encode.put(decode[i],i);
}
final int bitsRequired=PackedInts.bitsRequired(uniqueValues.size() - 1);
final PackedInts.Writer ordsWriter=PackedInts.getWriterNoHeader(data,PackedInts.Format.PACKED,(int)count,bitsRequired,PackedInts.DEFAULT_BUFFER_SIZE);
for (Number nv : values) {
ordsWriter.add(encode.get(nv == null ? 0 : nv.longValue()));
}
ordsWriter.finish();
break;
default :
throw new AssertionError();
}
}
