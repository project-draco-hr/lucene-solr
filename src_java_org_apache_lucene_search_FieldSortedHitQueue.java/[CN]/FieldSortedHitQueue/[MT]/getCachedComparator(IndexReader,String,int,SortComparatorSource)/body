{
  if (type == SortField.DOC)   return ScoreDocComparator.INDEXORDER;
  if (type == SortField.SCORE)   return ScoreDocComparator.RELEVANCE;
  if (reader.hashCode() == lastReaderHash) {
    ScoreDocLookupComparator comparer=(ScoreDocLookupComparator)fieldCache.get(field);
    if (comparer != null && comparer.sizeMatches(reader.maxDoc())) {
      return comparer;
    }
  }
 else {
    lastReaderHash=reader.hashCode();
    fieldCache.clear();
  }
  ScoreDocComparator comparer=null;
switch (type) {
case SortField.AUTO:
    comparer=determineComparator(reader,field);
  break;
case SortField.STRING:
comparer=StringSortedHitQueue.comparator(reader,field);
break;
case SortField.INT:
comparer=IntegerSortedHitQueue.comparator(reader,field);
break;
case SortField.FLOAT:
comparer=FloatSortedHitQueue.comparator(reader,field);
break;
case SortField.CUSTOM:
comparer=factory.newComparator(reader,field);
break;
default :
throw new RuntimeException("invalid sort field type: " + type);
}
fieldCache.put(field,comparer);
return comparer;
}
