{
  int timeout=Integer.parseInt(leaderVoteWait);
  long timeoutAt=System.currentTimeMillis() + timeout;
  boolean tryAgain=true;
  Slice slices=zkController.getClusterState().getSlice(collection,shardId);
  while (true && !isClosed) {
    if (slices != null) {
      Map<String,Replica> shards=slices.getReplicasMap();
      Set<Entry<String,Replica>> entrySet=shards.entrySet();
      int found=0;
      tryAgain=false;
      for (      Entry<String,Replica> entry : entrySet) {
        ZkCoreNodeProps props=new ZkCoreNodeProps(entry.getValue());
        if (props.getState().equals(ZkStateReader.ACTIVE) && zkController.getClusterState().liveNodesContain(props.getNodeName())) {
          found++;
        }
      }
      if ((afterExpiration || !weAreReplacement) && found >= slices.getReplicasMap().size()) {
        log.info("Enough replicas found to continue.");
        break;
      }
 else       if (!afterExpiration && found >= slices.getReplicasMap().size() - 1) {
        log.info("Enough replicas found to continue.");
        break;
      }
 else {
        log.info("Waiting until we see more replicas up: total=" + slices.getReplicasMap().size() + " found="+ found+ " timeoutin="+ (timeoutAt - System.currentTimeMillis()));
      }
      if (System.currentTimeMillis() > timeoutAt) {
        log.info("Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later");
        break;
      }
    }
    if (tryAgain) {
      Thread.sleep(500);
      slices=zkController.getClusterState().getSlice(collection,shardId);
    }
  }
}
