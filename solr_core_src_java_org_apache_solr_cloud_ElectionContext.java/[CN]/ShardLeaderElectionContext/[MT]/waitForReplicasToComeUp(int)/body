{
  long timeoutAt=System.nanoTime() + TimeUnit.NANOSECONDS.convert(timeoutms,TimeUnit.MILLISECONDS);
  final String shardsElectZkPath=electionPath + LeaderElector.ELECTION_NODE;
  Slice slices=zkController.getClusterState().getSlice(collection,shardId);
  int cnt=0;
  while (!isClosed && !cc.isShutDown()) {
    if (slices != null) {
      int found=0;
      try {
        found=zkClient.getChildren(shardsElectZkPath,null,true).size();
      }
 catch (      KeeperException e) {
        if (e instanceof KeeperException.SessionExpiredException) {
          throw new SolrException(ErrorCode.SERVER_ERROR,"ZK session expired - cancelling election for " + collection + " "+ shardId);
        }
        SolrException.log(log,"Error checking for the number of election participants",e);
      }
      if (found >= slices.getReplicasMap().size()) {
        log.info("Enough replicas found to continue.");
        return true;
      }
 else {
        if (cnt % 40 == 0) {
          log.info("Waiting until we see more replicas up for shard {}: total={}" + " found={}" + " timeoutin={}ms",shardId,slices.getReplicasMap().size(),found,TimeUnit.MILLISECONDS.convert(timeoutAt - System.nanoTime(),TimeUnit.NANOSECONDS));
        }
      }
      if (System.nanoTime() > timeoutAt) {
        log.info("Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later");
        return false;
      }
    }
 else {
      log.warn("Shard not found: " + shardId + " for collection "+ collection);
      return false;
    }
    Thread.sleep(500);
    slices=zkController.getClusterState().getSlice(collection,shardId);
    cnt++;
  }
  return false;
}
