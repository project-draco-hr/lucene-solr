{
  final List<Path<T>> queue=new ArrayList<Path<T>>();
  final List<Path<T>> endNodes=new ArrayList<Path<T>>();
  queue.add(new Path<T>(a.getInitialState(),fst.getFirstArc(new FST.Arc<T>()),fst.outputs.getNoOutput(),new IntsRef()));
  final FST.Arc<T> scratchArc=new FST.Arc<T>();
  final FST.BytesReader fstReader=fst.getBytesReader(0);
  while (queue.size() != 0) {
    final Path<T> path=queue.remove(queue.size() - 1);
    if (path.state.isAccept()) {
      endNodes.add(path);
    }
    IntsRef currentInput=path.input;
    for (    Transition t : path.state.getTransitions()) {
      if (t.getMin() != t.getMax()) {
        throw new IllegalStateException("can only handle Transitions that match one character");
      }
      final FST.Arc<T> nextArc=fst.findTargetArc(t.getMin(),path.fstNode,scratchArc,fstReader);
      if (nextArc != null) {
        IntsRef newInput=new IntsRef(currentInput.length + 1);
        newInput.copyInts(currentInput);
        newInput.ints[currentInput.length]=t.getMin();
        newInput.length=currentInput.length + 1;
        queue.add(new Path<T>(t.getDest(),new FST.Arc<T>().copyFrom(nextArc),fst.outputs.add(path.output,nextArc.output),newInput));
      }
    }
  }
  return endNodes;
}
