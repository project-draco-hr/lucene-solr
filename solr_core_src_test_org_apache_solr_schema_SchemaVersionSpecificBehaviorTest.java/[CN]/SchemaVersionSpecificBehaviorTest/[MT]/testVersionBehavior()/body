{
  for (  float v : new float[]{1.0F,1.1F,1.2F,1.3F,1.4F,1.5F}) {
    try {
      final IndexSchema schema=initCoreUsingSchemaVersion(v);
      final String ver=String.valueOf(v);
      for (      String f : new String[]{"text","xx_dyn_text","bool","xx_dyn_bool","str","xx_dyn_str"}) {
        SchemaField field=schema.getField(f);
        assertEquals(f + " field's multiValued is wrong for ver=" + ver,(v < 1.1F),field.multiValued());
        assertEquals(f + " field's type has wrong omitTfP for ver=" + ver,(v < 1.2F ? false : !(field.getType() instanceof TextField)),field.omitTermFreqAndPositions());
        if (field.getType() instanceof TextField) {
          TextField ft=(TextField)field.getType();
          assertEquals(f + " field's autoPhrase is wrong for ver=" + ver,(v < 1.4F),ft.getAutoGeneratePhraseQueries());
        }
        assertEquals(f + " field's type has wrong omitNorm for ver=" + ver,(v < 1.5F ? false : !(field.getType() instanceof TextField)),field.omitNorms());
      }
      for (      String f : new String[]{"multi_f","multi_t","ft_multi_f","ft_multi_t","xx_dyn_str_multi_f","xx_dyn_str_multi_t","xx_dyn_str_ft_multi_f","xx_dyn_str_ft_multi_t"}) {
        boolean expected=f.endsWith("multi_t");
        SchemaField field=schema.getField(f);
        assertEquals(f + " field's multiValued is wrong for ver=" + ver,expected,field.multiValued());
        FieldType ft=field.getType();
        if (f.contains("ft_multi")) {
          assertEquals(f + " field's multiValued doesn't match type for ver=" + ver,expected,ft.isMultiValued());
        }
 else {
          assertEquals(f + " field's type has wrong multiValued is wrong for ver=" + ver,(v < 1.1F),ft.isMultiValued());
        }
      }
      for (      String f : new String[]{"strTfP_f","strTfP_t","txtTfP_f","txtTfP_t","ft_strTfP_f","ft_strTfP_t","ft_txtTfP_f","ft_txtTfP_t","xx_dyn_strTfP_f","xx_dyn_strTfP_t","xx_dyn_txtTfP_f","xx_dyn_txtTfP_t","xx_dyn_ft_strTfP_f","xx_dyn_ft_strTfP_t","xx_dyn_ft_txtTfP_f","xx_dyn_ft_txtTfP_t"}) {
        boolean expected=f.endsWith("TfP_t");
        SchemaField field=schema.getField(f);
        assertEquals(f + " field's omitTfP is wrong for ver=" + ver,expected,field.omitTermFreqAndPositions());
        FieldType ft=field.getType();
        if (f.contains("ft_")) {
          assertEquals(f + " field's omitTfP doesn't match type for ver=" + ver,expected,ft.hasProperty(FieldType.OMIT_TF_POSITIONS));
        }
 else {
          assertEquals(f + " field's type has wrong omitTfP for ver=" + ver,(v < 1.2F ? false : !(field.getType() instanceof TextField)),ft.hasProperty(FieldType.OMIT_TF_POSITIONS));
        }
      }
      for (      String f : new String[]{"ft_txt_phrase_f","ft_txt_phrase_t","xx_dyn_ft_txt_phrase_f","xx_dyn_ft_txt_phrase_t"}) {
        boolean expected=f.endsWith("phrase_t");
        FieldType ft=schema.getFieldType(f);
        assertTrue("broken test, assert only valid on text fields: " + f,ft instanceof TextField);
        assertEquals(f + " field's autophrase is wrong for ver=" + ver,expected,((TextField)ft).getAutoGeneratePhraseQueries());
      }
      for (      String f : new String[]{"strnorm_f","strnorm_t","txtnorm_f","txtnorm_t","ft_strnorm_f","ft_strnorm_t","ft_txtnorm_f","ft_txtnorm_t","xx_dyn_strnorm_f","xx_dyn_strnorm_t","xx_dyn_txtnorm_f","xx_dyn_txtnorm_t","xx_dyn_ft_strnorm_f","xx_dyn_ft_strnorm_t","xx_dyn_ft_txtnorm_f","xx_dyn_ft_txtnorm_t"}) {
        boolean expected=f.endsWith("norm_t");
        SchemaField field=schema.getField(f);
        assertEquals(f + " field's omitNorm is wrong for ver=" + ver,expected,field.omitNorms());
        FieldType ft=field.getType();
        if (f.contains("ft_")) {
          assertEquals(f + " field's omitNorm doesn't match type for ver=" + ver,expected,ft.hasProperty(FieldType.OMIT_NORMS));
        }
 else {
          assertEquals(f + " field's type has wrong omitNorm for ver=" + ver,(v < 1.5F ? false : !(field.getType() instanceof TextField)),ft.hasProperty(FieldType.OMIT_NORMS));
        }
      }
    }
  finally {
      deleteCore();
    }
  }
}
