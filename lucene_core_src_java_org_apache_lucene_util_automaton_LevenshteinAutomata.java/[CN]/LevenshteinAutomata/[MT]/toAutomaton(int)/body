{
  if (n == 0) {
    return BasicAutomata.makeString(word,0,word.length);
  }
  if (n >= descriptions.length)   return null;
  final int range=2 * n + 1;
  ParametricDescription description=descriptions[n];
  State states[]=new State[description.size()];
  for (int i=0; i < states.length; i++) {
    states[i]=new State();
    states[i].number=i;
    states[i].setAccept(description.isAccept(i));
  }
  for (int k=0; k < states.length; k++) {
    final int xpos=description.getPosition(k);
    if (xpos < 0)     continue;
    final int end=xpos + Math.min(word.length - xpos,range);
    for (int x=0; x < alphabet.length; x++) {
      final int ch=alphabet[x];
      final int cvec=getVector(ch,xpos,end);
      int dest=description.transition(k,xpos,cvec);
      if (dest >= 0)       states[k].addTransition(new Transition(ch,states[dest]));
    }
    int dest=description.transition(k,xpos,0);
    if (dest >= 0)     for (int r=0; r < numRanges; r++)     states[k].addTransition(new Transition(rangeLower[r],rangeUpper[r],states[dest]));
  }
  Automaton a=new Automaton(states[0]);
  a.setDeterministic(true);
  a.reduce();
  return a;
}
