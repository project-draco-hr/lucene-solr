{
  int docCount=0;
  int idx=0;
  MatchingReaders matching=new MatchingReaders(mergeState);
  for (  AtomicReader reader : mergeState.readers) {
    final SegmentReader matchingSegmentReader=matching.matchingSegmentReaders[idx++];
    CompressingStoredFieldsReader matchingFieldsReader=null;
    if (matchingSegmentReader != null) {
      final StoredFieldsReader fieldsReader=matchingSegmentReader.getFieldsReader();
      if (fieldsReader != null && fieldsReader instanceof CompressingStoredFieldsReader) {
        matchingFieldsReader=(CompressingStoredFieldsReader)fieldsReader;
      }
    }
    final int maxDoc=reader.maxDoc();
    final Bits liveDocs=reader.getLiveDocs();
    if (matchingFieldsReader == null || matchingFieldsReader.getVersion() != VERSION_CURRENT || matchingFieldsReader.getCompressionMode() != compressionMode || matchingFieldsReader.getChunkSize() != chunkSize) {
      for (int i=nextLiveDoc(0,liveDocs,maxDoc); i < maxDoc; i=nextLiveDoc(i + 1,liveDocs,maxDoc)) {
        StoredDocument doc=reader.document(i);
        addDocument(doc,mergeState.fieldInfos);
        ++docCount;
        mergeState.checkAbort.work(300);
      }
    }
 else {
      int docID=nextLiveDoc(0,liveDocs,maxDoc);
      if (docID < maxDoc) {
        final ChunkIterator it=matchingFieldsReader.chunkIterator(docID);
        int[] startOffsets=new int[0];
        do {
          it.next(docID);
          if (startOffsets.length < it.chunkDocs) {
            startOffsets=new int[ArrayUtil.oversize(it.chunkDocs,4)];
          }
          for (int i=1; i < it.chunkDocs; ++i) {
            startOffsets[i]=startOffsets[i - 1] + it.lengths[i - 1];
          }
          it.decompress();
          if (startOffsets[it.chunkDocs - 1] + it.lengths[it.chunkDocs - 1] != it.bytes.length) {
            throw new CorruptIndexException("Corrupted: expected chunk size=" + startOffsets[it.chunkDocs - 1] + it.lengths[it.chunkDocs - 1]+ ", got "+ it.bytes.length);
          }
          for (; docID < it.docBase + it.chunkDocs; docID=nextLiveDoc(docID + 1,liveDocs,maxDoc)) {
            final int diff=docID - it.docBase;
            startDocument();
            bufferedDocs.writeBytes(it.bytes.bytes,it.bytes.offset + startOffsets[diff],it.lengths[diff]);
            numStoredFieldsInDoc=it.numStoredFields[diff];
            finishDocument();
            ++docCount;
            mergeState.checkAbort.work(300);
          }
        }
 while (docID < maxDoc);
        it.checkIntegrity();
      }
    }
  }
  finish(mergeState.fieldInfos,docCount);
  return docCount;
}
