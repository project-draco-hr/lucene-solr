{
  log("Scanning: " + jarFile.getPath(),verboseLevel);
  if (!skipSnapshotsChecksum || !jarFile.getName().contains("-SNAPSHOT")) {
    final File checksumFile=new File(licenseDirectory,jarFile.getName() + "." + CHECKSUM_TYPE);
    if (!(checksumFile.exists() && checksumFile.canRead())) {
      log("MISSING " + CHECKSUM_TYPE + " checksum file for: "+ jarFile.getPath(),Project.MSG_ERR);
      log("EXPECTED " + CHECKSUM_TYPE + " checksum file : "+ checksumFile.getPath(),Project.MSG_ERR);
      this.failures=true;
      return false;
    }
 else {
      final String expectedChecksum=readChecksumFile(checksumFile);
      try {
        final MessageDigest md=MessageDigest.getInstance(CHECKSUM_TYPE);
        byte[] buf=new byte[CHECKSUM_BUFFER_SIZE];
        try {
          FileInputStream fis=new FileInputStream(jarFile);
          try {
            DigestInputStream dis=new DigestInputStream(fis,md);
            try {
              while (dis.read(buf,0,CHECKSUM_BUFFER_SIZE) != -1) {
              }
            }
  finally {
              dis.close();
            }
          }
  finally {
            fis.close();
          }
        }
 catch (        IOException ioe) {
          throw new BuildException("IO error computing checksum of file: " + jarFile,ioe);
        }
        final byte[] checksumBytes=md.digest();
        final String checksum=createChecksumString(checksumBytes);
        if (!checksum.equals(expectedChecksum)) {
          log("CHECKSUM FAILED for " + jarFile.getPath() + " (expected: \""+ expectedChecksum+ "\" was: \""+ checksum+ "\")",Project.MSG_ERR);
          this.failures=true;
          return false;
        }
      }
 catch (      NoSuchAlgorithmException ae) {
        throw new BuildException("Digest type " + CHECKSUM_TYPE + " not supported by your JVM",ae);
      }
    }
  }
 else   if (skipSnapshotsChecksum) {
    log("Skipping jar because it is a SNAPSHOT : " + jarFile.getAbsolutePath(),Project.MSG_INFO);
  }
  Map<File,LicenseType> foundLicenses=new LinkedHashMap<File,LicenseType>();
  List<File> expectedLocations=new ArrayList<File>();
  outer:   for (  String mappedPath : licenseMapper.mapFileName(jarFile.getName())) {
    for (    LicenseType licenseType : LicenseType.values()) {
      File licensePath=new File(licenseDirectory,mappedPath + licenseType.licenseFileSuffix());
      if (licensePath.exists()) {
        foundLicenses.put(licensePath,licenseType);
        log(" FOUND " + licenseType.name() + " license at "+ licensePath.getPath(),verboseLevel);
        break outer;
      }
 else {
        expectedLocations.add(licensePath);
      }
    }
  }
  for (  Map.Entry<File,LicenseType> e : foundLicenses.entrySet()) {
    LicenseType license=e.getValue();
    String licensePath=e.getKey().getName();
    String baseName=licensePath.substring(0,licensePath.length() - license.licenseFileSuffix().length());
    File noticeFile=new File(licenseDirectory,baseName + license.noticeFileSuffix());
    if (noticeFile.exists()) {
      log(" FOUND NOTICE file at " + noticeFile.getAbsolutePath(),verboseLevel);
    }
 else {
      if (license.isNoticeRequired()) {
        this.failures=true;
        log("MISSING NOTICE for the license file:\n  " + licensePath + "\n  Expected location below:\n  "+ noticeFile.getAbsolutePath(),Project.MSG_ERR);
      }
    }
  }
  if (foundLicenses.isEmpty()) {
    this.failures=true;
    StringBuilder message=new StringBuilder();
    message.append("MISSING LICENSE for the following file:\n  " + jarFile.getAbsolutePath() + "\n  Expected locations below:\n");
    for (    File location : expectedLocations) {
      message.append("  => ").append(location.getAbsolutePath()).append("\n");
    }
    log(message.toString(),Project.MSG_ERR);
    return false;
  }
  return true;
}
