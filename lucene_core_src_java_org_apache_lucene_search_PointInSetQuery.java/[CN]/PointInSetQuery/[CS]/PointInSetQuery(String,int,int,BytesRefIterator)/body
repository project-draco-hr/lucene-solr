{
  this.field=field;
  if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {
    throw new IllegalArgumentException("bytesPerDim must be > 0 and <= " + PointValues.MAX_NUM_BYTES + "; got "+ bytesPerDim);
  }
  this.bytesPerDim=bytesPerDim;
  if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {
    throw new IllegalArgumentException("numDims must be > 0 and <= " + PointValues.MAX_DIMENSIONS + "; got "+ numDims);
  }
  this.numDims=numDims;
  PrefixCodedTerms.Builder builder=new PrefixCodedTerms.Builder();
  BytesRefBuilder previous=null;
  BytesRef current;
  while ((current=packedPoints.next()) != null) {
    if (current.length != numDims * bytesPerDim) {
      throw new IllegalArgumentException("packed point length should be " + (numDims * bytesPerDim) + " but got "+ current.length+ "; field=\""+ field+ "\" numDims="+ numDims+ " bytesPerDim="+ bytesPerDim);
    }
    if (previous == null) {
      previous=new BytesRefBuilder();
    }
 else {
      int cmp=previous.get().compareTo(current);
      if (cmp == 0) {
        continue;
      }
 else       if (cmp > 0) {
        throw new IllegalArgumentException("values are out of order: saw " + previous + " before "+ current);
      }
    }
    builder.add(field,current);
    previous.copyBytes(current);
  }
  sortedPackedPoints=builder.finish();
  sortedPackedPointsHashCode=sortedPackedPoints.hashCode();
}
