{
  String tempSourceCollectionName="split_" + sourceSlice.getName() + "_temp_"+ targetSlice.getName();
  ZkStateReader zkStateReader=ocmh.zkStateReader;
  if (clusterState.hasCollection(tempSourceCollectionName)) {
    log.info("Deleting temporary collection: " + tempSourceCollectionName);
    Map<String,Object> props=makeMap(Overseer.QUEUE_OPERATION,DELETE.toLower(),NAME,tempSourceCollectionName);
    try {
      ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(),new ZkNodeProps(props),results);
      clusterState=zkStateReader.getClusterState();
    }
 catch (    Exception e) {
      log.warn("Unable to clean up existing temporary collection: " + tempSourceCollectionName,e);
    }
  }
  CompositeIdRouter sourceRouter=(CompositeIdRouter)sourceCollection.getRouter();
  DocRouter.Range keyHashRange=sourceRouter.keyHashRange(splitKey);
  ShardHandlerFactory shardHandlerFactory=ocmh.shardHandlerFactory;
  ShardHandler shardHandler=shardHandlerFactory.getShardHandler();
  log.info("Hash range for split.key: {} is: {}",splitKey,keyHashRange);
  DocRouter.Range splitRange=ocmh.intersect(targetSlice.getRange(),ocmh.intersect(sourceSlice.getRange(),keyHashRange));
  if (splitRange == null) {
    log.info("No common hashes between source shard: {} and target shard: {}",sourceSlice.getName(),targetSlice.getName());
    return;
  }
  log.info("Common hash range between source shard: {} and target shard: {} = " + splitRange,sourceSlice.getName(),targetSlice.getName());
  Replica targetLeader=zkStateReader.getLeaderRetry(targetCollection.getName(),targetSlice.getName(),10000);
  Map<String,String> requestMap=new HashMap<>();
  log.info("Asking target leader node: " + targetLeader.getNodeName() + " core: "+ targetLeader.getStr("core")+ " to buffer updates");
  ModifiableSolrParams params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());
  params.set(CoreAdminParams.NAME,targetLeader.getStr("core"));
  ocmh.sendShardRequest(targetLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  ocmh.processResponses(results,shardHandler,true,"MIGRATE failed to request node to buffer updates",asyncId,requestMap);
  ZkNodeProps m=new ZkNodeProps(Overseer.QUEUE_OPERATION,OverseerAction.ADDROUTINGRULE.toLower(),COLLECTION_PROP,sourceCollection.getName(),SHARD_ID_PROP,sourceSlice.getName(),"routeKey",SolrIndexSplitter.getRouteKey(splitKey) + "!","range",splitRange.toString(),"targetCollection",targetCollection.getName(),"expireAt",RoutingRule.makeExpiryAt(timeout));
  log.info("Adding routing rule: " + m);
  Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));
  log.info("Waiting to see routing rule updated in clusterstate");
  TimeOut waitUntil=new TimeOut(60,TimeUnit.SECONDS);
  boolean added=false;
  while (!waitUntil.hasTimedOut()) {
    Thread.sleep(100);
    sourceCollection=zkStateReader.getClusterState().getCollection(sourceCollection.getName());
    sourceSlice=sourceCollection.getSlice(sourceSlice.getName());
    Map<String,RoutingRule> rules=sourceSlice.getRoutingRules();
    if (rules != null) {
      RoutingRule rule=rules.get(SolrIndexSplitter.getRouteKey(splitKey) + "!");
      if (rule != null && rule.getRouteRanges().contains(splitRange)) {
        added=true;
        break;
      }
    }
  }
  if (!added) {
    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Could not add routing rule: " + m);
  }
  log.info("Routing rule added successfully");
  Replica sourceLeader=zkStateReader.getLeaderRetry(sourceCollection.getName(),sourceSlice.getName(),10000);
  String configName=zkStateReader.readConfigName(sourceCollection.getName());
  Map<String,Object> props=makeMap(Overseer.QUEUE_OPERATION,CREATE.toLower(),NAME,tempSourceCollectionName,REPLICATION_FACTOR,1,NUM_SLICES,1,COLL_CONF,configName,CREATE_NODE_SET,sourceLeader.getNodeName());
  if (asyncId != null) {
    String internalAsyncId=asyncId + Math.abs(System.nanoTime());
    props.put(ASYNC,internalAsyncId);
  }
  log.info("Creating temporary collection: " + props);
  ocmh.commandMap.get(CREATE).call(clusterState,new ZkNodeProps(props),results);
  clusterState=zkStateReader.getClusterState();
  Slice tempSourceSlice=clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();
  Replica tempSourceLeader=zkStateReader.getLeaderRetry(tempSourceCollectionName,tempSourceSlice.getName(),120000);
  String tempCollectionReplica1=tempSourceCollectionName + "_" + tempSourceSlice.getName()+ "_replica1";
  String coreNodeName=ocmh.waitForCoreNodeName(tempSourceCollectionName,sourceLeader.getNodeName(),tempCollectionReplica1);
  log.info("Asking source leader to wait for: " + tempCollectionReplica1 + " to be alive on: "+ sourceLeader.getNodeName());
  CoreAdminRequest.WaitForState cmd=new CoreAdminRequest.WaitForState();
  cmd.setCoreName(tempCollectionReplica1);
  cmd.setNodeName(sourceLeader.getNodeName());
  cmd.setCoreNodeName(coreNodeName);
  cmd.setState(Replica.State.ACTIVE);
  cmd.setCheckLive(true);
  cmd.setOnlyIfLeader(true);
  ocmh.sendShardRequest(tempSourceLeader.getNodeName(),new ModifiableSolrParams(cmd.getParams()),shardHandler,null,null);
  ocmh.processResponses(results,shardHandler,true,"MIGRATE failed to create temp collection leader" + " or timed out waiting for it to come up",asyncId,requestMap);
  log.info("Asking source leader to split index");
  params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminParams.CoreAdminAction.SPLIT.toString());
  params.set(CoreAdminParams.CORE,sourceLeader.getStr("core"));
  params.add(CoreAdminParams.TARGET_CORE,tempSourceLeader.getStr("core"));
  params.set(CoreAdminParams.RANGES,splitRange.toString());
  params.set("split.key",splitKey);
  String tempNodeName=sourceLeader.getNodeName();
  ocmh.sendShardRequest(tempNodeName,params,shardHandler,asyncId,requestMap);
  ocmh.processResponses(results,shardHandler,true,"MIGRATE failed to invoke SPLIT core admin command",asyncId,requestMap);
  log.info("Creating a replica of temporary collection: {} on the target leader node: {}",tempSourceCollectionName,targetLeader.getNodeName());
  String tempCollectionReplica2=tempSourceCollectionName + "_" + tempSourceSlice.getName()+ "_replica2";
  props=new HashMap<>();
  props.put(Overseer.QUEUE_OPERATION,ADDREPLICA.toLower());
  props.put(COLLECTION_PROP,tempSourceCollectionName);
  props.put(SHARD_ID_PROP,tempSourceSlice.getName());
  props.put("node",targetLeader.getNodeName());
  props.put(CoreAdminParams.NAME,tempCollectionReplica2);
  for (  String key : message.keySet()) {
    if (key.startsWith(COLL_PROP_PREFIX)) {
      props.put(key,message.getStr(key));
    }
  }
  if (asyncId != null) {
    props.put(ASYNC,asyncId);
  }
  ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState,new ZkNodeProps(props),results,null);
  ocmh.processResponses(results,shardHandler,true,"MIGRATE failed to create replica of " + "temporary collection in target leader node.",asyncId,requestMap);
  coreNodeName=ocmh.waitForCoreNodeName(tempSourceCollectionName,targetLeader.getNodeName(),tempCollectionReplica2);
  log.info("Asking temp source leader to wait for: " + tempCollectionReplica2 + " to be alive on: "+ targetLeader.getNodeName());
  cmd=new CoreAdminRequest.WaitForState();
  cmd.setCoreName(tempSourceLeader.getStr("core"));
  cmd.setNodeName(targetLeader.getNodeName());
  cmd.setCoreNodeName(coreNodeName);
  cmd.setState(Replica.State.ACTIVE);
  cmd.setCheckLive(true);
  cmd.setOnlyIfLeader(true);
  params=new ModifiableSolrParams(cmd.getParams());
  ocmh.sendShardRequest(tempSourceLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  ocmh.processResponses(results,shardHandler,true,"MIGRATE failed to create temp collection" + " replica or timed out waiting for them to come up",asyncId,requestMap);
  log.info("Successfully created replica of temp source collection on target leader node");
  log.info("Requesting merge of temp source collection replica to target leader");
  params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());
  params.set(CoreAdminParams.CORE,targetLeader.getStr("core"));
  params.set(CoreAdminParams.SRC_CORE,tempCollectionReplica2);
  ocmh.sendShardRequest(targetLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  String msg="MIGRATE failed to merge " + tempCollectionReplica2 + " to "+ targetLeader.getStr("core")+ " on node: "+ targetLeader.getNodeName();
  ocmh.processResponses(results,shardHandler,true,msg,asyncId,requestMap);
  log.info("Asking target leader to apply buffered updates");
  params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());
  params.set(CoreAdminParams.NAME,targetLeader.getStr("core"));
  ocmh.sendShardRequest(targetLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  ocmh.processResponses(results,shardHandler,true,"MIGRATE failed to request node to apply buffered updates",asyncId,requestMap);
  try {
    log.info("Deleting temporary collection: " + tempSourceCollectionName);
    props=makeMap(Overseer.QUEUE_OPERATION,DELETE.toLower(),NAME,tempSourceCollectionName);
    ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(),new ZkNodeProps(props),results);
  }
 catch (  Exception e) {
    log.error("Unable to delete temporary collection: " + tempSourceCollectionName + ". Please remove it manually",e);
  }
}
