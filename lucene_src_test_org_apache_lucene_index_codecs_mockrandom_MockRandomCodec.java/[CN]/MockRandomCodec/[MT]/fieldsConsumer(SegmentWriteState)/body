{
  final long seed=seedRandom.nextLong();
  final String seedFileName=IndexFileNames.segmentFileName(state.segmentName,state.codecId,SEED_EXT);
  final IndexOutput out=state.directory.createOutput(seedFileName);
  out.writeLong(seed);
  out.close();
  final Random random=new Random(seed);
  PostingsWriterBase postingsWriter;
  final int n=random.nextInt(4);
  if (n == 0) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing MockSep postings");
    }
    postingsWriter=new SepPostingsWriterImpl(state,new MockSingleIntFactory());
  }
 else   if (n == 1) {
    final int blockSize=_TestUtil.nextInt(random,1,2000);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing MockFixedIntBlock(" + blockSize + ") postings");
    }
    postingsWriter=new SepPostingsWriterImpl(state,new MockFixedIntBlockCodec.MockIntFactory(blockSize));
  }
 else   if (n == 2) {
    final int baseBlockSize=_TestUtil.nextInt(random,1,127);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing MockVariableIntBlock(" + baseBlockSize + ") postings");
    }
    postingsWriter=new SepPostingsWriterImpl(state,new MockVariableIntBlockCodec.MockIntFactory(baseBlockSize));
  }
 else {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing Standard postings");
    }
    postingsWriter=new StandardPostingsWriter(state);
  }
  if (random.nextBoolean()) {
    final int totTFCutoff=_TestUtil.nextInt(random,1,20);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: pulsing postings with totTFCutoff=" + totTFCutoff);
    }
    postingsWriter=new PulsingPostingsWriterImpl(totTFCutoff,postingsWriter);
  }
  final TermsIndexWriterBase indexWriter;
  boolean success=false;
  try {
    if (random.nextBoolean()) {
      state.termIndexInterval=_TestUtil.nextInt(random,1,100);
      if (LuceneTestCase.VERBOSE) {
        System.out.println("MockRandomCodec: fixed-gap terms index (tii=" + state.termIndexInterval + ")");
      }
      indexWriter=new FixedGapTermsIndexWriter(state);
    }
 else {
      final VariableGapTermsIndexWriter.IndexTermSelector selector;
      final int n2=random.nextInt(3);
      if (n2 == 0) {
        final int tii=_TestUtil.nextInt(random,1,100);
        selector=new VariableGapTermsIndexWriter.EveryNTermSelector(tii);
        if (LuceneTestCase.VERBOSE) {
          System.out.println("MockRandomCodec: variable-gap terms index (tii=" + tii + ")");
        }
      }
 else       if (n2 == 1) {
        final int docFreqThresh=_TestUtil.nextInt(random,2,100);
        final int tii=_TestUtil.nextInt(random,1,100);
        selector=new VariableGapTermsIndexWriter.EveryNOrDocFreqTermSelector(docFreqThresh,tii);
      }
 else {
        final long seed2=random.nextLong();
        final int gap=_TestUtil.nextInt(random,2,40);
        if (LuceneTestCase.VERBOSE) {
          System.out.println("MockRandomCodec: random-gap terms index (max gap=" + gap + ")");
        }
        selector=new VariableGapTermsIndexWriter.IndexTermSelector(){
          final Random rand=new Random(seed2);
          @Override public boolean isIndexTerm(          BytesRef term,          TermStats stats){
            return random.nextInt(gap) == 17;
          }
          @Override public void newField(          FieldInfo fieldInfo){
          }
        }
;
      }
      indexWriter=new VariableGapTermsIndexWriter(state,selector);
    }
    success=true;
  }
  finally {
    if (!success) {
      postingsWriter.close();
    }
  }
  success=false;
  try {
    FieldsConsumer ret=new BlockTermsWriter(indexWriter,state,postingsWriter,BytesRef.getUTF8SortedAsUnicodeComparator());
    success=true;
    return ret;
  }
  finally {
    if (!success) {
      try {
        postingsWriter.close();
      }
  finally {
        indexWriter.close();
      }
    }
  }
}
