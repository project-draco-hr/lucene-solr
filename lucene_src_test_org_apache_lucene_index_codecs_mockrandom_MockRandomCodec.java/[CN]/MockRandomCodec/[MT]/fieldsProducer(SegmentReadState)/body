{
  final String seedFileName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.codecId,SEED_EXT);
  final IndexInput in=state.dir.openInput(seedFileName);
  final long seed=in.readLong();
  in.close();
  final Random random=new Random(seed);
  PostingsReaderBase postingsReader;
  final int n=random.nextInt(4);
  if (n == 0) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: reading MockSep postings");
    }
    postingsReader=new SepPostingsReaderImpl(state.dir,state.segmentInfo,state.readBufferSize,new MockSingleIntFactory(),state.codecId);
  }
 else   if (n == 1) {
    final int blockSize=_TestUtil.nextInt(random,1,2000);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: reading MockFixedIntBlock(" + blockSize + ") postings");
    }
    postingsReader=new SepPostingsReaderImpl(state.dir,state.segmentInfo,state.readBufferSize,new MockFixedIntBlockCodec.MockIntFactory(blockSize),state.codecId);
  }
 else   if (n == 2) {
    final int baseBlockSize=_TestUtil.nextInt(random,1,127);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: reading MockVariableIntBlock(" + baseBlockSize + ") postings");
    }
    postingsReader=new SepPostingsReaderImpl(state.dir,state.segmentInfo,state.readBufferSize,new MockVariableIntBlockCodec.MockIntFactory(baseBlockSize),state.codecId);
  }
 else {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: reading Standard postings");
    }
    postingsReader=new StandardPostingsReader(state.dir,state.segmentInfo,state.readBufferSize,state.codecId);
  }
  if (random.nextBoolean()) {
    final int totTFCutoff=_TestUtil.nextInt(random,1,20);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: reading pulsing postings with totTFCutoff=" + totTFCutoff);
    }
    postingsReader=new PulsingPostingsReaderImpl(postingsReader);
  }
  final TermsIndexReaderBase indexReader;
  boolean success=false;
  try {
    if (random.nextBoolean()) {
      state.termsIndexDivisor=_TestUtil.nextInt(random,1,10);
      if (LuceneTestCase.VERBOSE) {
        System.out.println("MockRandomCodec: fixed-gap terms index (divisor=" + state.termsIndexDivisor + ")");
      }
      indexReader=new FixedGapTermsIndexReader(state.dir,state.fieldInfos,state.segmentInfo.name,state.termsIndexDivisor,BytesRef.getUTF8SortedAsUnicodeComparator(),state.codecId);
    }
 else {
      final int n2=random.nextInt(3);
      if (n2 == 1) {
        random.nextInt();
      }
 else       if (n2 == 2) {
        random.nextLong();
      }
      if (LuceneTestCase.VERBOSE) {
        System.out.println("MockRandomCodec: variable-gap terms index (divisor=" + state.termsIndexDivisor + ")");
      }
      state.termsIndexDivisor=_TestUtil.nextInt(random,1,10);
      indexReader=new VariableGapTermsIndexReader(state.dir,state.fieldInfos,state.segmentInfo.name,state.termsIndexDivisor,state.codecId);
    }
    success=true;
  }
  finally {
    if (!success) {
      postingsReader.close();
    }
  }
  final int termsCacheSize=_TestUtil.nextInt(random,1,1024);
  success=false;
  try {
    FieldsProducer ret=new PrefixCodedTermsReader(indexReader,state.dir,state.fieldInfos,state.segmentInfo.name,postingsReader,state.readBufferSize,BytesRef.getUTF8SortedAsUnicodeComparator(),termsCacheSize,state.codecId);
    success=true;
    return ret;
  }
  finally {
    if (!success) {
      try {
        postingsReader.close();
      }
  finally {
        indexReader.close();
      }
    }
  }
}
