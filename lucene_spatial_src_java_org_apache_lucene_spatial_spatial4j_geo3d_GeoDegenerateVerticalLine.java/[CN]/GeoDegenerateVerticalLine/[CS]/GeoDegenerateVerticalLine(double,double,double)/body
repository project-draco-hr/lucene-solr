{
  if (topLat > Math.PI * 0.5 || topLat < -Math.PI * 0.5)   throw new IllegalArgumentException("Top latitude out of range");
  if (bottomLat > Math.PI * 0.5 || bottomLat < -Math.PI * 0.5)   throw new IllegalArgumentException("Bottom latitude out of range");
  if (topLat < bottomLat)   throw new IllegalArgumentException("Top latitude less than bottom latitude");
  if (longitude < -Math.PI || longitude > Math.PI)   throw new IllegalArgumentException("Longitude out of range");
  this.topLat=topLat;
  this.bottomLat=bottomLat;
  this.longitude=longitude;
  final double sinTopLat=Math.sin(topLat);
  final double cosTopLat=Math.cos(topLat);
  final double sinBottomLat=Math.sin(bottomLat);
  final double cosBottomLat=Math.cos(bottomLat);
  final double sinLongitude=Math.sin(longitude);
  final double cosLongitude=Math.cos(longitude);
  this.UHC=new GeoPoint(sinTopLat,sinLongitude,cosTopLat,cosLongitude);
  this.LHC=new GeoPoint(sinBottomLat,sinLongitude,cosBottomLat,cosLongitude);
  this.plane=new Plane(cosLongitude,sinLongitude);
  final double middleLat=(topLat + bottomLat) * 0.5;
  final double sinMiddleLat=Math.sin(middleLat);
  final double cosMiddleLat=Math.cos(middleLat);
  this.centerPoint=new GeoPoint(sinMiddleLat,sinLongitude,cosMiddleLat,cosLongitude);
  this.topPlane=new SidedPlane(centerPoint,sinTopLat);
  this.bottomPlane=new SidedPlane(centerPoint,sinBottomLat);
  this.boundingPlane=new SidedPlane(centerPoint,-sinLongitude,cosLongitude);
  this.edgePoints=new GeoPoint[]{centerPoint};
}
