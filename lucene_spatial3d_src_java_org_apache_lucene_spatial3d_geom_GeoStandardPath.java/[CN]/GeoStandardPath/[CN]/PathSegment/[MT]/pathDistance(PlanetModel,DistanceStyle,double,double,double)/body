{
  if (!isWithin(x,y,z))   return Double.MAX_VALUE;
  final double perpX=normalizedConnectingPlane.y * z - normalizedConnectingPlane.z * y;
  final double perpY=normalizedConnectingPlane.z * x - normalizedConnectingPlane.x * z;
  final double perpZ=normalizedConnectingPlane.x * y - normalizedConnectingPlane.y * x;
  final double magnitude=Math.sqrt(perpX * perpX + perpY * perpY + perpZ * perpZ);
  if (Math.abs(magnitude) < Vector.MINIMUM_RESOLUTION)   return distanceStyle.computeDistance(start,x,y,z);
  final double normFactor=1.0 / magnitude;
  final Plane normalizedPerpPlane=new Plane(perpX * normFactor,perpY * normFactor,perpZ * normFactor,0.0);
  final GeoPoint[] intersectionPoints=normalizedConnectingPlane.findIntersections(planetModel,normalizedPerpPlane);
  GeoPoint thePoint;
  if (intersectionPoints.length == 0)   throw new RuntimeException("Can't find world intersection for point x=" + x + " y="+ y+ " z="+ z);
 else   if (intersectionPoints.length == 1)   thePoint=intersectionPoints[0];
 else {
    if (startCutoffPlane.isWithin(intersectionPoints[0]) && endCutoffPlane.isWithin(intersectionPoints[0]))     thePoint=intersectionPoints[0];
 else     if (startCutoffPlane.isWithin(intersectionPoints[1]) && endCutoffPlane.isWithin(intersectionPoints[1]))     thePoint=intersectionPoints[1];
 else     throw new RuntimeException("Can't find world intersection for point x=" + x + " y="+ y+ " z="+ z);
  }
  return distanceStyle.computeDistance(thePoint,x,y,z) + distanceStyle.computeDistance(start,thePoint.x,thePoint.y,thePoint.z);
}
