HEADER = '// This file has been automatically generated, DO NOT EDIT\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.util.packed;\n\nimport org.apache.lucene.store.DataInput;\nimport org.apache.lucene.util.RamUsageEstimator;\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\n'
TYPES = {8: 'byte', 16: 'short', 32: 'int', 64: 'long', }
MASKS = {8: ' & 0xFFL', 16: ' & 0xFFFFL', 32: ' & 0xFFFFFFFFL', 64: '', }
CASTS = {8: '(byte) ', 16: '(short) ', 32: '(int) ', 64: '', }
if (__name__ == '__main__'):
    for bpv in TYPES.keys():
        type
        f = open(('Direct%d.java' % bpv), 'w')
        f.write(HEADER)
        f.write(('/**\n * Direct wrapping of %d-bits values to a backing array.\n * @lucene.internal\n */\n' % bpv))
        f.write(('final class Direct%d extends PackedInts.MutableImpl {\n' % bpv))
        f.write(('  final %s[] values;\n\n' % TYPES[bpv]))
        f.write(('  Direct%d(int valueCount) {\n' % bpv))
        f.write(('    super(valueCount, %d);\n' % bpv))
        f.write(('    values = new %s[valueCount];\n' % TYPES[bpv]))
        f.write('  }\n\n')
        f.write(('  Direct%d(int packedIntsVersion, DataInput in, int valueCount) throws IOException {\n' % bpv))
        f.write('    this(valueCount);\n')
        if (bpv == 8):
            f.write('    in.readBytes(values, 0, valueCount);\n')
        else:
            f.write('    for (int i = 0; i < valueCount; ++i) {\n')
            f.write(('      values[i] = in.read%s();\n' % TYPES[bpv].title()))
            f.write('    }\n')
        if (bpv != 64):
            f.write('    // because packed ints have not always been byte-aligned\n')
            f.write(('    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, %d) - %dL * valueCount);\n' % (bpv, (bpv / 8))))
            f.write('    for (int i = 0; i < remaining; ++i) {\n')
            f.write('      in.readByte();\n')
            f.write('    }\n')
        f.write('  }\n')
        f.write(('\n  @Override\n  public long get(final int index) {\n    return values[index]%s;\n  }\n\n  @Override\n  public void set(final int index, final long value) {\n    values[index] = %s(value);\n  }\n\n  @Override\n  public long ramBytesUsed() {\n    return RamUsageEstimator.alignObjectSize(\n        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER\n        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue\n        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // values ref\n        + RamUsageEstimator.sizeOf(values);\n  }\n\n  @Override\n  public void clear() {\n    Arrays.fill(values, %s0L);\n  }\n' % (MASKS[bpv], CASTS[bpv], CASTS[bpv])))
        if (bpv == 64):
            f.write('\n  @Override\n  public int get(int index, long[] arr, int off, int len) {\n    assert len > 0 : "len must be > 0 (got " + len + ")";\n    assert index >= 0 && index < valueCount;\n    assert off + len <= arr.length;\n\n    final int gets = Math.min(valueCount - index, len);\n    System.arraycopy(values, index, arr, off, gets);\n    return gets;\n  }\n\n  @Override\n  public int set(int index, long[] arr, int off, int len) {\n    assert len > 0 : "len must be > 0 (got " + len + ")";\n    assert index >= 0 && index < valueCount;\n    assert off + len <= arr.length;\n\n    final int sets = Math.min(valueCount - index, len);\n    System.arraycopy(arr, off, values, index, sets);\n    return sets;\n  }\n\n  @Override\n  public void fill(int fromIndex, int toIndex, long val) {\n    Arrays.fill(values, fromIndex, toIndex, val);\n  }\n')
        else:
            f.write(('\n  @Override\n  public int get(int index, long[] arr, int off, int len) {\n    assert len > 0 : "len must be > 0 (got " + len + ")";\n    assert index >= 0 && index < valueCount;\n    assert off + len <= arr.length;\n\n    final int gets = Math.min(valueCount - index, len);\n    for (int i = index, o = off, end = index + gets; i < end; ++i, ++o) {\n      arr[o] = values[i]%s;\n    }\n    return gets;\n  }\n\n  @Override\n  public int set(int index, long[] arr, int off, int len) {\n    assert len > 0 : "len must be > 0 (got " + len + ")";\n    assert index >= 0 && index < valueCount;\n    assert off + len <= arr.length;\n\n    final int sets = Math.min(valueCount - index, len);\n    for (int i = index, o = off, end = index + sets; i < end; ++i, ++o) {\n      values[i] = %sarr[o];\n    }\n    return sets;\n  }\n\n  @Override\n  public void fill(int fromIndex, int toIndex, long val) {\n    assert val == (val%s);\n    Arrays.fill(values, fromIndex, toIndex, %sval);\n  }\n' % (MASKS[bpv], CASTS[bpv], MASKS[bpv], CASTS[bpv])))
        f.write('}\n')
        f.close()
