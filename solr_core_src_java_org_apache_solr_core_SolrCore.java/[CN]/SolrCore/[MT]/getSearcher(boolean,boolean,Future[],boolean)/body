{
synchronized (searcherLock) {
    if (_searcher != null && !forceNew) {
      if (returnSearcher) {
        _searcher.incref();
        return _searcher;
      }
 else {
        return null;
      }
    }
    if (onDeckSearchers > 0 && !forceNew && _searcher == null) {
      try {
        searcherLock.wait();
      }
 catch (      InterruptedException e) {
        log.info(SolrException.toStr(e));
      }
    }
    if (_searcher != null && !forceNew) {
      if (returnSearcher) {
        _searcher.incref();
        return _searcher;
      }
 else {
        return null;
      }
    }
    onDeckSearchers++;
    if (onDeckSearchers < 1) {
      log.error(logid + "ERROR!!! onDeckSearchers is " + onDeckSearchers);
      onDeckSearchers=1;
    }
 else     if (onDeckSearchers > maxWarmingSearchers) {
      onDeckSearchers--;
      String msg="Error opening new searcher. exceeded limit of maxWarmingSearchers=" + maxWarmingSearchers + ", try again later.";
      log.warn(logid + "" + msg);
      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,msg);
    }
 else     if (onDeckSearchers > 1) {
      log.warn(logid + "PERFORMANCE WARNING: Overlapping onDeckSearchers=" + onDeckSearchers);
    }
  }
  final boolean[] decrementOnDeckCount=new boolean[]{true};
  RefCounted<SolrIndexSearcher> currSearcherHolder=null;
  RefCounted<SolrIndexSearcher> searchHolder=null;
  boolean success=false;
  openSearcherLock.lock();
  try {
    searchHolder=openNewSearcher(updateHandlerReopens,false);
    if (returnSearcher) {
      searchHolder.incref();
    }
    final RefCounted<SolrIndexSearcher> newSearchHolder=searchHolder;
    final SolrIndexSearcher newSearcher=newSearchHolder.get();
    boolean alreadyRegistered=false;
synchronized (searcherLock) {
      if (_searcher == null) {
        if (solrConfig.useColdSearcher) {
          registerSearcher(newSearchHolder);
          decrementOnDeckCount[0]=false;
          alreadyRegistered=true;
        }
      }
 else {
        currSearcherHolder=_searcher;
        currSearcherHolder.incref();
      }
    }
    final SolrIndexSearcher currSearcher=currSearcherHolder == null ? null : currSearcherHolder.get();
    Future future=null;
    if (newSearcher != currSearcher) {
      if (currSearcher != null) {
        future=searcherExecutor.submit(new Callable(){
          @Override public Object call() throws Exception {
            try {
              newSearcher.warm(currSearcher);
            }
 catch (            Throwable e) {
              SolrException.log(log,e);
              if (e instanceof Error) {
                throw (Error)e;
              }
            }
            return null;
          }
        }
);
      }
      if (currSearcher == null) {
        if (updateHandler != null && updateHandler.getUpdateLog() != null) {
          updateHandler.getUpdateLog().onFirstSearcher(newSearcher);
        }
        future=searcherExecutor.submit(new Callable(){
          @Override public Object call() throws Exception {
            try {
              for (              SolrEventListener listener : firstSearcherListeners) {
                listener.newSearcher(newSearcher,null);
              }
            }
 catch (            Throwable e) {
              SolrException.log(log,null,e);
              if (e instanceof Error) {
                throw (Error)e;
              }
            }
            return null;
          }
        }
);
      }
      if (currSearcher != null) {
        future=searcherExecutor.submit(new Callable(){
          @Override public Object call() throws Exception {
            try {
              for (              SolrEventListener listener : newSearcherListeners) {
                listener.newSearcher(newSearcher,currSearcher);
              }
            }
 catch (            Throwable e) {
              SolrException.log(log,null,e);
              if (e instanceof Error) {
                throw (Error)e;
              }
            }
            return null;
          }
        }
);
      }
    }
    final RefCounted<SolrIndexSearcher> currSearcherHolderF=currSearcherHolder;
    if (!alreadyRegistered) {
      future=searcherExecutor.submit(new Callable(){
        @Override public Object call() throws Exception {
          try {
            registerSearcher(newSearchHolder);
          }
 catch (          Throwable e) {
            SolrException.log(log,e);
            if (e instanceof Error) {
              throw (Error)e;
            }
          }
 finally {
            if (currSearcherHolderF != null)             currSearcherHolderF.decref();
          }
          return null;
        }
      }
);
    }
    if (waitSearcher != null) {
      waitSearcher[0]=future;
    }
    success=true;
    return returnSearcher ? newSearchHolder : null;
  }
 catch (  Exception e) {
    if (e instanceof SolrException)     throw (SolrException)e;
    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);
  }
 finally {
    if (!success) {
synchronized (searcherLock) {
        onDeckSearchers--;
        if (onDeckSearchers < 0) {
          log.error(logid + "ERROR!!! onDeckSearchers after decrement=" + onDeckSearchers);
          onDeckSearchers=0;
        }
        searcherLock.notify();
      }
      if (currSearcherHolder != null) {
        currSearcherHolder.decref();
      }
      if (searchHolder != null) {
        searchHolder.decref();
        if (returnSearcher) {
          searchHolder.decref();
        }
      }
    }
    openSearcherLock.unlock();
  }
}
