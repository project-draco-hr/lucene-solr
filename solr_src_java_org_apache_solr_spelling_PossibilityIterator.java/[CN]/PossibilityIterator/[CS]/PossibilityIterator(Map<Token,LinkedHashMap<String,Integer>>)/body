{
  for (  Map.Entry<Token,LinkedHashMap<String,Integer>> entry : suggestions.entrySet()) {
    Token token=entry.getKey();
    List<SpellCheckCorrection> possibleCorrections=new ArrayList<SpellCheckCorrection>();
    for (    Map.Entry<String,Integer> entry1 : entry.getValue().entrySet()) {
      SpellCheckCorrection correction=new SpellCheckCorrection();
      correction.setOriginal(token);
      correction.setCorrection(entry1.getKey());
      correction.setNumberOfOccurences(entry1.getValue());
      possibleCorrections.add(correction);
    }
    possibilityList.add(possibleCorrections);
  }
  int wrapSize=possibilityList.size();
  if (wrapSize == 0) {
    done=true;
  }
 else {
    correctionIndex=new int[wrapSize];
    for (int i=0; i < wrapSize; i++) {
      int suggestSize=possibilityList.get(i).size();
      if (suggestSize == 0) {
        done=true;
        break;
      }
      correctionIndex[i]=0;
    }
  }
  while (internalHasNext()) {
    rankedPossibilityList.add(internalNext());
  }
  Collections.sort(rankedPossibilityList);
  rankedPossibilityIterator=rankedPossibilityList.iterator();
}
