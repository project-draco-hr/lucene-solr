{
  failed.set(false);
  addCount.set(0);
  delCount.set(0);
  packCount.set(0);
  final long t0=System.currentTimeMillis();
  Random random=new Random(random().nextLong());
  final LineFileDocs docs=new LineFileDocs(random,true);
  final Path tempDir=createTempDir(testName);
  dir=getDirectory(newMockFSDirectory(tempDir));
  if (dir instanceof BaseDirectoryWrapper) {
    ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false);
  }
  MockAnalyzer analyzer=new MockAnalyzer(random());
  analyzer.setMaxTokenLength(TestUtil.nextInt(random(),1,IndexWriter.MAX_TERM_LENGTH));
  final IndexWriterConfig conf=newIndexWriterConfig(analyzer).setCommitOnClose(false);
  conf.setInfoStream(new FailOnNonBulkMergesInfoStream());
  if (conf.getMergePolicy() instanceof MockRandomMergePolicy) {
    ((MockRandomMergePolicy)conf.getMergePolicy()).setDoNonBulkMerges(false);
  }
  if (LuceneTestCase.TEST_NIGHTLY) {
    MergePolicy mp=conf.getMergePolicy();
    if (mp instanceof TieredMergePolicy) {
      ((TieredMergePolicy)mp).setMaxMergedSegmentMB(5000.);
    }
 else     if (mp instanceof LogByteSizeMergePolicy) {
      ((LogByteSizeMergePolicy)mp).setMaxMergeMB(1000.);
    }
 else     if (mp instanceof LogMergePolicy) {
      ((LogMergePolicy)mp).setMaxMergeDocs(100000);
    }
  }
  conf.setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer(){
    @Override public void warm(    LeafReader reader) throws IOException {
      if (VERBOSE) {
        System.out.println("TEST: now warm merged reader=" + reader);
      }
      warmed.put(((SegmentReader)reader).core,Boolean.TRUE);
      final int maxDoc=reader.maxDoc();
      final Bits liveDocs=reader.getLiveDocs();
      int sum=0;
      final int inc=Math.max(1,maxDoc / 50);
      for (int docID=0; docID < maxDoc; docID+=inc) {
        if (liveDocs == null || liveDocs.get(docID)) {
          final StoredDocument doc=reader.document(docID);
          sum+=doc.getFields().size();
        }
      }
      IndexSearcher searcher=newSearcher(reader);
      sum+=searcher.search(new TermQuery(new Term("body","united")),10).totalHits;
      if (VERBOSE) {
        System.out.println("TEST: warm visited " + sum + " fields");
      }
    }
  }
);
  if (VERBOSE) {
    conf.setInfoStream(new PrintStreamInfoStream(System.out){
      @Override public void message(      String component,      String message){
        if ("TP".equals(component)) {
          return;
        }
        super.message(component,message);
      }
    }
);
  }
  writer=new IndexWriter(dir,conf);
  TestUtil.reduceOpenFiles(writer);
  final ExecutorService es=random().nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory(testName));
  doAfterWriter(es);
  final int NUM_INDEX_THREADS=TestUtil.nextInt(random(),2,4);
  final int RUN_TIME_SEC=LuceneTestCase.TEST_NIGHTLY ? 300 : RANDOM_MULTIPLIER;
  final Set<String> delIDs=Collections.synchronizedSet(new HashSet<String>());
  final Set<String> delPackIDs=Collections.synchronizedSet(new HashSet<String>());
  final List<SubDocs> allSubDocs=Collections.synchronizedList(new ArrayList<SubDocs>());
  final long stopTime=System.currentTimeMillis() + RUN_TIME_SEC * 1000;
  final Thread[] indexThreads=launchIndexingThreads(docs,NUM_INDEX_THREADS,stopTime,delIDs,delPackIDs,allSubDocs);
  if (VERBOSE) {
    System.out.println("TEST: DONE start " + NUM_INDEX_THREADS + " indexing threads ["+ (System.currentTimeMillis() - t0)+ " ms]");
  }
  Thread.sleep(100);
  doSearching(es,stopTime);
  if (VERBOSE) {
    System.out.println("TEST: all searching done [" + (System.currentTimeMillis() - t0) + " ms]");
  }
  for (int thread=0; thread < indexThreads.length; thread++) {
    indexThreads[thread].join();
  }
  if (VERBOSE) {
    System.out.println("TEST: done join indexing threads [" + (System.currentTimeMillis() - t0) + " ms]; addCount="+ addCount+ " delCount="+ delCount);
  }
  final IndexSearcher s=getFinalSearcher();
  if (VERBOSE) {
    System.out.println("TEST: finalSearcher=" + s);
  }
  assertFalse(failed.get());
  boolean doFail=false;
  for (  String id : delIDs) {
    final TopDocs hits=s.search(new TermQuery(new Term("docid",id)),1);
    if (hits.totalHits != 0) {
      System.out.println("doc id=" + id + " is supposed to be deleted, but got "+ hits.totalHits+ " hits; first docID="+ hits.scoreDocs[0].doc);
      doFail=true;
    }
  }
  for (  String id : delPackIDs) {
    final TopDocs hits=s.search(new TermQuery(new Term("packID",id)),1);
    if (hits.totalHits != 0) {
      System.out.println("packID=" + id + " is supposed to be deleted, but got "+ hits.totalHits+ " matches");
      doFail=true;
    }
  }
  for (  SubDocs subDocs : allSubDocs) {
    TopDocs hits=s.search(new TermQuery(new Term("packID",subDocs.packID)),20);
    if (!subDocs.deleted) {
      if (hits.totalHits != subDocs.subIDs.size()) {
        System.out.println("packID=" + subDocs.packID + ": expected "+ subDocs.subIDs.size()+ " hits but got "+ hits.totalHits);
        doFail=true;
      }
 else {
        int lastDocID=-1;
        int startDocID=-1;
        for (        ScoreDoc scoreDoc : hits.scoreDocs) {
          final int docID=scoreDoc.doc;
          if (lastDocID != -1) {
            assertEquals(1 + lastDocID,docID);
          }
 else {
            startDocID=docID;
          }
          lastDocID=docID;
          final StoredDocument doc=s.doc(docID);
          assertEquals(subDocs.packID,doc.get("packID"));
        }
        lastDocID=startDocID - 1;
        for (        String subID : subDocs.subIDs) {
          hits=s.search(new TermQuery(new Term("docid",subID)),1);
          assertEquals(1,hits.totalHits);
          final int docID=hits.scoreDocs[0].doc;
          if (lastDocID != -1) {
            assertEquals(1 + lastDocID,docID);
          }
          lastDocID=docID;
        }
      }
    }
 else {
      for (      String subID : subDocs.subIDs) {
        assertEquals(0,s.search(new TermQuery(new Term("docid",subID)),1).totalHits);
      }
    }
  }
  final int endID=Integer.parseInt(docs.nextDoc().get("docid"));
  docs.close();
  for (int id=0; id < endID; id++) {
    String stringID="" + id;
    if (!delIDs.contains(stringID)) {
      final TopDocs hits=s.search(new TermQuery(new Term("docid",stringID)),1);
      if (hits.totalHits != 1) {
        System.out.println("doc id=" + stringID + " is not supposed to be deleted, but got hitCount="+ hits.totalHits+ "; delIDs="+ delIDs);
        doFail=true;
      }
    }
  }
  assertFalse(doFail);
  assertEquals("index=" + writer.segString() + " addCount="+ addCount+ " delCount="+ delCount,addCount.get() - delCount.get(),s.getIndexReader().numDocs());
  releaseSearcher(s);
  writer.commit();
  assertEquals("index=" + writer.segString() + " addCount="+ addCount+ " delCount="+ delCount,addCount.get() - delCount.get(),writer.numDocs());
  doClose();
  try {
    writer.commit();
  }
  finally {
    writer.close();
  }
  if (es != null) {
    es.shutdown();
    es.awaitTermination(1,TimeUnit.SECONDS);
  }
  TestUtil.checkIndex(dir);
  dir.close();
  IOUtils.rm(tempDir);
  if (VERBOSE) {
    System.out.println("TEST: done [" + (System.currentTimeMillis() - t0) + " ms]");
  }
}
