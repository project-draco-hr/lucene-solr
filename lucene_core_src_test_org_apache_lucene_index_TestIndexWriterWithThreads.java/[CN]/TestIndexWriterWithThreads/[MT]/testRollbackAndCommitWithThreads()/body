{
  final MockDirectoryWrapper d=newFSDirectory(_TestUtil.getTempDir("RollbackAndCommitWithThreads"));
  d.setPreventDoubleWrite(false);
  final int threadCount=_TestUtil.nextInt(random(),2,6);
  final AtomicReference<IndexWriter> writerRef=new AtomicReference<IndexWriter>();
  writerRef.set(new IndexWriter(d,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random()))));
  final LineFileDocs docs=new LineFileDocs(random());
  final Thread[] threads=new Thread[threadCount];
  final int iters=atLeast(1000);
  final AtomicBoolean failed=new AtomicBoolean();
  final Lock rollbackLock=new ReentrantLock();
  final Lock commitLock=new ReentrantLock();
  for (int threadID=0; threadID < threadCount; threadID++) {
    threads[threadID]=new Thread(){
      @Override public void run(){
        for (int iter=0; iter < iters && !failed.get(); iter++) {
          final int x=random().nextInt(3);
          try {
switch (x) {
case 0:
              rollbackLock.lock();
            if (VERBOSE) {
              System.out.println("\nTEST: " + Thread.currentThread().getName() + ": now rollback");
            }
          try {
            writerRef.get().rollback();
            if (VERBOSE) {
              System.out.println("TEST: " + Thread.currentThread().getName() + ": rollback done; now open new writer");
            }
            writerRef.set(new IndexWriter(d,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random()))));
          }
  finally {
            rollbackLock.unlock();
          }
        break;
case 1:
      commitLock.lock();
    if (VERBOSE) {
      System.out.println("\nTEST: " + Thread.currentThread().getName() + ": now commit");
    }
  try {
    if (random().nextBoolean()) {
      writerRef.get().prepareCommit();
    }
    writerRef.get().commit();
  }
 catch (  AlreadyClosedException ace) {
  }
catch (  NullPointerException npe) {
  }
 finally {
    commitLock.unlock();
  }
break;
case 2:
if (VERBOSE) {
System.out.println("\nTEST: " + Thread.currentThread().getName() + ": now add");
}
try {
writerRef.get().addDocument(docs.nextDoc());
}
 catch (AlreadyClosedException ace) {
}
catch (NullPointerException npe) {
}
catch (AssertionError ae) {
}
break;
}
}
 catch (Throwable t) {
failed.set(true);
throw new RuntimeException(t);
}
}
}
}
;
threads[threadID].start();
}
for (int threadID=0; threadID < threadCount; threadID++) {
threads[threadID].join();
}
assertTrue(!failed.get());
writerRef.get().close();
d.close();
}
