{
  final List<GeoPoint> noIdenticalPoints=new ArrayList<>(input.size());
  int startIndex=-1;
  final GeoPoint comparePoint=input.get(0);
  for (int i=0; i < input.size() - 1; i++) {
    final GeoPoint thePoint=input.get(getLegalIndex(-i - 1,input.size()));
    if (!thePoint.isNumericallyIdentical(comparePoint)) {
      startIndex=getLegalIndex(-i,input.size());
      break;
    }
  }
  if (startIndex == -1) {
    return null;
  }
  int currentIndex=startIndex;
  while (true) {
    final GeoPoint currentPoint=input.get(currentIndex);
    noIdenticalPoints.add(currentPoint);
    while (true) {
      currentIndex=getLegalIndex(currentIndex + 1,input.size());
      if (currentIndex == startIndex) {
        break;
      }
      final GeoPoint nextNonIdenticalPoint=input.get(currentIndex);
      if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {
        break;
      }
    }
    if (currentIndex == startIndex) {
      break;
    }
  }
  if (noIdenticalPoints.size() < 3) {
    return null;
  }
  for (int i=0; i < noIdenticalPoints.size(); i++) {
    final SafePath startPath=new SafePath(null,noIdenticalPoints.get(i),i,null);
    final SafePath resultPath=findSafePath(startPath,noIdenticalPoints,getLegalIndex(i + 1,noIdenticalPoints.size()),i);
    if (resultPath != null && resultPath.previous != null) {
      final List<GeoPoint> rval=new ArrayList<>(noIdenticalPoints.size());
      resultPath.fillInList(rval);
      return rval;
    }
  }
  return null;
}
