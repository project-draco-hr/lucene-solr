{
  final EdgeBuffer edgeBuffer=new EdgeBuffer(pointsList,internalEdges,startPointIndex,endPointIndex,startingEdge);
  Edge stoppingPoint=edgeBuffer.pickOne();
  Edge currentEdge=stoppingPoint;
  while (true) {
    if (currentEdge == null) {
      break;
    }
    final Boolean foundIt=findConvexPolygon(planetModel,currentEdge,rval,edgeBuffer,holes,testPoint);
    if (foundIt == null) {
      return null;
    }
    if (foundIt) {
      stoppingPoint=edgeBuffer.pickOne();
      currentEdge=stoppingPoint;
      continue;
    }
    currentEdge=edgeBuffer.getNext(currentEdge);
    if (currentEdge == stoppingPoint) {
      break;
    }
  }
  final Iterator<Edge> checkIterator=edgeBuffer.iterator();
  while (checkIterator.hasNext()) {
    final Edge checkEdge=checkIterator.next();
    final SidedPlane flippedPlane=new SidedPlane(checkEdge.plane);
    final Iterator<Edge> confirmIterator=edgeBuffer.iterator();
    while (confirmIterator.hasNext()) {
      final Edge confirmEdge=confirmIterator.next();
      if (confirmEdge == checkEdge) {
        continue;
      }
      final GeoPoint thePoint;
      if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {
        thePoint=confirmEdge.startPoint;
      }
 else       if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {
        thePoint=confirmEdge.endPoint;
      }
 else {
        thePoint=null;
      }
      if (thePoint != null) {
        final List<GeoPoint> thirdPartPoints=new ArrayList<>();
        final BitSet thirdPartInternal=new BitSet();
        thirdPartPoints.add(checkEdge.startPoint);
        thirdPartInternal.set(0,checkEdge.isInternal);
        thirdPartPoints.add(checkEdge.endPoint);
        thirdPartInternal.set(1,true);
        thirdPartPoints.add(thePoint);
        thirdPartInternal.set(2,true);
        final GeoPolygon thirdPoly=buildPolygonShape(rval,planetModel,thirdPartPoints,thirdPartInternal,0,1,checkEdge.plane,holes,testPoint);
        if (thirdPoly == null) {
          return null;
        }
        Edge loopEdge=edgeBuffer.getPrevious(checkEdge);
        final List<GeoPoint> firstPartPoints=new ArrayList<>();
        final BitSet firstPartInternal=new BitSet();
        int i=0;
        while (true) {
          firstPartPoints.add(loopEdge.endPoint);
          if (loopEdge.endPoint == thePoint) {
            break;
          }
          firstPartInternal.set(i++,loopEdge.isInternal);
          loopEdge=edgeBuffer.getPrevious(loopEdge);
        }
        firstPartInternal.set(i,true);
        final GeoPolygon firstPoly=buildPolygonShape(rval,planetModel,firstPartPoints,firstPartInternal,firstPartPoints.size() - 1,0,new SidedPlane(checkEdge.endPoint,false,checkEdge.startPoint,thePoint),holes,testPoint);
        if (firstPoly == null) {
          return null;
        }
        final List<GeoPoint> secondPartPoints=new ArrayList<>();
        final BitSet secondPartInternal=new BitSet();
        loopEdge=edgeBuffer.getNext(checkEdge);
        i=0;
        while (true) {
          secondPartPoints.add(loopEdge.startPoint);
          if (loopEdge.startPoint == thePoint) {
            break;
          }
          secondPartInternal.set(i++,loopEdge.isInternal);
          loopEdge=edgeBuffer.getNext(loopEdge);
        }
        secondPartInternal.set(i,true);
        final GeoPolygon secondPoly=buildPolygonShape(rval,planetModel,secondPartPoints,secondPartInternal,secondPartPoints.size() - 1,0,new SidedPlane(checkEdge.endPoint,true,checkEdge.startPoint,thePoint),holes,testPoint);
        if (secondPoly == null) {
          return null;
        }
        return rval;
      }
    }
  }
  if (makeConcavePolygon(planetModel,rval,edgeBuffer,holes,testPoint) == false) {
    return null;
  }
  return rval;
}
