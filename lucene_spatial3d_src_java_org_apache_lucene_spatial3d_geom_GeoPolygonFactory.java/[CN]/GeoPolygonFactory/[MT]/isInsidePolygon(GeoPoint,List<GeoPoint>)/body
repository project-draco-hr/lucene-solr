{
  final double norm=1.0 / point.magnitude();
  final double xyDenom=Math.sqrt(point.x * point.x + point.y * point.y);
  final double sinLatitude=point.z * norm;
  final double cosLatitude=xyDenom * norm;
  final double sinLongitude;
  final double cosLongitude;
  if (Math.abs(xyDenom) < Vector.MINIMUM_RESOLUTION) {
    sinLongitude=0.0;
    cosLongitude=1.0;
  }
 else {
    final double xyNorm=1.0 / xyDenom;
    sinLongitude=point.y * xyNorm;
    cosLongitude=point.x * xyNorm;
  }
  double arcDistance=0.0;
  Double prevAngle=null;
  for (  final GeoPoint polyPoint : polyPoints) {
    final Double angle=computeAngle(polyPoint,sinLatitude,cosLatitude,sinLongitude,cosLongitude);
    if (angle == null) {
      return null;
    }
    if (prevAngle != null) {
      double angleDelta=angle - prevAngle;
      if (angleDelta < -Math.PI) {
        angleDelta+=Math.PI * 2.0;
      }
      if (angleDelta > Math.PI) {
        angleDelta-=Math.PI * 2.0;
      }
      if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {
        return null;
      }
      arcDistance+=angleDelta;
    }
    prevAngle=angle;
  }
  if (prevAngle != null) {
    final Double lastAngle=computeAngle(polyPoints.get(0),sinLatitude,cosLatitude,sinLongitude,cosLongitude);
    if (lastAngle == null) {
      return null;
    }
    double angleDelta=lastAngle - prevAngle;
    if (angleDelta < -Math.PI) {
      angleDelta+=Math.PI * 2.0;
    }
    if (angleDelta > Math.PI) {
      angleDelta-=Math.PI * 2.0;
    }
    if (Math.abs(angleDelta - Math.PI) < Vector.MINIMUM_RESOLUTION) {
      return null;
    }
    arcDistance+=angleDelta;
  }
  if (Math.abs(arcDistance) < Vector.MINIMUM_RESOLUTION) {
    return null;
  }
  return arcDistance > 0.0;
}
