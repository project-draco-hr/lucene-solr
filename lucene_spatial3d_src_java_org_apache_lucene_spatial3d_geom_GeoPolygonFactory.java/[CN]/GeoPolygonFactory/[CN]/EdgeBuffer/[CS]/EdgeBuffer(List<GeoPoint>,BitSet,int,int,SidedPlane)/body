{
  final Edge startEdge=new Edge(pointList.get(startPlaneStartIndex),pointList.get(startPlaneEndIndex),startPlane,internalEdges.get(startPlaneStartIndex));
  Edge currentEdge=startEdge;
  int startIndex=startPlaneStartIndex;
  int endIndex=startPlaneEndIndex;
  while (true) {
    startIndex=endIndex;
    endIndex++;
    if (endIndex >= pointList.size()) {
      endIndex-=pointList.size();
    }
    final GeoPoint newPoint=pointList.get(endIndex);
    final boolean isNewPointWithin;
    final GeoPoint pointToPresent;
    if (currentEdge.plane.evaluateIsZero(newPoint)) {
      int checkPointIndex=-1;
      final Plane checkPlane=new Plane(pointList.get(startIndex),newPoint);
      for (int i=0; i < pointList.size(); i++) {
        final int index=getLegalIndex(startIndex - 1 - i,pointList.size());
        if (!checkPlane.evaluateIsZero(pointList.get(index))) {
          checkPointIndex=index;
          break;
        }
 else {
        }
      }
      if (checkPointIndex == -1) {
        throw new IllegalArgumentException("polygon is illegal (linear)");
      }
      pointToPresent=pointList.get(checkPointIndex);
      isNewPointWithin=currentEdge.plane.isWithin(pointToPresent);
    }
 else {
      isNewPointWithin=currentEdge.plane.isWithin(newPoint);
      pointToPresent=currentEdge.startPoint;
    }
    final SidedPlane newPlane=new SidedPlane(pointToPresent,isNewPointWithin,pointList.get(startIndex),newPoint);
    final Edge newEdge=new Edge(pointList.get(startIndex),pointList.get(endIndex),newPlane,internalEdges.get(startIndex));
    previousEdges.put(newEdge,currentEdge);
    nextEdges.put(currentEdge,newEdge);
    edges.add(newEdge);
    currentEdge=newEdge;
    if (currentEdge.endPoint == startEdge.startPoint) {
      previousEdges.put(startEdge,currentEdge);
      nextEdges.put(currentEdge,startEdge);
      edges.add(startEdge);
      break;
    }
  }
  oneEdge=startEdge;
}
