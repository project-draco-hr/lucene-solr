{
  int iters=atLeast(100);
  for (int iter=0; iter < iters; iter++) {
    BytesRef minTerm=TestUtil.randomBinaryTerm(random());
    boolean minInclusive=random().nextBoolean();
    BytesRef maxTerm=TestUtil.randomBinaryTerm(random());
    boolean maxInclusive=random().nextBoolean();
    if (VERBOSE) {
      System.out.println("TEST: iter=" + iter + " minTerm="+ minTerm+ " minInclusive="+ minInclusive+ " maxTerm="+ maxTerm+ " maxInclusive="+ maxInclusive);
    }
    Automaton a=Automata.makeBinaryInterval(minTerm,minInclusive,maxTerm,maxInclusive);
    Automaton minA=MinimizationOperations.minimize(a,Integer.MAX_VALUE);
    if (minA.getNumStates() != a.getNumStates()) {
      assertTrue(minA.getNumStates() < a.getNumStates());
      System.out.println("Original was not minimal:");
      System.out.println("Original:\n" + a.toDot());
      System.out.println("Minimized:\n" + minA.toDot());
      System.out.println("minTerm=" + minTerm + " minInclusive="+ minInclusive);
      System.out.println("maxTerm=" + maxTerm + " maxInclusive="+ maxInclusive);
      fail("auotmaton was not minimal");
    }
    if (VERBOSE) {
      System.out.println(a.toDot());
    }
    for (int iter2=0; iter2 < 500; iter2++) {
      BytesRef term=TestUtil.randomBinaryTerm(random());
      int minCmp=minTerm.compareTo(term);
      int maxCmp=maxTerm.compareTo(term);
      boolean expected;
      if (minCmp > 0 || maxCmp < 0) {
        expected=false;
      }
 else       if (minCmp == 0 && maxCmp == 0) {
        expected=minInclusive && maxInclusive;
      }
 else       if (minCmp == 0) {
        expected=minInclusive;
      }
 else       if (maxCmp == 0) {
        expected=maxInclusive;
      }
 else {
        expected=true;
      }
      if (VERBOSE) {
        System.out.println("  check term=" + term + " expected="+ expected);
      }
      IntsRefBuilder intsBuilder=new IntsRefBuilder();
      Util.toIntsRef(term,intsBuilder);
      assertEquals(expected,Operations.run(a,intsBuilder.toIntsRef()));
    }
  }
}
