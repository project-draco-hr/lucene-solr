{
  Directory dir=newDirectory();
  RandomIndexWriter w=new RandomIndexWriter(random(),dir);
  int numDocs=atLeast(1000);
  double[] values=new double[numDocs];
  double minValue=Double.POSITIVE_INFINITY;
  double maxValue=Double.NEGATIVE_INFINITY;
  for (int i=0; i < numDocs; i++) {
    Document doc=new Document();
    double v=random().nextDouble();
    values[i]=v;
    doc.add(new DoubleDocValuesField("field",v));
    doc.add(new DoubleField("field",v,Field.Store.NO));
    w.addDocument(doc);
    minValue=Math.min(minValue,v);
    maxValue=Math.max(maxValue,v);
  }
  IndexReader r=w.getReader();
  IndexSearcher s=newSearcher(r);
  FacetsConfig config=new FacetsConfig();
  int numIters=atLeast(10);
  for (int iter=0; iter < numIters; iter++) {
    if (VERBOSE) {
      System.out.println("TEST: iter=" + iter);
    }
    int numRange=TestUtil.nextInt(random(),1,5);
    DoubleRange[] ranges=new DoubleRange[numRange];
    int[] expectedCounts=new int[numRange];
    double minAcceptedValue=Double.POSITIVE_INFINITY;
    double maxAcceptedValue=Double.NEGATIVE_INFINITY;
    for (int rangeID=0; rangeID < numRange; rangeID++) {
      double min;
      if (rangeID > 0 && random().nextInt(10) == 7) {
        DoubleRange prevRange=ranges[random().nextInt(rangeID)];
        if (random().nextBoolean()) {
          min=prevRange.min;
        }
 else {
          min=prevRange.max;
        }
      }
 else {
        min=random().nextDouble();
      }
      double max;
      if (rangeID > 0 && random().nextInt(10) == 7) {
        DoubleRange prevRange=ranges[random().nextInt(rangeID)];
        if (random().nextBoolean()) {
          max=prevRange.min;
        }
 else {
          max=prevRange.max;
        }
      }
 else {
        max=random().nextDouble();
      }
      if (min > max) {
        double x=min;
        min=max;
        max=x;
      }
      boolean minIncl;
      boolean maxIncl;
      if (min == max) {
        minIncl=true;
        maxIncl=true;
      }
 else {
        minIncl=random().nextBoolean();
        maxIncl=random().nextBoolean();
      }
      ranges[rangeID]=new DoubleRange("r" + rangeID,min,minIncl,max,maxIncl);
      for (int i=0; i < numDocs; i++) {
        boolean accept=true;
        if (minIncl) {
          accept&=values[i] >= min;
        }
 else {
          accept&=values[i] > min;
        }
        if (maxIncl) {
          accept&=values[i] <= max;
        }
 else {
          accept&=values[i] < max;
        }
        if (accept) {
          expectedCounts[rangeID]++;
          minAcceptedValue=Math.min(minAcceptedValue,values[i]);
          maxAcceptedValue=Math.max(maxAcceptedValue,values[i]);
        }
      }
    }
    FacetsCollector sfc=new FacetsCollector();
    s.search(new MatchAllDocsQuery(),sfc);
    Filter fastMatchFilter;
    if (random().nextBoolean()) {
      if (random().nextBoolean()) {
        fastMatchFilter=NumericRangeFilter.newDoubleRange("field",minValue,maxValue,true,true);
      }
 else {
        fastMatchFilter=NumericRangeFilter.newDoubleRange("field",minAcceptedValue,maxAcceptedValue,true,true);
      }
    }
 else {
      fastMatchFilter=null;
    }
    ValueSource vs=new DoubleFieldSource("field");
    Facets facets=new DoubleRangeFacetCounts("field",vs,sfc,fastMatchFilter,ranges);
    FacetResult result=facets.getTopChildren(10,"field");
    assertEquals(numRange,result.labelValues.length);
    for (int rangeID=0; rangeID < numRange; rangeID++) {
      if (VERBOSE) {
        System.out.println("  range " + rangeID + " expectedCount="+ expectedCounts[rangeID]);
      }
      LabelAndValue subNode=result.labelValues[rangeID];
      assertEquals("r" + rangeID,subNode.label);
      assertEquals(expectedCounts[rangeID],subNode.value.intValue());
      DoubleRange range=ranges[rangeID];
      DrillDownQuery ddq=new DrillDownQuery(config);
      if (random().nextBoolean()) {
        if (random().nextBoolean()) {
          ddq.add("field",NumericRangeFilter.newDoubleRange("field",range.min,range.max,range.minInclusive,range.maxInclusive));
        }
 else {
          ddq.add("field",NumericRangeQuery.newDoubleRange("field",range.min,range.max,range.minInclusive,range.maxInclusive));
        }
      }
 else {
        ddq.add("field",range.getFilter(fastMatchFilter,vs));
      }
      assertEquals(expectedCounts[rangeID],s.search(ddq,10).totalHits);
    }
  }
  w.close();
  IOUtils.close(r,dir);
}
