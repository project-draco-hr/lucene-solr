{
  Directory dir=newDirectory();
  RandomIndexWriter w=new RandomIndexWriter(random(),dir);
  int numDocs=atLeast(1000);
  float[] values=new float[numDocs];
  float minValue=Float.POSITIVE_INFINITY;
  float maxValue=Float.NEGATIVE_INFINITY;
  for (int i=0; i < numDocs; i++) {
    Document doc=new Document();
    float v=random().nextFloat();
    values[i]=v;
    doc.add(new FloatDocValuesField("field",v));
    doc.add(new FloatPoint("field",v));
    w.addDocument(doc);
    minValue=Math.min(minValue,v);
    maxValue=Math.max(maxValue,v);
  }
  IndexReader r=w.getReader();
  IndexSearcher s=newSearcher(r,false);
  FacetsConfig config=new FacetsConfig();
  int numIters=atLeast(10);
  for (int iter=0; iter < numIters; iter++) {
    if (VERBOSE) {
      System.out.println("TEST: iter=" + iter);
    }
    int numRange=TestUtil.nextInt(random(),1,5);
    DoubleRange[] ranges=new DoubleRange[numRange];
    int[] expectedCounts=new int[numRange];
    float minAcceptedValue=Float.POSITIVE_INFINITY;
    float maxAcceptedValue=Float.NEGATIVE_INFINITY;
    boolean[] rangeMinIncl=new boolean[numRange];
    boolean[] rangeMaxIncl=new boolean[numRange];
    if (VERBOSE) {
      System.out.println("TEST: " + numRange + " ranges");
    }
    for (int rangeID=0; rangeID < numRange; rangeID++) {
      double min;
      if (rangeID > 0 && random().nextInt(10) == 7) {
        DoubleRange prevRange=ranges[random().nextInt(rangeID)];
        if (random().nextBoolean()) {
          min=prevRange.min;
        }
 else {
          min=prevRange.max;
        }
      }
 else {
        min=random().nextDouble();
      }
      double max;
      if (rangeID > 0 && random().nextInt(10) == 7) {
        DoubleRange prevRange=ranges[random().nextInt(rangeID)];
        if (random().nextBoolean()) {
          max=prevRange.min;
        }
 else {
          max=prevRange.max;
        }
      }
 else {
        max=random().nextDouble();
      }
      if (min > max) {
        double x=min;
        min=max;
        max=x;
      }
      min=(float)min;
      max=(float)max;
      boolean minIncl;
      boolean maxIncl;
      if (min == max) {
        minIncl=true;
        maxIncl=true;
      }
 else {
        minIncl=random().nextBoolean();
        maxIncl=random().nextBoolean();
      }
      rangeMinIncl[rangeID]=minIncl;
      rangeMaxIncl[rangeID]=maxIncl;
      ranges[rangeID]=new DoubleRange("r" + rangeID,min,minIncl,max,maxIncl);
      if (VERBOSE) {
        System.out.println("TEST:   range " + rangeID + ": "+ ranges[rangeID]);
      }
      for (int i=0; i < numDocs; i++) {
        boolean accept=true;
        if (minIncl) {
          accept&=values[i] >= min;
        }
 else {
          accept&=values[i] > min;
        }
        if (maxIncl) {
          accept&=values[i] <= max;
        }
 else {
          accept&=values[i] < max;
        }
        if (VERBOSE) {
          System.out.println("TEST:   check doc=" + i + " val="+ values[i]+ " accept="+ accept);
        }
        if (accept) {
          expectedCounts[rangeID]++;
          minAcceptedValue=Math.min(minAcceptedValue,values[i]);
          maxAcceptedValue=Math.max(maxAcceptedValue,values[i]);
        }
      }
    }
    FacetsCollector sfc=new FacetsCollector();
    s.search(new MatchAllDocsQuery(),sfc);
    Query fastMatchQuery;
    if (random().nextBoolean()) {
      if (random().nextBoolean()) {
        fastMatchQuery=FloatPoint.newRangeQuery("field",minValue,maxValue);
      }
 else {
        fastMatchQuery=FloatPoint.newRangeQuery("field",minAcceptedValue,maxAcceptedValue);
      }
    }
 else {
      fastMatchQuery=null;
    }
    ValueSource vs=new FloatFieldSource("field");
    Facets facets=new DoubleRangeFacetCounts("field",vs,sfc,fastMatchQuery,ranges);
    FacetResult result=facets.getTopChildren(10,"field");
    assertEquals(numRange,result.labelValues.length);
    for (int rangeID=0; rangeID < numRange; rangeID++) {
      if (VERBOSE) {
        System.out.println("TEST: verify range " + rangeID + " expectedCount="+ expectedCounts[rangeID]);
      }
      LabelAndValue subNode=result.labelValues[rangeID];
      assertEquals("r" + rangeID,subNode.label);
      assertEquals(expectedCounts[rangeID],subNode.value.intValue());
      DoubleRange range=ranges[rangeID];
      DrillDownQuery ddq=new DrillDownQuery(config);
      if (random().nextBoolean()) {
        float minFloat=(float)range.min;
        if (rangeMinIncl[rangeID] == false) {
          minFloat=Math.nextUp(minFloat);
        }
        float maxFloat=(float)range.max;
        if (rangeMaxIncl[rangeID] == false) {
          maxFloat=Math.nextAfter(maxFloat,Float.NEGATIVE_INFINITY);
        }
        ddq.add("field",FloatPoint.newRangeQuery("field",minFloat,maxFloat));
      }
 else {
        ddq.add("field",range.getQuery(fastMatchQuery,vs));
      }
      assertEquals(expectedCounts[rangeID],s.search(ddq,10).totalHits);
    }
  }
  w.close();
  IOUtils.close(r,dir);
}
