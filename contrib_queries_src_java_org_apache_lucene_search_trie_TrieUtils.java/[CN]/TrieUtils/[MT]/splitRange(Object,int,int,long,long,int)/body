{
  final long diff=1L << (shift + precisionStep), mask=((1L << precisionStep) - 1L) << shift;
  final boolean hasLower=(minBound & mask) != 0L, hasUpper=(maxBound & mask) != mask;
  final long nextMinBound=(hasLower ? (minBound + diff) : minBound) & ~mask, nextMaxBound=(hasUpper ? (maxBound - diff) : maxBound) & ~mask;
  if (shift + precisionStep >= valSize || nextMinBound > nextMaxBound) {
    addRange(builder,valSize,precisionStep,minBound,maxBound,shift);
  }
 else {
    if (hasLower)     addRange(builder,valSize,precisionStep,minBound,minBound | mask,shift);
    if (hasUpper)     addRange(builder,valSize,precisionStep,maxBound & ~mask,maxBound,shift);
    splitRange(builder,valSize,precisionStep,nextMinBound,nextMaxBound,shift + precisionStep);
  }
}
