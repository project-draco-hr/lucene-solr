{
  for (int level=0, shift=0; ; level++) {
    final long diff=1L << (shift + precisionStep), mask=((1L << precisionStep) - 1L) << shift;
    final boolean hasLower=(minBound & mask) != 0L, hasUpper=(maxBound & mask) != mask;
    final long nextMinBound=(hasLower ? (minBound + diff) : minBound) & ~mask, nextMaxBound=(hasUpper ? (maxBound - diff) : maxBound) & ~mask;
    if (shift + precisionStep >= valSize || nextMinBound > nextMaxBound) {
      addRange(builder,valSize,minBound,maxBound,shift,level);
      break;
    }
    if (hasLower)     addRange(builder,valSize,minBound,minBound | mask,shift,level);
    if (hasUpper)     addRange(builder,valSize,maxBound & ~mask,maxBound,shift,level);
    minBound=nextMinBound;
    maxBound=nextMaxBound;
    shift+=precisionStep;
  }
}
