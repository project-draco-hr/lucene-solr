{
  for (int shift=0; ; shift+=precisionStep) {
    final long diff=1L << (shift + precisionStep), mask=((1L << precisionStep) - 1L) << shift;
    final boolean hasLower=(minBound & mask) != 0L, hasUpper=(maxBound & mask) != mask;
    final long nextMinBound=(hasLower ? (minBound + diff) : minBound) & ~mask, nextMaxBound=(hasUpper ? (maxBound - diff) : maxBound) & ~mask;
    if (shift + precisionStep >= valSize || nextMinBound > nextMaxBound) {
      addRange(builder,valSize,precisionStep,minBound,maxBound,shift);
      break;
    }
    if (hasLower)     addRange(builder,valSize,precisionStep,minBound,minBound | mask,shift);
    if (hasUpper)     addRange(builder,valSize,precisionStep,maxBound & ~mask,maxBound,shift);
    minBound=nextMinBound;
    maxBound=nextMaxBound;
  }
}
