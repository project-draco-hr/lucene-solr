{
  final int from=random().nextInt(5);
  final int to=from + TestUtil.nextInt(random(),1,10000);
  final int maxLen=TestUtil.nextInt(random(),1,12);
  BytesRef[] arr=new BytesRef[from + to + random().nextInt(5)];
  for (int i=0; i < arr.length; ++i) {
    byte[] bytes=new byte[TestUtil.nextInt(random(),0,maxLen)];
    random().nextBytes(bytes);
    arr[i]=new BytesRef(bytes);
  }
  final int k=TestUtil.nextInt(random(),from,to - 1);
  BytesRef[] expected=arr.clone();
  Arrays.sort(expected,from,to);
  BytesRef[] actual=arr.clone();
  RadixSelector selector=new RadixSelector(random().nextBoolean() ? maxLen : Integer.MAX_VALUE){
    @Override protected void swap(    int i,    int j){
      ArrayUtil.swap(actual,i,j);
    }
    @Override protected int byteAt(    int i,    int k){
      BytesRef b=actual[i];
      if (k >= b.length) {
        return -1;
      }
 else {
        return Byte.toUnsignedInt(b.bytes[b.offset + k]);
      }
    }
  }
;
  selector.select(from,to,k);
  assertEquals(expected[k],actual[k]);
  for (int i=0; i < actual.length; ++i) {
    if (i < from || i >= to) {
      assertSame(arr[i],actual[i]);
    }
 else     if (i <= k) {
      assertTrue(actual[i].compareTo(actual[k]) <= 0);
    }
 else {
      assertTrue(actual[i].compareTo(actual[k]) >= 0);
    }
  }
}
