{
  boolean ordered=true;
  int slop=1;
  IndexReaderContext topReaderContext=searcher.getTopReaderContext();
  List<AtomicReaderContext> leaves=topReaderContext.leaves();
  int subIndex=ReaderUtil.subIndex(11,leaves);
  for (int i=0, c=leaves.size(); i < c; i++) {
    final AtomicReaderContext ctx=leaves.get(i);
    final Similarity sim=new DefaultSimilarity(){
      @Override public float sloppyFreq(      int distance){
        return 0.0f;
      }
    }
;
    final Similarity oldSim=searcher.getSimilarity();
    Scorer spanScorer;
    try {
      searcher.setSimilarity(sim);
      SpanNearQuery snq=new SpanNearQuery(new SpanQuery[]{makeSpanTermQuery("t1"),makeSpanTermQuery("t2")},slop,ordered);
      spanScorer=searcher.createNormalizedWeight(snq).scorer(ctx,true,false,ctx.reader().getLiveDocs());
    }
  finally {
      searcher.setSimilarity(oldSim);
    }
    if (i == subIndex) {
      assertTrue("first doc",spanScorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
      assertEquals("first doc number",spanScorer.docID() + ctx.docBase,11);
      float score=spanScorer.score();
      assertTrue("first doc score should be zero, " + score,score == 0.0f);
    }
 else {
      assertTrue("no second doc",spanScorer.nextDoc() == DocIdSetIterator.NO_MORE_DOCS);
    }
  }
}
