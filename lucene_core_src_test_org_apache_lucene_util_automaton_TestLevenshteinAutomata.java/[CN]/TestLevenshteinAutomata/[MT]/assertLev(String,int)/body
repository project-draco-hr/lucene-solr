{
  LevenshteinAutomata builder=new LevenshteinAutomata(s,false);
  LevenshteinAutomata tbuilder=new LevenshteinAutomata(s,true);
  LightAutomaton automata[]=new LightAutomaton[maxDistance + 1];
  LightAutomaton tautomata[]=new LightAutomaton[maxDistance + 1];
  for (int n=0; n < automata.length; n++) {
    automata[n]=builder.toLightAutomaton(n);
    tautomata[n]=tbuilder.toLightAutomaton(n);
    assertNotNull(automata[n]);
    assertNotNull(tautomata[n]);
    assertTrue(BasicOperations.isDeterministic(automata[n]));
    assertTrue(BasicOperations.isDeterministic(tautomata[n]));
    assertTrue(SpecialOperations.isFinite(automata[n]));
    assertTrue(SpecialOperations.isFinite(tautomata[n]));
    AutomatonTestUtil.assertNoDetachedStates(automata[n]);
    AutomatonTestUtil.assertNoDetachedStates(tautomata[n]);
    if (n > 0) {
      assertTrue(BasicOperations.subsetOf(automata[n - 1],automata[n]));
      assertTrue(BasicOperations.subsetOf(automata[n - 1],tautomata[n]));
      assertTrue(BasicOperations.subsetOf(tautomata[n - 1],automata[n]));
      assertTrue(BasicOperations.subsetOf(tautomata[n - 1],tautomata[n]));
      assertNotSame(automata[n - 1],automata[n]);
    }
    assertTrue(BasicOperations.subsetOf(automata[n],tautomata[n]));
switch (n) {
case 0:
      assertTrue(BasicOperations.sameLanguage(BasicAutomata.makeStringLight(s),automata[0]));
    assertTrue(BasicOperations.sameLanguage(BasicAutomata.makeStringLight(s),tautomata[0]));
  break;
case 1:
assertTrue(BasicOperations.sameLanguage(naiveLev1(s),automata[1]));
assertTrue(BasicOperations.sameLanguage(naiveLev1T(s),tautomata[1]));
break;
default :
assertBruteForce(s,automata[n],n);
assertBruteForceT(s,tautomata[n],n);
break;
}
}
}
