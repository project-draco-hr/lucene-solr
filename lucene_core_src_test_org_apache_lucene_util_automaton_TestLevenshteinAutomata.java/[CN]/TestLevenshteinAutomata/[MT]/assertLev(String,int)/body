{
  LevenshteinAutomata builder=new LevenshteinAutomata(s,false);
  LevenshteinAutomata tbuilder=new LevenshteinAutomata(s,true);
  Automaton automata[]=new Automaton[maxDistance + 1];
  Automaton tautomata[]=new Automaton[maxDistance + 1];
  for (int n=0; n < automata.length; n++) {
    automata[n]=builder.toAutomaton(n);
    tautomata[n]=tbuilder.toAutomaton(n);
    assertNotNull(automata[n]);
    assertNotNull(tautomata[n]);
    assertTrue(automata[n].isDeterministic());
    assertTrue(tautomata[n].isDeterministic());
    assertTrue(Operations.isFinite(automata[n]));
    assertTrue(Operations.isFinite(tautomata[n]));
    assertFalse(Operations.hasDeadStatesFromInitial(automata[n]));
    assertFalse(Operations.hasDeadStatesFromInitial(tautomata[n]));
    if (n > 0) {
      assertTrue(Operations.subsetOf(Operations.removeDeadStates(automata[n - 1]),Operations.removeDeadStates(automata[n])));
      assertTrue(Operations.subsetOf(Operations.removeDeadStates(automata[n - 1]),Operations.removeDeadStates(tautomata[n])));
      assertTrue(Operations.subsetOf(Operations.removeDeadStates(tautomata[n - 1]),Operations.removeDeadStates(automata[n])));
      assertTrue(Operations.subsetOf(Operations.removeDeadStates(tautomata[n - 1]),Operations.removeDeadStates(tautomata[n])));
      assertNotSame(automata[n - 1],automata[n]);
    }
    assertTrue(Operations.subsetOf(Operations.removeDeadStates(automata[n]),Operations.removeDeadStates(tautomata[n])));
switch (n) {
case 0:
      assertTrue(Operations.sameLanguage(Automata.makeString(s),Operations.removeDeadStates(automata[0])));
    assertTrue(Operations.sameLanguage(Automata.makeString(s),Operations.removeDeadStates(tautomata[0])));
  break;
case 1:
assertTrue(Operations.sameLanguage(naiveLev1(s),Operations.removeDeadStates(automata[1])));
assertTrue(Operations.sameLanguage(naiveLev1T(s),Operations.removeDeadStates(tautomata[1])));
break;
default :
assertBruteForce(s,automata[n],n);
assertBruteForceT(s,tautomata[n],n);
break;
}
}
}
