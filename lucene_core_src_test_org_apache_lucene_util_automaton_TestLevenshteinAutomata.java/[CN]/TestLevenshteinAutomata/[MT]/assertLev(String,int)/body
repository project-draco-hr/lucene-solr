{
  LevenshteinAutomata builder=new LevenshteinAutomata(s,false);
  LevenshteinAutomata tbuilder=new LevenshteinAutomata(s,true);
  Automaton automata[]=new Automaton[maxDistance + 1];
  Automaton tautomata[]=new Automaton[maxDistance + 1];
  for (int n=0; n < automata.length; n++) {
    automata[n]=builder.toAutomaton(n);
    tautomata[n]=tbuilder.toAutomaton(n);
    assertNotNull(automata[n]);
    assertNotNull(tautomata[n]);
    assertTrue(automata[n].isDeterministic());
    assertTrue(tautomata[n].isDeterministic());
    assertTrue(SpecialOperations.isFinite(automata[n]));
    assertTrue(SpecialOperations.isFinite(tautomata[n]));
    AutomatonTestUtil.assertNoDetachedStates(automata[n]);
    AutomatonTestUtil.assertNoDetachedStates(tautomata[n]);
    if (n > 0) {
      assertTrue(automata[n - 1].subsetOf(automata[n]));
      assertTrue(automata[n - 1].subsetOf(tautomata[n]));
      assertTrue(tautomata[n - 1].subsetOf(automata[n]));
      assertTrue(tautomata[n - 1].subsetOf(tautomata[n]));
      assertNotSame(automata[n - 1],automata[n]);
    }
    assertTrue(automata[n].subsetOf(tautomata[n]));
switch (n) {
case 0:
      assertTrue(BasicOperations.sameLanguage(BasicAutomata.makeString(s),automata[0]));
    assertTrue(BasicOperations.sameLanguage(BasicAutomata.makeString(s),tautomata[0]));
  break;
case 1:
assertTrue(BasicOperations.sameLanguage(naiveLev1(s),automata[1]));
assertTrue(BasicOperations.sameLanguage(naiveLev1T(s),tautomata[1]));
break;
default :
assertBruteForce(s,automata[n],n);
assertBruteForceT(s,tautomata[n],n);
break;
}
}
}
