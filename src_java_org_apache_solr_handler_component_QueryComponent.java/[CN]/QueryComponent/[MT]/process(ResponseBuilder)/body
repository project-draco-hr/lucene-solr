{
  SolrQueryRequest req=rb.req;
  SolrQueryResponse rsp=rb.rsp;
  SolrParams params=req.getParams();
  if (!params.getBool(COMPONENT_NAME,true)) {
    return;
  }
  SolrIndexSearcher searcher=req.getSearcher();
  if (rb.getQueryCommand().getOffset() < 0) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"'start' parameter cannot be negative");
  }
  long timeAllowed=(long)params.getInt(CommonParams.TIME_ALLOWED,-1);
  String ids=params.get(ShardParams.IDS);
  if (ids != null) {
    SchemaField idField=req.getSchema().getUniqueKeyField();
    List<String> idArr=StrUtils.splitSmart(ids,",",true);
    int[] luceneIds=new int[idArr.size()];
    int docs=0;
    for (int i=0; i < idArr.size(); i++) {
      int id=req.getSearcher().getFirstMatch(new Term(idField.getName(),idField.getType().toInternal(idArr.get(i))));
      if (id >= 0)       luceneIds[docs++]=id;
    }
    DocListAndSet res=new DocListAndSet();
    res.docList=new DocSlice(0,docs,luceneIds,null,docs,0);
    if (rb.isNeedDocSet()) {
      List<Query> queries=new ArrayList<Query>();
      queries.add(rb.getQuery());
      List<Query> filters=rb.getFilters();
      if (filters != null)       queries.addAll(filters);
      res.docSet=searcher.getDocSet(queries);
    }
    rb.setResults(res);
    rsp.add("response",rb.getResults().docList);
    return;
  }
  SolrIndexSearcher.QueryCommand cmd=rb.getQueryCommand();
  cmd.setTimeAllowed(timeAllowed);
  SolrIndexSearcher.QueryResult result=new SolrIndexSearcher.QueryResult();
  searcher.search(result,cmd);
  rb.setResult(result);
  rsp.add("response",rb.getResults().docList);
  rsp.getToLog().add("hits",rb.getResults().docList.matches());
  boolean fsv=req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);
  if (fsv) {
    Sort sort=rb.getSortSpec().getSort();
    SortField[] sortFields=sort == null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();
    ScoreDoc sd=new ScoreDoc(0,1.0f);
    NamedList sortVals=new NamedList();
    StringFieldable field=new StringFieldable();
    for (    SortField sortField : sortFields) {
      int type=sortField.getType();
      if (type == SortField.SCORE || type == SortField.DOC)       continue;
      ScoreDocComparator comparator=null;
      IndexReader reader=searcher.getReader();
      String fieldname=sortField.getField();
      FieldType ft=fieldname == null ? null : req.getSchema().getFieldTypeNoEx(fieldname);
switch (type) {
case SortField.INT:
        comparator=comparatorInt(reader,fieldname);
      break;
case SortField.FLOAT:
    comparator=comparatorFloat(reader,fieldname);
  break;
case SortField.LONG:
comparator=comparatorLong(reader,fieldname);
break;
case SortField.DOUBLE:
comparator=comparatorDouble(reader,fieldname);
break;
case SortField.STRING:
if (sortField.getLocale() != null) comparator=comparatorStringLocale(reader,fieldname,sortField.getLocale());
 else comparator=comparatorString(reader,fieldname);
break;
case SortField.CUSTOM:
comparator=sortField.getFactory().newComparator(reader,fieldname);
break;
default :
throw new RuntimeException("unknown field type: " + type);
}
DocList docList=rb.getResults().docList;
ArrayList<Object> vals=new ArrayList<Object>(docList.size());
DocIterator it=rb.getResults().docList.iterator();
while (it.hasNext()) {
sd.doc=it.nextDoc();
Object val=comparator.sortValue(sd);
if (val instanceof String) {
field.val=(String)val;
val=ft.toObject(field);
}
vals.add(val);
}
sortVals.add(fieldname,vals);
}
rsp.add("sort_values",sortVals);
}
if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size() <= 50) {
SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList,rb.getQuery(),req,rsp);
}
}
