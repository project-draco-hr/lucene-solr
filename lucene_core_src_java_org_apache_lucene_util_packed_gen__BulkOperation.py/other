from fractions import gcd
'Code generation for bulk operations'
PACKED_64_SINGLE_BLOCK_BPV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 21, 32]
OUTPUT_FILE = 'BulkOperation.java'
HEADER = '// This file has been automatically generated, DO NOT EDIT\n\npackage org.apache.lucene.util.packed;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.nio.LongBuffer;\nimport java.nio.ByteBuffer;\n\n/**\n * Efficient sequential read/write of packed integers.\n */\nenum BulkOperation implements PackedInts.Decoder, PackedInts.Encoder {\n'
FOOTER = "\n\n  private static long[] toLongArray(int[] ints, int offset, int length) {\n    long[] arr = new long[length];\n    for (int i = 0; i < length; ++i) {\n      arr[i] = ints[offset + i];\n    }\n    return arr;\n  }\n\n  @Override\n  public void decode(long[] blocks, int blocksOffset, int[] values, int valuesOffset, int iterations) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public void decode(byte[] blocks, int blocksOffset, int[] values, int valuesOffset, int iterations) {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public void encode(int[] values, int valuesOffset, long[] blocks, int blocksOffset, int iterations) {\n    encode(toLongArray(values, valuesOffset, iterations * valueCount()), 0, blocks, blocksOffset, iterations);\n  }\n\n  @Override\n  public void encode(long[] values, int valuesOffset, byte[] blocks, int blocksOffset, int iterations) {\n    final long[] longBLocks = new long[blockCount() * iterations];\n    encode(values, valuesOffset, longBLocks, 0, iterations);\n    ByteBuffer.wrap(blocks, blocksOffset, 8 * iterations * blockCount()).asLongBuffer().put(longBLocks);\n  }\n\n  @Override\n  public void encode(int[] values, int valuesOffset, byte[] blocks, int blocksOffset, int iterations) {\n    final long[] longBLocks = new long[blockCount() * iterations];\n    encode(values, valuesOffset, longBLocks, 0, iterations);\n    ByteBuffer.wrap(blocks, blocksOffset, 8 * iterations * blockCount()).asLongBuffer().put(longBLocks);\n  }\n\n  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v=64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blockCount() + valueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blockCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / valueCount());\n    } else {\n      return iterations;\n    }\n  }\n}\n"
if (__name__ == '__main__'):
    p64_bpv = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 21, 32]
    f = open(OUTPUT_FILE, 'w')
    f.write(HEADER)
    for bpv in xrange(1, 65):
        packed64(bpv, f)
        f.write('  ,\n')
    for bpv in PACKED_64_SINGLE_BLOCK_BPV:
        if (bpv != PACKED_64_SINGLE_BLOCK_BPV[0]):
            f.write('  ,\n')
        packed64singleblock(bpv, f)
    f.write('  ;\n\n')
    f.write('  public static BulkOperation of(PackedInts.Format format, int bitsPerValue) {\n')
    f.write('    switch (format) {\n')
    f.write('    case PACKED:\n')
    f.write('      switch (bitsPerValue) {\n')
    for i in xrange(1, 65):
        f.write(('      case %d:\n' % i))
        f.write(('        return PACKED_%d;\n' % i))
    f.write('      default:\n')
    f.write('        throw new AssertionError();\n')
    f.write('      }\n')
    f.write('    case PACKED_SINGLE_BLOCK:\n')
    f.write('      switch (bitsPerValue) {\n')
    for i in PACKED_64_SINGLE_BLOCK_BPV:
        f.write(('      case %d:\n' % i))
        f.write(('        return PACKED_SINGLE_BLOCK_%d;\n' % i))
    f.write('      default:\n')
    f.write('        throw new AssertionError();\n')
    f.write('      }\n')
    f.write('    default:\n')
    f.write('      throw new AssertionError();\n')
    f.write('    }\n')
    f.write('  }\n')
    f.write(FOOTER)
    f.close()
