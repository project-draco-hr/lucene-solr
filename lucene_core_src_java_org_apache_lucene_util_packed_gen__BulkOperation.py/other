from fractions import gcd
'Code generation for bulk operations'
PACKED_64_SINGLE_BLOCK_BPV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 21, 32]
OUTPUT_FILE = 'BulkOperation.java'
HEADER = '// This file has been automatically generated, DO NOT EDIT\n\npackage org.apache.lucene.util.packed;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport java.util.EnumMap;\n\n/**\n * Efficient sequential read/write of packed integers.\n */\nabstract class BulkOperation {\n\n  static final EnumMap<PackedInts.Format, BulkOperation[]> BULK_OPERATIONS = new EnumMap<PackedInts.Format, BulkOperation[]>(PackedInts.Format.class);\n\n  public static BulkOperation of(PackedInts.Format format, int bitsPerValue) {\n    assert bitsPerValue > 0 && bitsPerValue <= 64;\n    BulkOperation[] ops = BULK_OPERATIONS.get(format);\n    if (ops == null || ops[bitsPerValue] == null) {\n      throw new IllegalArgumentException("format: " + format + ", bitsPerValue: " + bitsPerValue);\n    }\n    return ops[bitsPerValue];\n  }\n\n  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -> b=1, v=4\n   *  - 24 bits per value -> b=3, v=8\n   *  - 50 bits per value -> b=25, v=32\n   *  - 63 bits per value -> b=63, v = 64\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput) => this requires n * (b + v) longs in memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (8 * (b + v))</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = (ramBudget >>> 3) / (blocks() + values());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * blocks() >= valueCount) {\n      // don\'t allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / values());\n    } else {\n      return iterations;\n    }\n  }\n\n  /**\n   * The minimum number of blocks required to perform a bulk get/set.\n   */\n  public abstract int blocks();\n\n  /**\n   * The number of values that can be stored in <code>blocks()</code> blocks.\n   */\n  public abstract int values();\n\n  /**\n   * Get <code>n * values()</code> values from <code>n * blocks()</code> blocks.\n   */\n  public abstract void get(long[] blocks, int blockIndex, long[] values, int valuesIndex, int iterations);\n\n  /**\n   * Set <code>n * values()</code> values into <code>n * blocks()</code> blocks.\n   */\n  public abstract void set(long[] blocks, int blockIndex, long[] values, int valuesIndex, int iterations);\n\n'
FOOTER = '}'
if (__name__ == '__main__'):
    p64_bpv = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 21, 32]
    f = open(OUTPUT_FILE, 'w')
    f.write(HEADER)
    f.write('  static {\n')
    f.write('    BULK_OPERATIONS.put(PackedInts.Format.PACKED, new BulkOperation[65]);')
    for bpv in xrange(1, 65):
        f.write(('    BULK_OPERATIONS.get(PackedInts.Format.PACKED)[%d] = new Packed64BulkOperation%d();\n' % (bpv, bpv)))
    f.write('    BULK_OPERATIONS.put(PackedInts.Format.PACKED_SINGLE_BLOCK, new BulkOperation[65]);\n')
    for bpv in PACKED_64_SINGLE_BLOCK_BPV:
        f.write(('    BULK_OPERATIONS.get(PackedInts.Format.PACKED_SINGLE_BLOCK)[%d] = new Packed64SingleBlockBulkOperation%d();\n' % (bpv, bpv)))
    f.write('  }\n')
    for bpv in xrange(1, 65):
        packed64(bpv, f)
    for bpv in PACKED_64_SINGLE_BLOCK_BPV:
        packed64singleblock(bpv, f)
    f.write(FOOTER)
    f.close()
