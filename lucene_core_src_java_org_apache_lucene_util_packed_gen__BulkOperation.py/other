from fractions import gcd
'Code generation for bulk operations'
MAX_SPECIALIZED_BITS_PER_VALUE = 24
PACKED_64_SINGLE_BLOCK_BPV = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 21, 32]
OUTPUT_FILE = 'BulkOperation.java'
HEADER = '// This file has been automatically generated, DO NOT EDIT\n\npackage org.apache.lucene.util.packed;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the "License"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'
FOOTER = "\n  protected int writeLong(long block, byte[] blocks, int blocksOffset) {\n    for (int j = 1; j <= 8; ++j) {\n      blocks[blocksOffset++] = (byte) (block >>> (64 - (j << 3)));\n    }\n    return blocksOffset;\n  }\n\n  /**\n   * For every number of bits per value, there is a minimum number of\n   * blocks (b) / values (v) you need to write in order to reach the next block\n   * boundary:\n   *  - 16 bits per value -&gt; b=2, v=1\n   *  - 24 bits per value -&gt; b=3, v=1\n   *  - 50 bits per value -&gt; b=25, v=4\n   *  - 63 bits per value -&gt; b=63, v=8\n   *  - ...\n   *\n   * A bulk read consists in copying <code>iterations*v</code> values that are\n   * contained in <code>iterations*b</code> blocks into a <code>long[]</code>\n   * (higher values of <code>iterations</code> are likely to yield a better\n   * throughput): this requires n * (b + 8v) bytes of memory.\n   *\n   * This method computes <code>iterations</code> as\n   * <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).\n   */\n  public final int computeIterations(int valueCount, int ramBudget) {\n    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());\n    if (iterations == 0) {\n      // at least 1\n      return 1;\n    } else if ((iterations - 1) * byteValueCount() >= valueCount) {\n      // don't allocate for more than the size of the reader\n      return (int) Math.ceil((double) valueCount / byteValueCount());\n    } else {\n      return iterations;\n    }\n  }\n}\n"
if (__name__ == '__main__'):
    f = open(OUTPUT_FILE, 'w')
    f.write(HEADER)
    f.write('\n')
    f.write('/**\n * Efficient sequential read/write of packed integers.\n */\n')
    f.write('abstract class BulkOperation implements PackedInts.Decoder, PackedInts.Encoder {\n')
    f.write('  private static final BulkOperation[] packedBulkOps = new BulkOperation[] {\n')
    for bpv in xrange(1, 65):
        if (bpv > MAX_SPECIALIZED_BITS_PER_VALUE):
            f.write(('    new BulkOperationPacked(%d),\n' % bpv))
            continue
        f2 = open(('BulkOperationPacked%d.java' % bpv), 'w')
        f2.write(HEADER)
        if (bpv == 64):
            f2.write('import java.nio.LongBuffer;\n')
            f2.write('import java.nio.ByteBuffer;\n')
            f2.write('\n')
        f2.write('/**\n * Efficient sequential read/write of packed integers.\n */\n')
        f2.write(('final class BulkOperationPacked%d extends BulkOperationPacked {\n' % bpv))
        packed64(bpv, f2)
        f2.write('}\n')
        f2.close()
        f.write(('    new BulkOperationPacked%d(),\n' % bpv))
    f.write('  };\n')
    f.write('\n')
    f.write('  // NOTE: this is sparse (some entries are null):\n')
    f.write('  private static final BulkOperation[] packedSingleBlockBulkOps = new BulkOperation[] {\n')
    for bpv in xrange(1, (max(PACKED_64_SINGLE_BLOCK_BPV) + 1)):
        if (bpv in PACKED_64_SINGLE_BLOCK_BPV):
            f.write(('    new BulkOperationPackedSingleBlock(%d),\n' % bpv))
        else:
            f.write('    null,\n')
    f.write('  };\n')
    f.write('\n')
    f.write('\n')
    f.write('  public static BulkOperation of(PackedInts.Format format, int bitsPerValue) {\n')
    f.write('    switch (format) {\n')
    f.write('    case PACKED:\n')
    f.write('      assert packedBulkOps[bitsPerValue - 1] != null;\n')
    f.write('      return packedBulkOps[bitsPerValue - 1];\n')
    f.write('    case PACKED_SINGLE_BLOCK:\n')
    f.write('      assert packedSingleBlockBulkOps[bitsPerValue - 1] != null;\n')
    f.write('      return packedSingleBlockBulkOps[bitsPerValue - 1];\n')
    f.write('    default:\n')
    f.write('      throw new AssertionError();\n')
    f.write('    }\n')
    f.write('  }\n')
    f.write(FOOTER)
    f.close()
