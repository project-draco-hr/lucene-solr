def packed64(bpv, f):
    blocks = bpv
    values = ((blocks * 64) / bpv)
    while (((blocks % 2) == 0) and ((values % 2) == 0)):
        blocks /= 2
        values /= 2
    assert ((values * bpv) == (64 * blocks)), ('%d values, %d blocks, %d bits per value' % (values, blocks, bpv))
    mask = ((1 << bpv) - 1)
    f.write(('  static final class Packed64BulkOperation%d extends BulkOperation {\n\n' % bpv))
    f.write('    public int blocks() {\n')
    f.write(('      return %d;\n' % blocks))
    f.write('    }\n\n')
    f.write('    public int values() {\n')
    f.write(('      return %d;\n' % values))
    f.write('    }\n\n')
    if (bpv == 64):
        f.write('    public void decode(LongBuffer blocks, LongBuffer values, int iterations) {\n      final int originalLimit = blocks.limit();\n      blocks.limit(blocks.position() + iterations * blocks());\n      values.put(blocks);\n      blocks.limit(originalLimit);\n    }\n\n    public void decode(LongBuffer blocks, IntBuffer values, int iterations) {\n      throw new UnsupportedOperationException();\n    }\n\n    public void encode(LongBuffer values, LongBuffer blocks, int iterations) {\n      final int originalLimit = values.limit();\n      values.limit(values.position() + iterations * values());\n      blocks.put(values);\n      values.limit(originalLimit);\n    }\n\n    public void encode(IntBuffer values, LongBuffer blocks, int iterations) {\n      for (int i = values.position(), end = values.position() + iterations, j = blocks.position(); i < end; ++i, ++j) {\n        blocks.put(j, values.get(i));\n      }\n    }\n  }\n')
    else:
        p64_decode(bpv, 32, values)
        p64_decode(bpv, 64, values)
        p64_encode(bpv, 32, values)
        p64_encode(bpv, 64, values)
        f.write('  }\n')
