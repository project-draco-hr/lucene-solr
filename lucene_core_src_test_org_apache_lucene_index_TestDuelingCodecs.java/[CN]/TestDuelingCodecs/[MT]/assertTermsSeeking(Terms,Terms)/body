{
  TermsEnum leftEnum=null;
  TermsEnum rightEnum=null;
  int numTests=atLeast(20);
  Random random=random();
  HashSet<BytesRef> tests=new HashSet<BytesRef>();
  int numPasses=0;
  while (numPasses < 10 && tests.size() < numTests) {
    leftEnum=leftTerms.iterator(leftEnum);
    BytesRef term=null;
    while ((term=leftEnum.next()) != null) {
      int code=random.nextInt(10);
      if (code == 0) {
        tests.add(BytesRef.deepCopyOf(term));
      }
 else       if (code == 1) {
        term=BytesRef.deepCopyOf(term);
        if (term.length > 0) {
          term.length=random.nextInt(term.length);
        }
      }
 else       if (code == 2) {
        byte newbytes[]=new byte[term.length + 5];
        System.arraycopy(term.bytes,term.offset,newbytes,5,term.length);
        tests.add(new BytesRef(newbytes,5,term.length));
      }
 else       if (code == 3) {
switch (random().nextInt(3)) {
case 0:
          tests.add(new BytesRef());
        break;
case 1:
      tests.add(new BytesRef(new byte[]{(byte)0xFF,(byte)0xFF}));
    break;
case 2:
  tests.add(new BytesRef(_TestUtil.randomSimpleString(random())));
break;
default :
throw new AssertionError();
}
}
}
numPasses++;
}
rightEnum=rightTerms.iterator(rightEnum);
ArrayList<BytesRef> shuffledTests=new ArrayList<BytesRef>(tests);
Collections.shuffle(shuffledTests,random);
for (BytesRef b : shuffledTests) {
if (rarely()) {
leftEnum=leftTerms.iterator(leftEnum);
rightEnum=rightTerms.iterator(rightEnum);
}
final boolean useCache=random().nextBoolean();
final boolean seekExact=random().nextBoolean();
if (seekExact) {
assertEquals(info,leftEnum.seekExact(b,useCache),rightEnum.seekExact(b,useCache));
}
 else {
SeekStatus leftStatus=leftEnum.seekCeil(b,useCache);
SeekStatus rightStatus=rightEnum.seekCeil(b,useCache);
assertEquals(info,leftStatus,rightStatus);
if (leftStatus != SeekStatus.END) {
assertEquals(info,leftEnum.term(),rightEnum.term());
assertTermStats(leftEnum,rightEnum);
}
}
}
}
