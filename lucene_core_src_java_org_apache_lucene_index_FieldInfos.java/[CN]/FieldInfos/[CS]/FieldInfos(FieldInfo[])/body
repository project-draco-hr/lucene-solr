{
  boolean hasVectors=false;
  boolean hasProx=false;
  boolean hasPayloads=false;
  boolean hasOffsets=false;
  boolean hasFreq=false;
  boolean hasNorms=false;
  boolean hasDocValues=false;
  for (  FieldInfo info : infos) {
    if (info.number < 0) {
      throw new IllegalArgumentException("illegal field number: " + info.number + " for field "+ info.name);
    }
    FieldInfo previous=byNumber.put(info.number,info);
    if (previous != null) {
      throw new IllegalArgumentException("duplicate field numbers: " + previous.name + " and "+ info.name+ " have: "+ info.number);
    }
    previous=byName.put(info.name,info);
    if (previous != null) {
      throw new IllegalArgumentException("duplicate field names: " + previous.number + " and "+ info.number+ " have: "+ info.name);
    }
    hasVectors|=info.hasVectors();
    hasProx|=info.isIndexed() && info.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
    hasFreq|=info.isIndexed() && info.getIndexOptions() != IndexOptions.DOCS_ONLY;
    hasOffsets|=info.isIndexed() && info.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
    hasNorms|=info.hasNorms();
    hasDocValues|=info.hasDocValues();
    hasPayloads|=info.hasPayloads();
  }
  this.hasVectors=hasVectors;
  this.hasProx=hasProx;
  this.hasPayloads=hasPayloads;
  this.hasOffsets=hasOffsets;
  this.hasFreq=hasFreq;
  this.hasNorms=hasNorms;
  this.hasDocValues=hasDocValues;
  this.values=Collections.unmodifiableCollection(byNumber.values());
}
