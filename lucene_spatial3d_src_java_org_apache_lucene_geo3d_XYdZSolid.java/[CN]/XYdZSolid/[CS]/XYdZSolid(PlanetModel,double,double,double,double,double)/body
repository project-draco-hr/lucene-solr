{
  super(planetModel);
  if (maxX - minX < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("X values in wrong order or identical");
  if (maxY - minY < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("Y values in wrong order or identical");
  final double worldMinZ=planetModel.getMinimumZValue();
  final double worldMaxZ=planetModel.getMaximumZValue();
  minXPlane=new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);
  maxXPlane=new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);
  minYPlane=new SidedPlane(0.0,maxY,0.0,yUnitVector,-minY);
  maxYPlane=new SidedPlane(0.0,minY,0.0,yUnitVector,-maxY);
  zPlane=new Plane(zUnitVector,-Z);
  final GeoPoint[] minXZ=minXPlane.findIntersections(planetModel,zPlane,maxXPlane,minYPlane,maxYPlane);
  final GeoPoint[] maxXZ=maxXPlane.findIntersections(planetModel,zPlane,minXPlane,minYPlane,maxYPlane);
  final GeoPoint[] minYZ=minYPlane.findIntersections(planetModel,zPlane,maxYPlane,minXPlane,maxXPlane);
  final GeoPoint[] maxYZ=maxYPlane.findIntersections(planetModel,zPlane,minYPlane,minXPlane,maxXPlane);
  notableZPoints=glueTogether(minXZ,maxXZ,minYZ,maxYZ);
  final boolean minXminYZ=planetModel.pointOutside(minX,minY,Z);
  final boolean minXmaxYZ=planetModel.pointOutside(minX,maxY,Z);
  final boolean maxXminYZ=planetModel.pointOutside(maxX,minY,Z);
  final boolean maxXmaxYZ=planetModel.pointOutside(maxX,maxY,Z);
  final GeoPoint[] zEdges;
  if (Z - worldMinZ >= -Vector.MINIMUM_RESOLUTION && Z - worldMaxZ <= Vector.MINIMUM_RESOLUTION && minX < 0.0 && maxX > 0.0 && minY < 0.0 && maxY > 0.0 && minXminYZ && minXmaxYZ && maxXminYZ && maxXmaxYZ) {
    zEdges=new GeoPoint[]{zPlane.getSampleIntersectionPoint(planetModel,xVerticalPlane)};
  }
 else {
    zEdges=EMPTY_POINTS;
  }
  this.edgePoints=glueTogether(minXZ,maxXZ,minYZ,maxYZ,zEdges);
}
