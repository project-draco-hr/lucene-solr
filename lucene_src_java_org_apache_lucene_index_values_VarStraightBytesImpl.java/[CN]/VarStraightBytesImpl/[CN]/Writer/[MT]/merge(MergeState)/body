{
  merge=true;
  datOut=getDataOut();
  boolean success=false;
  try {
    if (state.bits == null && state.reader instanceof Reader) {
      Reader reader=(Reader)state.reader;
      final int maxDocs=reader.maxDoc;
      if (maxDocs == 0) {
        return;
      }
      if (lastDocID + 1 < state.docBase) {
        fill(state.docBase);
        lastDocID=state.docBase - 1;
      }
      final long numDataBytes;
      final IndexInput cloneIdx=reader.cloneIndex();
      try {
        numDataBytes=cloneIdx.readVLong();
        final ReaderIterator iter=PackedInts.getReaderIterator(cloneIdx);
        for (int i=0; i < maxDocs; i++) {
          long offset=iter.next();
          ++lastDocID;
          if (lastDocID >= docToAddress.length) {
            int oldSize=docToAddress.length;
            docToAddress=ArrayUtil.grow(docToAddress,1 + lastDocID);
            bytesUsed.addAndGet((docToAddress.length - oldSize) * RamUsageEstimator.NUM_BYTES_INT);
          }
          docToAddress[lastDocID]=address + offset;
        }
        address+=numDataBytes;
        iter.close();
      }
  finally {
        IOUtils.closeSafely(true,cloneIdx);
      }
      final IndexInput cloneData=reader.cloneData();
      try {
        datOut.copyBytes(cloneData,numDataBytes);
      }
  finally {
        IOUtils.closeSafely(true,cloneData);
      }
    }
 else {
      super.merge(state);
    }
    success=true;
  }
  finally {
    if (!success) {
      IOUtils.closeSafely(!success,datOut);
    }
  }
}
