{
  final String fileName=IndexFileNames.segmentFileName(si.name,"",Lucene50SegmentInfoFormat.SI_EXTENSION);
  si.addFile(fileName);
  boolean success=false;
  try (IndexOutput output=dir.createOutput(fileName,ioContext)){
    CodecUtil.writeHeader(output,Lucene50SegmentInfoFormat.CODEC_NAME,Lucene50SegmentInfoFormat.VERSION_CURRENT);
    Version version=si.getVersion();
    if (version.major < 5) {
      throw new IllegalArgumentException("invalid major version: should be >= 5 but got: " + version.major + " segment="+ si);
    }
    output.writeString(version.toString());
    output.writeInt(si.getDocCount());
    output.writeByte((byte)(si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
    output.writeStringStringMap(si.getDiagnostics());
    Set<String> files=si.files();
    for (    String file : files) {
      if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {
        throw new IllegalArgumentException("invalid files: expected segment=" + si.name + ", got="+ files);
      }
    }
    output.writeStringSet(files);
    byte[] id=si.getId();
    if (id.length != StringHelper.ID_LENGTH) {
      throw new IllegalArgumentException("invalid id, got=" + StringHelper.idToString(id));
    }
    output.writeBytes(id,0,id.length);
    CodecUtil.writeFooter(output);
    success=true;
  }
  finally {
    if (!success) {
      IOUtils.deleteFilesIgnoringExceptions(si.dir,fileName);
    }
  }
}
