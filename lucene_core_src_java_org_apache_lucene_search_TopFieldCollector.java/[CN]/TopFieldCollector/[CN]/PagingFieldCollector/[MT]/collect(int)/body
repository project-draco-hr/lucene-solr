{
  totalHits++;
  float score=Float.NaN;
  if (trackMaxScore) {
    score=scorer.score();
    if (score > maxScore) {
      maxScore=score;
    }
  }
  if (queueFull) {
    for (int i=0; ; i++) {
      final int c=reverseMul[i] * comparators[i].compareBottom(doc);
      if (c < 0) {
        return;
      }
 else       if (c > 0) {
        break;
      }
 else       if (i == comparators.length - 1) {
        if (doc + docBase > bottom.doc) {
          return;
        }
        break;
      }
    }
  }
  boolean sameValues=true;
  for (int compIDX=0; compIDX < comparators.length; compIDX++) {
    final FieldComparator comp=comparators[compIDX];
    final int cmp=reverseMul[compIDX] * comp.compareTop(doc);
    if (cmp > 0) {
      return;
    }
 else     if (cmp < 0) {
      sameValues=false;
      break;
    }
  }
  if (sameValues && doc <= afterDoc) {
    return;
  }
  if (queueFull) {
    for (int i=0; i < comparators.length; i++) {
      comparators[i].copy(bottom.slot,doc);
    }
    if (trackDocScores && !trackMaxScore) {
      score=scorer.score();
    }
    updateBottom(doc,score);
    for (int i=0; i < comparators.length; i++) {
      comparators[i].setBottom(bottom.slot);
    }
  }
 else {
    collectedHits++;
    final int slot=collectedHits - 1;
    for (int i=0; i < comparators.length; i++) {
      comparators[i].copy(slot,doc);
    }
    if (trackDocScores && !trackMaxScore) {
      score=scorer.score();
    }
    bottom=pq.add(new Entry(slot,docBase + doc,score));
    queueFull=collectedHits == numHits;
    if (queueFull) {
      for (int i=0; i < comparators.length; i++) {
        comparators[i].setBottom(bottom.slot);
      }
    }
  }
}
