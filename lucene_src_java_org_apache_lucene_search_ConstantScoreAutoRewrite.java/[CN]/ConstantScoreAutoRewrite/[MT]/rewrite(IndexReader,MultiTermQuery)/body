{
  final int docCountCutoff=(int)((docCountPercent / 100.) * reader.maxDoc());
  final int termCountLimit=Math.min(BooleanQuery.getMaxClauseCount(),termCountCutoff);
  final CutOffTermCollector col=new CutOffTermCollector(docCountCutoff,termCountLimit);
  collectTerms(reader,query,col);
  final int size=col.pendingTerms.size();
  if (col.hasCutOff) {
    return MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.rewrite(reader,query);
  }
 else   if (size == 0) {
    return getTopLevelQuery();
  }
 else {
    final BooleanQuery bq=getTopLevelQuery();
    final Term placeholderTerm=new Term(query.field);
    final BytesRefHash pendingTerms=col.pendingTerms;
    final int sort[]=pendingTerms.sort(col.termsEnum.getComparator());
    for (int i=0; i < size; i++) {
      final int pos=sort[i];
      addClause(bq,placeholderTerm.createTerm(pendingTerms.get(pos,new BytesRef())),1,1.0f,col.array.termState[pos]);
    }
    final Query result=new ConstantScoreQuery(bq);
    result.setBoost(query.getBoost());
    query.incTotalNumberOfTerms(size);
    return result;
  }
}
