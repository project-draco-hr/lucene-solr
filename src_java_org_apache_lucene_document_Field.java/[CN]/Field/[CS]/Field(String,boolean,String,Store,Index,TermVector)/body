{
  if (name == null)   throw new NullPointerException("name cannot be null");
  if (value == null)   throw new NullPointerException("value cannot be null");
  if (name.length() == 0 && value.length() == 0)   throw new IllegalArgumentException("name and value cannot both be empty");
  if (index == Index.NO && store == Store.NO)   throw new IllegalArgumentException("it doesn't make sense to have a field that " + "is neither indexed nor stored");
  if (index == Index.NO && termVector != TermVector.NO)   throw new IllegalArgumentException("cannot store term vector information " + "for a field that is not indexed");
  if (internName)   name=name.intern();
  this.name=name;
  this.fieldsData=value;
  if (store == Store.YES) {
    this.isStored=true;
    this.isCompressed=false;
  }
 else   if (store == Store.COMPRESS) {
    this.isStored=true;
    this.isCompressed=true;
  }
 else   if (store == Store.NO) {
    this.isStored=false;
    this.isCompressed=false;
  }
 else   throw new IllegalArgumentException("unknown store parameter " + store);
  if (index == Index.NO) {
    this.isIndexed=false;
    this.isTokenized=false;
    this.omitTermFreqAndPositions=false;
    this.omitNorms=true;
  }
 else   if (index == Index.ANALYZED) {
    this.isIndexed=true;
    this.isTokenized=true;
  }
 else   if (index == Index.NOT_ANALYZED) {
    this.isIndexed=true;
    this.isTokenized=false;
  }
 else   if (index == Index.NOT_ANALYZED_NO_NORMS) {
    this.isIndexed=true;
    this.isTokenized=false;
    this.omitNorms=true;
  }
 else   if (index == Index.ANALYZED_NO_NORMS) {
    this.isIndexed=true;
    this.isTokenized=true;
    this.omitNorms=true;
  }
 else {
    throw new IllegalArgumentException("unknown index parameter " + index);
  }
  this.isBinary=false;
  setStoreTermVector(termVector);
}
