{
  a.expandSingleton();
  HashMap<State,HashSet<State>> forward=new HashMap<State,HashSet<State>>();
  HashMap<State,HashSet<State>> back=new HashMap<State,HashSet<State>>();
  for (  StatePair p : pairs) {
    HashSet<State> to=forward.get(p.s1);
    if (to == null) {
      to=new HashSet<State>();
      forward.put(p.s1,to);
    }
    to.add(p.s2);
    HashSet<State> from=back.get(p.s2);
    if (from == null) {
      from=new HashSet<State>();
      back.put(p.s2,from);
    }
    from.add(p.s1);
  }
  LinkedList<StatePair> worklist=new LinkedList<StatePair>(pairs);
  HashSet<StatePair> workset=new HashSet<StatePair>(pairs);
  while (!worklist.isEmpty()) {
    StatePair p=worklist.removeFirst();
    workset.remove(p);
    HashSet<State> to=forward.get(p.s2);
    HashSet<State> from=back.get(p.s1);
    if (to != null) {
      for (      State s : to) {
        StatePair pp=new StatePair(p.s1,s);
        if (!pairs.contains(pp)) {
          pairs.add(pp);
          forward.get(p.s1).add(s);
          back.get(s).add(p.s1);
          worklist.add(pp);
          workset.add(pp);
          if (from != null) {
            for (            State q : from) {
              StatePair qq=new StatePair(q,p.s1);
              if (!workset.contains(qq)) {
                worklist.add(qq);
                workset.add(qq);
              }
            }
          }
        }
      }
    }
  }
  for (  StatePair p : pairs)   p.s1.addEpsilon(p.s2);
  a.deterministic=false;
  a.clearNumberedStates();
  a.checkMinimizeAlways();
}
