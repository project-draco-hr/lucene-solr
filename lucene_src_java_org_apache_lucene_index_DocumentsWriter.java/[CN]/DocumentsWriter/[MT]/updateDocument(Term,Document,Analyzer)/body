{
  long seqID=threadPool.executePerThread(this,doc,new DocumentsWriterThreadPool.PerThreadTask<Long>(){
    @Override public Long process(    final DocumentsWriterPerThread perThread) throws IOException {
      long perThreadRAMUsedBeforeAdd=perThread.numBytesUsed;
      perThread.addDocument(doc,analyzer);
      final long sequenceID;
      sequenceIDLock.lock();
      try {
        ensureOpen();
        sequenceID=nextSequenceID();
        if (delTerm != null) {
          deletesInRAM.addDeleteTerm(delTerm,sequenceID,numDocumentsWriterPerThreads);
        }
        perThread.commitDocument(sequenceID);
        if (!minSequenceIDsPerThread.containsKey(perThread)) {
          minSequenceIDsPerThread.put(perThread,sequenceID);
        }
        numDocsInRAM.incrementAndGet();
      }
  finally {
        sequenceIDLock.unlock();
      }
      if (finishAddDocument(perThread,perThreadRAMUsedBeforeAdd)) {
        super.clearThreadBindings();
      }
      return sequenceID;
    }
  }
);
  indexWriter.maybeMerge();
  return seqID;
}
