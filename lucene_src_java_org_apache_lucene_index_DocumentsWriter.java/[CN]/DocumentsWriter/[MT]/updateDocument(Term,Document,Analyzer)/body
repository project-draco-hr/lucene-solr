{
  UpdateResult result=threadPool.executePerThread(this,doc,new DocumentsWriterThreadPool.PerThreadTask<UpdateResult>(){
    @Override public UpdateResult process(    final DocumentsWriterPerThread perThread) throws IOException {
      long perThreadRAMUsedBeforeAdd=perThread.numBytesUsed;
      perThread.addDocument(doc,analyzer);
      final long sequenceID;
      sequenceIDLock.lock();
      try {
        ensureOpen();
        sequenceID=nextSequenceID();
        if (delTerm != null) {
          deletesInRAM.addDeleteTerm(delTerm,sequenceID,numDocumentsWriterPerThreads);
        }
        perThread.commitDocument(sequenceID);
        if (!minSequenceIDsPerThread.containsKey(perThread)) {
          minSequenceIDsPerThread.put(perThread,sequenceID);
        }
        numDocsInRAM.incrementAndGet();
      }
  finally {
        sequenceIDLock.unlock();
      }
      UpdateResult result=new UpdateResult(sequenceID);
      if (finishAddDocument(perThread,perThreadRAMUsedBeforeAdd)) {
        result.flushed=true;
        super.clearThreadBindings();
      }
      return result;
    }
  }
);
  if (result == null) {
    return -1;
  }
  if (result.flushed) {
    indexWriter.maybeMerge();
  }
  return result.sequenceID;
}
