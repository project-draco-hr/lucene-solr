{
synchronized (indexWriter) {
    indexWriter.segmentInfos.add(newSegment);
    indexWriter.checkpoint();
    SegmentReader reader=indexWriter.readerPool.get(newSegment,false);
    boolean any=false;
    try {
      any=applyDeletes(reader,newSegment.getMinSequenceID(),newSegment.getMaxSequenceID(),perThread.sequenceIDs);
    }
  finally {
      indexWriter.readerPool.release(reader);
    }
    if (any) {
      indexWriter.checkpoint();
    }
    if (indexWriter.mergePolicy.useCompoundFile(indexWriter.segmentInfos,newSegment)) {
      boolean success=false;
      try {
        createCompoundFile(newSegment.name,perThread);
        success=true;
      }
  finally {
        if (!success) {
          if (infoStream != null) {
            message("hit exception " + "reating compound file for newly flushed segment " + newSegment.name);
          }
          indexWriter.deleter.deleteFile(IndexFileNames.segmentFileName(newSegment.name,"",IndexFileNames.COMPOUND_FILE_EXTENSION));
        }
      }
synchronized (indexWriter) {
        newSegment.setUseCompoundFile(true);
        indexWriter.checkpoint();
        indexWriter.deleter.deleteNewFiles(perThread.closedFiles());
      }
    }
  }
}
