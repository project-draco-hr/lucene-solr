{
  final boolean doBalance;
  final long deletesRAMUsed;
synchronized (this) {
    if (ramBufferSize == IndexWriterConfig.DISABLE_AUTO_FLUSH || bufferIsFull) {
      return;
    }
    deletesRAMUsed=deletesInRAM.bytesUsed + deletesFlushed.bytesUsed;
    doBalance=bytesUsed() + deletesRAMUsed >= ramBufferSize;
  }
  if (doBalance) {
    if (infoStream != null)     message("  RAM: now balance allocations: usedMB=" + toMB(bytesUsed()) + " vs trigger="+ toMB(ramBufferSize)+ " deletesMB="+ toMB(deletesRAMUsed)+ " byteBlockFree="+ toMB(byteBlockAllocator.bytesUsed())+ " perDocFree="+ toMB(perDocAllocator.bytesUsed()));
    final long startBytesUsed=bytesUsed() + deletesRAMUsed;
    int iter=0;
    boolean any=true;
    while (bytesUsed() + deletesRAMUsed > freeLevel) {
synchronized (this) {
        if (0 == perDocAllocator.numBufferedBlocks() && 0 == byteBlockAllocator.numBufferedBlocks() && 0 == freeIntBlocks.size() && !any) {
          bufferIsFull=bytesUsed() + deletesRAMUsed > ramBufferSize;
          if (infoStream != null) {
            if (bytesUsed() + deletesRAMUsed > ramBufferSize)             message("    nothing to free; now set bufferIsFull");
 else             message("    nothing to free");
          }
          break;
        }
        if ((0 == iter % 4) && byteBlockAllocator.numBufferedBlocks() > 0) {
          byteBlockAllocator.freeBlocks(1);
        }
        if ((1 == iter % 4) && freeIntBlocks.size() > 0) {
          freeIntBlocks.remove(freeIntBlocks.size() - 1);
          bytesUsed.addAndGet(-INT_BLOCK_SIZE * INT_NUM_BYTE);
        }
        if ((2 == iter % 4) && perDocAllocator.numBufferedBlocks() > 0) {
          perDocAllocator.freeBlocks(32);
        }
      }
      if ((3 == iter % 4) && any)       any=consumer.freeRAM();
      iter++;
    }
    if (infoStream != null)     message("    after free: freedMB=" + nf.format((startBytesUsed - bytesUsed() - deletesRAMUsed) / 1024. / 1024.) + " usedMB="+ nf.format((bytesUsed() + deletesRAMUsed) / 1024. / 1024.));
  }
}
