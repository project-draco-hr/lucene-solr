{
  byte[] data=zkClient.getData(path,this,null,true);
  if (data != null) {
    CoreState[] states=CoreState.load(data);
    List<CoreState> stateList=Arrays.asList(states);
    HashSet<CoreState> modifiedCores=new HashSet<CoreState>();
    modifiedCores.addAll(stateList);
    modifiedCores.removeAll(currentState);
    HashSet<CoreState> newState=new HashSet<CoreState>();
    newState.addAll(stateList);
    HashMap<String,CoreState> lookup=new HashMap<String,CoreState>();
    for (    CoreState state : states) {
      lookup.put(state.getCoreName(),state);
    }
    for (    CoreState state : currentState) {
      if (lookup.containsKey(state.getCoreName())) {
        if (!state.getProperties().equals(lookup.get(state.getCoreName()).getProperties())) {
          modifiedCores.add(lookup.get(state.getCoreName()));
        }
      }
    }
    HashMap<String,CoreState> deletedCores=new HashMap<String,CoreState>();
    for (    CoreState state : currentState) {
      deletedCores.put(state.getCoreNodeName(),state);
    }
    for (    CoreState state : stateList) {
      deletedCores.remove(state.getCoreNodeName());
    }
    if (deletedCores.size() > 0) {
      listener.coreDeleted(nodeName,deletedCores.values());
    }
    currentState=Collections.unmodifiableSet(newState);
    if (modifiedCores.size() > 0) {
      try {
        listener.coreChanged(nodeName,Collections.unmodifiableSet(modifiedCores));
      }
 catch (      KeeperException e) {
        log.warn("Could not talk to ZK",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("Could not talk to ZK",e);
      }
    }
  }
 else {
  }
}
