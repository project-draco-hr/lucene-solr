{
  AttributeSource atts=new AttributeSource();
  MaxNonCompetitiveBoostAttribute maxBoostAtt=atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);
  Terms terms=MultiFields.getTerms(ir,term.field());
  if (terms == null) {
    return Collections.emptyList();
  }
  FuzzyTermsEnum e=new FuzzyTermsEnum(terms,atts,term,editDistance,Math.max(minPrefix,editDistance - 1),true);
  final PriorityQueue<ScoreTerm> stQueue=new PriorityQueue<>();
  BytesRef queryTerm=new BytesRef(term.text());
  BytesRef candidateTerm;
  ScoreTerm st=new ScoreTerm();
  BoostAttribute boostAtt=e.attributes().addAttribute(BoostAttribute.class);
  while ((candidateTerm=e.next()) != null) {
    final float boost=boostAtt.getBoost();
    if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)     continue;
    if (queryTerm.bytesEquals(candidateTerm))     continue;
    int df=e.docFreq();
    if (df <= docfreq)     continue;
    final float score;
    final String termAsString;
    if (distance == INTERNAL_LEVENSHTEIN) {
      termAsString=null;
      score=boost / e.getScaleFactor() + e.getMinSimilarity();
    }
 else {
      spare.copyUTF8Bytes(candidateTerm);
      termAsString=spare.toString();
      score=distance.getDistance(term.text(),termAsString);
    }
    if (score < accuracy)     continue;
    st.term=BytesRef.deepCopyOf(candidateTerm);
    st.boost=boost;
    st.docfreq=df;
    st.termAsString=termAsString;
    st.score=score;
    stQueue.offer(st);
    st=(stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();
    maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);
  }
  return stQueue;
}
