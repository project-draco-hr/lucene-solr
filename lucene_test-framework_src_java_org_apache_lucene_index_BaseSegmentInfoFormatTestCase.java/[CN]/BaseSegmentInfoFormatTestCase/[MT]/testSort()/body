{
  assumeTrue("test requires a codec that can read/write index sort",supportsIndexSort());
  final int iters=atLeast(5);
  for (int i=0; i < iters; ++i) {
    Sort sort;
    if (i == 0) {
      sort=null;
    }
 else {
      final int numSortFields=TestUtil.nextInt(random(),1,3);
      SortField[] sortFields=new SortField[numSortFields];
      for (int j=0; j < numSortFields; ++j) {
        sortFields[j]=new SortField(TestUtil.randomSimpleString(random()),random().nextBoolean() ? SortField.Type.LONG : SortField.Type.STRING,random().nextBoolean());
        if (random().nextBoolean()) {
switch (sortFields[j].getType()) {
case LONG:
            sortFields[j].setMissingValue(random().nextLong());
          break;
case STRING:
        sortFields[j].setMissingValue(random().nextBoolean() ? SortField.STRING_FIRST : SortField.STRING_LAST);
      break;
default :
    fail();
}
}
}
sort=new Sort(sortFields);
}
Directory dir=newDirectory();
Codec codec=getCodec();
byte id[]=StringHelper.randomId();
SegmentInfo info=new SegmentInfo(dir,getVersions()[0],"_123",1,false,codec,Collections.<String,String>emptyMap(),id,new HashMap<>(),sort);
info.setFiles(Collections.<String>emptySet());
codec.segmentInfoFormat().write(dir,info,IOContext.DEFAULT);
SegmentInfo info2=codec.segmentInfoFormat().read(dir,"_123",id,IOContext.DEFAULT);
assertEquals(sort,info2.getIndexSort());
dir.close();
}
}
