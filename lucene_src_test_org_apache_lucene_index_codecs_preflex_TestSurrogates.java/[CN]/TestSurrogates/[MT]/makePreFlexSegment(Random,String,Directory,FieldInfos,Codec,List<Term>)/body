{
  final int numField=_TestUtil.nextInt(r,2,5);
  List<Term> terms=new ArrayList<Term>();
  int tc=0;
  for (int f=0; f < numField; f++) {
    String field="f" + f;
    Term protoTerm=new Term(field);
    fieldInfos.add(field,true,false,false,false,false,false,false);
    final int numTerms=10000 * _TestUtil.getRandomMultiplier();
    for (int i=0; i < numTerms; i++) {
      String s;
      if (r.nextInt(3) == 1) {
        s=makeDifficultRandomUnicodeString(r);
      }
 else {
        s=_TestUtil.randomUnicodeString(r);
        s=s.replace((char)0xffff,(char)0xfffe);
      }
      terms.add(protoTerm.createTerm(s + "_" + (tc++)));
    }
  }
  fieldInfos.write(dir,segName);
  Collections.sort(terms,new Comparator<Term>(){
    public int compare(    Term o1,    Term o2){
      return o1.compareToUTF16(o2);
    }
  }
);
  TermInfosWriter w=new TermInfosWriter(dir,segName,fieldInfos,128);
  TermInfo ti=new TermInfo();
  String lastText=null;
  int uniqueTermCount=0;
  if (VERBOSE) {
    System.out.println("TEST: utf16 order:");
  }
  for (  Term t : terms) {
    FieldInfo fi=fieldInfos.fieldInfo(t.field());
    String text=t.text();
    if (lastText != null && lastText.equals(text)) {
      continue;
    }
    fieldTerms.add(t);
    uniqueTermCount++;
    lastText=text;
    if (VERBOSE) {
      System.out.println("  " + toHexString(t));
    }
    w.add(fi.number,t.bytes().bytes,t.bytes().length,ti);
  }
  w.close();
  Collections.sort(fieldTerms);
  if (VERBOSE) {
    System.out.println("\nTEST: codepoint order");
    for (    Term t : fieldTerms) {
      System.out.println("  " + t.field() + ":"+ toHexString(t));
    }
  }
  dir.createOutput(segName + ".prx").close();
  dir.createOutput(segName + ".frq").close();
  return new SegmentInfo(segName,uniqueTermCount,dir,false,-1,null,false,true,codec);
}
