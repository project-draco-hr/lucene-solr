{
  MockDirectoryWrapper.Failure failure=new MockDirectoryWrapper.Failure(){
    boolean sawMaybe=false;
    boolean failed=false;
    Thread thread;
    @Override public MockDirectoryWrapper.Failure reset(){
      thread=Thread.currentThread();
      sawMaybe=false;
      failed=false;
      return this;
    }
    @Override public void eval(    MockDirectoryWrapper dir) throws IOException {
      if (Thread.currentThread() != thread) {
        return;
      }
      if (sawMaybe && !failed) {
        boolean seen=false;
        StackTraceElement[] trace=new Exception().getStackTrace();
        for (int i=0; i < trace.length; i++) {
          if ("applyDeletesAndUpdates".equals(trace[i].getMethodName()) || "slowFileExists".equals(trace[i].getMethodName())) {
            seen=true;
            break;
          }
        }
        if (!seen) {
          failed=true;
          if (VERBOSE) {
            System.out.println("TEST: mock failure: now fail");
            new Throwable().printStackTrace(System.out);
          }
          throw new RuntimeException("fail after applyDeletes");
        }
      }
      if (!failed) {
        StackTraceElement[] trace=new Exception().getStackTrace();
        for (int i=0; i < trace.length; i++) {
          if ("applyDeletesAndUpdates".equals(trace[i].getMethodName())) {
            if (VERBOSE) {
              System.out.println("TEST: mock failure: saw applyDeletes");
              new Throwable().printStackTrace(System.out);
            }
            sawMaybe=true;
            break;
          }
        }
      }
    }
  }
;
  String[] keywords={"1","2"};
  String[] unindexed={"Netherlands","Italy"};
  String[] unstored={"Amsterdam has lots of bridges","Venice has lots of canals"};
  String[] text={"Amsterdam","Venice"};
  MockDirectoryWrapper dir=newMockDirectory();
  IndexWriter modifier=new IndexWriter(dir,newIndexWriterConfig(new MockAnalyzer(random(),MockTokenizer.WHITESPACE,false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));
  MergePolicy lmp=modifier.getConfig().getMergePolicy();
  lmp.setNoCFSRatio(1.0);
  dir.failOn(failure.reset());
  FieldType custom1=new FieldType();
  custom1.setStored(true);
  for (int i=0; i < keywords.length; i++) {
    Document doc=new Document();
    doc.add(newStringField("id",keywords[i],Field.Store.YES));
    doc.add(newField("country",unindexed[i],custom1));
    doc.add(newTextField("contents",unstored[i],Field.Store.NO));
    doc.add(newTextField("city",text[i],Field.Store.YES));
    modifier.addDocument(doc);
  }
  if (VERBOSE) {
    System.out.println("TEST: now full merge");
  }
  modifier.forceMerge(1);
  if (VERBOSE) {
    System.out.println("TEST: now commit");
  }
  modifier.commit();
  Term term=new Term("city","Amsterdam");
  int hitCount=getHitCount(dir,term);
  assertEquals(1,hitCount);
  if (VERBOSE) {
    System.out.println("TEST: delete term=" + term);
  }
  modifier.deleteDocuments(term);
  if (VERBOSE) {
    System.out.println("TEST: add empty doc");
  }
  Document doc=new Document();
  modifier.addDocument(doc);
  boolean failed=false;
  try {
    if (VERBOSE) {
      System.out.println("TEST: now commit for failure");
    }
    modifier.commit();
  }
 catch (  RuntimeException ioe) {
    failed=true;
  }
  assertTrue(failed);
  modifier.commit();
  hitCount=getHitCount(dir,term);
  assertEquals(0,hitCount);
  modifier.close();
  dir.close();
}
