{
  AntClassLoader antLoader=null;
  try {
    if (classpath != null) {
      classpath.setProject(getProject());
      this.loader=antLoader=getProject().createClassLoader(ClassLoader.getSystemClassLoader(),classpath);
      antLoader.setParentFirst(false);
    }
 else {
      this.loader=ClassLoader.getSystemClassLoader();
    }
    classFiles.setProject(getProject());
    apiSignatures.setProject(getProject());
    final long start=System.currentTimeMillis();
    try {
      @SuppressWarnings("unchecked") Iterator<Resource> iter=(Iterator<Resource>)apiSignatures.iterator();
      if (!iter.hasNext()) {
        throw new BuildException("You need to supply at least one API signature definition through apiFile=, <apiFileSet/>, or inner text.");
      }
      while (iter.hasNext()) {
        final Resource r=iter.next();
        if (!r.isExists()) {
          throw new BuildException("Resource does not exist: " + r);
        }
        if (r instanceof StringResource) {
          log("Reading inline API signatures...",Project.MSG_INFO);
          parseApiFile(new StringReader(((StringResource)r).getValue()));
        }
 else {
          log("Reading API signatures: " + r,Project.MSG_INFO);
          parseApiFile(new InputStreamReader(r.getInputStream(),"UTF-8"));
        }
      }
    }
 catch (    IOException ioe) {
      throw new BuildException("IO problem while reading files with API signatures.",ioe);
    }
    if (forbiddenMethods.isEmpty() && forbiddenClasses.isEmpty()) {
      throw new BuildException("No API signatures found; use apiFile=, <apiFileSet/>, or inner text to define those!");
    }
    log("Loading classes to check...",Project.MSG_INFO);
    @SuppressWarnings("unchecked") Iterator<Resource> iter=(Iterator<Resource>)classFiles.iterator();
    if (!iter.hasNext()) {
      throw new BuildException("There is no <fileset/> given or the fileset does not contain any class files to check.");
    }
    while (iter.hasNext()) {
      final Resource r=iter.next();
      if (!r.isExists()) {
        throw new BuildException("Class file does not exist: " + r);
      }
      ClassReader reader=loadClassFromResource(r);
      classesToCheck.put(reader.getClassName(),new ClassSignatureLookup(reader));
    }
    log("Scanning for API signatures and dependencies...",Project.MSG_INFO);
    int errors=0;
    for (    final ClassSignatureLookup c : classesToCheck.values()) {
      errors+=checkClass(c.reader);
    }
    log(String.format(Locale.ROOT,"Scanned %d (and %d related) class file(s) for forbidden API invocations (in %.2fs), %d error(s).",classesToCheck.size(),classpathClassCache.size(),(System.currentTimeMillis() - start) / 1000.0,errors),errors > 0 ? Project.MSG_ERR : Project.MSG_INFO);
    if (errors > 0) {
      throw new BuildException("Check for forbidden API calls failed, see log.");
    }
  }
  finally {
    this.loader=null;
    if (antLoader != null)     antLoader.cleanup();
    antLoader=null;
    classesToCheck.clear();
    classpathClassCache.clear();
    forbiddenFields.clear();
    forbiddenMethods.clear();
    forbiddenClasses.clear();
  }
}
