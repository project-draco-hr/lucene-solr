{
  this.ctx=new SpatialContext(false,null,new RectangleImpl(0,256,-128,128,null));
  this.grid=new QuadPrefixTree(ctx,randomIntBetween(1,8));
  this.strategy=new RecursivePrefixTreeStrategy(grid,getClass().getSimpleName());
  deleteAll();
  Map<String,Shape> indexedShapes=new LinkedHashMap<String,Shape>();
  Map<String,Rectangle> indexedGriddedShapes=new LinkedHashMap<String,Rectangle>();
  final int numIndexedShapes=randomIntBetween(1,6);
  for (int i=1; i <= numIndexedShapes; i++) {
    String id="" + i;
    Shape indexShape=randomRectangle();
    Rectangle gridShape=gridSnapp(indexShape);
    indexedShapes.put(id,indexShape);
    indexedGriddedShapes.put(id,gridShape);
    adoc(id,indexShape);
  }
  commit();
  final int numQueryShapes=atLeast(10);
  for (int i=0; i < numQueryShapes; i++) {
    int scanLevel=randomInt(grid.getMaxLevels());
    ((RecursivePrefixTreeStrategy)strategy).setPrefixGridScanLevel(scanLevel);
    Rectangle queryShape=randomRectangle();
    Rectangle queryGridShape=gridSnapp(queryShape);
    final SpatialOperation operation=SpatialOperation.Intersects;
    Set<String> expectedIds=new TreeSet<String>();
    Set<String> optionalIds=new TreeSet<String>();
    for (    String id : indexedShapes.keySet()) {
      Shape indexShape=indexedShapes.get(id);
      Rectangle indexGridShape=indexedGriddedShapes.get(id);
      if (operation.evaluate(indexShape,queryShape))       expectedIds.add(id);
 else       if (operation.evaluate(indexGridShape,queryGridShape))       optionalIds.add(id);
    }
    Query query=strategy.makeQuery(new SpatialArgs(operation,queryShape));
    SearchResults got=executeQuery(query,100);
    Set<String> remainingExpectedIds=new TreeSet<String>(expectedIds);
    String msg=queryShape.toString() + " Expect: " + expectedIds+ " Opt: "+ optionalIds;
    for (    SearchResult result : got.results) {
      String id=result.getId();
      Object removed=remainingExpectedIds.remove(id);
      if (removed == null) {
        assertTrue("Shouldn't match " + id + " in "+ msg,optionalIds.contains(id));
      }
    }
    assertTrue("Didn't match " + remainingExpectedIds + " in "+ msg,remainingExpectedIds.isEmpty());
  }
}
