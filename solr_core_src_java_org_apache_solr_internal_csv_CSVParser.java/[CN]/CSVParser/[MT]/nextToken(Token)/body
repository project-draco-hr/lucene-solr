{
  wsBuf.clear();
  int lastChar=in.readAgain();
  int c=in.read();
  boolean eol=isEndOfLine(c);
  c=in.readAgain();
  while (strategy.getIgnoreEmptyLines() && eol && (lastChar == '\n' || lastChar == ExtendedBufferedReader.UNDEFINED)&& !isEndOfFile(lastChar)) {
    lastChar=c;
    c=in.read();
    eol=isEndOfLine(c);
    c=in.readAgain();
    if (isEndOfFile(c)) {
      tkn.type=TT_EOF;
      return tkn;
    }
  }
  if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {
    tkn.type=TT_EOF;
    return tkn;
  }
  while (!tkn.isReady && tkn.type != TT_EOF) {
    while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {
      wsBuf.append((char)c);
      c=in.read();
      eol=isEndOfLine(c);
    }
    if (c == strategy.getCommentStart()) {
      in.readLine();
      tkn=nextToken(tkn.reset());
    }
 else     if (c == strategy.getDelimiter()) {
      tkn.type=TT_TOKEN;
      tkn.isReady=true;
    }
 else     if (eol) {
      tkn.type=TT_EORECORD;
      tkn.isReady=true;
    }
 else     if (c == strategy.getEncapsulator()) {
      encapsulatedTokenLexer(tkn,c);
    }
 else     if (isEndOfFile(c)) {
      tkn.type=TT_EOF;
      tkn.isReady=true;
    }
 else {
      if (!strategy.getIgnoreLeadingWhitespaces()) {
        tkn.content.append(wsBuf);
      }
      simpleTokenLexer(tkn,c);
    }
  }
  return tkn;
}
