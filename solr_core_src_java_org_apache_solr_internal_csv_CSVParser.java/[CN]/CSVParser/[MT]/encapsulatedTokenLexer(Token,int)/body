{
  int startLineNumber=getLineNumber();
  for (; ; ) {
    c=in.read();
    if (c == '\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {
      tkn.content.append((char)unicodeEscapeLexer(c));
    }
 else     if (c == strategy.getEscape()) {
      tkn.content.append((char)readEscape(c));
    }
 else     if (c == strategy.getEncapsulator()) {
      if (in.lookAhead() == strategy.getEncapsulator()) {
        c=in.read();
        tkn.content.append((char)c);
      }
 else {
        for (; ; ) {
          c=in.read();
          if (c == strategy.getDelimiter()) {
            tkn.type=TT_TOKEN;
            tkn.isReady=true;
            return tkn;
          }
 else           if (isEndOfFile(c)) {
            tkn.type=TT_EOF;
            tkn.isReady=true;
            return tkn;
          }
 else           if (isEndOfLine(c)) {
            tkn.type=TT_EORECORD;
            tkn.isReady=true;
            return tkn;
          }
 else           if (!isWhitespace(c)) {
            throw new IOException("(line " + getLineNumber() + ") invalid char between encapsulated token end delimiter");
          }
        }
      }
    }
 else     if (isEndOfFile(c)) {
      throw new IOException("(startline " + startLineNumber + ")"+ "eof reached before encapsulated token finished");
    }
 else {
      tkn.content.append((char)c);
    }
  }
}
