{
  int pos=-1;
  int offset=0;
  if (info.numTokens == 0) {
    info.boost=boost;
  }
 else   if (info.numTokens > 0) {
    pos=info.lastPosition + positionIncrementGap;
    offset=info.lastOffset + offsetGap;
    info.boost*=boost;
  }
  try (TokenStream stream=tokenStream){
    TermToBytesRefAttribute termAtt=stream.getAttribute(TermToBytesRefAttribute.class);
    PositionIncrementAttribute posIncrAttribute=stream.addAttribute(PositionIncrementAttribute.class);
    OffsetAttribute offsetAtt=stream.addAttribute(OffsetAttribute.class);
    PayloadAttribute payloadAtt=storePayloads ? stream.addAttribute(PayloadAttribute.class) : null;
    stream.reset();
    while (stream.incrementToken()) {
      info.numTokens++;
      final int posIncr=posIncrAttribute.getPositionIncrement();
      if (posIncr == 0) {
        info.numOverlapTokens++;
      }
      pos+=posIncr;
      int ord=info.terms.add(termAtt.getBytesRef());
      if (ord < 0) {
        ord=(-ord) - 1;
        postingsWriter.reset(info.sliceArray.end[ord]);
      }
 else {
        info.sliceArray.start[ord]=postingsWriter.startNewSlice();
      }
      info.sliceArray.freq[ord]++;
      info.sumTotalTermFreq++;
      postingsWriter.writeInt(pos);
      if (storeOffsets) {
        postingsWriter.writeInt(offsetAtt.startOffset() + offset);
        postingsWriter.writeInt(offsetAtt.endOffset() + offset);
      }
      if (storePayloads) {
        final BytesRef payload=payloadAtt.getPayload();
        final int pIndex;
        if (payload == null || payload.length == 0) {
          pIndex=-1;
        }
 else {
          pIndex=payloadsBytesRefs.append(payload);
        }
        postingsWriter.writeInt(pIndex);
      }
      info.sliceArray.end[ord]=postingsWriter.getCurrentOffset();
    }
    stream.end();
    if (info.numTokens > 0) {
      info.lastPosition=pos;
      info.lastOffset=offsetAtt.endOffset() + offset;
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}
