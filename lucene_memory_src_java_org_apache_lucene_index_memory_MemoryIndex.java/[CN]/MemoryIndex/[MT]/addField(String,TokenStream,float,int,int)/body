{
  try (TokenStream stream=tokenStream){
    if (frozen)     throw new IllegalArgumentException("Cannot call addField() when MemoryIndex is frozen");
    if (fieldName == null)     throw new IllegalArgumentException("fieldName must not be null");
    if (stream == null)     throw new IllegalArgumentException("token stream must not be null");
    if (boost <= 0.0f)     throw new IllegalArgumentException("boost factor must be greater than 0.0");
    int numTokens=0;
    int numOverlapTokens=0;
    int pos=-1;
    final BytesRefHash terms;
    final SliceByteStartArray sliceArray;
    Info info;
    long sumTotalTermFreq=0;
    int offset=0;
    FieldInfo fieldInfo;
    if ((info=fields.get(fieldName)) != null) {
      fieldInfo=info.fieldInfo;
      numTokens=info.numTokens;
      numOverlapTokens=info.numOverlapTokens;
      pos=info.lastPosition + positionIncrementGap;
      offset=info.lastOffset + offsetGap;
      terms=info.terms;
      boost*=info.boost;
      sliceArray=info.sliceArray;
      sumTotalTermFreq=info.sumTotalTermFreq;
    }
 else {
      fieldInfo=new FieldInfo(fieldName,fields.size(),true,false,this.storePayloads,this.storeOffsets ? IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS,DocValuesType.NONE,-1,Collections.emptyMap());
      sliceArray=new SliceByteStartArray(BytesRefHash.DEFAULT_CAPACITY);
      terms=new BytesRefHash(byteBlockPool,BytesRefHash.DEFAULT_CAPACITY,sliceArray);
    }
    TermToBytesRefAttribute termAtt=stream.getAttribute(TermToBytesRefAttribute.class);
    PositionIncrementAttribute posIncrAttribute=stream.addAttribute(PositionIncrementAttribute.class);
    OffsetAttribute offsetAtt=stream.addAttribute(OffsetAttribute.class);
    PayloadAttribute payloadAtt=storePayloads ? stream.addAttribute(PayloadAttribute.class) : null;
    BytesRef ref=termAtt.getBytesRef();
    stream.reset();
    while (stream.incrementToken()) {
      termAtt.fillBytesRef();
      numTokens++;
      final int posIncr=posIncrAttribute.getPositionIncrement();
      if (posIncr == 0)       numOverlapTokens++;
      pos+=posIncr;
      int ord=terms.add(ref);
      if (ord < 0) {
        ord=(-ord) - 1;
        postingsWriter.reset(sliceArray.end[ord]);
      }
 else {
        sliceArray.start[ord]=postingsWriter.startNewSlice();
      }
      sliceArray.freq[ord]++;
      sumTotalTermFreq++;
      postingsWriter.writeInt(pos);
      if (storeOffsets) {
        postingsWriter.writeInt(offsetAtt.startOffset() + offset);
        postingsWriter.writeInt(offsetAtt.endOffset() + offset);
      }
      if (storePayloads) {
        final BytesRef payload=payloadAtt.getPayload();
        final int pIndex;
        if (payload == null || payload.length == 0) {
          pIndex=-1;
        }
 else {
          pIndex=payloadsBytesRefs.append(payload);
        }
        postingsWriter.writeInt(pIndex);
      }
      sliceArray.end[ord]=postingsWriter.getCurrentOffset();
    }
    stream.end();
    if (numTokens > 0) {
      fields.put(fieldName,new Info(fieldInfo,terms,sliceArray,numTokens,numOverlapTokens,boost,pos,offsetAtt.endOffset() + offset,sumTotalTermFreq));
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}
