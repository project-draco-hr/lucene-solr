{
  final Directory dir=newDirectory();
  final RandomIndexWriter w=new RandomIndexWriter(random(),dir);
  final List<Document> docs=new ArrayList<>();
  for (int i=0; i < 10; i++) {
    docs.clear();
    docs.add(makeJob("ruby",i));
    docs.add(makeJob("java",2007));
    docs.add(makeResume("Frank","United States"));
    w.addDocuments(docs);
  }
  IndexReader r=w.getReader();
  w.close();
  IndexSearcher s=newSearcher(r,false);
  BooleanQuery.Builder builder=new BooleanQuery.Builder();
  builder.add(IntPoint.newExactQuery("year",2007),BooleanClause.Occur.MUST);
  Query qc=new Query(){
    @Override public Query rewrite(    IndexReader reader) throws IOException {
      return builder.build();
    }
    @Override public String toString(    String field){
      return "hack!";
    }
    @Override public boolean equals(    Object o){
      return o == this;
    }
    @Override public int hashCode(){
      return System.identityHashCode(this);
    }
  }
;
  BitSetProducer parentsFilter=new QueryBitSetProducer(new TermQuery(new Term("docType","resume")));
  CheckJoinIndex.check(r,parentsFilter);
  Query qw1=qc.rewrite(r);
  Query qw2=qw1.rewrite(r);
  assertNotSame(qc,qw1);
  assertNotSame(qw1,qw2);
  ToParentBlockJoinQuery qp=new ToParentBlockJoinQuery(qc,parentsFilter,ScoreMode.Max);
  ToParentBlockJoinCollector c=new ToParentBlockJoinCollector(Sort.RELEVANCE,10,true,true);
  s.search(qp,c);
  TopGroups<Integer> groups=c.getTopGroups(qp,Sort.INDEXORDER,0,10,0,true);
  for (  GroupDocs<Integer> group : groups.groups) {
    assertEquals(1,group.totalHits);
  }
  r.close();
  dir.close();
}
