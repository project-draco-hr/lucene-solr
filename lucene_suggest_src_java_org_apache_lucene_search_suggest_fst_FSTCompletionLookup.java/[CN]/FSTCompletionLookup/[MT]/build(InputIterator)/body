{
  if (iterator.hasPayloads()) {
    throw new IllegalArgumentException("this suggester doesn't support payloads");
  }
  if (iterator.hasContexts()) {
    throw new IllegalArgumentException("this suggester doesn't support contexts");
  }
  OfflineSorter sorter=new OfflineSorter(tempDir,tempFileNamePrefix);
  ExternalRefSorter externalSorter=new ExternalRefSorter(sorter);
  IndexOutput tempInput=tempDir.createTempOutput(tempFileNamePrefix,"input",IOContext.DEFAULT);
  String tempSortedFileName=null;
  OfflineSorter.ByteSequencesWriter writer=new OfflineSorter.ByteSequencesWriter(tempInput);
  OfflineSorter.ByteSequencesReader reader=null;
  count=0;
  try {
    byte[] buffer=new byte[0];
    ByteArrayDataOutput output=new ByteArrayDataOutput(buffer);
    BytesRef spare;
    int inputLineCount=0;
    while ((spare=iterator.next()) != null) {
      if (spare.length + 4 >= buffer.length) {
        buffer=ArrayUtil.grow(buffer,spare.length + 4);
      }
      output.reset(buffer);
      output.writeInt(encodeWeight(iterator.weight()));
      output.writeBytes(spare.bytes,spare.offset,spare.length);
      writer.write(buffer,0,output.getPosition());
      inputLineCount++;
    }
    writer.close();
    tempSortedFileName=sorter.sort(tempInput.getName());
    tempDir.deleteFiles(Collections.singleton(tempInput.getName()));
    FSTCompletionBuilder builder=new FSTCompletionBuilder(buckets,externalSorter,sharedTailLength);
    reader=new OfflineSorter.ByteSequencesReader(tempDir.openInput(tempSortedFileName,IOContext.READONCE));
    long line=0;
    int previousBucket=0;
    int previousScore=0;
    ByteArrayDataInput input=new ByteArrayDataInput();
    BytesRefBuilder tmp1=new BytesRefBuilder();
    BytesRef tmp2=new BytesRef();
    while (reader.read(tmp1)) {
      input.reset(tmp1.bytes());
      int currentScore=input.readInt();
      int bucket;
      if (line > 0 && currentScore == previousScore) {
        bucket=previousBucket;
      }
 else {
        bucket=(int)(line * buckets / inputLineCount);
      }
      previousScore=currentScore;
      previousBucket=bucket;
      tmp2.bytes=tmp1.bytes();
      tmp2.offset=input.getPosition();
      tmp2.length=tmp1.length() - input.getPosition();
      builder.add(tmp2,bucket);
      line++;
      count++;
    }
    this.higherWeightsCompletion=builder.build();
    this.normalCompletion=new FSTCompletion(higherWeightsCompletion.getFST(),false,exactMatchFirst);
  }
  finally {
    IOUtils.closeWhileHandlingException(reader,writer,externalSorter);
    IOUtils.deleteFilesIgnoringExceptions(tempDir,tempInput.getName(),tempSortedFileName);
  }
}
