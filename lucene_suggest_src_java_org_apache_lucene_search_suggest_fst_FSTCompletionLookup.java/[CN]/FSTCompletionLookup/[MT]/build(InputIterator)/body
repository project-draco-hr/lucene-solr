{
  if (tfit.hasPayloads()) {
    throw new IllegalArgumentException("this suggester doesn't support payloads");
  }
  File tempInput=File.createTempFile(FSTCompletionLookup.class.getSimpleName(),".input",Sort.defaultTempDir());
  File tempSorted=File.createTempFile(FSTCompletionLookup.class.getSimpleName(),".sorted",Sort.defaultTempDir());
  Sort.ByteSequencesWriter writer=new Sort.ByteSequencesWriter(tempInput);
  Sort.ByteSequencesReader reader=null;
  ExternalRefSorter sorter=null;
  boolean success=false;
  try {
    byte[] buffer=new byte[0];
    ByteArrayDataOutput output=new ByteArrayDataOutput(buffer);
    BytesRef spare;
    while ((spare=tfit.next()) != null) {
      if (spare.length + 4 >= buffer.length) {
        buffer=ArrayUtil.grow(buffer,spare.length + 4);
      }
      output.reset(buffer);
      output.writeInt(encodeWeight(tfit.weight()));
      output.writeBytes(spare.bytes,spare.offset,spare.length);
      writer.write(buffer,0,output.getPosition());
    }
    writer.close();
    SortInfo info=new Sort().sort(tempInput,tempSorted);
    tempInput.delete();
    FSTCompletionBuilder builder=new FSTCompletionBuilder(buckets,sorter=new ExternalRefSorter(new Sort()),sharedTailLength);
    final int inputLines=info.lines;
    reader=new Sort.ByteSequencesReader(tempSorted);
    long line=0;
    int previousBucket=0;
    int previousScore=0;
    ByteArrayDataInput input=new ByteArrayDataInput();
    BytesRef tmp1=new BytesRef();
    BytesRef tmp2=new BytesRef();
    while (reader.read(tmp1)) {
      input.reset(tmp1.bytes);
      int currentScore=input.readInt();
      int bucket;
      if (line > 0 && currentScore == previousScore) {
        bucket=previousBucket;
      }
 else {
        bucket=(int)(line * buckets / inputLines);
      }
      previousScore=currentScore;
      previousBucket=bucket;
      tmp2.bytes=tmp1.bytes;
      tmp2.offset=input.getPosition();
      tmp2.length=tmp1.length - input.getPosition();
      builder.add(tmp2,bucket);
      line++;
    }
    this.higherWeightsCompletion=builder.build();
    this.normalCompletion=new FSTCompletion(higherWeightsCompletion.getFST(),false,exactMatchFirst);
    success=true;
  }
  finally {
    if (success)     IOUtils.close(reader,writer,sorter);
 else     IOUtils.closeWhileHandlingException(reader,writer,sorter);
    tempInput.delete();
    tempSorted.delete();
  }
}
