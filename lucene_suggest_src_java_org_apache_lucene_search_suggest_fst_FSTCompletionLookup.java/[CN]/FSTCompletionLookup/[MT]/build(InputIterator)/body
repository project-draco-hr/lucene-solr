{
  if (iterator.hasPayloads()) {
    throw new IllegalArgumentException("this suggester doesn't support payloads");
  }
  if (iterator.hasContexts()) {
    throw new IllegalArgumentException("this suggester doesn't support contexts");
  }
  File tempInput=File.createTempFile(FSTCompletionLookup.class.getSimpleName(),".input",OfflineSorter.defaultTempDir());
  File tempSorted=File.createTempFile(FSTCompletionLookup.class.getSimpleName(),".sorted",OfflineSorter.defaultTempDir());
  OfflineSorter.ByteSequencesWriter writer=new OfflineSorter.ByteSequencesWriter(tempInput);
  OfflineSorter.ByteSequencesReader reader=null;
  ExternalRefSorter sorter=null;
  boolean success=false;
  count=0;
  try {
    byte[] buffer=new byte[0];
    ByteArrayDataOutput output=new ByteArrayDataOutput(buffer);
    BytesRef spare;
    while ((spare=iterator.next()) != null) {
      if (spare.length + 4 >= buffer.length) {
        buffer=ArrayUtil.grow(buffer,spare.length + 4);
      }
      output.reset(buffer);
      output.writeInt(encodeWeight(iterator.weight()));
      output.writeBytes(spare.bytes,spare.offset,spare.length);
      writer.write(buffer,0,output.getPosition());
    }
    writer.close();
    SortInfo info=new OfflineSorter().sort(tempInput,tempSorted);
    Files.delete(tempInput.toPath());
    FSTCompletionBuilder builder=new FSTCompletionBuilder(buckets,sorter=new ExternalRefSorter(new OfflineSorter()),sharedTailLength);
    final int inputLines=info.lines;
    reader=new OfflineSorter.ByteSequencesReader(tempSorted);
    long line=0;
    int previousBucket=0;
    int previousScore=0;
    ByteArrayDataInput input=new ByteArrayDataInput();
    BytesRefBuilder tmp1=new BytesRefBuilder();
    BytesRef tmp2=new BytesRef();
    while (reader.read(tmp1)) {
      input.reset(tmp1.bytes());
      int currentScore=input.readInt();
      int bucket;
      if (line > 0 && currentScore == previousScore) {
        bucket=previousBucket;
      }
 else {
        bucket=(int)(line * buckets / inputLines);
      }
      previousScore=currentScore;
      previousBucket=bucket;
      tmp2.bytes=tmp1.bytes();
      tmp2.offset=input.getPosition();
      tmp2.length=tmp1.length() - input.getPosition();
      builder.add(tmp2,bucket);
      line++;
      count++;
    }
    this.higherWeightsCompletion=builder.build();
    this.normalCompletion=new FSTCompletion(higherWeightsCompletion.getFST(),false,exactMatchFirst);
    success=true;
  }
  finally {
    IOUtils.closeWhileHandlingException(reader,writer,sorter);
    if (success) {
      Files.delete(tempSorted.toPath());
    }
 else {
      IOUtils.deleteFilesIgnoringExceptions(tempInput,tempSorted);
    }
  }
}
