{
  final List<PerDocValues> perDocProducers=new ArrayList<PerDocValues>();
  final List<ReaderUtil.Slice> perDocSlices=new ArrayList<ReaderUtil.Slice>();
  final List<Bits> perDocBits=new ArrayList<Bits>();
  final List<Integer> perDocBitsStarts=new ArrayList<Integer>();
  int docBase=0;
  for (  IndexReader r : readers) {
    final int maxDoc=r.maxDoc();
    final PerDocValues producer=r.perDocValues();
    if (producer != null) {
      perDocSlices.add(new ReaderUtil.Slice(docBase,maxDoc,perDocProducers.size()));
      perDocProducers.add(producer);
      perDocBits.add(r.getLiveDocs());
      perDocBitsStarts.add(docBase);
    }
    docBase+=maxDoc;
  }
  perDocBitsStarts.add(docBase);
  if (!perDocSlices.isEmpty()) {
    final PerDocConsumer docsConsumer=codec.docsConsumer(new PerDocWriteState(segmentWriteState));
    boolean success=false;
    try {
      final MultiPerDocValues multiPerDocValues=new MultiPerDocValues(perDocProducers.toArray(PerDocValues.EMPTY_ARRAY),perDocSlices.toArray(ReaderUtil.Slice.EMPTY_ARRAY));
      docsConsumer.merge(mergeState,multiPerDocValues);
      success=true;
    }
  finally {
      IOUtils.closeSafely(!success,docsConsumer);
    }
  }
}
