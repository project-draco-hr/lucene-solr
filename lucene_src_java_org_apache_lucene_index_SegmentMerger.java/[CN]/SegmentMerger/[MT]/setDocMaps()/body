{
  final int numReaders=mergeState.readers.size();
  mergeState.docMaps=new int[numReaders][];
  mergeState.docBase=new int[numReaders];
  mergeState.segmentDocCounts=new HashMap<SegmentInfo,Integer>();
  mergeState.dirPayloadProcessor=new PayloadProcessorProvider.DirPayloadProcessor[numReaders];
  mergeState.currentPayloadProcessor=new PayloadProcessorProvider.PayloadProcessor[numReaders];
  int docBase=0;
  int i=0;
  while (i < mergeState.readers.size()) {
    final MergeState.IndexReaderAndLiveDocs reader=mergeState.readers.get(i);
    mergeState.docBase[i]=docBase;
    final int maxDoc=reader.reader.maxDoc();
    final int docCount;
    final Bits liveDocs=reader.liveDocs;
    final int[] docMap;
    if (liveDocs != null) {
      int delCount=0;
      docMap=new int[maxDoc];
      int newDocID=0;
      for (int j=0; j < maxDoc; j++) {
        if (!liveDocs.get(j)) {
          docMap[j]=-1;
          delCount++;
        }
 else {
          docMap[j]=newDocID++;
        }
      }
      docCount=maxDoc - delCount;
    }
 else {
      docCount=maxDoc;
      docMap=null;
    }
    if (reader.reader instanceof SegmentReader) {
      mergeState.segmentDocCounts.put(((SegmentReader)reader.reader).getSegmentInfo(),docCount);
    }
    if (docCount == 0) {
      mergeState.readers.remove(i);
      continue;
    }
    mergeState.docMaps[i]=docMap;
    docBase+=docCount;
    if (mergeState.payloadProcessorProvider != null) {
      mergeState.dirPayloadProcessor[i]=mergeState.payloadProcessorProvider.getDirProcessor(reader.reader.directory());
    }
    i++;
  }
  final int numReadersLeft=mergeState.readers.size();
  if (numReadersLeft < mergeState.docMaps.length) {
    mergeState.docMaps=shrink(mergeState.docMaps,numReadersLeft);
    mergeState.docBase=shrink(mergeState.docBase,numReadersLeft);
  }
  return docBase;
}
