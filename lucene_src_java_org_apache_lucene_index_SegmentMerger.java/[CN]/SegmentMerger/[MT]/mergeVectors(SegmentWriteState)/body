{
  TermVectorsWriter termVectorsWriter=new TermVectorsWriter(directory,segment,mergeState.fieldInfos,context);
  int rawDocLengths[]=new int[MAX_RAW_MERGE_DOCS];
  int rawDocLengths2[]=new int[MAX_RAW_MERGE_DOCS];
  try {
    int idx=0;
    for (    final MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {
      final SegmentReader matchingSegmentReader=mergeState.matchingSegmentReaders[idx++];
      TermVectorsReader matchingVectorsReader=null;
      if (matchingSegmentReader != null) {
        TermVectorsReader vectorsReader=matchingSegmentReader.getTermVectorsReader();
        if (vectorsReader != null && vectorsReader.canReadRawDocs()) {
          matchingVectorsReader=vectorsReader;
        }
      }
      if (reader.liveDocs != null) {
        copyVectorsWithDeletions(termVectorsWriter,matchingVectorsReader,reader,rawDocLengths,rawDocLengths2);
      }
 else {
        copyVectorsNoDeletions(termVectorsWriter,matchingVectorsReader,reader,rawDocLengths,rawDocLengths2);
      }
    }
  }
  finally {
    termVectorsWriter.close();
  }
  final String fileName=IndexFileNames.segmentFileName(segment,"",IndexFileNames.VECTORS_INDEX_EXTENSION);
  final long tvxSize=directory.fileLength(fileName);
  final int mergedDocs=segmentWriteState.numDocs;
  if (4 + ((long)mergedDocs) * 16 != tvxSize)   throw new RuntimeException("mergeVectors produced an invalid result: mergedDocs is " + mergedDocs + " but tvx size is "+ tvxSize+ " file="+ fileName+ " file exists?="+ directory.fileExists(fileName)+ "; now aborting this merge to prevent index corruption");
}
