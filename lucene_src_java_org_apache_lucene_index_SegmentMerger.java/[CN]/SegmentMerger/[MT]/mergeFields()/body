{
  if (!mergeDocStores) {
    final SegmentReader sr=(SegmentReader)readers.get(readers.size() - 1);
    fieldInfos=(FieldInfos)sr.core.fieldInfos.clone();
  }
 else {
    fieldInfos=new FieldInfos();
  }
  for (  IndexReader reader : readers) {
    if (reader instanceof SegmentReader) {
      SegmentReader segmentReader=(SegmentReader)reader;
      FieldInfos readerFieldInfos=segmentReader.fieldInfos();
      int numReaderFieldInfos=readerFieldInfos.size();
      for (int j=0; j < numReaderFieldInfos; j++) {
        FieldInfo fi=readerFieldInfos.fieldInfo(j);
        fieldInfos.add(fi.name,fi.isIndexed,fi.storeTermVector,fi.storePositionWithTermVector,fi.storeOffsetWithTermVector,!reader.hasNorms(fi.name),fi.storePayloads,fi.omitTermFreqAndPositions);
      }
    }
 else {
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET),true,true,true,false,false);
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION),true,true,false,false,false);
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET),true,false,true,false,false);
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.TERMVECTOR),true,false,false,false,false);
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS),false,false,false,false,true);
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.STORES_PAYLOADS),false,false,false,true,false);
      addIndexed(reader,fieldInfos,reader.getFieldNames(FieldOption.INDEXED),false,false,false,false,false);
      fieldInfos.add(reader.getFieldNames(FieldOption.UNINDEXED),false);
    }
  }
  final SegmentCodecs codecInfo=SegmentCodecs.build(fieldInfos,this.codecs);
  fieldInfos.write(directory,segment + ".fnm");
  int docCount=0;
  setMatchingSegmentReaders();
  if (mergeDocStores) {
    final FieldsWriter fieldsWriter=new FieldsWriter(directory,segment,fieldInfos);
    try {
      int idx=0;
      for (      IndexReader reader : readers) {
        final SegmentReader matchingSegmentReader=matchingSegmentReaders[idx++];
        FieldsReader matchingFieldsReader=null;
        if (matchingSegmentReader != null) {
          final FieldsReader fieldsReader=matchingSegmentReader.getFieldsReader();
          if (fieldsReader != null) {
            matchingFieldsReader=fieldsReader;
          }
        }
        if (reader.hasDeletions()) {
          docCount+=copyFieldsWithDeletions(fieldsWriter,reader,matchingFieldsReader);
        }
 else {
          docCount+=copyFieldsNoDeletions(fieldsWriter,reader,matchingFieldsReader);
        }
      }
    }
  finally {
      fieldsWriter.close();
    }
    final String fileName=IndexFileNames.segmentFileName(segment,"",IndexFileNames.FIELDS_INDEX_EXTENSION);
    final long fdxFileLength=directory.fileLength(fileName);
    if (4 + ((long)docCount) * 8 != fdxFileLength)     throw new RuntimeException("mergeFields produced an invalid result: docCount is " + docCount + " but fdx file size is "+ fdxFileLength+ " file="+ fileName+ " file exists?="+ directory.fileExists(fileName)+ "; now aborting this merge to prevent index corruption");
  }
 else {
    for (    final IndexReader reader : readers) {
      docCount+=reader.numDocs();
    }
  }
  segmentWriteState=new SegmentWriteState(null,directory,segment,fieldInfos,null,docCount,0,termIndexInterval,codecInfo);
  return docCount;
}
