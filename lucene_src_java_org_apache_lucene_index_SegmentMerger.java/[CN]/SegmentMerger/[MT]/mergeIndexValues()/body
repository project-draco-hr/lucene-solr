{
  final int numFields=fieldInfos.size();
  for (int i=0; i < numFields; i++) {
    final FieldInfo fieldInfo=fieldInfos.fieldInfo(i);
    final Values v=fieldInfo.indexValues;
    if (v != null) {
      int docBase=0;
      final List<Writer.MergeState> mergeStates=new ArrayList<Writer.MergeState>();
      for (      IndexReader reader : readers) {
        Reader r=reader.getIndexValues(fieldInfo.name);
        if (r != null) {
          mergeStates.add(new Writer.MergeState(r,docBase,reader.maxDoc(),reader.getDeletedDocs()));
        }
        docBase+=reader.numDocs();
      }
      if (mergeStates.isEmpty()) {
        continue;
      }
      final String id=segment + "_" + fieldInfo.number;
      final Writer writer;
switch (v) {
case PACKED_INTS:
case PACKED_INTS_FIXED:
        writer=Ints.getWriter(directory,id,true);
      break;
case SIMPLE_FLOAT_4BYTE:
    writer=Floats.getWriter(directory,id,4);
  break;
case SIMPLE_FLOAT_8BYTE:
writer=Floats.getWriter(directory,id,8);
break;
case BYTES_FIXED_STRAIGHT:
writer=Bytes.getWriter(directory,id,Bytes.Mode.STRAIGHT,null,true);
break;
case BYTES_FIXED_DEREF:
writer=Bytes.getWriter(directory,id,Bytes.Mode.DEREF,null,true);
break;
case BYTES_FIXED_SORTED:
writer=Bytes.getWriter(directory,id,Bytes.Mode.SORTED,null,true);
break;
case BYTES_VAR_STRAIGHT:
writer=Bytes.getWriter(directory,id,Bytes.Mode.STRAIGHT,null,false);
break;
case BYTES_VAR_DEREF:
writer=Bytes.getWriter(directory,id,Bytes.Mode.DEREF,null,false);
break;
case BYTES_VAR_SORTED:
writer=Bytes.getWriter(directory,id,Bytes.Mode.SORTED,null,false);
break;
default :
continue;
}
writer.add(mergeStates);
writer.finish(mergedDocs);
}
}
}
