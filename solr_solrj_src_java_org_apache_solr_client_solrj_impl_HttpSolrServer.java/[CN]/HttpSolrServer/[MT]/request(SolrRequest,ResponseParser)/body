{
  HttpRequestBase method=null;
  InputStream is=null;
  SolrParams params=request.getParams();
  Collection<ContentStream> streams=requestWriter.getContentStreams(request);
  String path=requestWriter.getPath(request);
  if (path == null || !path.startsWith("/")) {
    path=DEFAULT_PATH;
  }
  ResponseParser parser=request.getResponseParser();
  if (parser == null) {
    parser=this.parser;
  }
  ModifiableSolrParams wparams=new ModifiableSolrParams(params);
  if (parser != null) {
    wparams.set(CommonParams.WT,parser.getWriterType());
    wparams.set(CommonParams.VERSION,parser.getVersion());
  }
  if (invariantParams != null) {
    wparams.add(invariantParams);
  }
  params=wparams;
  int tries=maxRetries + 1;
  try {
    while (tries-- > 0) {
      try {
        if (SolrRequest.METHOD.GET == request.getMethod()) {
          if (streams != null) {
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"GET can't send streams!");
          }
          method=new HttpGet(baseUrl + path + ClientUtils.toQueryString(params,false));
        }
 else         if (SolrRequest.METHOD.POST == request.getMethod()) {
          String url=baseUrl + path;
          boolean hasNullStreamName=false;
          if (streams != null) {
            for (            ContentStream cs : streams) {
              if (cs.getName() == null) {
                hasNullStreamName=true;
                break;
              }
            }
          }
          boolean isMultipart=(this.useMultiPartPost || (streams != null && streams.size() > 1)) && !hasNullStreamName;
          LinkedList<NameValuePair> postParams=new LinkedList<NameValuePair>();
          if (streams == null || isMultipart) {
            HttpPost post=new HttpPost(url);
            post.setHeader("Content-Charset","UTF-8");
            if (!isMultipart) {
              post.addHeader("Content-Type","application/x-www-form-urlencoded; charset=UTF-8");
            }
            List<FormBodyPart> parts=new LinkedList<FormBodyPart>();
            Iterator<String> iter=params.getParameterNamesIterator();
            while (iter.hasNext()) {
              String p=iter.next();
              String[] vals=params.getParams(p);
              if (vals != null) {
                for (                String v : vals) {
                  if (isMultipart) {
                    parts.add(new FormBodyPart(p,new StringBody(v,Charset.forName("UTF-8"))));
                  }
 else {
                    postParams.add(new BasicNameValuePair(p,v));
                  }
                }
              }
            }
            if (isMultipart && streams != null) {
              for (              ContentStream content : streams) {
                String contentType=content.getContentType();
                if (contentType == null) {
                  contentType=BinaryResponseParser.BINARY_CONTENT_TYPE;
                }
                String name=content.getName();
                if (name == null) {
                  name="";
                }
                parts.add(new FormBodyPart(name,new InputStreamBody(content.getStream(),contentType,content.getName())));
              }
            }
            if (parts.size() > 0) {
              MultipartEntity entity=new MultipartEntity(HttpMultipartMode.STRICT);
              for (              FormBodyPart p : parts) {
                entity.addPart(p);
              }
              post.setEntity(entity);
            }
 else {
              post.setEntity(new UrlEncodedFormEntity(postParams,"UTF-8"));
            }
            method=post;
          }
 else {
            String pstr=ClientUtils.toQueryString(params,false);
            HttpPost post=new HttpPost(url + pstr);
            final ContentStream[] contentStream=new ContentStream[1];
            for (            ContentStream content : streams) {
              contentStream[0]=content;
              break;
            }
            if (contentStream[0] instanceof RequestWriter.LazyContentStream) {
              post.setEntity(new InputStreamEntity(contentStream[0].getStream(),-1){
                @Override public Header getContentType(){
                  return new BasicHeader("Content-Type",contentStream[0].getContentType());
                }
                @Override public boolean isRepeatable(){
                  return false;
                }
              }
);
            }
 else {
              post.setEntity(new InputStreamEntity(contentStream[0].getStream(),-1){
                @Override public Header getContentType(){
                  return new BasicHeader("Content-Type",contentStream[0].getContentType());
                }
                @Override public boolean isRepeatable(){
                  return false;
                }
              }
);
            }
            method=post;
          }
        }
 else {
          throw new SolrServerException("Unsupported method: " + request.getMethod());
        }
      }
 catch (      NoHttpResponseException r) {
        method=null;
        if (is != null) {
          is.close();
        }
        if (tries < 1) {
          throw r;
        }
      }
    }
  }
 catch (  IOException ex) {
    throw new SolrServerException("error reading streams",ex);
  }
  method.getParams().setParameter(ClientPNames.HANDLE_REDIRECTS,followRedirects);
  method.addHeader("User-Agent",AGENT);
  InputStream respBody=null;
  boolean shouldClose=true;
  try {
    final HttpResponse response=httpClient.execute(method);
    int httpStatus=response.getStatusLine().getStatusCode();
    respBody=response.getEntity().getContent();
    Header ctHeader=response.getLastHeader("content-type");
    String contentType;
    if (ctHeader != null) {
      contentType=ctHeader.getValue();
    }
 else {
      contentType="";
    }
switch (httpStatus) {
case HttpStatus.SC_OK:
case HttpStatus.SC_BAD_REQUEST:
case HttpStatus.SC_CONFLICT:
      break;
case HttpStatus.SC_MOVED_PERMANENTLY:
case HttpStatus.SC_MOVED_TEMPORARILY:
    if (!followRedirects) {
      throw new SolrServerException("Server at " + getBaseURL() + " sent back a redirect ("+ httpStatus+ ").");
    }
  break;
default :
if (processor == null) {
  throw new RemoteSolrException(httpStatus,"Server at " + getBaseURL() + " returned non ok status:"+ httpStatus+ ", message:"+ response.getStatusLine().getReasonPhrase(),null);
}
}
if (processor == null) {
NamedList<Object> rsp=new NamedList<Object>();
rsp.add("stream",respBody);
shouldClose=false;
return rsp;
}
String procCt=processor.getContentType();
if (procCt != null) {
if (!contentType.equals(procCt)) {
String msg="Expected content type " + procCt + " but got "+ contentType+ ".";
Header encodingHeader=response.getEntity().getContentEncoding();
String encoding;
if (encodingHeader != null) {
  encoding=encodingHeader.getValue();
}
 else {
  encoding="UTF-8";
}
try {
  msg=msg + " " + IOUtils.toString(respBody,encoding);
}
 catch (IOException e) {
  new RemoteSolrException(httpStatus,"Could not parse response with encoding " + encoding,e);
}
RemoteSolrException e=new RemoteSolrException(httpStatus,msg,null);
throw e;
}
}
NamedList<Object> rsp=null;
String charset=EntityUtils.getContentCharSet(response.getEntity());
try {
rsp=processor.processResponse(respBody,charset);
}
 catch (Exception e) {
throw new RemoteSolrException(httpStatus,e.getMessage(),e);
}
if (httpStatus != HttpStatus.SC_OK) {
String reason=null;
try {
NamedList err=(NamedList)rsp.get("error");
if (err != null) {
  reason=(String)err.get("msg");
}
}
 catch (Exception ex) {
}
if (reason == null) {
StringBuilder msg=new StringBuilder();
msg.append(response.getStatusLine().getReasonPhrase());
msg.append("\n\n");
msg.append("request: " + method.getURI());
reason=java.net.URLDecoder.decode(msg.toString(),UTF_8);
}
throw new RemoteSolrException(httpStatus,reason,null);
}
return rsp;
}
 catch (ConnectException e) {
throw new SolrServerException("Server refused connection at: " + getBaseURL(),e);
}
catch (SocketTimeoutException e) {
throw new SolrServerException("Timeout occured while waiting response from server at: " + getBaseURL(),e);
}
catch (IOException e) {
throw new SolrServerException("IOException occured when talking to server at: " + getBaseURL(),e);
}
 finally {
if (respBody != null && shouldClose) {
try {
respBody.close();
}
 catch (Throwable t) {
}
}
}
}
