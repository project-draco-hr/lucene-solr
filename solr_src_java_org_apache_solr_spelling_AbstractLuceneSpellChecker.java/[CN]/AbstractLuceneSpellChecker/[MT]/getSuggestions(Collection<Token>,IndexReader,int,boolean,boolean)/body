{
  SpellingResult result=new SpellingResult(tokens);
  reader=determineReader(reader);
  Term term=field != null ? new Term(field,"") : null;
  for (  Token token : tokens) {
    String tokenText=new String(token.buffer(),0,token.length());
    String[] suggestions=spellChecker.suggestSimilar(tokenText,(int)Math.max(count,AbstractLuceneSpellChecker.DEFAULT_SUGGESTION_COUNT),field != null ? reader : null,field,onlyMorePopular);
    if (suggestions.length == 1 && suggestions[0].equals(tokenText)) {
      continue;
    }
    if (extendedResults == true && reader != null && field != null) {
      term=term.createTerm(tokenText);
      result.add(token,reader.docFreq(term));
      int countLimit=Math.min(count,suggestions.length);
      for (int i=0; i < countLimit; i++) {
        term=term.createTerm(suggestions[i]);
        result.add(token,suggestions[i],reader.docFreq(term));
      }
    }
 else {
      if (suggestions.length > 0) {
        List<String> suggList=Arrays.asList(suggestions);
        if (suggestions.length > count) {
          suggList=suggList.subList(0,count);
        }
        result.add(token,suggList);
      }
    }
  }
  return result;
}
