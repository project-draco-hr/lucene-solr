{
  tvf.seek(tvfPointer);
  int numTerms=tvf.readVInt();
  if (numTerms == 0)   return;
  boolean storePositions;
  boolean storeOffsets;
  if (tvfFormat == FORMAT_VERSION) {
    byte bits=tvf.readByte();
    storePositions=(bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;
    storeOffsets=(bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;
  }
 else {
    tvf.readVInt();
    storePositions=false;
    storeOffsets=false;
  }
  mapper.setExpectations(field,numTerms,storeOffsets,storePositions);
  int start=0;
  int deltaLength=0;
  int totalLength=0;
  char[] buffer=new char[10];
  char[] previousBuffer={};
  for (int i=0; i < numTerms; i++) {
    start=tvf.readVInt();
    deltaLength=tvf.readVInt();
    totalLength=start + deltaLength;
    if (buffer.length < totalLength) {
      buffer=null;
      buffer=new char[totalLength];
      if (start > 0)       System.arraycopy(previousBuffer,0,buffer,0,start);
    }
    tvf.readChars(buffer,start,deltaLength);
    String term=new String(buffer,0,totalLength);
    previousBuffer=buffer;
    int freq=tvf.readVInt();
    int[] positions=null;
    if (storePositions) {
      if (mapper.isIgnoringPositions() == false) {
        positions=new int[freq];
        int prevPosition=0;
        for (int j=0; j < freq; j++) {
          positions[j]=prevPosition + tvf.readVInt();
          prevPosition=positions[j];
        }
      }
 else {
        for (int j=0; j < freq; j++) {
          tvf.readVInt();
        }
      }
    }
    TermVectorOffsetInfo[] offsets=null;
    if (storeOffsets) {
      if (mapper.isIgnoringOffsets() == false) {
        offsets=new TermVectorOffsetInfo[freq];
        int prevOffset=0;
        for (int j=0; j < freq; j++) {
          int startOffset=prevOffset + tvf.readVInt();
          int endOffset=startOffset + tvf.readVInt();
          offsets[j]=new TermVectorOffsetInfo(startOffset,endOffset);
          prevOffset=endOffset;
        }
      }
 else {
        for (int j=0; j < freq; j++) {
          tvf.readVInt();
          tvf.readVInt();
        }
      }
    }
    mapper.map(term,freq,offsets,positions);
  }
}
