{
  CompletionService<SegFacet> completionService=new ExecutorCompletionService<>(executor);
  baseSet=docs.getTopFilter();
  final List<LeafReaderContext> leaves=searcher.getTopReaderContext().leaves();
  LinkedList<Callable<SegFacet>> pending=new LinkedList<>();
  int threads=nThreads <= 0 ? Integer.MAX_VALUE : nThreads;
  for (  final LeafReaderContext leave : leaves) {
    final SegFacet segFacet=new SegFacet(leave);
    Callable<SegFacet> task=new Callable<SegFacet>(){
      @Override public SegFacet call() throws Exception {
        segFacet.countTerms();
        return segFacet;
      }
    }
;
    if (--threads >= 0) {
      completionService.submit(task);
    }
 else {
      pending.add(task);
    }
  }
  PriorityQueue<SegFacet> queue=new PriorityQueue<SegFacet>(leaves.size()){
    @Override protected boolean lessThan(    SegFacet a,    SegFacet b){
      return a.tempBR.compareTo(b.tempBR) < 0;
    }
  }
;
  boolean hasMissingCount=false;
  int missingCount=0;
  for (int i=0, c=leaves.size(); i < c; i++) {
    SegFacet seg=null;
    try {
      Future<SegFacet> future=completionService.take();
      seg=future.get();
      if (!pending.isEmpty()) {
        completionService.submit(pending.removeFirst());
      }
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,e);
    }
catch (    ExecutionException e) {
      Throwable cause=e.getCause();
      if (cause instanceof RuntimeException) {
        throw (RuntimeException)cause;
      }
 else {
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Error in per-segment faceting on field: " + fieldName,cause);
      }
    }
    if (seg.startTermIndex < seg.endTermIndex) {
      if (seg.startTermIndex == -1) {
        hasMissingCount=true;
        missingCount+=seg.counts[0];
        seg.pos=0;
      }
 else {
        seg.pos=seg.startTermIndex;
      }
      if (seg.pos < seg.endTermIndex) {
        seg.tenum=seg.si.termsEnum();
        seg.tenum.seekExact(seg.pos);
        seg.tempBR=seg.tenum.term();
        queue.add(seg);
      }
    }
  }
  FacetCollector collector;
  if (sort.equals(FacetParams.FACET_SORT_COUNT) || sort.equals(FacetParams.FACET_SORT_COUNT_LEGACY)) {
    collector=new CountSortedFacetCollector(offset,limit,mincount);
  }
 else {
    collector=new IndexSortedFacetCollector(offset,limit,mincount);
  }
  BytesRefBuilder val=new BytesRefBuilder();
  while (queue.size() > 0) {
    SegFacet seg=queue.top();
    boolean collect=containsBR == null || StringHelper.contains(seg.tempBR,containsBR,ignoreCase);
    if (collect) {
      val.copyBytes(seg.tempBR);
    }
    int count=0;
    do {
      if (collect) {
        count+=seg.counts[seg.pos - seg.startTermIndex];
      }
      seg.pos++;
      if (seg.pos >= seg.endTermIndex) {
        queue.pop();
        seg=queue.top();
      }
 else {
        seg.tempBR=seg.tenum.next();
        seg=queue.updateTop();
      }
    }
 while (seg != null && val.get().compareTo(seg.tempBR) == 0);
    if (collect) {
      boolean stop=collector.collect(val.get(),count);
      if (stop)       break;
    }
  }
  NamedList<Integer> res=collector.getFacetCounts();
  FieldType ft=searcher.getSchema().getFieldType(fieldName);
  int sz=res.size();
  for (int i=0; i < sz; i++) {
    res.setName(i,ft.indexedToReadable(res.getName(i)));
  }
  if (missing) {
    if (!hasMissingCount) {
      missingCount=SimpleFacets.getFieldMissingCount(searcher,docs,fieldName);
    }
    res.add(null,missingCount);
  }
  return res;
}
