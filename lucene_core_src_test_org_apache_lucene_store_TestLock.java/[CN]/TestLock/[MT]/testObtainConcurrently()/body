{
  final Directory directory;
  if (random().nextBoolean()) {
    directory=newDirectory();
  }
 else {
    LockFactory lf=random().nextBoolean() ? SimpleFSLockFactory.INSTANCE : NativeFSLockFactory.INSTANCE;
    directory=newFSDirectory(createTempDir(),lf);
  }
  final AtomicBoolean running=new AtomicBoolean(true);
  final AtomicInteger atomicCounter=new AtomicInteger(0);
  final ReentrantLock assertingLock=new ReentrantLock();
  int numThreads=2 + random().nextInt(10);
  final int runs=500 + random().nextInt(1000);
  CyclicBarrier barrier=new CyclicBarrier(numThreads);
  Thread[] threads=new Thread[numThreads];
  for (int i=0; i < threads.length; i++) {
    threads[i]=new Thread(){
      @Override public void run(){
        try {
          barrier.await();
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        while (running.get()) {
          try (Lock lock=directory.makeLock("foo.lock")){
            if (lock.isLocked() == false && lock.obtain()) {
              assertTrue(lock.isLocked());
              assertFalse(assertingLock.isLocked());
              if (assertingLock.tryLock()) {
                assertingLock.unlock();
              }
 else {
                fail();
              }
            }
          }
 catch (          IOException ex) {
          }
          if (atomicCounter.incrementAndGet() > runs) {
            running.set(false);
          }
        }
      }
    }
;
    threads[i].start();
  }
  for (int i=0; i < threads.length; i++) {
    threads[i].join();
  }
  directory.close();
}
