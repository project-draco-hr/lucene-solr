{
  final int maxQueueSize=offset + topN;
  for (int shardIDX=0; shardIDX < shards.size(); shardIDX++) {
    final Collection<SearchGroup<T>> shard=shards.get(shardIDX);
    if (!shard.isEmpty()) {
      updateNextGroup(maxQueueSize,new ShardIter<>(shard,shardIDX));
    }
  }
  final List<SearchGroup<T>> newTopGroups=new ArrayList<>(topN);
  int count=0;
  while (!queue.isEmpty()) {
    final MergedGroup<T> group=queue.pollFirst();
    group.processed=true;
    if (count++ >= offset) {
      final SearchGroup<T> newGroup=new SearchGroup<>();
      newGroup.groupValue=group.groupValue;
      newGroup.sortValues=group.topValues;
      newTopGroups.add(newGroup);
      if (newTopGroups.size() == topN) {
        break;
      }
    }
    for (    ShardIter<T> shardIter : group.shards) {
      updateNextGroup(maxQueueSize,shardIter);
    }
  }
  if (newTopGroups.isEmpty()) {
    return null;
  }
 else {
    return newTopGroups;
  }
}
