{
  final String fileName=IndexFileNames.segmentFileName(segment,"",Lucene46SegmentInfoFormat.SI_EXTENSION);
  try (ChecksumIndexInput input=dir.openChecksumInput(fileName,context)){
    int codecVersion=CodecUtil.checkHeader(input,Lucene46SegmentInfoFormat.CODEC_NAME,Lucene46SegmentInfoFormat.VERSION_START,Lucene46SegmentInfoFormat.VERSION_CURRENT);
    final Version version;
    try {
      version=Version.parse(input.readString());
    }
 catch (    ParseException pe) {
      throw new CorruptIndexException("unable to parse version string: " + pe.getMessage(),input,pe);
    }
    final int docCount=input.readInt();
    if (docCount < 0) {
      throw new CorruptIndexException("invalid docCount: " + docCount,input);
    }
    final boolean isCompoundFile=input.readByte() == SegmentInfo.YES;
    final Map<String,String> diagnostics=input.readStringStringMap();
    final Set<String> files=input.readStringSet();
    String id;
    if (codecVersion >= Lucene46SegmentInfoFormat.VERSION_ID) {
      id=input.readString();
    }
 else {
      id=null;
    }
    if (codecVersion >= Lucene46SegmentInfoFormat.VERSION_CHECKSUM) {
      CodecUtil.checkFooter(input);
    }
 else {
      CodecUtil.checkEOF(input);
    }
    final SegmentInfo si=new SegmentInfo(dir,version,segment,docCount,isCompoundFile,null,diagnostics,id);
    si.setFiles(files);
    return si;
  }
 }
