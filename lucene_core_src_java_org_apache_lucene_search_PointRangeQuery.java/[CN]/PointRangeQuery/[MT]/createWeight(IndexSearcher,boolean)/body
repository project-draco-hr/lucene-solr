{
  return new ConstantScoreWeight(this){
    @Override public Scorer scorer(    LeafReaderContext context) throws IOException {
      LeafReader reader=context.reader();
      PointValues values=reader.getPointValues();
      if (values == null) {
        return null;
      }
      FieldInfo fieldInfo=reader.getFieldInfos().fieldInfo(field);
      if (fieldInfo == null) {
        return null;
      }
      if (fieldInfo.getPointDimensionCount() != numDims) {
        throw new IllegalArgumentException("field=\"" + field + "\" was indexed with numDims="+ fieldInfo.getPointDimensionCount()+ " but this query has numDims="+ numDims);
      }
      if (bytesPerDim != fieldInfo.getPointNumBytes()) {
        throw new IllegalArgumentException("field=\"" + field + "\" was indexed with bytesPerDim="+ fieldInfo.getPointNumBytes()+ " but this query has bytesPerDim="+ bytesPerDim);
      }
      int bytesPerDim=fieldInfo.getPointNumBytes();
      byte[] packedLower=new byte[numDims * bytesPerDim];
      byte[] packedUpper=new byte[numDims * bytesPerDim];
      for (int dim=0; dim < numDims; dim++) {
        System.arraycopy(lowerPoint[dim],0,packedLower,dim * bytesPerDim,bytesPerDim);
        System.arraycopy(upperPoint[dim],0,packedUpper,dim * bytesPerDim,bytesPerDim);
      }
      DocIdSetBuilder result=new DocIdSetBuilder(reader.maxDoc());
      values.intersect(field,new IntersectVisitor(){
        @Override public void grow(        int count){
          result.grow(count);
        }
        @Override public void visit(        int docID){
          result.add(docID);
        }
        @Override public void visit(        int docID,        byte[] packedValue){
          for (int dim=0; dim < numDims; dim++) {
            int offset=dim * bytesPerDim;
            if (StringHelper.compare(bytesPerDim,packedValue,offset,packedLower,offset) < 0) {
              return;
            }
            if (StringHelper.compare(bytesPerDim,packedValue,offset,packedUpper,offset) > 0) {
              return;
            }
          }
          result.add(docID);
        }
        @Override public Relation compare(        byte[] minPackedValue,        byte[] maxPackedValue){
          boolean crosses=false;
          for (int dim=0; dim < numDims; dim++) {
            int offset=dim * bytesPerDim;
            if (StringHelper.compare(bytesPerDim,minPackedValue,offset,packedUpper,offset) > 0 || StringHelper.compare(bytesPerDim,maxPackedValue,offset,packedLower,offset) < 0) {
              return Relation.CELL_OUTSIDE_QUERY;
            }
            crosses|=StringHelper.compare(bytesPerDim,minPackedValue,offset,packedLower,offset) < 0 || StringHelper.compare(bytesPerDim,maxPackedValue,offset,packedUpper,offset) > 0;
          }
          if (crosses) {
            return Relation.CELL_CROSSES_QUERY;
          }
 else {
            return Relation.CELL_INSIDE_QUERY;
          }
        }
      }
);
      return new ConstantScoreScorer(this,score(),result.build().iterator());
    }
  }
;
}
