{
  return new ConstantScoreWeight(this){
    private DocIdSet buildMatchingDocIdSet(    LeafReader reader,    PointValues values) throws IOException {
      DocIdSetBuilder result=new DocIdSetBuilder(reader.maxDoc());
      values.intersect(field,new IntersectVisitor(){
        @Override public void grow(        int count){
          result.grow(count);
        }
        @Override public void visit(        int docID){
          result.add(docID);
        }
        @Override public void visit(        int docID,        byte[] packedValue){
          for (int dim=0; dim < numDims; dim++) {
            int offset=dim * bytesPerDim;
            if (StringHelper.compare(bytesPerDim,packedValue,offset,lowerPoint,offset) < 0) {
              return;
            }
            if (StringHelper.compare(bytesPerDim,packedValue,offset,upperPoint,offset) > 0) {
              return;
            }
          }
          result.add(docID);
        }
        @Override public Relation compare(        byte[] minPackedValue,        byte[] maxPackedValue){
          boolean crosses=false;
          for (int dim=0; dim < numDims; dim++) {
            int offset=dim * bytesPerDim;
            if (StringHelper.compare(bytesPerDim,minPackedValue,offset,upperPoint,offset) > 0 || StringHelper.compare(bytesPerDim,maxPackedValue,offset,lowerPoint,offset) < 0) {
              return Relation.CELL_OUTSIDE_QUERY;
            }
            crosses|=StringHelper.compare(bytesPerDim,minPackedValue,offset,lowerPoint,offset) < 0 || StringHelper.compare(bytesPerDim,maxPackedValue,offset,upperPoint,offset) > 0;
          }
          if (crosses) {
            return Relation.CELL_CROSSES_QUERY;
          }
 else {
            return Relation.CELL_INSIDE_QUERY;
          }
        }
      }
);
      return result.build();
    }
    @Override public Scorer scorer(    LeafReaderContext context) throws IOException {
      LeafReader reader=context.reader();
      PointValues values=reader.getPointValues();
      if (values == null) {
        return null;
      }
      FieldInfo fieldInfo=reader.getFieldInfos().fieldInfo(field);
      if (fieldInfo == null) {
        return null;
      }
      if (fieldInfo.getPointDimensionCount() != numDims) {
        throw new IllegalArgumentException("field=\"" + field + "\" was indexed with numDims="+ fieldInfo.getPointDimensionCount()+ " but this query has numDims="+ numDims);
      }
      if (bytesPerDim != fieldInfo.getPointNumBytes()) {
        throw new IllegalArgumentException("field=\"" + field + "\" was indexed with bytesPerDim="+ fieldInfo.getPointNumBytes()+ " but this query has bytesPerDim="+ bytesPerDim);
      }
      boolean allDocsMatch;
      if (values.getDocCount(field) == reader.maxDoc()) {
        final byte[] fieldPackedLower=values.getMinPackedValue(field);
        final byte[] fieldPackedUpper=values.getMaxPackedValue(field);
        allDocsMatch=true;
        for (int i=0; i < numDims; ++i) {
          int offset=i * bytesPerDim;
          if (StringHelper.compare(bytesPerDim,lowerPoint,offset,fieldPackedLower,offset) > 0 || StringHelper.compare(bytesPerDim,upperPoint,offset,fieldPackedUpper,offset) < 0) {
            allDocsMatch=false;
            break;
          }
        }
      }
 else {
        allDocsMatch=false;
      }
      DocIdSetIterator iterator;
      if (allDocsMatch) {
        iterator=DocIdSetIterator.all(reader.maxDoc());
      }
 else {
        iterator=buildMatchingDocIdSet(reader,values).iterator();
      }
      return new ConstantScoreScorer(this,score(),iterator);
    }
  }
;
}
