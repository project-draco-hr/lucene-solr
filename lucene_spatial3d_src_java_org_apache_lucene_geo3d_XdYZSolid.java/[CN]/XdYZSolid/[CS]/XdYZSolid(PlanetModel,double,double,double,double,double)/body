{
  super(planetModel);
  if (maxX - minX < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("X values in wrong order or identical");
  if (maxZ - minZ < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("Z values in wrong order or identical");
  final double worldMinY=planetModel.getMinimumYValue();
  final double worldMaxY=planetModel.getMaximumYValue();
  minXPlane=new SidedPlane(maxX,0.0,0.0,xUnitVector,-minX);
  maxXPlane=new SidedPlane(minX,0.0,0.0,xUnitVector,-maxX);
  yPlane=new Plane(yUnitVector,-Y);
  minZPlane=new SidedPlane(0.0,0.0,maxZ,zUnitVector,-minZ);
  maxZPlane=new SidedPlane(0.0,0.0,minZ,zUnitVector,-maxZ);
  final GeoPoint[] minXY=minXPlane.findIntersections(planetModel,yPlane,maxXPlane,minZPlane,maxZPlane);
  final GeoPoint[] maxXY=maxXPlane.findIntersections(planetModel,yPlane,minXPlane,minZPlane,maxZPlane);
  final GeoPoint[] YminZ=yPlane.findIntersections(planetModel,minZPlane,maxZPlane,minXPlane,maxXPlane);
  final GeoPoint[] YmaxZ=yPlane.findIntersections(planetModel,maxZPlane,minZPlane,minXPlane,maxXPlane);
  notableYPoints=glueTogether(minXY,maxXY,YminZ,YmaxZ);
  final boolean minXYminZ=planetModel.pointOutside(minX,Y,minZ);
  final boolean minXYmaxZ=planetModel.pointOutside(minX,Y,maxZ);
  final boolean maxXYminZ=planetModel.pointOutside(maxX,Y,minZ);
  final boolean maxXYmaxZ=planetModel.pointOutside(maxX,Y,maxZ);
  final GeoPoint[] yEdges;
  if (Y - worldMinY >= -Vector.MINIMUM_RESOLUTION && Y - worldMaxY <= Vector.MINIMUM_RESOLUTION && minX < 0.0 && maxX > 0.0 && minZ < 0.0 && maxZ > 0.0 && minXYminZ && minXYmaxZ && maxXYminZ && maxXYmaxZ) {
    yEdges=new GeoPoint[]{yPlane.getSampleIntersectionPoint(planetModel,yVerticalPlane)};
  }
 else {
    yEdges=EMPTY_POINTS;
  }
  this.edgePoints=glueTogether(minXY,maxXY,YminZ,YmaxZ,yEdges);
}
