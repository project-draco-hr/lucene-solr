{
  final Map<SegmentCommitInfo,Boolean> oldSegments=new HashMap<>();
  for (  final SegmentCommitInfo si : segmentInfos) {
    final Boolean v=segmentsToMerge.get(si);
    if (v != null && shouldUpgradeSegment(si)) {
      oldSegments.put(si,v);
    }
  }
  if (verbose(writer)) {
    message("findForcedMerges: segmentsToUpgrade=" + oldSegments,writer);
  }
  if (oldSegments.isEmpty())   return null;
  MergeSpecification spec=in.findForcedMerges(segmentInfos,maxSegmentCount,oldSegments,writer);
  if (spec != null) {
    for (    final OneMerge om : spec.merges) {
      oldSegments.keySet().removeAll(om.segments);
    }
  }
  if (!oldSegments.isEmpty()) {
    if (verbose(writer)) {
      message("findForcedMerges: " + in.getClass().getSimpleName() + " does not want to merge all old segments, merge remaining ones into new segment: "+ oldSegments,writer);
    }
    final List<SegmentCommitInfo> newInfos=new ArrayList<>();
    for (    final SegmentCommitInfo si : segmentInfos) {
      if (oldSegments.containsKey(si)) {
        newInfos.add(si);
      }
    }
    if (spec == null) {
      spec=new MergeSpecification();
    }
    spec.add(new OneMerge(newInfos));
  }
  return spec;
}
