{
  TokenStream source=analyzer.tokenStream(field,new StringReader(queryText));
  List<AttributeSource.State> list=new ArrayList<AttributeSource.State>();
  int positionCount=0;
  boolean severalTokensAtSamePosition=false;
  TermAttribute termAtt=source.addAttribute(TermAttribute.class);
  PositionIncrementAttribute posincrAtt=source.addAttribute(PositionIncrementAttribute.class);
  try {
    while (source.incrementToken()) {
      list.add(source.captureState());
      if (posincrAtt.getPositionIncrement() == 1)       positionCount++;
 else       severalTokensAtSamePosition=true;
    }
    source.end();
    source.close();
  }
 catch (  IOException e) {
  }
  if (list.size() == 0)   return null;
 else   if (list.size() == 1) {
    source.restoreState(list.get(0));
    return new TermQuery(new Term(field,termAtt.term()));
  }
 else {
    if (severalTokensAtSamePosition) {
      if (positionCount == 1) {
        BooleanQuery q=new BooleanQuery();
        for (int i=0; i < list.size(); i++) {
          source.restoreState(list.get(i));
          TermQuery currentQuery=new TermQuery(new Term(field,termAtt.term()));
          q.add(currentQuery,BooleanClause.Occur.SHOULD);
        }
        return q;
      }
 else {
        MultiPhraseQuery mpq=new MultiPhraseQuery();
        List<Term> multiTerms=new ArrayList<Term>();
        for (int i=0; i < list.size(); i++) {
          source.restoreState(list.get(i));
          if (posincrAtt.getPositionIncrement() == 1 && multiTerms.size() > 0) {
            mpq.add((Term[])multiTerms.toArray(new Term[0]));
            multiTerms.clear();
          }
          multiTerms.add(new Term(field,termAtt.term()));
        }
        mpq.add((Term[])multiTerms.toArray(new Term[0]));
        return mpq;
      }
    }
 else {
      PhraseQuery q=new PhraseQuery();
      q.setSlop(phraseSlop);
      for (int i=0; i < list.size(); i++) {
        source.restoreState(list.get(i));
        q.add(new Term(field,termAtt.term()));
      }
      return q;
    }
  }
}
