{
synchronized (this) {
    final DocumentsWriterPerThread poll;
    if ((poll=flushQueue.poll()) != null) {
      stallControl.updateStalled(this);
      return poll;
    }
  }
  if (numPending > 0 && !fullFlush) {
    final Iterator<ThreadState> allActiveThreads=perThreadPool.getActivePerThreadsIterator();
    while (allActiveThreads.hasNext() && numPending > 0) {
      ThreadState next=allActiveThreads.next();
      if (next.flushPending) {
        final DocumentsWriterPerThread dwpt=tryCheckoutForFlush(next);
        if (dwpt != null) {
          return dwpt;
        }
      }
    }
  }
  return null;
}
