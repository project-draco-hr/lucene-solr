{
  SolrParams params=rb.req.getParams();
  if (!params.getBool(COMPONENT_NAME,false)) {
    return;
  }
  NamedList<Object> termVectors=new NamedList<>();
  rb.rsp.add(TERM_VECTORS,termVectors);
  IndexSchema schema=rb.req.getSchema();
  SchemaField keyField=schema.getUniqueKeyField();
  String uniqFieldName=null;
  if (keyField != null) {
    uniqFieldName=keyField.getName();
    termVectors.add("uniqueKeyFieldName",uniqFieldName);
  }
  FieldOptions allFields=new FieldOptions();
  allFields.termFreq=params.getBool(TermVectorParams.TF,false);
  allFields.positions=params.getBool(TermVectorParams.POSITIONS,false);
  allFields.offsets=params.getBool(TermVectorParams.OFFSETS,false);
  allFields.payloads=params.getBool(TermVectorParams.PAYLOADS,false);
  allFields.docFreq=params.getBool(TermVectorParams.DF,false);
  allFields.tfIdf=params.getBool(TermVectorParams.TF_IDF,false);
  if (params.getBool(TermVectorParams.ALL,false)) {
    allFields.termFreq=true;
    allFields.positions=true;
    allFields.offsets=true;
    allFields.payloads=true;
    allFields.docFreq=true;
    allFields.tfIdf=true;
  }
  Map<String,FieldOptions> fieldOptions=new HashMap<>();
  NamedList<List<String>> warnings=new NamedList<>();
  List<String> noTV=new ArrayList<>();
  List<String> noPos=new ArrayList<>();
  List<String> noOff=new ArrayList<>();
  List<String> noPay=new ArrayList<>();
  Set<String> fields=getFields(rb);
  if (null != fields) {
    for (    String field : fields) {
      if (null == field || "score".equals(field))       continue;
      final boolean fieldIsUniqueKey=field.equals(uniqFieldName);
      SchemaField sf=schema.getFieldOrNull(field);
      if (sf != null) {
        if (sf.storeTermVector()) {
          FieldOptions option=fieldOptions.get(field);
          if (option == null) {
            option=new FieldOptions();
            option.fieldName=field;
            fieldOptions.put(field,option);
          }
          option.termFreq=params.getFieldBool(field,TermVectorParams.TF,allFields.termFreq);
          option.docFreq=params.getFieldBool(field,TermVectorParams.DF,allFields.docFreq);
          option.tfIdf=params.getFieldBool(field,TermVectorParams.TF_IDF,allFields.tfIdf);
          option.positions=params.getFieldBool(field,TermVectorParams.POSITIONS,allFields.positions);
          if (option.positions && !sf.storeTermPositions() && !fieldIsUniqueKey) {
            noPos.add(field);
          }
          option.offsets=params.getFieldBool(field,TermVectorParams.OFFSETS,allFields.offsets);
          if (option.offsets && !sf.storeTermOffsets() && !fieldIsUniqueKey) {
            noOff.add(field);
          }
          option.payloads=params.getFieldBool(field,TermVectorParams.PAYLOADS,allFields.payloads);
          if (option.payloads && !sf.storeTermPayloads() && !fieldIsUniqueKey) {
            noPay.add(field);
          }
        }
 else {
          if (!fieldIsUniqueKey)           noTV.add(field);
        }
      }
 else {
        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"undefined field: " + field);
      }
    }
  }
  boolean hasWarnings=false;
  if (!noTV.isEmpty()) {
    warnings.add("noTermVectors",noTV);
    hasWarnings=true;
  }
  if (!noPos.isEmpty()) {
    warnings.add("noPositions",noPos);
    hasWarnings=true;
  }
  if (!noOff.isEmpty()) {
    warnings.add("noOffsets",noOff);
    hasWarnings=true;
  }
  if (!noPay.isEmpty()) {
    warnings.add("noPayloads",noPay);
    hasWarnings=true;
  }
  if (hasWarnings) {
    termVectors.add("warnings",warnings);
  }
  DocListAndSet listAndSet=rb.getResults();
  List<Integer> docIds=getInts(params.getParams(TermVectorParams.DOC_IDS));
  Iterator<Integer> iter;
  if (docIds != null && !docIds.isEmpty()) {
    iter=docIds.iterator();
  }
 else {
    DocList list=listAndSet.docList;
    iter=list.iterator();
  }
  SolrIndexSearcher searcher=rb.req.getSearcher();
  IndexReader reader=searcher.getIndexReader();
  final String finalUniqFieldName=uniqFieldName;
  final List<String> uniqValues=new ArrayList<>();
  final StoredFieldVisitor getUniqValue=new StoredFieldVisitor(){
    @Override public void stringField(    FieldInfo fieldInfo,    byte[] bytes){
      uniqValues.add(new String(bytes,StandardCharsets.UTF_8));
    }
    @Override public void intField(    FieldInfo fieldInfo,    int value){
      uniqValues.add(Integer.toString(value));
    }
    @Override public void longField(    FieldInfo fieldInfo,    long value){
      uniqValues.add(Long.toString(value));
    }
    @Override public Status needsField(    FieldInfo fieldInfo){
      return (fieldInfo.name.equals(finalUniqFieldName)) ? Status.YES : Status.NO;
    }
  }
;
  while (iter.hasNext()) {
    Integer docId=iter.next();
    NamedList<Object> docNL=new NamedList<>();
    if (keyField != null) {
      reader.document(docId,getUniqValue);
      String uniqVal=null;
      if (uniqValues.size() != 0) {
        uniqVal=uniqValues.get(0);
        uniqValues.clear();
        docNL.add("uniqueKey",uniqVal);
        termVectors.add(uniqVal,docNL);
      }
    }
 else {
      termVectors.add("doc-" + docId,docNL);
    }
    if (null != fields) {
      for (      Map.Entry<String,FieldOptions> entry : fieldOptions.entrySet()) {
        final String field=entry.getKey();
        final Terms vector=reader.getTermVector(docId,field);
        if (vector != null) {
          TermsEnum termsEnum=vector.iterator();
          mapOneVector(docNL,entry.getValue(),reader,docId,termsEnum,field);
        }
      }
    }
 else {
      final Fields vectors=reader.getTermVectors(docId);
      for (      String field : vectors) {
        Terms terms=vectors.terms(field);
        if (terms != null) {
          TermsEnum termsEnum=terms.iterator();
          mapOneVector(docNL,allFields,reader,docId,termsEnum,field);
        }
      }
    }
  }
}
