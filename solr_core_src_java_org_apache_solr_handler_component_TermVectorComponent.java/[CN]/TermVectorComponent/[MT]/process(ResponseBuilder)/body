{
  SolrParams params=rb.req.getParams();
  if (!params.getBool(COMPONENT_NAME,false)) {
    return;
  }
  NamedList<Object> termVectors=new NamedList<Object>();
  rb.rsp.add(TERM_VECTORS,termVectors);
  FieldOptions allFields=new FieldOptions();
  allFields.termFreq=params.getBool(TermVectorParams.TF,false);
  allFields.positions=params.getBool(TermVectorParams.POSITIONS,false);
  allFields.offsets=params.getBool(TermVectorParams.OFFSETS,false);
  allFields.docFreq=params.getBool(TermVectorParams.DF,false);
  allFields.tfIdf=params.getBool(TermVectorParams.TF_IDF,false);
  if (params.getBool(TermVectorParams.ALL,false)) {
    allFields.termFreq=true;
    allFields.positions=true;
    allFields.offsets=true;
    allFields.docFreq=true;
    allFields.tfIdf=true;
  }
  IndexSchema schema=rb.req.getSchema();
  Map<String,FieldOptions> fieldOptions=new HashMap<String,FieldOptions>();
  NamedList<List<String>> warnings=new NamedList<List<String>>();
  List<String> noTV=new ArrayList<String>();
  List<String> noPos=new ArrayList<String>();
  List<String> noOff=new ArrayList<String>();
  Set<String> fields=getFields(rb);
  if (null != fields) {
    for (    String field : fields) {
      if (null == field || "score".equals(field))       continue;
      SchemaField sf=schema.getFieldOrNull(field);
      if (sf != null) {
        if (sf.storeTermVector()) {
          FieldOptions option=fieldOptions.get(field);
          if (option == null) {
            option=new FieldOptions();
            option.fieldName=field;
            fieldOptions.put(field,option);
          }
          option.termFreq=params.getFieldBool(field,TermVectorParams.TF,allFields.termFreq);
          option.docFreq=params.getFieldBool(field,TermVectorParams.DF,allFields.docFreq);
          option.tfIdf=params.getFieldBool(field,TermVectorParams.TF_IDF,allFields.tfIdf);
          option.positions=params.getFieldBool(field,TermVectorParams.POSITIONS,allFields.positions);
          if (option.positions && !sf.storeTermPositions()) {
            noPos.add(field);
          }
          option.offsets=params.getFieldBool(field,TermVectorParams.OFFSETS,allFields.offsets);
          if (option.offsets && !sf.storeTermOffsets()) {
            noOff.add(field);
          }
        }
 else {
          noTV.add(field);
        }
      }
 else {
        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"undefined field: " + field);
      }
    }
  }
  boolean hasWarnings=false;
  if (!noTV.isEmpty()) {
    warnings.add("noTermVectors",noTV);
    hasWarnings=true;
  }
  if (!noPos.isEmpty()) {
    warnings.add("noPositions",noPos);
    hasWarnings=true;
  }
  if (!noOff.isEmpty()) {
    warnings.add("noOffsets",noOff);
    hasWarnings=true;
  }
  if (hasWarnings) {
    termVectors.add("warnings",warnings);
  }
  DocListAndSet listAndSet=rb.getResults();
  List<Integer> docIds=getInts(params.getParams(TermVectorParams.DOC_IDS));
  Iterator<Integer> iter;
  if (docIds != null && !docIds.isEmpty()) {
    iter=docIds.iterator();
  }
 else {
    DocList list=listAndSet.docList;
    iter=list.iterator();
  }
  SolrIndexSearcher searcher=rb.req.getSearcher();
  IndexReader reader=searcher.getIndexReader();
  SchemaField keyField=schema.getUniqueKeyField();
  String uniqFieldName=null;
  if (keyField != null) {
    uniqFieldName=keyField.getName();
  }
  final String finalUniqFieldName=uniqFieldName;
  final List<String> uniqValues=new ArrayList<String>();
  final StoredFieldVisitor getUniqValue=new StoredFieldVisitor(){
    @Override public void stringField(    FieldInfo fieldInfo,    String value){
      uniqValues.add(value);
    }
    @Override public void intField(    FieldInfo fieldInfo,    int value){
      uniqValues.add(Integer.toString(value));
    }
    @Override public void longField(    FieldInfo fieldInfo,    long value){
      uniqValues.add(Long.toString(value));
    }
    @Override public Status needsField(    FieldInfo fieldInfo){
      return (fieldInfo.name.equals(finalUniqFieldName)) ? Status.YES : Status.NO;
    }
  }
;
  TermsEnum termsEnum=null;
  while (iter.hasNext()) {
    Integer docId=iter.next();
    NamedList<Object> docNL=new NamedList<Object>();
    termVectors.add("doc-" + docId,docNL);
    if (keyField != null) {
      reader.document(docId,getUniqValue);
      String uniqVal=null;
      if (uniqValues.size() != 0) {
        uniqVal=uniqValues.get(0);
        uniqValues.clear();
        docNL.add("uniqueKey",uniqVal);
        termVectors.add("uniqueKeyFieldName",uniqFieldName);
      }
    }
    if (null != fields) {
      for (      Map.Entry<String,FieldOptions> entry : fieldOptions.entrySet()) {
        final String field=entry.getKey();
        final Terms vector=reader.getTermVector(docId,field);
        if (vector != null) {
          termsEnum=vector.iterator(termsEnum);
          mapOneVector(docNL,entry.getValue(),reader,docId,vector.iterator(termsEnum),field);
        }
      }
    }
 else {
      final Fields vectors=reader.getTermVectors(docId);
      final FieldsEnum fieldsEnum=vectors.iterator();
      String field;
      while ((field=fieldsEnum.next()) != null) {
        Terms terms=fieldsEnum.terms();
        if (terms != null) {
          termsEnum=terms.iterator(termsEnum);
          mapOneVector(docNL,allFields,reader,docId,termsEnum,field);
        }
      }
    }
  }
}
