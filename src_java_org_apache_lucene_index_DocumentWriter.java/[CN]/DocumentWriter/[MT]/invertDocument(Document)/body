{
  Iterator fieldIterator=doc.getFields().iterator();
  while (fieldIterator.hasNext()) {
    Fieldable field=(Fieldable)fieldIterator.next();
    String fieldName=field.name();
    int fieldNumber=fieldInfos.fieldNumber(fieldName);
    int length=fieldLengths[fieldNumber];
    int position=fieldPositions[fieldNumber];
    if (length > 0)     position+=analyzer.getPositionIncrementGap(fieldName);
    int offset=fieldOffsets[fieldNumber];
    if (field.isIndexed()) {
      if (!field.isTokenized()) {
        String stringValue=field.stringValue();
        if (field.isStoreOffsetWithTermVector())         addPosition(fieldName,stringValue,position++,null,new TermVectorOffsetInfo(offset,offset + stringValue.length()));
 else         addPosition(fieldName,stringValue,position++,null,null);
        offset+=stringValue.length();
        length++;
      }
 else {
        Reader reader;
        if (field.readerValue() != null)         reader=field.readerValue();
 else         if (field.stringValue() != null)         reader=new StringReader(field.stringValue());
 else         throw new IllegalArgumentException("field must have either String or Reader value");
        TokenStream stream=analyzer.tokenStream(fieldName,reader);
        try {
          Token lastToken=null;
          for (Token t=stream.next(); t != null; t=stream.next()) {
            position+=(t.getPositionIncrement() - 1);
            Payload payload=t.getPayload();
            if (payload != null) {
              fieldStoresPayloads.set(fieldNumber);
            }
            TermVectorOffsetInfo termVectorOffsetInfo;
            if (field.isStoreOffsetWithTermVector()) {
              termVectorOffsetInfo=new TermVectorOffsetInfo(offset + t.startOffset(),offset + t.endOffset());
            }
 else {
              termVectorOffsetInfo=null;
            }
            addPosition(fieldName,t.termText(),position++,payload,termVectorOffsetInfo);
            lastToken=t;
            if (++length >= maxFieldLength) {
              if (infoStream != null)               infoStream.println("maxFieldLength " + maxFieldLength + " reached, ignoring following tokens");
              break;
            }
          }
          if (lastToken != null)           offset+=lastToken.endOffset() + 1;
        }
  finally {
          stream.close();
        }
      }
      fieldLengths[fieldNumber]=length;
      fieldPositions[fieldNumber]=position;
      fieldBoosts[fieldNumber]*=field.getBoost();
      fieldOffsets[fieldNumber]=offset;
    }
  }
  for (int i=fieldStoresPayloads.nextSetBit(0); i >= 0; i=fieldStoresPayloads.nextSetBit(i + 1)) {
    fieldInfos.fieldInfo(i).storePayloads=true;
  }
}
