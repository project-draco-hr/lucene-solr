{
  if (VERBOSE) {
    System.out.println("  verifyEnum: options=" + options + " maxTestOptions="+ maxTestOptions);
  }
  assertEquals(term,termsEnum.term());
  boolean useLiveDocs=options.contains(Option.LIVE_DOCS) && random().nextBoolean();
  Bits liveDocs;
  if (useLiveDocs) {
    liveDocs=globalLiveDocs;
    if (VERBOSE) {
      System.out.println("  use liveDocs");
    }
  }
 else {
    liveDocs=null;
    if (VERBOSE) {
      System.out.println("  no liveDocs");
    }
  }
  FieldInfo fieldInfo=currentFieldInfos.fieldInfo(field);
  SeedPostings expected=getSeedPostings(term.utf8ToString(),fields.get(field).get(term).seed,useLiveDocs,maxIndexOptions,true);
  assertEquals(expected.docFreq,termsEnum.docFreq());
  boolean allowFreqs=fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS) >= 0 && maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;
  boolean doCheckFreqs=allowFreqs && (alwaysTestMax || random().nextInt(3) <= 2);
  boolean allowPositions=fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 && maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
  boolean doCheckPositions=allowPositions && (alwaysTestMax || random().nextInt(3) <= 2);
  boolean allowOffsets=fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0 && maxTestOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
  boolean doCheckOffsets=allowOffsets && (alwaysTestMax || random().nextInt(3) <= 2);
  boolean doCheckPayloads=options.contains(Option.PAYLOADS) && allowPositions && fieldInfo.hasPayloads()&& (alwaysTestMax || random().nextInt(3) <= 2);
  DocsEnum prevDocsEnum=null;
  DocsEnum docsEnum;
  DocsAndPositionsEnum docsAndPositionsEnum;
  if (!doCheckPositions) {
    if (allowPositions && random().nextInt(10) == 7) {
      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {
        prevDocsEnum=threadState.reuseDocsAndPositionsEnum;
      }
      int flags=0;
      if (alwaysTestMax || random().nextBoolean()) {
        flags|=DocsAndPositionsEnum.FLAG_OFFSETS;
      }
      if (alwaysTestMax || random().nextBoolean()) {
        flags|=DocsAndPositionsEnum.FLAG_PAYLOADS;
      }
      if (VERBOSE) {
        System.out.println("  get DocsAndPositionsEnum (but we won't check positions) flags=" + flags);
      }
      threadState.reuseDocsAndPositionsEnum=termsEnum.docsAndPositions(liveDocs,(DocsAndPositionsEnum)prevDocsEnum,flags);
      docsEnum=threadState.reuseDocsAndPositionsEnum;
      docsAndPositionsEnum=threadState.reuseDocsAndPositionsEnum;
    }
 else {
      if (VERBOSE) {
        System.out.println("  get DocsEnum");
      }
      if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {
        prevDocsEnum=threadState.reuseDocsEnum;
      }
      threadState.reuseDocsEnum=termsEnum.docs(liveDocs,prevDocsEnum,doCheckFreqs ? DocsEnum.FLAG_FREQS : DocsEnum.FLAG_NONE);
      docsEnum=threadState.reuseDocsEnum;
      docsAndPositionsEnum=null;
    }
  }
 else {
    if (options.contains(Option.REUSE_ENUMS) && random().nextInt(10) < 9) {
      prevDocsEnum=threadState.reuseDocsAndPositionsEnum;
    }
    int flags=0;
    if (alwaysTestMax || doCheckOffsets || random().nextInt(3) == 1) {
      flags|=DocsAndPositionsEnum.FLAG_OFFSETS;
    }
    if (alwaysTestMax || doCheckPayloads || random().nextInt(3) == 1) {
      flags|=DocsAndPositionsEnum.FLAG_PAYLOADS;
    }
    if (VERBOSE) {
      System.out.println("  get DocsAndPositionsEnum flags=" + flags);
    }
    threadState.reuseDocsAndPositionsEnum=termsEnum.docsAndPositions(liveDocs,(DocsAndPositionsEnum)prevDocsEnum,flags);
    docsEnum=threadState.reuseDocsAndPositionsEnum;
    docsAndPositionsEnum=threadState.reuseDocsAndPositionsEnum;
  }
  assertNotNull("null DocsEnum",docsEnum);
  int initialDocID=docsEnum.docID();
  assertEquals("inital docID should be -1" + docsEnum,-1,initialDocID);
  if (VERBOSE) {
    if (prevDocsEnum == null) {
      System.out.println("  got enum=" + docsEnum);
    }
 else     if (prevDocsEnum == docsEnum) {
      System.out.println("  got reuse enum=" + docsEnum);
    }
 else {
      System.out.println("  got enum=" + docsEnum + " (reuse of "+ prevDocsEnum+ " failed)");
    }
  }
  int stopAt;
  if (!alwaysTestMax && options.contains(Option.PARTIAL_DOC_CONSUME) && expected.docFreq > 1 && random().nextInt(10) == 7) {
    stopAt=random().nextInt(expected.docFreq - 1);
    if (VERBOSE) {
      System.out.println("  will not consume all docs (" + stopAt + " vs "+ expected.docFreq+ ")");
    }
  }
 else {
    stopAt=expected.docFreq;
    if (VERBOSE) {
      System.out.println("  consume all docs");
    }
  }
  double skipChance=alwaysTestMax ? 0.5 : random().nextDouble();
  int numSkips=expected.docFreq < 3 ? 1 : TestUtil.nextInt(random(),1,Math.min(20,expected.docFreq / 3));
  int skipInc=expected.docFreq / numSkips;
  int skipDocInc=maxDoc / numSkips;
  boolean doAllSkipping=options.contains(Option.SKIPPING) && random().nextInt(7) == 1;
  double freqAskChance=alwaysTestMax ? 1.0 : random().nextDouble();
  double payloadCheckChance=alwaysTestMax ? 1.0 : random().nextDouble();
  double offsetCheckChance=alwaysTestMax ? 1.0 : random().nextDouble();
  if (VERBOSE) {
    if (options.contains(Option.SKIPPING)) {
      System.out.println("  skipChance=" + skipChance + " numSkips="+ numSkips);
    }
 else {
      System.out.println("  no skipping");
    }
    if (doCheckFreqs) {
      System.out.println("  freqAskChance=" + freqAskChance);
    }
    if (doCheckPayloads) {
      System.out.println("  payloadCheckChance=" + payloadCheckChance);
    }
    if (doCheckOffsets) {
      System.out.println("  offsetCheckChance=" + offsetCheckChance);
    }
  }
  while (expected.upto <= stopAt) {
    if (expected.upto == stopAt) {
      if (stopAt == expected.docFreq) {
        assertEquals("DocsEnum should have ended but didn't",DocsEnum.NO_MORE_DOCS,docsEnum.nextDoc());
        assertEquals("DocsEnum should have ended but didn't",DocsEnum.NO_MORE_DOCS,docsEnum.docID());
      }
      break;
    }
    if (options.contains(Option.SKIPPING) && (doAllSkipping || random().nextDouble() <= skipChance)) {
      int targetDocID=-1;
      if (expected.upto < stopAt && random().nextBoolean()) {
        final int skipCount=TestUtil.nextInt(random(),1,skipInc);
        for (int skip=0; skip < skipCount; skip++) {
          if (expected.nextDoc() == DocsEnum.NO_MORE_DOCS) {
            break;
          }
        }
      }
 else {
        final int skipDocIDs=TestUtil.nextInt(random(),1,skipDocInc);
        if (skipDocIDs > 0) {
          targetDocID=expected.docID() + skipDocIDs;
          expected.advance(targetDocID);
        }
      }
      if (expected.upto >= stopAt) {
        int target=random().nextBoolean() ? maxDoc : DocsEnum.NO_MORE_DOCS;
        if (VERBOSE) {
          System.out.println("  now advance to end (target=" + target + ")");
        }
        assertEquals("DocsEnum should have ended but didn't",DocsEnum.NO_MORE_DOCS,docsEnum.advance(target));
        break;
      }
 else {
        if (VERBOSE) {
          if (targetDocID != -1) {
            System.out.println("  now advance to random target=" + targetDocID + " ("+ expected.upto+ " of "+ stopAt+ ") current="+ docsEnum.docID());
          }
 else {
            System.out.println("  now advance to known-exists target=" + expected.docID() + " ("+ expected.upto+ " of "+ stopAt+ ") current="+ docsEnum.docID());
          }
        }
        int docID=docsEnum.advance(targetDocID != -1 ? targetDocID : expected.docID());
        assertEquals("docID is wrong",expected.docID(),docID);
      }
    }
 else {
      expected.nextDoc();
      if (VERBOSE) {
        System.out.println("  now nextDoc to " + expected.docID() + " ("+ expected.upto+ " of "+ stopAt+ ")");
      }
      int docID=docsEnum.nextDoc();
      assertEquals("docID is wrong",expected.docID(),docID);
      if (docID == DocsEnum.NO_MORE_DOCS) {
        break;
      }
    }
    if (doCheckFreqs && random().nextDouble() <= freqAskChance) {
      if (VERBOSE) {
        System.out.println("    now freq()=" + expected.freq());
      }
      int freq=docsEnum.freq();
      assertEquals("freq is wrong",expected.freq(),freq);
    }
    if (doCheckPositions) {
      int freq=docsEnum.freq();
      int numPosToConsume;
      if (!alwaysTestMax && options.contains(Option.PARTIAL_POS_CONSUME) && random().nextInt(5) == 1) {
        numPosToConsume=random().nextInt(freq);
      }
 else {
        numPosToConsume=freq;
      }
      for (int i=0; i < numPosToConsume; i++) {
        int pos=expected.nextPosition();
        if (VERBOSE) {
          System.out.println("    now nextPosition to " + pos);
        }
        assertEquals("position is wrong",pos,docsAndPositionsEnum.nextPosition());
        if (doCheckPayloads) {
          BytesRef expectedPayload=expected.getPayload();
          if (random().nextDouble() <= payloadCheckChance) {
            if (VERBOSE) {
              System.out.println("      now check expectedPayload length=" + (expectedPayload == null ? 0 : expectedPayload.length));
            }
            if (expectedPayload == null || expectedPayload.length == 0) {
              assertNull("should not have payload",docsAndPositionsEnum.getPayload());
            }
 else {
              BytesRef payload=docsAndPositionsEnum.getPayload();
              assertNotNull("should have payload but doesn't",payload);
              assertEquals("payload length is wrong",expectedPayload.length,payload.length);
              for (int byteUpto=0; byteUpto < expectedPayload.length; byteUpto++) {
                assertEquals("payload bytes are wrong",expectedPayload.bytes[expectedPayload.offset + byteUpto],payload.bytes[payload.offset + byteUpto]);
              }
              payload=BytesRef.deepCopyOf(payload);
              assertEquals("2nd call to getPayload returns something different!",payload,docsAndPositionsEnum.getPayload());
            }
          }
 else {
            if (VERBOSE) {
              System.out.println("      skip check payload length=" + (expectedPayload == null ? 0 : expectedPayload.length));
            }
          }
        }
        if (doCheckOffsets) {
          if (random().nextDouble() <= offsetCheckChance) {
            if (VERBOSE) {
              System.out.println("      now check offsets: startOff=" + expected.startOffset() + " endOffset="+ expected.endOffset());
            }
            assertEquals("startOffset is wrong",expected.startOffset(),docsAndPositionsEnum.startOffset());
            assertEquals("endOffset is wrong",expected.endOffset(),docsAndPositionsEnum.endOffset());
          }
 else {
            if (VERBOSE) {
              System.out.println("      skip check offsets");
            }
          }
        }
 else         if (fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) < 0) {
          if (VERBOSE) {
            System.out.println("      now check offsets are -1");
          }
          assertEquals("startOffset isn't -1",-1,docsAndPositionsEnum.startOffset());
          assertEquals("endOffset isn't -1",-1,docsAndPositionsEnum.endOffset());
        }
      }
    }
  }
}
