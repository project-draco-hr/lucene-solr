{
  Codec codec=getCodec();
  SegmentInfo segmentInfo=new SegmentInfo(dir,Version.LATEST,"_0",maxDoc,false,codec,null,StringHelper.randomId());
  int maxIndexOption=Arrays.asList(IndexOptions.values()).indexOf(maxAllowed);
  if (VERBOSE) {
    System.out.println("\nTEST: now build index");
  }
  FieldInfo[] newFieldInfoArray=new FieldInfo[fields.size()];
  for (int fieldUpto=0; fieldUpto < fields.size(); fieldUpto++) {
    FieldInfo oldFieldInfo=fieldInfos.fieldInfo(fieldUpto);
    IndexOptions indexOptions=IndexOptions.values()[alwaysTestMax ? maxIndexOption : random().nextInt(1 + maxIndexOption)];
    boolean doPayloads=indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 && allowPayloads;
    newFieldInfoArray[fieldUpto]=new FieldInfo(oldFieldInfo.name,fieldUpto,false,false,doPayloads,indexOptions,null,-1,null);
  }
  FieldInfos newFieldInfos=new FieldInfos(newFieldInfoArray);
  long bytes=totalPostings * 8 + totalPayloadBytes;
  SegmentWriteState writeState=new SegmentWriteState(null,dir,segmentInfo,newFieldInfos,null,new IOContext(new FlushInfo(maxDoc,bytes)));
  Fields seedFields=new SeedFields(fields,newFieldInfos,maxAllowed,allowPayloads);
  FieldsConsumer consumer=codec.postingsFormat().fieldsConsumer(writeState);
  boolean success=false;
  try {
    consumer.write(seedFields);
    success=true;
  }
  finally {
    if (success) {
      IOUtils.close(consumer);
    }
 else {
      IOUtils.closeWhileHandlingException(consumer);
    }
  }
  if (VERBOSE) {
    System.out.println("TEST: after indexing: files=");
    for (    String file : dir.listAll()) {
      System.out.println("  " + file + ": "+ dir.fileLength(file)+ " bytes");
    }
  }
  currentFieldInfos=newFieldInfos;
  SegmentReadState readState=new SegmentReadState(dir,segmentInfo,newFieldInfos,IOContext.READ);
  return codec.postingsFormat().fieldsProducer(readState);
}
