{
  int i_C=0, i_I=0, i_W=0, i_D=0, i_bboxD=0;
  int laps=0;
  final int MINLAPS=scaledRandomIntBetween(20000,200000);
  while (i_C < getContainsMinimum(MINLAPS) || i_I < getIntersectsMinimum(MINLAPS) || i_W < getWithinMinimum(MINLAPS) || (!isRandomShapeRectangular() && i_D < getDisjointMinimum(MINLAPS)) || i_bboxD < getBoundingMinimum(MINLAPS)) {
    laps++;
    LogRule.clear();
    if (laps > MINLAPS) {
      fail("Did not find enough contains/within/intersection/disjoint/bounds cases in a reasonable number" + " of random attempts. CWIDbD: " + i_C + "("+ getContainsMinimum(MINLAPS)+ "),"+ i_W+ "("+ getWithinMinimum(MINLAPS)+ "),"+ i_I+ "("+ getIntersectsMinimum(MINLAPS)+ "),"+ i_D+ "("+ getDisjointMinimum(MINLAPS)+ "),"+ i_bboxD+ "("+ getBoundingMinimum(MINLAPS)+ ")"+ "  Laps exceeded "+ MINLAPS);
    }
    Point nearP=randomPointIn(ctx.getWorldBounds());
    S s=generateRandomShape(nearP);
    Rectangle r=randomRectangle(s.getBoundingBox().getCenter());
    SpatialRelation ic=s.relate(r);
    LogRule.log("S-R Rel: {}, Shape {}, Rectangle {}",ic,s,r);
    if (ic != DISJOINT) {
      assertTrue("if not disjoint then the shape's bbox shouldn't be disjoint",s.getBoundingBox().relate(r).intersects());
    }
    try {
      int MAX_TRIES=scaledRandomIntBetween(10,100);
switch (ic) {
case CONTAINS:
        i_C++;
      for (int j=0; j < MAX_TRIES; j++) {
        Point p=randomPointIn(r);
        assertRelation(null,CONTAINS,s,p);
      }
    break;
case WITHIN:
  i_W++;
for (int j=0; j < MAX_TRIES; j++) {
  Point p=randomPointInOrNull(s);
  if (p == null) {
    break;
  }
  assertRelation(null,CONTAINS,r,p);
}
break;
case DISJOINT:
if (!s.getBoundingBox().relate(r).intersects()) {
i_bboxD++;
if (i_bboxD >= getBoundingMinimum(MINLAPS)) break;
}
 else {
i_D++;
}
for (int j=0; j < MAX_TRIES; j++) {
Point p=randomPointIn(r);
assertRelation(null,DISJOINT,s,p);
}
break;
case INTERSECTS:
i_I++;
SpatialRelation pointR=null;
Rectangle randomPointSpace=null;
MAX_TRIES=1000;
for (int j=0; j < MAX_TRIES; j++) {
Point p;
if (j < 4) {
p=new PointImpl(0,0,ctx);
InfBufLine.cornerByQuadrant(r,j + 1,p);
}
 else {
if (randomPointSpace == null) {
if (pointR == DISJOINT) {
randomPointSpace=intersectRects(r,s.getBoundingBox());
}
 else {
randomPointSpace=r;
}
}
p=randomPointIn(randomPointSpace);
}
SpatialRelation pointRNew=s.relate(p);
if (pointR == null) {
pointR=pointRNew;
}
 else if (pointR != pointRNew) {
break;
}
 else if (j >= MAX_TRIES) {
fail("Tried intersection brute-force too many times without success");
}
}
break;
default :
fail("" + ic);
}
}
 catch (AssertionError e) {
onAssertFail(e,s,r,ic);
}
}
System.out.println("Laps: " + laps + " CWIDbD: "+ i_C+ ","+ i_W+ ","+ i_I+ ","+ i_D+ ","+ i_bboxD);
}
