{
  int i_C=0, i_I=0, i_W=0, i_D=0, i_bboxD=0;
  int laps=0;
  final int MINLAPSPERCASE=scaledRandomIntBetween(20,200);
  while (i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE || (!isRandomShapeRectangular() && i_D < MINLAPSPERCASE) || i_bboxD < MINLAPSPERCASE) {
    laps++;
    TestLog.clear();
    Point nearP=randomPointIn(ctx.getWorldBounds());
    S s=generateRandomShape(nearP);
    Rectangle r=randomRectangle(s.getBoundingBox().getCenter());
    SpatialRelation ic=s.relate(r);
    TestLog.log("S-R Rel: {}, Shape {}, Rectangle {}",ic,s,r);
    if (ic != DISJOINT) {
      assertTrue("if not disjoint then the shape's bbox shouldn't be disjoint",s.getBoundingBox().relate(r).intersects());
    }
    try {
      int MAX_TRIES=scaledRandomIntBetween(10,100);
switch (ic) {
case CONTAINS:
        i_C++;
      for (int j=0; j < MAX_TRIES; j++) {
        Point p=randomPointIn(r);
        assertRelation(null,CONTAINS,s,p);
      }
    break;
case WITHIN:
  i_W++;
for (int j=0; j < MAX_TRIES; j++) {
  Point p=randomPointIn(s);
  assertRelation(null,CONTAINS,r,p);
}
break;
case DISJOINT:
if (!s.getBoundingBox().relate(r).intersects()) {
i_bboxD++;
if (i_bboxD > MINLAPSPERCASE) break;
}
 else {
i_D++;
}
for (int j=0; j < MAX_TRIES; j++) {
Point p=randomPointIn(r);
assertRelation(null,DISJOINT,s,p);
}
break;
case INTERSECTS:
i_I++;
SpatialRelation pointR=null;
Rectangle randomPointSpace=null;
MAX_TRIES=1000;
for (int j=0; j < MAX_TRIES; j++) {
Point p;
if (j < 4) {
p=new PointImpl(0,0,ctx);
InfBufLine.cornerByQuadrant(r,j + 1,p);
}
 else {
if (randomPointSpace == null) {
if (pointR == DISJOINT) {
randomPointSpace=intersectRects(r,s.getBoundingBox());
}
 else {
randomPointSpace=r;
}
}
p=randomPointIn(randomPointSpace);
}
SpatialRelation pointRNew=s.relate(p);
if (pointR == null) {
pointR=pointRNew;
}
 else if (pointR != pointRNew) {
break;
}
 else if (j >= MAX_TRIES) {
fail("Tried intersection brute-force too many times without success");
}
}
break;
default :
fail("" + ic);
}
}
 catch (AssertionError e) {
onAssertFail(e,s,r,ic);
}
if (laps > MINLAPSPERCASE * 1000) fail("Did not find enough intersection cases in a reasonable number" + " of random attempts. CWIDbD: " + i_C + ","+ i_W+ ","+ i_I+ ","+ i_D+ ","+ i_bboxD+ "  Laps exceeded "+ MINLAPSPERCASE * 1000);
}
System.out.println("Laps: " + laps + " CWIDbD: "+ i_C+ ","+ i_W+ ","+ i_I+ ","+ i_D+ ","+ i_bboxD);
}
