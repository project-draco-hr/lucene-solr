{
  totalHitCount++;
  float score=Float.NaN;
  if (trackMaxScore) {
    score=scorer.score();
    if (score > maxScore) {
      maxScore=score;
    }
  }
  if (queueFull) {
    for (int i=0; ; i++) {
      final int c=reverseMul[i] * comparators[i].compareBottom(parentDoc);
      if (c < 0) {
        return;
      }
 else       if (c > 0) {
        break;
      }
 else       if (i == compEnd) {
        return;
      }
    }
    for (int i=0; i < comparators.length; i++) {
      comparators[i].copy(bottom.slot,parentDoc);
    }
    if (!trackMaxScore && trackScores) {
      score=scorer.score();
    }
    bottom.doc=docBase + parentDoc;
    bottom.readerContext=currentReaderContext;
    bottom.score=score;
    copyGroups(bottom);
    bottom=queue.updateTop();
    for (int i=0; i < comparators.length; i++) {
      comparators[i].setBottom(bottom.slot);
    }
  }
 else {
    final int comparatorSlot=totalHitCount - 1;
    for (int i=0; i < comparators.length; i++) {
      comparators[i].copy(comparatorSlot,parentDoc);
    }
    final OneGroup og=new OneGroup(comparatorSlot,docBase + parentDoc,score,joinScorers.length,trackScores);
    og.readerContext=currentReaderContext;
    copyGroups(og);
    bottom=queue.add(og);
    queueFull=totalHitCount == numParentHits;
    if (queueFull) {
      for (int i=0; i < comparators.length; i++) {
        comparators[i].setBottom(bottom.slot);
      }
    }
  }
}
