{
  final BytesRef term=new BytesRef();
  return new SortedDocValues(){
    private int docID=-1;
    @Override public int docID(){
      return docID;
    }
    @Override public int nextDoc(){
      while (true) {
        docID++;
        if (docID >= docToTermOrd.size()) {
          docID=NO_MORE_DOCS;
          return docID;
        }
        if (docToTermOrd.get(docID) != 0) {
          return docID;
        }
      }
    }
    @Override public int advance(    int target){
      if (target < docToTermOrd.size()) {
        docID=target;
        if (docToTermOrd.get(docID) != 0) {
          return docID;
        }
 else {
          return nextDoc();
        }
      }
 else {
        docID=NO_MORE_DOCS;
        return docID;
      }
    }
    @Override public boolean advanceExact(    int target) throws IOException {
      docID=target;
      return docToTermOrd.get(docID) != 0;
    }
    @Override public long cost(){
      return 0;
    }
    @Override public int ordValue(){
      return (int)docToTermOrd.get(docID) - 1;
    }
    @Override public int getValueCount(){
      return numOrd;
    }
    @Override public BytesRef lookupOrd(    int ord){
      if (ord < 0) {
        throw new IllegalArgumentException("ord must be >=0 (got ord=" + ord + ")");
      }
      bytes.fill(term,termOrdToBytesOffset.get(ord));
      return term;
    }
  }
;
}
