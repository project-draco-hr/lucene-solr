{
  if (entry.bytesPerNorm == 0) {
    return new LongValues(){
      @Override long get(      int index){
        return entry.normsOffset;
      }
    }
;
  }
 else {
    final RandomAccessInput slice=data.randomAccessSlice(entry.normsOffset,entry.numDocsWithField * (long)entry.bytesPerNorm);
switch (entry.bytesPerNorm) {
case 1:
      return new LongValues(){
        @Override long get(        int index) throws IOException {
          return slice.readByte(index);
        }
      }
;
case 2:
    return new LongValues(){
      @Override long get(      int index) throws IOException {
        return slice.readShort(((long)index) << 1);
      }
    }
;
case 4:
  return new LongValues(){
    @Override long get(    int index) throws IOException {
      return slice.readInt(((long)index) << 2);
    }
  }
;
case 8:
return new LongValues(){
  @Override long get(  int index) throws IOException {
    return slice.readLong(((long)index) << 3);
  }
}
;
default :
throw new AssertionError();
}
}
}
