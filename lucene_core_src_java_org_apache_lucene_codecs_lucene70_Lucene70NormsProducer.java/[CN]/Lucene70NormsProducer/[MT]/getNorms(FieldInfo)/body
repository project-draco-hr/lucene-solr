{
  final NormsEntry entry=norms.get(field.number);
  if (entry.docsWithFieldOffset == -2) {
    return DocValues.emptyNumeric();
  }
 else   if (entry.docsWithFieldOffset == -1) {
    if (entry.bytesPerNorm == 0) {
      return new DenseNormsIterator(maxDoc){
        @Override public long longValue() throws IOException {
          return entry.normsOffset;
        }
      }
;
    }
    final RandomAccessInput slice=data.randomAccessSlice(entry.normsOffset,entry.numDocsWithField * (long)entry.bytesPerNorm);
switch (entry.bytesPerNorm) {
case 1:
      return new DenseNormsIterator(maxDoc){
        @Override public long longValue() throws IOException {
          return slice.readByte(doc);
        }
      }
;
case 2:
    return new DenseNormsIterator(maxDoc){
      @Override public long longValue() throws IOException {
        return slice.readShort(((long)doc) << 1);
      }
    }
;
case 4:
  return new DenseNormsIterator(maxDoc){
    @Override public long longValue() throws IOException {
      return slice.readInt(((long)doc) << 2);
    }
  }
;
case 8:
return new DenseNormsIterator(maxDoc){
  @Override public long longValue() throws IOException {
    return slice.readLong(((long)doc) << 3);
  }
}
;
default :
throw new AssertionError();
}
}
 else {
final IndexedDISI disi=new IndexedDISI(data,entry.docsWithFieldOffset,entry.docsWithFieldLength,entry.numDocsWithField);
if (entry.bytesPerNorm == 0) {
return new SparseNormsIterator(disi){
@Override public long longValue() throws IOException {
return entry.normsOffset;
}
}
;
}
final RandomAccessInput slice=data.randomAccessSlice(entry.normsOffset,entry.numDocsWithField * (long)entry.bytesPerNorm);
switch (entry.bytesPerNorm) {
case 1:
return new SparseNormsIterator(disi){
@Override public long longValue() throws IOException {
return slice.readByte(disi.index());
}
}
;
case 2:
return new SparseNormsIterator(disi){
@Override public long longValue() throws IOException {
return slice.readShort(((long)disi.index()) << 1);
}
}
;
case 4:
return new SparseNormsIterator(disi){
@Override public long longValue() throws IOException {
return slice.readInt(((long)disi.index()) << 2);
}
}
;
case 8:
return new SparseNormsIterator(disi){
@Override public long longValue() throws IOException {
return slice.readLong(((long)disi.index()) << 3);
}
}
;
default :
throw new AssertionError();
}
}
}
