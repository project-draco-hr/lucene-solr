{
  if (length > 0)   position+=analyzer.getPositionIncrementGap(fieldInfo.name);
  if (!field.isTokenized()) {
    String stringValue=field.stringValue();
    final int valueLength=stringValue.length();
    Token token=localToken;
    token.clear();
    char[] termBuffer=token.termBuffer();
    if (termBuffer.length < valueLength)     termBuffer=token.resizeTermBuffer(valueLength);
    stringValue.getChars(0,valueLength,termBuffer,0);
    token.setTermLength(valueLength);
    token.setStartOffset(offset);
    token.setEndOffset(offset + stringValue.length());
    addPosition(token);
    offset+=stringValue.length();
    length++;
  }
 else {
    final TokenStream stream;
    final TokenStream streamValue=field.tokenStreamValue();
    if (streamValue != null)     stream=streamValue;
 else {
      final Reader reader;
      final Reader readerValue=field.readerValue();
      if (readerValue != null)       reader=readerValue;
 else {
        String stringValue=field.stringValue();
        if (stringValue == null)         throw new IllegalArgumentException("field must have either TokenStream, String or Reader value");
        threadState.stringReader.init(stringValue);
        reader=threadState.stringReader;
      }
      stream=analyzer.reusableTokenStream(fieldInfo.name,reader);
    }
    stream.reset();
    try {
      offsetEnd=offset - 1;
      for (; ; ) {
        Token token=stream.next(localToken);
        if (token == null)         break;
        position+=(token.getPositionIncrement() - 1);
        if (position < 0)         position=0;
        addPosition(token);
        if (++length >= maxFieldLength) {
          if (threadState.docWriter.infoStream != null)           threadState.docWriter.infoStream.println("maxFieldLength " + maxFieldLength + " reached for field "+ fieldInfo.name+ ", ignoring following tokens");
          break;
        }
      }
      offset=offsetEnd + 1;
    }
  finally {
      stream.close();
    }
  }
  boost*=field.getBoost();
}
