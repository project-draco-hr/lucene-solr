{
  String collection=cloudDesc.getCollectionName();
  String shardId=cloudDesc.getShardId();
  String leaderUrl;
  try {
    leaderUrl=getLeaderProps(collection,cloudDesc.getShardId(),timeoutms).getCoreUrl();
    String clusterStateLeaderUrl=zkStateReader.getLeaderUrl(collection,shardId,timeoutms * 2);
    int tries=0;
    final long msInSec=1000L;
    int maxTries=(int)Math.floor(leaderConflictResolveWait / msInSec);
    while (!leaderUrl.equals(clusterStateLeaderUrl)) {
      if (tries > maxTries) {
        throw new SolrException(ErrorCode.SERVER_ERROR,"There is conflicting information about the leader of shard: " + cloudDesc.getShardId() + " our state says:"+ clusterStateLeaderUrl+ " but zookeeper says:"+ leaderUrl);
      }
      Thread.sleep(msInSec);
      tries++;
      clusterStateLeaderUrl=zkStateReader.getLeaderUrl(collection,shardId,timeoutms);
      leaderUrl=getLeaderProps(collection,cloudDesc.getShardId(),timeoutms).getCoreUrl();
      if (tries % 30 == 0) {
        String warnMsg=String.format("Still seeing conflicting information about the leader " + "of shard %s for collection %s after %d seconds; our state says %s, but ZooKeeper says %s",cloudDesc.getShardId(),collection,tries,clusterStateLeaderUrl,leaderUrl);
        log.warn(warnMsg);
      }
    }
  }
 catch (  Exception e) {
    log.error("Error getting leader from zk",e);
    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Error getting leader from zk for shard " + shardId,e);
  }
  return leaderUrl;
}
