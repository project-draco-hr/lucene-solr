{
  final int numSegments=infos.size();
  if (verbose())   message("findMerges: " + numSegments + " segments");
  float[] levels=new float[numSegments];
  final float norm=(float)Math.log(mergeFactor);
  for (int i=0; i < numSegments; i++) {
    final SegmentInfo info=infos.info(i);
    long size=size(info);
    if (size < 1)     size=1;
    levels[i]=(float)Math.log(size) / norm;
  }
  final float levelFloor;
  if (minMergeSize <= 0)   levelFloor=(float)0.0;
 else   levelFloor=(float)(Math.log(minMergeSize) / norm);
  MergeSpecification spec=null;
  int start=0;
  while (start < numSegments) {
    float maxLevel=levels[start];
    for (int i=1 + start; i < numSegments; i++) {
      final float level=levels[i];
      if (level > maxLevel)       maxLevel=level;
    }
    float levelBottom;
    if (maxLevel <= levelFloor)     levelBottom=-1.0F;
 else {
      levelBottom=(float)(maxLevel - LEVEL_LOG_SPAN);
      if (levelBottom < levelFloor && maxLevel >= levelFloor)       levelBottom=levelFloor;
    }
    int upto=numSegments - 1;
    while (upto >= start) {
      if (levels[upto] >= levelBottom) {
        break;
      }
      upto--;
    }
    if (verbose())     message("  level " + levelBottom + " to "+ maxLevel+ ": "+ (1 + upto - start)+ " segments");
    int end=start + mergeFactor;
    while (end <= 1 + upto) {
      boolean anyTooLarge=false;
      for (int i=start; i < end; i++) {
        final SegmentInfo info=infos.info(i);
        anyTooLarge|=(size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);
      }
      if (!anyTooLarge) {
        if (spec == null)         spec=new MergeSpecification();
        if (verbose())         message("    " + start + " to "+ end+ ": add this merge");
        spec.add(makeOneMerge(infos,infos.range(start,end)));
      }
 else       if (verbose())       message("    " + start + " to "+ end+ ": contains segment over maxMergeSize or maxMergeDocs; skipping");
      start=end;
      end=start + mergeFactor;
    }
    start=1 + upto;
  }
  return spec;
}
