{
  NamedList result=new NamedList();
  Map<Token,LinkedHashMap<String,Integer>> suggestions=spellingResult.getSuggestions();
  boolean hasFreqInfo=spellingResult.hasTokenFrequencyInfo();
  boolean isCorrectlySpelled=false;
  Map<Token,String> best=null;
  if (collate == true) {
    best=new LinkedHashMap<Token,String>(suggestions.size());
  }
  if (suggestions.size() > 0) {
    isCorrectlySpelled=true;
  }
  for (  Map.Entry<Token,LinkedHashMap<String,Integer>> entry : suggestions.entrySet()) {
    Token inputToken=entry.getKey();
    Map<String,Integer> theSuggestions=entry.getValue();
    if (theSuggestions != null && theSuggestions.size() > 0) {
      SimpleOrderedMap suggestionList=new SimpleOrderedMap();
      suggestionList.add("numFound",theSuggestions.size());
      suggestionList.add("startOffset",inputToken.startOffset());
      suggestionList.add("endOffset",inputToken.endOffset());
      if (extendedResults && hasFreqInfo) {
        suggestionList.add("origFreq",spellingResult.getTokenFrequency(inputToken));
        ArrayList<SimpleOrderedMap> sugs=new ArrayList<SimpleOrderedMap>();
        suggestionList.add("suggestion",sugs);
        for (        Map.Entry<String,Integer> suggEntry : theSuggestions.entrySet()) {
          SimpleOrderedMap sugEntry=new SimpleOrderedMap();
          sugEntry.add("word",suggEntry.getKey());
          sugEntry.add("freq",suggEntry.getValue());
          sugs.add(sugEntry);
        }
      }
 else {
        suggestionList.add("suggestion",theSuggestions.keySet());
      }
      if (collate == true) {
        best.put(inputToken,theSuggestions.keySet().iterator().next());
      }
      if (hasFreqInfo) {
        isCorrectlySpelled=isCorrectlySpelled && spellingResult.getTokenFrequency(inputToken) > 0;
      }
      result.add(new String(inputToken.termBuffer(),0,inputToken.termLength()),suggestionList);
    }
  }
  if (hasFreqInfo) {
    result.add("correctlySpelled",isCorrectlySpelled);
  }
 else   if (extendedResults && suggestions.size() == 0) {
    result.add("correctlySpelled",true);
  }
  if (collate == true) {
    StringBuilder collation=new StringBuilder(origQuery);
    int offset=0;
    for (Iterator<Map.Entry<Token,String>> bestIter=best.entrySet().iterator(); bestIter.hasNext(); ) {
      Map.Entry<Token,String> entry=bestIter.next();
      Token tok=entry.getKey();
      collation.replace(tok.startOffset() + offset,tok.endOffset() + offset,entry.getValue());
      offset+=entry.getValue().length() - (tok.endOffset() - tok.startOffset());
    }
    String collVal=collation.toString();
    if (collVal.equals(origQuery) == false) {
      LOG.debug("Collation:" + collation);
      result.add("collation",collVal);
    }
  }
  return result;
}
