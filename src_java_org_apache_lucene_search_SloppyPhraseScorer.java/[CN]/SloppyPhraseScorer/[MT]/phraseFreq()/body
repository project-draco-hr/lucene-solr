{
  pq.clear();
  int end=0;
  for (PhrasePositions pp=first; pp != null; pp=pp.next) {
    pp.firstPosition();
    if (pp.position > end)     end=pp.position;
    pq.put(pp);
  }
  float freq=0.0f;
  boolean done=false;
  do {
    PhrasePositions pp=(PhrasePositions)pq.pop();
    int start=pp.position;
    int next=((PhrasePositions)pq.top()).position;
    for (int pos=start; pos <= next; pos=pp.position) {
      start=pos;
      if (!pp.nextPosition()) {
        done=true;
        break;
      }
    }
    int matchLength=end - start;
    if (matchLength <= slop)     freq+=1.0 / (matchLength + 1);
    if (pp.position > end)     end=pp.position;
    pq.put(pp);
  }
 while (!done);
  return freq;
}
