{
  int deleteCount=0;
  int docBase=0;
  int docCount=0;
  MockDirectoryWrapper dir=newMockDirectory();
  final AtomicBoolean shouldFail=new AtomicBoolean();
  dir.failOn(new MockDirectoryWrapper.Failure(){
    @Override public void eval(    MockDirectoryWrapper dir) throws IOException {
      StackTraceElement[] trace=new Exception().getStackTrace();
      if (shouldFail.get() == false) {
        return;
      }
      boolean sawSeal=false;
      boolean sawWrite=false;
      for (int i=0; i < trace.length; i++) {
        if ("sealFlushedSegment".equals(trace[i].getMethodName())) {
          sawSeal=true;
          break;
        }
        if ("writeLiveDocs".equals(trace[i].getMethodName()) || "writeFieldUpdates".equals(trace[i].getMethodName())) {
          sawWrite=true;
        }
      }
      if (sawWrite && sawSeal == false && random().nextInt(3) == 2) {
        if (VERBOSE) {
          System.out.println("TEST: now fail; thread=" + Thread.currentThread().getName() + " exc:");
          new Throwable().printStackTrace(System.out);
        }
        shouldFail.set(false);
        throw new FakeIOException();
      }
    }
  }
);
  RandomIndexWriter w=null;
  for (int iter=0; iter < 10 * RANDOM_MULTIPLIER; iter++) {
    int numDocs=atLeast(100);
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " numDocs="+ numDocs+ " docBase="+ docBase+ " delCount="+ deleteCount);
    }
    if (w == null) {
      IndexWriterConfig iwc=newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random()));
      final MergeScheduler ms=iwc.getMergeScheduler();
      if (ms instanceof ConcurrentMergeScheduler) {
        final ConcurrentMergeScheduler suppressFakeIOE=new ConcurrentMergeScheduler(){
          @Override protected void handleMergeException(          Throwable exc){
            if (!(exc instanceof FakeIOException)) {
              super.handleMergeException(exc);
            }
          }
        }
;
        final ConcurrentMergeScheduler cms=(ConcurrentMergeScheduler)ms;
        suppressFakeIOE.setMaxMergesAndThreads(cms.getMaxMergeCount(),cms.getMaxThreadCount());
        suppressFakeIOE.setMergeThreadPriority(cms.getMergeThreadPriority());
        iwc.setMergeScheduler(suppressFakeIOE);
      }
      w=new RandomIndexWriter(random(),dir,iwc);
      w.setDoRandomForceMergeAssert(false);
    }
    for (int i=0; i < numDocs; i++) {
      Document doc=new Document();
      doc.add(new StringField("id","" + (docBase + i),Field.Store.NO));
      doc.add(new NumericDocValuesField("f",1L));
      doc.add(new NumericDocValuesField("cf",2L));
      doc.add(new BinaryDocValuesField("bf",TestBinaryDocValuesUpdates.toBytes(1L)));
      doc.add(new BinaryDocValuesField("bcf",TestBinaryDocValuesUpdates.toBytes(2L)));
      w.addDocument(doc);
    }
    docCount+=numDocs;
    shouldFail.set(true);
    boolean doClose=false;
    try {
      boolean defaultCodecSupportsFieldUpdates=defaultCodecSupportsFieldUpdates();
      for (int i=0; i < numDocs; i++) {
        if (random().nextInt(10) == 7) {
          boolean fieldUpdate=defaultCodecSupportsFieldUpdates && random().nextBoolean();
          int docid=docBase + i;
          if (fieldUpdate) {
            long value=iter;
            if (VERBOSE) {
              System.out.println("  update id=" + docid + " to value "+ value);
            }
            Term idTerm=new Term("id",Integer.toString(docid));
            if (random().nextBoolean()) {
              w.updateDocValues(idTerm,new NumericDocValuesField("f",value),new NumericDocValuesField("cf",value * 2));
            }
 else             if (random().nextBoolean()) {
              w.updateDocValues(idTerm,new BinaryDocValuesField("bf",TestBinaryDocValuesUpdates.toBytes(value)),new BinaryDocValuesField("bcf",TestBinaryDocValuesUpdates.toBytes(value * 2)));
            }
 else {
              w.updateDocValues(idTerm,new NumericDocValuesField("f",value),new NumericDocValuesField("cf",value * 2),new BinaryDocValuesField("bf",TestBinaryDocValuesUpdates.toBytes(value)),new BinaryDocValuesField("bcf",TestBinaryDocValuesUpdates.toBytes(value * 2)));
            }
          }
          if (!fieldUpdate || random().nextBoolean()) {
            if (VERBOSE) {
              System.out.println("  delete id=" + docid);
            }
            deleteCount++;
            w.deleteDocuments(new Term("id","" + docid));
          }
        }
      }
      IndexReader r=w.getReader(true);
      assertEquals(docCount - deleteCount,r.numDocs());
      r.close();
      if (random().nextBoolean()) {
        if (VERBOSE) {
          System.out.println("  now close writer");
        }
        doClose=true;
        w.commit();
        w.shutdown();
        w=null;
      }
    }
 catch (    IOException ioe) {
      if (ioe instanceof FakeIOException || (ioe.getCause() != null && ioe.getCause() instanceof FakeIOException)) {
        if (VERBOSE) {
          System.out.println("TEST: w.shutdown() hit expected IOE");
        }
      }
 else {
        throw ioe;
      }
    }
    shouldFail.set(false);
    IndexReader r;
    if (doClose && w != null) {
      if (VERBOSE) {
        System.out.println("  now 2nd close writer");
      }
      try {
        w.shutdown();
      }
 catch (      AlreadyClosedException ace) {
      }
      w=null;
    }
    if (w == null || random().nextBoolean()) {
      if (VERBOSE) {
        System.out.println("TEST: verify against non-NRT reader");
      }
      if (w != null) {
        w.commit();
      }
      r=DirectoryReader.open(dir);
    }
 else {
      if (VERBOSE) {
        System.out.println("TEST: verify against NRT reader");
      }
      r=w.getReader();
    }
    assertEquals(docCount - deleteCount,r.numDocs());
    BytesRef scratch=new BytesRef();
    for (    AtomicReaderContext context : r.leaves()) {
      AtomicReader reader=context.reader();
      Bits liveDocs=reader.getLiveDocs();
      NumericDocValues f=reader.getNumericDocValues("f");
      NumericDocValues cf=reader.getNumericDocValues("cf");
      BinaryDocValues bf=reader.getBinaryDocValues("bf");
      BinaryDocValues bcf=reader.getBinaryDocValues("bcf");
      for (int i=0; i < reader.maxDoc(); i++) {
        if (liveDocs == null || liveDocs.get(i)) {
          assertEquals("doc=" + (docBase + i),cf.get(i),f.get(i) * 2);
          assertEquals("doc=" + (docBase + i),TestBinaryDocValuesUpdates.getValue(bcf,i,scratch),TestBinaryDocValuesUpdates.getValue(bf,i,scratch) * 2);
        }
      }
    }
    r.close();
    if (w != null && random().nextBoolean()) {
      if (VERBOSE) {
        System.out.println("TEST: close writer");
      }
      w.shutdown();
      w=null;
    }
    docBase+=numDocs;
  }
  if (w != null) {
    w.shutdown();
  }
  IndexReader r=DirectoryReader.open(dir);
  assertEquals(docCount - deleteCount,r.numDocs());
  r.close();
  dir.close();
}
