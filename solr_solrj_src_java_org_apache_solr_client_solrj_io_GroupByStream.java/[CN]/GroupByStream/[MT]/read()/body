{
  if (currentTuple.EOF) {
    return currentTuple;
  }
  PriorityQueue<Tuple> group=new PriorityQueue<>(size,reverseComp);
  group.add(currentTuple);
  while (true) {
    Tuple t=tupleStream.read();
    if (t.EOF) {
      currentTuple=t;
      break;
    }
    if (interGroupComp.compare(currentTuple,t) == 0) {
      if (group.size() >= size) {
        Tuple peek=group.peek();
        if (intraGroupComp.compare(t,peek) < 0) {
          group.poll();
          group.add(t);
        }
      }
 else {
        group.add(t);
      }
    }
 else {
      currentTuple=t;
      break;
    }
  }
  Tuple[] members=new Tuple[group.size()];
  for (int i=group.size() - 1; i >= 0; i--) {
    Tuple t=group.poll();
    members[i]=t;
  }
  Tuple groupHead=members[0];
  if (members.length > 1) {
    List groupList=new ArrayList();
    for (int i=1; i < members.length; i++) {
      groupList.add(members[i].fields);
    }
    groupHead.set("tuples",groupList);
  }
 else {
    groupHead.set("tuples",new ArrayList());
  }
  return groupHead;
}
