{
  LinkedList<TermInfo> phraseCandidate=new LinkedList<TermInfo>();
  while (!fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit)) {
    int longest=0;
    phraseCandidate.clear();
    QueryPhraseMap currMap=null;
    for (    TermInfo ti : fieldTermStack) {
      QueryPhraseMap nextMap=null;
      if (currMap == null) {
        nextMap=fieldQuery.getFieldTermMap(field,ti.getText());
        if (nextMap == null) {
          break;
        }
      }
 else {
        nextMap=currMap.getTermMap(ti.getText());
      }
      if (nextMap != null) {
        currMap=nextMap;
        phraseCandidate.add(ti);
        if (currMap.isValidTermOrPhrase(phraseCandidate)) {
          longest=phraseCandidate.size();
        }
      }
    }
    if (longest > 0) {
      addIfNoOverlap(new WeightedPhraseInfo(phraseCandidate.subList(0,longest),currMap.getBoost(),currMap.getTermOrPhraseNumber()));
    }
    fieldTermStack.pop();
  }
}
