{
  final String field=fieldTermStack.getFieldName();
  @SuppressWarnings("unchecked") Deque<TermInfo>[] termStacks=new Deque[]{new ArrayDeque<TermInfo>()};
  for (TermInfo ti=fieldTermStack.pop(); ti != null; ti=fieldTermStack.pop()) {
    if (!fieldTermStack.isEmpty() && fieldTermStack.peek().getPosition() == ti.getPosition()) {
      List<TermInfo> samePositionTermInfos=new ArrayList<>(2);
      samePositionTermInfos.add(ti);
      samePositionTermInfos.add(fieldTermStack.pop());
      while (!fieldTermStack.isEmpty() && fieldTermStack.peek().getPosition() == ti.getPosition()) {
        samePositionTermInfos.add(fieldTermStack.pop());
      }
      final int numTokensAtSamePosition=samePositionTermInfos.size();
      @SuppressWarnings("unchecked") Deque<TermInfo>[] newTermStacks=new Deque[termStacks.length * numTokensAtSamePosition];
      for (int i=0, k=0; i < termStacks.length; ++i) {
        for (int j=0; j < numTokensAtSamePosition; ++j) {
          if (j == numTokensAtSamePosition - 1) {
            newTermStacks[k]=termStacks[i];
          }
 else {
            newTermStacks[k]=new ArrayDeque<>(termStacks[i]);
          }
          newTermStacks[k++].offer(samePositionTermInfos.get(j));
        }
      }
      termStacks=newTermStacks;
    }
 else {
      for (      Deque<TermInfo> d : termStacks) {
        d.offer(ti);
      }
    }
  }
  for (  Deque<TermInfo> d : termStacks) {
    extractPhrases(field,d,fieldQuery,phraseLimit);
  }
}
