{
  SchemaField schemaField=searcher.getSchema().getField(fieldName);
  FieldType ft=schemaField.getType();
  StatsValues res=StatsValuesFactory.createStatsValues(schemaField,calcDistinct);
  final FieldFacetStats[] facetStats=new FieldFacetStats[facet.length];
  int upto=0;
  for (  String facetField : facet) {
    SchemaField facetSchemaField=searcher.getSchema().getField(facetField);
    facetStats[upto++]=new FieldFacetStats(searcher,facetField,schemaField,facetSchemaField,calcDistinct);
  }
  final boolean multiValued=schemaField.multiValued() || ft.multiValuedFieldCache();
  SortedSetDocValues si;
  OrdinalMap ordinalMap=null;
  if (multiValued) {
    si=searcher.getAtomicReader().getSortedSetDocValues(fieldName);
    if (si instanceof MultiSortedSetDocValues) {
      ordinalMap=((MultiSortedSetDocValues)si).mapping;
    }
  }
 else {
    SortedDocValues single=searcher.getAtomicReader().getSortedDocValues(fieldName);
    si=single == null ? null : DocValues.singleton(single);
    if (single instanceof MultiSortedDocValues) {
      ordinalMap=((MultiSortedDocValues)single).mapping;
    }
  }
  if (si == null) {
    si=DocValues.emptySortedSet();
  }
  if (si.getValueCount() >= Integer.MAX_VALUE) {
    throw new UnsupportedOperationException("Currently this stats method is limited to " + Integer.MAX_VALUE + " unique terms");
  }
  DocSet missing=docs.andNot(searcher.getDocSet(new TermRangeQuery(fieldName,null,null,false,false)));
  final int nTerms=(int)si.getValueCount();
  final int[] counts=new int[nTerms];
  Filter filter=docs.getTopFilter();
  List<AtomicReaderContext> leaves=searcher.getTopReaderContext().leaves();
  for (int subIndex=0; subIndex < leaves.size(); subIndex++) {
    AtomicReaderContext leaf=leaves.get(subIndex);
    DocIdSet dis=filter.getDocIdSet(leaf,null);
    DocIdSetIterator disi=null;
    if (dis != null) {
      disi=dis.iterator();
    }
    if (disi != null) {
      int docBase=leaf.docBase;
      if (multiValued) {
        SortedSetDocValues sub=leaf.reader().getSortedSetDocValues(fieldName);
        if (sub == null) {
          sub=DocValues.emptySortedSet();
        }
        final SortedDocValues singleton=DocValues.unwrapSingleton(sub);
        if (singleton != null) {
          accumSingle(counts,docBase,facetStats,singleton,disi,subIndex,ordinalMap);
        }
 else {
          accumMulti(counts,docBase,facetStats,sub,disi,subIndex,ordinalMap);
        }
      }
 else {
        SortedDocValues sub=leaf.reader().getSortedDocValues(fieldName);
        if (sub == null) {
          sub=DocValues.emptySorted();
        }
        accumSingle(counts,docBase,facetStats,sub,disi,subIndex,ordinalMap);
      }
    }
  }
  for (int ord=0; ord < counts.length; ord++) {
    int count=counts[ord];
    if (count > 0) {
      final BytesRef value=si.lookupOrd(ord);
      res.accumulate(value,count);
      for (      FieldFacetStats f : facetStats) {
        f.accumulateTermNum(ord,value);
      }
    }
  }
  res.addMissing(missing.size());
  if (facetStats.length > 0) {
    for (    FieldFacetStats f : facetStats) {
      Map<String,StatsValues> facetStatsValues=f.facetStatsValues;
      FieldType facetType=searcher.getSchema().getFieldType(f.name);
      for (      Map.Entry<String,StatsValues> entry : facetStatsValues.entrySet()) {
        String termLabel=entry.getKey();
        int missingCount=searcher.numDocs(new TermQuery(new Term(f.name,facetType.toInternal(termLabel))),missing);
        entry.getValue().addMissing(missingCount);
      }
      res.addFacet(f.name,facetStatsValues);
    }
  }
  return res;
}
