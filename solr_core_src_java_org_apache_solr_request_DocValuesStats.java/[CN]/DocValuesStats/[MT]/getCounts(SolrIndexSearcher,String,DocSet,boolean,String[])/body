{
  SchemaField schemaField=searcher.getSchema().getField(fieldName);
  FieldType ft=schemaField.getType();
  StatsValues res=StatsValuesFactory.createStatsValues(schemaField,calcDistinct);
  final FieldFacetStats[] facetStats=new FieldFacetStats[facet.length];
  int upto=0;
  for (  String facetField : facet) {
    SchemaField fsf=searcher.getSchema().getField(facetField);
    if (fsf.multiValued()) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"Stats can only facet on single-valued fields, not: " + facetField);
    }
    SchemaField facetSchemaField=searcher.getSchema().getField(facetField);
    facetStats[upto++]=new FieldFacetStats(searcher,facetField,schemaField,facetSchemaField,calcDistinct);
  }
  final boolean multiValued=schemaField.multiValued() || ft.multiValuedFieldCache();
  SortedSetDocValues si;
  OrdinalMap ordinalMap=null;
  if (multiValued) {
    si=searcher.getAtomicReader().getSortedSetDocValues(fieldName);
    if (si instanceof MultiSortedSetDocValues) {
      ordinalMap=((MultiSortedSetDocValues)si).mapping;
    }
  }
 else {
    SortedDocValues single=searcher.getAtomicReader().getSortedDocValues(fieldName);
    si=single == null ? null : DocValues.singleton(single);
    if (single instanceof MultiSortedDocValues) {
      ordinalMap=((MultiSortedDocValues)single).mapping;
    }
  }
  if (si == null) {
    si=DocValues.emptySortedSet();
  }
  if (si.getValueCount() >= Integer.MAX_VALUE) {
    throw new UnsupportedOperationException("Currently this stats method is limited to " + Integer.MAX_VALUE + " unique terms");
  }
  int missingDocCountTotal=0;
  final int nTerms=(int)si.getValueCount();
  final int[] counts=new int[nTerms];
  Filter filter=docs.getTopFilter();
  List<AtomicReaderContext> leaves=searcher.getTopReaderContext().leaves();
  for (int subIndex=0; subIndex < leaves.size(); subIndex++) {
    AtomicReaderContext leaf=leaves.get(subIndex);
    DocIdSet dis=filter.getDocIdSet(leaf,null);
    DocIdSetIterator disi=null;
    if (dis != null) {
      disi=dis.iterator();
    }
    if (disi != null) {
      int docBase=leaf.docBase;
      if (multiValued) {
        SortedSetDocValues sub=leaf.reader().getSortedSetDocValues(fieldName);
        if (sub == null) {
          sub=DocValues.emptySortedSet();
        }
        final SortedDocValues singleton=DocValues.unwrapSingleton(sub);
        if (singleton != null) {
          missingDocCountTotal+=accumSingle(counts,docBase,facetStats,singleton,disi,subIndex,ordinalMap);
        }
 else {
          missingDocCountTotal+=accumMulti(counts,docBase,facetStats,sub,disi,subIndex,ordinalMap);
        }
      }
 else {
        SortedDocValues sub=leaf.reader().getSortedDocValues(fieldName);
        if (sub == null) {
          sub=DocValues.emptySorted();
        }
        missingDocCountTotal+=accumSingle(counts,docBase,facetStats,sub,disi,subIndex,ordinalMap);
      }
    }
  }
  for (int ord=0; ord < counts.length; ord++) {
    int count=counts[ord];
    if (count > 0) {
      final BytesRef value=si.lookupOrd(ord);
      res.accumulate(value,count);
      for (      FieldFacetStats f : facetStats) {
        f.accumulateTermNum(ord,value);
      }
    }
  }
  res.addMissing(missingDocCountTotal);
  if (facetStats.length > 0) {
    for (    FieldFacetStats f : facetStats) {
      Map<String,StatsValues> facetStatsValues=f.facetStatsValues;
      f.accumulateMissing();
      res.addFacet(f.name,facetStatsValues);
    }
  }
  return res;
}
