{
  while (true) {
    final int shapeType=random().nextInt(4);
switch (shapeType) {
case 0:
{
        final int vertexCount=random().nextInt(3) + 3;
        final List<GeoPoint> geoPoints=new ArrayList<>();
        while (geoPoints.size() < vertexCount) {
          final GeoPoint gPt=new GeoPoint(planetModel,toRadians(randomLat()),toRadians(randomLon()));
          geoPoints.add(gPt);
        }
        final int convexPointIndex=random().nextInt(vertexCount);
        try {
          return GeoPolygonFactory.makeGeoPolygon(planetModel,geoPoints,convexPointIndex);
        }
 catch (        IllegalArgumentException e) {
          continue;
        }
      }
case 1:
{
      double lat=toRadians(randomLat());
      double lon=toRadians(randomLon());
      double angle;
      if (smallBBox) {
        angle=random().nextDouble() * Math.PI / 360.0;
      }
 else {
        angle=random().nextDouble() * Math.PI / 2.0;
      }
      try {
        return GeoCircleFactory.makeGeoCircle(planetModel,lat,lon,angle);
      }
 catch (      IllegalArgumentException iae) {
        continue;
      }
    }
case 2:
{
    double lat0=toRadians(randomLat());
    double lat1=toRadians(randomLat());
    if (lat1 < lat0) {
      double x=lat0;
      lat0=lat1;
      lat1=x;
    }
    double lon0=toRadians(randomLon());
    double lon1=toRadians(randomLon());
    if (lon1 < lon0) {
      double x=lon0;
      lon0=lon1;
      lon1=x;
    }
    return GeoBBoxFactory.makeGeoBBox(planetModel,lat1,lat0,lon0,lon1);
  }
case 3:
{
  final int pointCount=random().nextInt(5) + 1;
  final double width=toRadians(random().nextInt(89) + 1);
  try {
    final GeoPath path=new GeoPath(planetModel,width);
    for (int i=0; i < pointCount; i++) {
      path.addPoint(toRadians(randomLat()),toRadians(randomLon()));
    }
    path.done();
    return path;
  }
 catch (  IllegalArgumentException e) {
    continue;
  }
}
default :
throw new IllegalStateException("Unexpected shape type");
}
}
}
