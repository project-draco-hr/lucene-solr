{
  Slice slice=collection.getSlice(sliceName);
  Map<String,Object> sliceProps=slice.getProperties();
  if (slice.getState() == Slice.State.RECOVERY) {
    log.info("Shard: {} is in recovery state",sliceName);
    if (replica.getState() == Replica.State.ACTIVE) {
      log.info("Shard: {} is in recovery state and coreNodeName: {} is active",sliceName,coreNodeName);
      boolean allActive=true;
      for (      Map.Entry<String,Replica> entry : slice.getReplicasMap().entrySet()) {
        if (coreNodeName.equals(entry.getKey()))         continue;
        if (entry.getValue().getState() != Replica.State.ACTIVE) {
          allActive=false;
          break;
        }
      }
      if (allActive) {
        log.info("Shard: {} - all replicas are active. Finding status of fellow sub-shards",sliceName);
        Map<String,Slice> allSlicesCopy=new HashMap<>(collection.getSlicesMap());
        List<Slice> subShardSlices=new ArrayList<>();
        outer:         for (        Map.Entry<String,Slice> entry : allSlicesCopy.entrySet()) {
          if (sliceName.equals(entry.getKey()))           continue;
          Slice otherSlice=entry.getValue();
          if (otherSlice.getState() == Slice.State.RECOVERY) {
            if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {
              log.info("Shard: {} - Fellow sub-shard: {} found",sliceName,otherSlice.getName());
              for (              Map.Entry<String,Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {
                if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {
                  allActive=false;
                  break outer;
                }
              }
              log.info("Shard: {} - Fellow sub-shard: {} has all replicas active",sliceName,otherSlice.getName());
              subShardSlices.add(otherSlice);
            }
          }
        }
        if (allActive) {
          log.info("Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.",sliceName);
          String parentSliceName=(String)sliceProps.remove(Slice.PARENT);
          String shardParentZkSession=(String)sliceProps.remove("shard_parent_zk_session");
          String shardParentNode=(String)sliceProps.remove("shard_parent_node");
          boolean isLeaderSame=true;
          if (shardParentNode != null && shardParentZkSession != null) {
            log.info("Checking whether sub-shard leader node is still the same one at {} with ZK session id {}",shardParentNode,shardParentZkSession);
            try {
              Stat leaderZnodeStat=zkStateReader.getZkClient().exists(ZkStateReader.LIVE_NODES_ZKNODE + "/" + shardParentNode,null,true);
              if (leaderZnodeStat == null) {
                log.error("The shard leader node: {} is not live anymore!",shardParentNode);
                isLeaderSame=false;
              }
 else               if (leaderZnodeStat.getEphemeralOwner() != Long.parseLong(shardParentZkSession)) {
                log.error("The zk session id for shard leader node: {} has changed from {} to {}",shardParentNode,shardParentZkSession,leaderZnodeStat.getEphemeralOwner());
                isLeaderSame=false;
              }
            }
 catch (            Exception e) {
              log.warn("Error occurred while checking if parent shard node is still live with the same zk session id. " + "We cannot switch shard states at this time.",e);
              return collection;
            }
          }
          if (isLeaderSame) {
            log.info("Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.",shardParentNode,shardParentZkSession);
            Map<String,Object> propMap=new HashMap<>();
            propMap.put(Overseer.QUEUE_OPERATION,"updateshardstate");
            propMap.put(parentSliceName,Slice.State.INACTIVE.toString());
            propMap.put(sliceName,Slice.State.ACTIVE.toString());
            for (            Slice subShardSlice : subShardSlices) {
              propMap.put(subShardSlice.getName(),Slice.State.ACTIVE.toString());
            }
            propMap.put(ZkStateReader.COLLECTION_PROP,collection.getName());
            ZkNodeProps m=new ZkNodeProps(propMap);
            return new SliceMutator(zkStateReader).updateShardState(prevState,m).collection;
          }
 else {
            Map<String,Object> propMap=new HashMap<>();
            propMap.put(Overseer.QUEUE_OPERATION,"updateshardstate");
            propMap.put(sliceName,Slice.State.RECOVERY_FAILED.toString());
            for (            Slice subShardSlice : subShardSlices) {
              propMap.put(subShardSlice.getName(),Slice.State.RECOVERY_FAILED.toString());
            }
            propMap.put(ZkStateReader.COLLECTION_PROP,collection.getName());
            ZkNodeProps m=new ZkNodeProps(propMap);
            return new SliceMutator(zkStateReader).updateShardState(prevState,m).collection;
          }
        }
      }
    }
  }
  return collection;
}
