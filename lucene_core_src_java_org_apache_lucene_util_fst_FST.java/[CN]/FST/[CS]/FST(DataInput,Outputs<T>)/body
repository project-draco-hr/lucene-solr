{
  this.outputs=outputs;
  writer=null;
  CodecUtil.checkHeader(in,FILE_FORMAT_NAME,VERSION_PACKED,VERSION_PACKED);
  packed=in.readByte() == 1;
  if (in.readByte() == 1) {
    int numBytes=in.readVInt();
    bytes=new byte[numBytes];
    in.readBytes(bytes,0,numBytes);
    if (packed) {
      emptyOutput=outputs.read(getBytesReader(0));
    }
 else {
      emptyOutput=outputs.read(getBytesReader(numBytes - 1));
    }
  }
 else {
    emptyOutput=null;
  }
  final byte t=in.readByte();
switch (t) {
case 0:
    inputType=INPUT_TYPE.BYTE1;
  break;
case 1:
inputType=INPUT_TYPE.BYTE2;
break;
case 2:
inputType=INPUT_TYPE.BYTE4;
break;
default :
throw new IllegalStateException("invalid input type " + t);
}
if (packed) {
final int nodeRefCount=in.readVInt();
nodeRefToAddress=new int[nodeRefCount];
for (int idx=0; idx < nodeRefCount; idx++) {
nodeRefToAddress[idx]=in.readVInt();
}
}
 else {
nodeRefToAddress=null;
}
startNode=in.readVInt();
nodeCount=in.readVInt();
arcCount=in.readVInt();
arcWithOutputCount=in.readVInt();
bytes=new byte[in.readVInt()];
in.readBytes(bytes,0,bytes.length);
NO_OUTPUT=outputs.getNoOutput();
cacheRootArcs();
}
