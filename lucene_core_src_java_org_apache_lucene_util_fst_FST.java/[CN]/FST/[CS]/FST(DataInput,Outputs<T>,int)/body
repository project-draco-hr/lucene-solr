{
  this.outputs=outputs;
  if (maxBlockBits < 1 || maxBlockBits > 30) {
    throw new IllegalArgumentException("maxBlockBits should be 1 .. 30; got " + maxBlockBits);
  }
  version=CodecUtil.checkHeader(in,FILE_FORMAT_NAME,VERSION_PACKED,VERSION_NO_NODE_ARC_COUNTS);
  packed=in.readByte() == 1;
  if (in.readByte() == 1) {
    BytesStore emptyBytes=new BytesStore(10);
    int numBytes=in.readVInt();
    emptyBytes.copyBytes(in,numBytes);
    BytesReader reader;
    if (packed) {
      reader=emptyBytes.getForwardReader();
    }
 else {
      reader=emptyBytes.getReverseReader();
      if (numBytes > 0) {
        reader.setPosition(numBytes - 1);
      }
    }
    emptyOutput=outputs.readFinalOutput(reader);
  }
 else {
    emptyOutput=null;
  }
  final byte t=in.readByte();
switch (t) {
case 0:
    inputType=INPUT_TYPE.BYTE1;
  break;
case 1:
inputType=INPUT_TYPE.BYTE2;
break;
case 2:
inputType=INPUT_TYPE.BYTE4;
break;
default :
throw new IllegalStateException("invalid input type " + t);
}
if (packed) {
nodeRefToAddress=PackedInts.getReader(in);
}
 else {
nodeRefToAddress=null;
}
startNode=in.readVLong();
if (version < VERSION_NO_NODE_ARC_COUNTS) {
in.readVLong();
in.readVLong();
in.readVLong();
}
long numBytes=in.readVLong();
if (numBytes > 1 << maxBlockBits) {
bytes=new BytesStore(in,numBytes,1 << maxBlockBits);
bytesArray=null;
}
 else {
bytes=null;
bytesArray=new byte[(int)numBytes];
in.readBytes(bytesArray,0,bytesArray.length);
}
cacheRootArcs();
}
