{
  this.outputs=outputs;
  if (maxBlockBits < 1 || maxBlockBits > 30) {
    throw new IllegalArgumentException("maxBlockBits should be 1 .. 30; got " + maxBlockBits);
  }
  version=CodecUtil.checkHeader(in,FILE_FORMAT_NAME,VERSION_PACKED,VERSION_VINT_TARGET);
  packed=in.readByte() == 1;
  if (in.readByte() == 1) {
    BytesStore emptyBytes=new BytesStore(10);
    int numBytes=in.readVInt();
    emptyBytes.copyBytes(in,numBytes);
    BytesReader reader;
    if (packed) {
      reader=emptyBytes.getForwardReader();
    }
 else {
      reader=emptyBytes.getReverseReader();
      if (numBytes > 0) {
        reader.setPosition(numBytes - 1);
      }
    }
    emptyOutput=outputs.readFinalOutput(reader);
  }
 else {
    emptyOutput=null;
  }
  final byte t=in.readByte();
switch (t) {
case 0:
    inputType=INPUT_TYPE.BYTE1;
  break;
case 1:
inputType=INPUT_TYPE.BYTE2;
break;
case 2:
inputType=INPUT_TYPE.BYTE4;
break;
default :
throw new IllegalStateException("invalid input type " + t);
}
if (packed) {
nodeRefToAddress=PackedInts.getReader(in);
}
 else {
nodeRefToAddress=null;
}
startNode=in.readVLong();
nodeCount=in.readVLong();
arcCount=in.readVLong();
arcWithOutputCount=in.readVLong();
long numBytes=in.readVLong();
bytes=new BytesStore(in,numBytes,1 << maxBlockBits);
NO_OUTPUT=outputs.getNoOutput();
cacheRootArcs();
allowArrayArcs=false;
}
