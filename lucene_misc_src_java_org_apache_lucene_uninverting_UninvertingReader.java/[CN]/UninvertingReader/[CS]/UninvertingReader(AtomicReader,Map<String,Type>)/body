{
  super(in);
  this.mapping=mapping;
  ArrayList<FieldInfo> filteredInfos=new ArrayList<>();
  for (  FieldInfo fi : in.getFieldInfos()) {
    FieldInfo.DocValuesType type=fi.getDocValuesType();
    if (fi.isIndexed() && !fi.hasDocValues()) {
      Type t=mapping.get(fi.name);
      if (t != null) {
switch (t) {
case INTEGER:
case LONG:
case FLOAT:
case DOUBLE:
          type=FieldInfo.DocValuesType.NUMERIC;
        break;
case BINARY:
      type=FieldInfo.DocValuesType.BINARY;
    break;
case SORTED:
  type=FieldInfo.DocValuesType.SORTED;
break;
case SORTED_SET_BINARY:
case SORTED_SET_INTEGER:
case SORTED_SET_FLOAT:
case SORTED_SET_LONG:
case SORTED_SET_DOUBLE:
type=FieldInfo.DocValuesType.SORTED_SET;
break;
default :
throw new AssertionError();
}
}
}
filteredInfos.add(new FieldInfo(fi.name,fi.isIndexed(),fi.number,fi.hasVectors(),fi.omitsNorms(),fi.hasPayloads(),fi.getIndexOptions(),type,fi.getNormType(),-1,null));
}
fieldInfos=new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));
}
