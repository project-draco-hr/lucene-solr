{
  super(in);
  this.mapping=mapping;
  ArrayList<FieldInfo> filteredInfos=new ArrayList<>();
  for (  FieldInfo fi : in.getFieldInfos()) {
    DocValuesType type=fi.getDocValuesType();
    if (fi.getIndexOptions() != IndexOptions.NONE && fi.getDocValuesType() == DocValuesType.NONE) {
      Type t=mapping.get(fi.name);
      if (t != null) {
switch (t) {
case INTEGER:
case LONG:
case FLOAT:
case DOUBLE:
          type=DocValuesType.NUMERIC;
        break;
case BINARY:
      type=DocValuesType.BINARY;
    break;
case SORTED:
  type=DocValuesType.SORTED;
break;
case SORTED_SET_BINARY:
case SORTED_SET_INTEGER:
case SORTED_SET_FLOAT:
case SORTED_SET_LONG:
case SORTED_SET_DOUBLE:
type=DocValuesType.SORTED_SET;
break;
default :
throw new AssertionError();
}
}
}
filteredInfos.add(new FieldInfo(fi.name,fi.number,fi.hasVectors(),fi.omitsNorms(),fi.hasPayloads(),fi.getIndexOptions(),type,fi.getDocValuesGen(),fi.attributes(),fi.getPointDimensionCount(),fi.getPointNumBytes()));
}
fieldInfos=new FieldInfos(filteredInfos.toArray(new FieldInfo[filteredInfos.size()]));
}
