{
  final int iterations=RandomInts.randomIntBetween(random(),1,1000);
  final float acceptableOverheadRatio=random().nextFloat();
  final int[] values=new int[(iterations - 1) * BLOCK_SIZE + ForUtil.MAX_DATA_SIZE];
  for (int i=0; i < iterations; ++i) {
    final int bpv=random().nextInt(32);
    if (bpv == 0) {
      final int value=RandomInts.randomIntBetween(random(),0,Integer.MAX_VALUE);
      for (int j=0; j < BLOCK_SIZE; ++j) {
        values[i * BLOCK_SIZE + j]=value;
      }
    }
 else {
      for (int j=0; j < BLOCK_SIZE; ++j) {
        values[i * BLOCK_SIZE + j]=RandomInts.randomIntBetween(random(),0,(int)PackedInts.maxValue(bpv));
      }
    }
  }
  final Directory d=new RAMDirectory();
  final long endPointer;
{
    IndexOutput out=d.createOutput("test.bin",IOContext.DEFAULT);
    final ForUtil forUtil=new ForUtil(acceptableOverheadRatio,out);
    for (int i=0; i < iterations; ++i) {
      forUtil.writeBlock(Arrays.copyOfRange(values,i * BLOCK_SIZE,values.length),new byte[MAX_ENCODED_SIZE],out);
    }
    endPointer=out.getFilePointer();
    out.close();
  }
{
    IndexInput in=d.openInput("test.bin",IOContext.READONCE);
    final ForUtil forUtil=new ForUtil(in);
    for (int i=0; i < iterations; ++i) {
      if (random().nextBoolean()) {
        forUtil.skipBlock(in);
        continue;
      }
      final int[] restored=new int[MAX_DATA_SIZE];
      forUtil.readBlock(in,new byte[MAX_ENCODED_SIZE],restored);
      assertArrayEquals(Arrays.copyOfRange(values,i * BLOCK_SIZE,(i + 1) * BLOCK_SIZE),Arrays.copyOf(restored,BLOCK_SIZE));
    }
    assertEquals(endPointer,in.getFilePointer());
    in.close();
  }
}
