{
  createRandomIndex(false);
  final int iters=atLeast(3);
  for (int i=0; i < iters; ++i) {
    final IndexSearcher searcher=newSearcher(reader);
    final int numHits=TestUtil.nextInt(random(),1,numDocs);
    final Sort sort=new Sort(new SortField("ndv2",SortField.Type.LONG,false));
    final boolean fillFields=random().nextBoolean();
    final boolean trackDocScores=random().nextBoolean();
    final boolean trackMaxScore=random().nextBoolean();
    final TopFieldCollector collector1=TopFieldCollector.create(sort,numHits,fillFields,trackDocScores,trackMaxScore);
    final TopFieldCollector collector2=TopFieldCollector.create(sort,numHits,fillFields,trackDocScores,trackMaxScore);
    final Query query;
    if (random().nextBoolean()) {
      query=new TermQuery(new Term("s",RandomPicks.randomFrom(random(),terms)));
    }
 else {
      query=new MatchAllDocsQuery();
    }
    searcher.search(query,collector1);
    Sort different=new Sort(new SortField("ndv2",SortField.Type.LONG));
    searcher.search(query,new EarlyTerminatingSortingCollector(collector2,different,numHits,different){
      @Override public LeafCollector getLeafCollector(      LeafReaderContext context) throws IOException {
        final LeafCollector ret=super.getLeafCollector(context);
        assertTrue("segment should not be recognized as sorted as different sorter was used",ret.getClass() == in.getLeafCollector(context).getClass());
        return ret;
      }
    }
);
    assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());
    assertTopDocsEquals(collector1.topDocs().scoreDocs,collector2.topDocs().scoreDocs);
  }
  closeIndex();
}
