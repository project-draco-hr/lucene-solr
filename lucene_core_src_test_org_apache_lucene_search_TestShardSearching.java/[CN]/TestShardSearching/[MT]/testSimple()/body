{
  final int numNodes=TestUtil.nextInt(random(),1,10);
  final double runTimeSec=atLeast(3);
  final int minDocsToMakeTerms=TestUtil.nextInt(random(),5,20);
  final int maxSearcherAgeSeconds=TestUtil.nextInt(random(),1,3);
  if (VERBOSE) {
    System.out.println("TEST: numNodes=" + numNodes + " runTimeSec="+ runTimeSec+ " maxSearcherAgeSeconds="+ maxSearcherAgeSeconds);
  }
  start(numNodes,runTimeSec,maxSearcherAgeSeconds);
  final List<PreviousSearchState> priorSearches=new ArrayList<>();
  List<BytesRef> terms=null;
  while (System.nanoTime() < endTimeNanos) {
    final boolean doFollowon=priorSearches.size() > 0 && random().nextInt(7) == 1;
    final int myNodeID=random().nextInt(numNodes);
    final NodeState.ShardIndexSearcher localShardSearcher;
    final PreviousSearchState prevSearchState;
    if (doFollowon) {
      prevSearchState=priorSearches.get(random().nextInt(priorSearches.size()));
      if (VERBOSE) {
        System.out.println("\nTEST: follow-on query age=" + ((System.nanoTime() - prevSearchState.searchTimeNanos) / 1000000000.0));
      }
      try {
        localShardSearcher=nodes[myNodeID].acquire(prevSearchState.versions);
      }
 catch (      SearcherExpiredException see) {
        if (VERBOSE) {
          System.out.println("  searcher expired during local shard searcher init: " + see);
        }
        priorSearches.remove(prevSearchState);
        continue;
      }
    }
 else {
      if (VERBOSE) {
        System.out.println("\nTEST: fresh query");
      }
      localShardSearcher=nodes[myNodeID].acquire();
      prevSearchState=null;
    }
    final IndexReader[] subs=new IndexReader[numNodes];
    PreviousSearchState searchState=null;
    try {
      int docCount=0;
      try {
        for (int nodeID=0; nodeID < numNodes; nodeID++) {
          final long subVersion=localShardSearcher.nodeVersions[nodeID];
          final IndexSearcher sub=nodes[nodeID].searchers.acquire(subVersion);
          if (sub == null) {
            nodeID--;
            while (nodeID >= 0) {
              subs[nodeID].decRef();
              subs[nodeID]=null;
              nodeID--;
            }
            throw new SearcherExpiredException("nodeID=" + nodeID + " version="+ subVersion);
          }
          subs[nodeID]=sub.getIndexReader();
          docCount+=subs[nodeID].maxDoc();
        }
      }
 catch (      SearcherExpiredException see) {
        if (VERBOSE) {
          System.out.println("  searcher expired during mock reader init: " + see);
        }
        continue;
      }
      final IndexReader mockReader=new MultiReader(subs);
      final IndexSearcher mockSearcher=new IndexSearcher(mockReader);
      Query query;
      Sort sort;
      if (prevSearchState != null) {
        query=prevSearchState.query;
        sort=prevSearchState.sort;
      }
 else {
        if (terms == null && docCount > minDocsToMakeTerms) {
          final TermsEnum termsEnum=MultiFields.getTerms(mockReader,"body").iterator(null);
          terms=new ArrayList<>();
          while (termsEnum.next() != null) {
            terms.add(BytesRef.deepCopyOf(termsEnum.term()));
          }
          if (VERBOSE) {
            System.out.println("TEST: init terms: " + terms.size() + " terms");
          }
          if (terms.size() == 0) {
            terms=null;
          }
        }
        if (VERBOSE) {
          System.out.println("  maxDoc=" + mockReader.maxDoc());
        }
        if (terms != null) {
          if (random().nextBoolean()) {
            query=new TermQuery(new Term("body",terms.get(random().nextInt(terms.size()))));
          }
 else {
            final String t=terms.get(random().nextInt(terms.size())).utf8ToString();
            final String prefix;
            if (t.length() <= 1) {
              prefix=t;
            }
 else {
              prefix=t.substring(0,TestUtil.nextInt(random(),1,2));
            }
            query=new PrefixQuery(new Term("body",prefix));
          }
          if (random().nextBoolean()) {
            sort=null;
          }
 else {
            final int what=random().nextInt(3);
            if (what == 0) {
              sort=new Sort(SortField.FIELD_SCORE);
            }
 else             if (what == 1) {
              sort=null;
            }
 else             if (what == 2) {
              sort=new Sort(new SortField[]{new SortField("docid_int",SortField.Type.INT,random().nextBoolean())});
            }
 else {
              sort=new Sort(new SortField[]{new SortField("title",SortField.Type.STRING,random().nextBoolean())});
            }
          }
        }
 else {
          query=null;
          sort=null;
        }
      }
      if (query != null) {
        try {
          searchState=assertSame(mockSearcher,localShardSearcher,query,sort,prevSearchState);
        }
 catch (        SearcherExpiredException see) {
          if (VERBOSE) {
            System.out.println("  searcher expired during search: " + see);
            see.printStackTrace(System.out);
          }
          if (prevSearchState != null) {
            priorSearches.remove(prevSearchState);
          }
        }
      }
    }
  finally {
      nodes[myNodeID].release(localShardSearcher);
      for (      IndexReader sub : subs) {
        if (sub != null) {
          sub.decRef();
        }
      }
    }
    if (searchState != null && searchState.searchAfterLocal != null && random().nextInt(5) == 3) {
      priorSearches.add(searchState);
      if (priorSearches.size() > 200) {
        Collections.shuffle(priorSearches,random());
        priorSearches.subList(100,priorSearches.size()).clear();
      }
    }
  }
  finish();
}
