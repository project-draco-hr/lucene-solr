{
  log.info("Process current queue of overseer operations");
  LeaderStatus isLeader=amILeader();
  while (isLeader == LeaderStatus.DONT_KNOW) {
    log.debug("am_i_leader unclear {}",isLeader);
    isLeader=amILeader();
  }
  String oldestItemInWorkQueue=null;
  boolean hasLeftOverItems=true;
  try {
    oldestItemInWorkQueue=workQueue.getTailId();
  }
 catch (  KeeperException e) {
    SolrException.log(log,"",e);
  }
catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  if (oldestItemInWorkQueue == null)   hasLeftOverItems=false;
 else   log.debug("Found already existing elements in the work-queue. Last element: {}",oldestItemInWorkQueue);
  try {
    prioritizer.prioritizeOverseerNodes(myId);
  }
 catch (  Exception e) {
    log.error("Unable to prioritize overseer ",e);
  }
  this.tpe=new ExecutorUtil.MDCAwareThreadPoolExecutor(5,MAX_PARALLEL_TASKS,0L,TimeUnit.MILLISECONDS,new SynchronousQueue<Runnable>(),new DefaultSolrThreadFactory("OverseerThreadFactory"));
  try {
    while (!this.isClosed) {
      try {
        isLeader=amILeader();
        if (LeaderStatus.NO == isLeader) {
          break;
        }
 else         if (LeaderStatus.YES != isLeader) {
          log.debug("am_i_leader unclear {}",isLeader);
          continue;
        }
        log.debug("Cleaning up work-queue. #Running tasks: {}",runningTasks.size());
        cleanUpWorkQueue();
        printTrackingMaps();
        boolean waited=false;
        while (runningTasks.size() > MAX_PARALLEL_TASKS) {
synchronized (waitLock) {
            waitLock.wait(100);
          }
          waited=true;
        }
        if (waited)         cleanUpWorkQueue();
        List<QueueEvent> heads=workQueue.peekTopN(MAX_PARALLEL_TASKS,runningZKTasks,2000L);
        if (heads == null)         continue;
        log.debug("Got {} tasks from work-queue : [{}]",heads.size(),heads.toString());
        if (isClosed)         break;
        taskBatch.batchId++;
        for (        QueueEvent head : heads) {
          if (runningZKTasks.contains(head.getId()))           continue;
          final ZkNodeProps message=ZkNodeProps.load(head.getBytes());
          OverseerMessageHandler messageHandler=selector.selectOverseerMessageHandler(message);
          final String asyncId=message.getStr(ASYNC);
          if (hasLeftOverItems) {
            if (head.getId().equals(oldestItemInWorkQueue))             hasLeftOverItems=false;
            if (asyncId != null && (completedMap.contains(asyncId) || failureMap.contains(asyncId))) {
              log.debug("Found already processed task in workQueue, cleaning up. AsyncId [{}]",asyncId);
              workQueue.remove(head);
              continue;
            }
          }
          String operation=message.getStr(Overseer.QUEUE_OPERATION);
          OverseerMessageHandler.Lock lock=messageHandler.lockTask(message,taskBatch);
          if (lock == null) {
            log.debug("Exclusivity check failed for [{}]",message.toString());
            continue;
          }
          try {
            markTaskAsRunning(head,asyncId);
            log.debug("Marked task [{}] as running",head.getId());
          }
 catch (          KeeperException.NodeExistsException e) {
            lock.unlock();
            log.error("Tried to pick up task [{}] when it was already running!",head.getId());
            continue;
          }
catch (          InterruptedException e) {
            lock.unlock();
            log.error("Thread interrupted while trying to pick task for execution.",head.getId());
            Thread.currentThread().interrupt();
            continue;
          }
          log.info(messageHandler.getName() + ": Get the message id:" + head.getId()+ " message:"+ message.toString());
          Runner runner=new Runner(messageHandler,message,operation,head,lock);
          tpe.execute(runner);
        }
      }
 catch (      KeeperException e) {
        if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
          log.warn("Overseer cannot talk to ZK");
          return;
        }
        SolrException.log(log,"",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      }
catch (      Exception e) {
        SolrException.log(log,"",e);
      }
    }
  }
  finally {
    this.close();
  }
}
