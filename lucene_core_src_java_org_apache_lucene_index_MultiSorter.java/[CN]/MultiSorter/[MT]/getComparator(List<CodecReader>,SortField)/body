{
switch (sortField.getType()) {
case STRING:
{
      MultiReader multiReader=new MultiReader(readers.toArray(new LeafReader[readers.size()]));
      final SortedDocValues sorted=MultiDocValues.getSortedValues(multiReader,sortField.getField());
      final int[] docStarts=new int[readers.size()];
      List<LeafReaderContext> leaves=multiReader.leaves();
      for (int i=0; i < readers.size(); i++) {
        docStarts[i]=leaves.get(i).docBase;
      }
      final int missingOrd;
      if (sortField.getMissingValue() == SortField.STRING_LAST) {
        missingOrd=Integer.MAX_VALUE;
      }
 else {
        missingOrd=Integer.MIN_VALUE;
      }
      final int reverseMul;
      if (sortField.getReverse()) {
        reverseMul=-1;
      }
 else {
        reverseMul=1;
      }
      return new CrossReaderComparator(){
        @Override public int compare(        int readerIndexA,        int docIDA,        int readerIndexB,        int docIDB){
          int ordA=sorted.getOrd(docStarts[readerIndexA] + docIDA);
          if (ordA == -1) {
            ordA=missingOrd;
          }
          int ordB=sorted.getOrd(docStarts[readerIndexB] + docIDB);
          if (ordB == -1) {
            ordB=missingOrd;
          }
          return reverseMul * Integer.compare(ordA,ordB);
        }
      }
;
    }
case LONG:
{
    List<NumericDocValues> values=new ArrayList<>();
    List<Bits> docsWithFields=new ArrayList<>();
    for (    CodecReader reader : readers) {
      values.add(DocValues.getNumeric(reader,sortField.getField()));
      docsWithFields.add(DocValues.getDocsWithField(reader,sortField.getField()));
    }
    final int reverseMul;
    if (sortField.getReverse()) {
      reverseMul=-1;
    }
 else {
      reverseMul=1;
    }
    final long missingValue;
    if (sortField.getMissingValue() != null) {
      missingValue=(Long)sortField.getMissingValue();
    }
 else {
      missingValue=0;
    }
    return new CrossReaderComparator(){
      @Override public int compare(      int readerIndexA,      int docIDA,      int readerIndexB,      int docIDB){
        long valueA;
        if (docsWithFields.get(readerIndexA).get(docIDA)) {
          valueA=values.get(readerIndexA).get(docIDA);
        }
 else {
          valueA=missingValue;
        }
        long valueB;
        if (docsWithFields.get(readerIndexB).get(docIDB)) {
          valueB=values.get(readerIndexB).get(docIDB);
        }
 else {
          valueB=missingValue;
        }
        return reverseMul * Long.compare(valueA,valueB);
      }
    }
;
  }
case INT:
{
  List<NumericDocValues> values=new ArrayList<>();
  List<Bits> docsWithFields=new ArrayList<>();
  for (  CodecReader reader : readers) {
    values.add(DocValues.getNumeric(reader,sortField.getField()));
    docsWithFields.add(DocValues.getDocsWithField(reader,sortField.getField()));
  }
  final int reverseMul;
  if (sortField.getReverse()) {
    reverseMul=-1;
  }
 else {
    reverseMul=1;
  }
  final int missingValue;
  if (sortField.getMissingValue() != null) {
    missingValue=(Integer)sortField.getMissingValue();
  }
 else {
    missingValue=0;
  }
  return new CrossReaderComparator(){
    @Override public int compare(    int readerIndexA,    int docIDA,    int readerIndexB,    int docIDB){
      int valueA;
      if (docsWithFields.get(readerIndexA).get(docIDA)) {
        valueA=(int)values.get(readerIndexA).get(docIDA);
      }
 else {
        valueA=missingValue;
      }
      int valueB;
      if (docsWithFields.get(readerIndexB).get(docIDB)) {
        valueB=(int)values.get(readerIndexB).get(docIDB);
      }
 else {
        valueB=missingValue;
      }
      return reverseMul * Integer.compare(valueA,valueB);
    }
  }
;
}
case DOUBLE:
{
List<NumericDocValues> values=new ArrayList<>();
List<Bits> docsWithFields=new ArrayList<>();
for (CodecReader reader : readers) {
  values.add(DocValues.getNumeric(reader,sortField.getField()));
  docsWithFields.add(DocValues.getDocsWithField(reader,sortField.getField()));
}
final int reverseMul;
if (sortField.getReverse()) {
  reverseMul=-1;
}
 else {
  reverseMul=1;
}
final double missingValue;
if (sortField.getMissingValue() != null) {
  missingValue=(Double)sortField.getMissingValue();
}
 else {
  missingValue=0.0;
}
return new CrossReaderComparator(){
  @Override public int compare(  int readerIndexA,  int docIDA,  int readerIndexB,  int docIDB){
    double valueA;
    if (docsWithFields.get(readerIndexA).get(docIDA)) {
      valueA=Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));
    }
 else {
      valueA=missingValue;
    }
    double valueB;
    if (docsWithFields.get(readerIndexB).get(docIDB)) {
      valueB=Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));
    }
 else {
      valueB=missingValue;
    }
    return reverseMul * Double.compare(valueA,valueB);
  }
}
;
}
case FLOAT:
{
List<NumericDocValues> values=new ArrayList<>();
List<Bits> docsWithFields=new ArrayList<>();
for (CodecReader reader : readers) {
values.add(DocValues.getNumeric(reader,sortField.getField()));
docsWithFields.add(DocValues.getDocsWithField(reader,sortField.getField()));
}
final int reverseMul;
if (sortField.getReverse()) {
reverseMul=-1;
}
 else {
reverseMul=1;
}
final float missingValue;
if (sortField.getMissingValue() != null) {
missingValue=(Float)sortField.getMissingValue();
}
 else {
missingValue=0.0f;
}
return new CrossReaderComparator(){
@Override public int compare(int readerIndexA,int docIDA,int readerIndexB,int docIDB){
  float valueA;
  if (docsWithFields.get(readerIndexA).get(docIDA)) {
    valueA=Float.intBitsToFloat((int)values.get(readerIndexA).get(docIDA));
  }
 else {
    valueA=missingValue;
  }
  float valueB;
  if (docsWithFields.get(readerIndexB).get(docIDB)) {
    valueB=Float.intBitsToFloat((int)values.get(readerIndexB).get(docIDB));
  }
 else {
    valueB=missingValue;
  }
  return reverseMul * Float.compare(valueA,valueB);
}
}
;
}
default :
throw new IllegalArgumentException("unhandled SortField.getType()=" + sortField.getType());
}
}
