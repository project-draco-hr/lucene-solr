{
  SortField fields[]=sort.getSort();
  final CrossReaderComparator[] comparators=new CrossReaderComparator[fields.length];
  for (int i=0; i < fields.length; i++) {
    comparators[i]=getComparator(readers,fields[i]);
  }
  int leafCount=readers.size();
  PriorityQueue<LeafAndDocID> queue=new PriorityQueue<LeafAndDocID>(leafCount){
    @Override public boolean lessThan(    LeafAndDocID a,    LeafAndDocID b){
      for (int i=0; i < comparators.length; i++) {
        int cmp=comparators[i].compare(a.readerIndex,a.docID,b.readerIndex,b.docID);
        if (cmp != 0) {
          return cmp < 0;
        }
      }
      if (a.readerIndex != b.readerIndex) {
        return a.readerIndex < b.readerIndex;
      }
      return a.docID < b.docID;
    }
  }
;
  PackedLongValues.Builder[] builders=new PackedLongValues.Builder[leafCount];
  for (int i=0; i < leafCount; i++) {
    CodecReader reader=readers.get(i);
    queue.add(new LeafAndDocID(i,reader.getLiveDocs(),reader.maxDoc()));
    builders[i]=PackedLongValues.monotonicBuilder(PackedInts.COMPACT);
  }
  int mappedDocID=0;
  while (queue.size() != 0) {
    LeafAndDocID top=queue.top();
    builders[top.readerIndex].add(mappedDocID);
    if (top.liveDocs == null || top.liveDocs.get(top.docID)) {
      mappedDocID++;
    }
    top.docID++;
    if (top.docID < top.maxDoc) {
      queue.updateTop();
    }
 else {
      queue.pop();
    }
  }
  MergeState.DocMap[] docMaps=new MergeState.DocMap[leafCount];
  for (int i=0; i < leafCount; i++) {
    final PackedLongValues remapped=builders[i].build();
    final Bits liveDocs=readers.get(i).getLiveDocs();
    docMaps[i]=new MergeState.DocMap(){
      @Override public int get(      int docID){
        if (liveDocs == null || liveDocs.get(docID)) {
          return (int)remapped.get(docID);
        }
 else {
          return -1;
        }
      }
    }
;
  }
  return docMaps;
}
