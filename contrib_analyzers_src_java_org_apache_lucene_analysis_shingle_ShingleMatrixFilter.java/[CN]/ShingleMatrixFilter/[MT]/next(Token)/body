{
  if (matrix == null) {
    matrix=new Matrix();
    while (matrix.columns.size() < maximumShingleSize && readColumn()) {
    }
  }
  if (currentPermuationTokens != null) {
    currentShingleLength++;
    if (currentShingleLength + currentPermutationTokensStartOffset <= currentPermuationTokens.size() && currentShingleLength <= maximumShingleSize) {
      if (ignoringSinglePrefixOrSuffixShingle && currentShingleLength == 1 && (currentPermutationRows.get(currentPermutationTokensStartOffset).getColumn().isFirst() || currentPermutationRows.get(currentPermutationTokensStartOffset).getColumn().isLast())) {
        return next(token);
      }
      int termLength=0;
      List<Token> shingle=new ArrayList<Token>();
      for (int i=0; i < currentShingleLength; i++) {
        Token shingleToken=currentPermuationTokens.get(i + currentPermutationTokensStartOffset);
        termLength+=shingleToken.termLength();
        shingle.add(shingleToken);
      }
      if (spacerCharacter != null) {
        termLength+=currentShingleLength - 1;
      }
      if (!shinglesSeen.add(shingle)) {
        return next(token);
      }
      StringBuilder sb=new StringBuilder(termLength + 10);
      for (      Token shingleToken : shingle) {
        if (spacerCharacter != null && sb.length() > 0) {
          sb.append(spacerCharacter);
        }
        sb.append(shingleToken.termBuffer(),0,shingleToken.termLength());
      }
      token.setTermText(sb.toString());
      updateToken(token,shingle,currentPermutationTokensStartOffset,currentPermutationRows,currentPermuationTokens);
      return token;
    }
 else {
      if (currentPermutationTokensStartOffset < currentPermuationTokens.size() - 1) {
        currentPermutationTokensStartOffset++;
        currentShingleLength=minimumShingleSize - 1;
        return next(token);
      }
      if (permutations == null) {
        return null;
      }
      if (!permutations.hasNext()) {
        if (input != null && readColumn()) {
        }
        Matrix.Column deletedColumn=matrix.columns.remove(0);
        List<Token> deletedColumnTokens=new ArrayList<Token>();
        for (        Matrix.Column.Row row : deletedColumn.getRows()) {
          for (          Token shingleToken : row.getTokens()) {
            deletedColumnTokens.add(shingleToken);
          }
        }
        for (Iterator<List<Token>> shinglesSeenIterator=shinglesSeen.iterator(); shinglesSeenIterator.hasNext(); ) {
          List<Token> shingle=shinglesSeenIterator.next();
          for (          Token deletedColumnToken : deletedColumnTokens) {
            if (shingle.contains(deletedColumnToken)) {
              shinglesSeenIterator.remove();
              break;
            }
          }
        }
        if (matrix.columns.size() < minimumShingleSize) {
          return null;
        }
        permutations=matrix.permutationIterator();
      }
      nextTokensPermutation();
      return next(token);
    }
  }
  if (permutations == null) {
    permutations=matrix.permutationIterator();
  }
  if (!permutations.hasNext()) {
    return null;
  }
  nextTokensPermutation();
  return next(token);
}
