{
  final int iters=atLeast(100);
  for (int iter=0; iter < iters; ++iter) {
    final int maxDoc=TestUtil.nextInt(random(),100,10000);
    final int numIterators=TestUtil.nextInt(random(),5,10);
    final FixedBitSet[] sets=new FixedBitSet[numIterators];
    final List<Scorer> scorers=new LinkedList<>();
    for (int i=0; i < numIterators; ++i) {
      final FixedBitSet set=randomSet(maxDoc);
      if (random().nextBoolean()) {
        sets[i]=set;
        scorers.add(new ConstantScoreScorer(null,0f,new BitDocIdSet(set).iterator()));
      }
 else {
        final FixedBitSet confirmed=clearRandomBits(set);
        sets[i]=confirmed;
        final TwoPhaseIterator approximation=approximation(new BitDocIdSet(set).iterator(),confirmed);
        scorers.add(scorer(approximation));
      }
    }
    final int subIters=atLeast(3);
    for (int subIter=0; subIter < subIters && scorers.size() > 3; ++subIter) {
      final int subSeqStart=TestUtil.nextInt(random(),0,scorers.size() - 2);
      final int subSeqEnd=TestUtil.nextInt(random(),subSeqStart + 2,scorers.size());
      List<Scorer> subIterators=scorers.subList(subSeqStart,subSeqEnd);
      Scorer subConjunction;
      if (wrapWithScorer) {
        subConjunction=new ConjunctionScorer(null,subIterators,Collections.emptyList());
      }
 else {
        subConjunction=new ConstantScoreScorer(null,0f,ConjunctionDISI.intersectScorers(subIterators));
      }
      scorers.set(subSeqStart,subConjunction);
      int toRemove=subSeqEnd - subSeqStart - 1;
      while (toRemove-- > 0) {
        scorers.remove(subSeqStart + 1);
      }
    }
    if (scorers.size() == 1) {
      scorers.add(new ConstantScoreScorer(null,0f,DocIdSetIterator.all(maxDoc)));
    }
    final ConjunctionDISI conjunction=ConjunctionDISI.intersectScorers(scorers);
    assertEquals(intersect(sets),toBitSet(maxDoc,conjunction));
  }
}
