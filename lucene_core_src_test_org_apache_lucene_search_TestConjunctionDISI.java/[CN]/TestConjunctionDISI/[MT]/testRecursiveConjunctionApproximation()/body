{
  final int iters=atLeast(100);
  for (int iter=0; iter < iters; ++iter) {
    final int maxDoc=TestUtil.nextInt(random(),100,10000);
    final int numIterators=TestUtil.nextInt(random(),2,5);
    final FixedBitSet[] sets=new FixedBitSet[numIterators];
    Scorer conjunction=null;
    boolean hasApproximation=false;
    for (int i=0; i < numIterators; ++i) {
      final FixedBitSet set=randomSet(maxDoc);
      final Scorer newIterator;
      if (random().nextBoolean()) {
        sets[i]=set;
        newIterator=new ConstantScoreScorer(null,0f,new BitDocIdSet(set).iterator());
      }
 else {
        final FixedBitSet confirmed=clearRandomBits(set);
        sets[i]=confirmed;
        final TwoPhaseIterator approximation=approximation(new BitDocIdSet(set).iterator(),confirmed);
        newIterator=scorer(approximation);
        hasApproximation=true;
      }
      if (conjunction == null) {
        conjunction=newIterator;
      }
 else {
        final ConjunctionDISI conj=ConjunctionDISI.intersectScorers(Arrays.asList(conjunction,newIterator));
        conjunction=scorer(conj,conj.asTwoPhaseIterator());
      }
    }
    TwoPhaseIterator twoPhaseIterator=conjunction.twoPhaseIterator();
    assertEquals(hasApproximation,twoPhaseIterator != null);
    if (hasApproximation) {
      assertEquals(intersect(sets),toBitSet(maxDoc,TwoPhaseIterator.asDocIdSetIterator(twoPhaseIterator)));
    }
 else {
      assertEquals(intersect(sets),toBitSet(maxDoc,conjunction.iterator()));
    }
  }
}
