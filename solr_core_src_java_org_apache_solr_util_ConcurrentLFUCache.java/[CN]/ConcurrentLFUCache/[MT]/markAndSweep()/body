{
  if (!markAndSweepLock.tryLock())   return;
  try {
    long lowHitCount=this.lowHitCount;
    isCleaning=true;
    this.lowHitCount=lowHitCount;
    int sz=stats.size.get();
    if (sz <= upperWaterMark) {
      return;
    }
    int wantToRemove=sz - lowerWaterMark;
    TreeSet<CacheEntry<K,V>> tree=new TreeSet<>();
    for (    CacheEntry<K,V> ce : map.values()) {
      ce.hitsCopy=ce.hits.get();
      ce.lastAccessedCopy=ce.lastAccessed;
      if (timeDecay) {
        ce.hits.set(ce.hitsCopy >>> 1);
      }
      if (tree.size() < wantToRemove) {
        tree.add(ce);
      }
 else {
        if (tree.size() > 0) {
          if (ce.hitsCopy < tree.first().hitsCopy) {
            tree.remove(tree.first());
            tree.add(ce);
          }
 else           if (ce.hitsCopy == tree.first().hitsCopy) {
            tree.add(ce);
            tree.remove(tree.first());
          }
        }
      }
    }
    for (    CacheEntry<K,V> e : tree) {
      evictEntry(e.key);
    }
  }
  finally {
    isCleaning=false;
    markAndSweepLock.unlock();
  }
}
