{
  consumer.startDocument();
  fieldsWriter.startDocument();
  fieldCount=0;
  final int thisFieldGen=fieldGen++;
  for (  IndexableField field : docState.doc.indexableFields()) {
    final String fieldName=field.name();
    IndexableFieldType ft=field.fieldType();
    DocFieldProcessorPerField fp=processField(fieldInfos,thisFieldGen,fieldName,ft);
    fp.addField(field);
  }
  for (  StorableField field : docState.doc.storableFields()) {
    final String fieldName=field.name();
    IndexableFieldType ft=field.fieldType();
    DocFieldProcessorPerField fp=processField(fieldInfos,thisFieldGen,fieldName,ft);
    fieldsWriter.addField(field,fp.fieldInfo);
    final DocValues.Type dvType=field.fieldType().docValueType();
    if (dvType != null) {
      DocValuesConsumerHolder docValuesConsumer=docValuesConsumer(dvType,docState,fp.fieldInfo);
      DocValuesConsumer consumer=docValuesConsumer.docValuesConsumer;
      if (docValuesConsumer.compatibility == null) {
        consumer.add(docState.docID,(StorableField)field);
        docValuesConsumer.compatibility=new TypeCompatibility(dvType,consumer.getValueSize());
      }
 else       if (docValuesConsumer.compatibility.isCompatible(dvType,TypePromoter.getValueSize(dvType,field.binaryValue()))) {
        consumer.add(docState.docID,field);
      }
 else {
        docValuesConsumer.compatibility.isCompatible(dvType,TypePromoter.getValueSize(dvType,field.binaryValue()));
        TypeCompatibility compatibility=docValuesConsumer.compatibility;
        throw new IllegalArgumentException("Incompatible DocValues type: " + dvType.name() + " size: "+ TypePromoter.getValueSize(dvType,field.binaryValue())+ " expected: "+ " type: "+ compatibility.getBaseType()+ " size: "+ compatibility.getBaseSize());
      }
    }
  }
  ArrayUtil.quickSort(fields,0,fieldCount,fieldsComp);
  for (int i=0; i < fieldCount; i++) {
    final DocFieldProcessorPerField perField=fields[i];
    perField.consumer.processFields(perField.fields,perField.fieldCount);
  }
  if (docState.maxTermPrefix != null && docState.infoStream.isEnabled("IW")) {
    docState.infoStream.message("IW","WARNING: document contains at least one immense term (whose UTF8 encoding is longer than the max length " + DocumentsWriterPerThread.MAX_TERM_LENGTH_UTF8 + "), all of which were skipped.  Please correct the analyzer to not produce such terms.  The prefix of the first immense term is: '"+ docState.maxTermPrefix+ "...'");
    docState.maxTermPrefix=null;
  }
}
