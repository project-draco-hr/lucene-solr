{
  consumer.startDocument();
  fieldsWriter.startDocument();
  fieldCount=0;
  final int thisFieldGen=fieldGen++;
  for (  IndexableField field : docState.doc.indexableFields()) {
    final String fieldName=field.name();
    IndexableFieldType ft=field.fieldType();
    DocFieldProcessorPerField fp=processField(fieldInfos,thisFieldGen,fieldName,ft);
    fp.addField(field);
  }
  for (  StorableField field : docState.doc.storableFields()) {
    final String fieldName=field.name();
    IndexableFieldType ft=field.fieldType();
    DocFieldProcessorPerField fp=processField(fieldInfos,thisFieldGen,fieldName,ft);
    if (ft.stored()) {
      fieldsWriter.addField(field,fp.fieldInfo);
    }
    final DocValues.Type dvType=ft.docValueType();
    if (dvType != null) {
switch (dvType) {
case BYTES_VAR_STRAIGHT:
        fp.addBytesDVField(docState.docID,field.binaryValue());
      break;
case VAR_INTS:
case FIXED_INTS_8:
case FIXED_INTS_16:
case FIXED_INTS_32:
case FIXED_INTS_64:
    fp.addNumberDVField(docState.docID,field.numericValue());
  break;
default :
break;
}
DocValuesConsumerHolder docValuesConsumer=docValuesConsumer(dvType,docState,fp.fieldInfo);
DocValuesConsumer consumer=docValuesConsumer.docValuesConsumer;
if (docValuesConsumer.compatibility == null) {
consumer.add(docState.docID,field);
docValuesConsumer.compatibility=new TypeCompatibility(dvType,consumer.getValueSize());
}
 else if (docValuesConsumer.compatibility.isCompatible(dvType,TypePromoter.getValueSize(dvType,field.binaryValue()))) {
consumer.add(docState.docID,field);
}
 else {
docValuesConsumer.compatibility.isCompatible(dvType,TypePromoter.getValueSize(dvType,field.binaryValue()));
TypeCompatibility compatibility=docValuesConsumer.compatibility;
throw new IllegalArgumentException("Incompatible DocValues type: " + dvType.name() + " size: "+ TypePromoter.getValueSize(dvType,field.binaryValue())+ " expected: "+ " type: "+ compatibility.getBaseType()+ " size: "+ compatibility.getBaseSize());
}
}
}
ArrayUtil.quickSort(fields,0,fieldCount,fieldsComp);
for (int i=0; i < fieldCount; i++) {
final DocFieldProcessorPerField perField=fields[i];
perField.consumer.processFields(perField.fields,perField.fieldCount);
}
if (docState.maxTermPrefix != null && docState.infoStream.isEnabled("IW")) {
docState.infoStream.message("IW","WARNING: document contains at least one immense term (whose UTF8 encoding is longer than the max length " + DocumentsWriterPerThread.MAX_TERM_LENGTH_UTF8 + "), all of which were skipped.  Please correct the analyzer to not produce such terms.  The prefix of the first immense term is: '"+ docState.maxTermPrefix+ "...'");
docState.maxTermPrefix=null;
}
}
