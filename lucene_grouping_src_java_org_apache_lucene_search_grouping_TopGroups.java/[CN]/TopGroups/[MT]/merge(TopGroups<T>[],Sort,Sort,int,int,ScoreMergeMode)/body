{
  if (shardGroups.length == 0) {
    return null;
  }
  int totalHitCount=0;
  int totalGroupedHitCount=0;
  Integer totalGroupCount=null;
  final int numGroups=shardGroups[0].groups.length;
  for (  TopGroups<T> shard : shardGroups) {
    if (numGroups != shard.groups.length) {
      throw new IllegalArgumentException("number of groups differs across shards; you must pass same top groups to all shards' second-pass collector");
    }
    totalHitCount+=shard.totalHitCount;
    totalGroupedHitCount+=shard.totalGroupedHitCount;
    if (shard.totalGroupCount != null) {
      if (totalGroupCount == null) {
        totalGroupCount=0;
      }
      totalGroupCount+=shard.totalGroupCount;
    }
  }
  @SuppressWarnings({"unchecked","rawtypes"}) final GroupDocs<T>[] mergedGroupDocs=new GroupDocs[numGroups];
  final TopDocs[] shardTopDocs=new TopDocs[shardGroups.length];
  float totalMaxScore=Float.MIN_VALUE;
  for (int groupIDX=0; groupIDX < numGroups; groupIDX++) {
    final T groupValue=shardGroups[0].groups[groupIDX].groupValue;
    float maxScore=Float.MIN_VALUE;
    int totalHits=0;
    double scoreSum=0.0;
    for (int shardIDX=0; shardIDX < shardGroups.length; shardIDX++) {
      final TopGroups<T> shard=shardGroups[shardIDX];
      final GroupDocs<?> shardGroupDocs=shard.groups[groupIDX];
      if (groupValue == null) {
        if (shardGroupDocs.groupValue != null) {
          throw new IllegalArgumentException("group values differ across shards; you must pass same top groups to all shards' second-pass collector");
        }
      }
 else       if (!groupValue.equals(shardGroupDocs.groupValue)) {
        throw new IllegalArgumentException("group values differ across shards; you must pass same top groups to all shards' second-pass collector");
      }
      shardTopDocs[shardIDX]=new TopDocs(shardGroupDocs.totalHits,shardGroupDocs.scoreDocs,shardGroupDocs.maxScore);
      maxScore=Math.max(maxScore,shardGroupDocs.maxScore);
      totalHits+=shardGroupDocs.totalHits;
      scoreSum+=shardGroupDocs.score;
    }
    final TopDocs mergedTopDocs=TopDocs.merge(docSort,docOffset + docTopN,shardTopDocs);
    final ScoreDoc[] mergedScoreDocs;
    if (docOffset == 0) {
      mergedScoreDocs=mergedTopDocs.scoreDocs;
    }
 else     if (docOffset >= mergedTopDocs.scoreDocs.length) {
      mergedScoreDocs=new ScoreDoc[0];
    }
 else {
      mergedScoreDocs=new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];
      System.arraycopy(mergedTopDocs.scoreDocs,docOffset,mergedScoreDocs,0,mergedTopDocs.scoreDocs.length - docOffset);
    }
    final float groupScore;
switch (scoreMergeMode) {
case None:
      groupScore=Float.NaN;
    break;
case Avg:
  if (totalHits > 0) {
    groupScore=(float)(scoreSum / totalHits);
  }
 else {
    groupScore=Float.NaN;
  }
break;
case Total:
groupScore=(float)scoreSum;
break;
default :
throw new IllegalArgumentException("can't handle ScoreMergeMode " + scoreMergeMode);
}
mergedGroupDocs[groupIDX]=new GroupDocs<>(groupScore,maxScore,totalHits,mergedScoreDocs,groupValue,shardGroups[0].groups[groupIDX].groupSortValues);
totalMaxScore=Math.max(totalMaxScore,maxScore);
}
if (totalGroupCount != null) {
TopGroups<T> result=new TopGroups<>(groupSort.getSort(),docSort == null ? null : docSort.getSort(),totalHitCount,totalGroupedHitCount,mergedGroupDocs,totalMaxScore);
return new TopGroups<>(result,totalGroupCount);
}
 else {
return new TopGroups<>(groupSort.getSort(),docSort == null ? null : docSort.getSort(),totalHitCount,totalGroupedHitCount,mergedGroupDocs,totalMaxScore);
}
}
