{
  Exception e1=res.getException();
  if (e1 != null) {
    if (!(e1 instanceof IgnoreException)) {
      writeException(e1,writer,false);
    }
    return;
  }
  SolrRequestInfo info=SolrRequestInfo.getRequestInfo();
  SortSpec sortSpec=info.getResponseBuilder().getSortSpec();
  Exception exception=null;
  if (sortSpec == null) {
    exception=new IOException(new SyntaxError("No sort criteria was provided."));
  }
  SolrIndexSearcher searcher=req.getSearcher();
  Sort sort=searcher.weightSort(sortSpec.getSort());
  if (sort == null) {
    exception=new IOException(new SyntaxError("No sort criteria was provided."));
  }
  if (sort.needsScores()) {
    exception=new IOException(new SyntaxError("Scoring is not currently supported with xsort."));
  }
  FixedBitSet[] sets=(FixedBitSet[])req.getContext().get("export");
  Integer th=(Integer)req.getContext().get("totalHits");
  if (sets == null) {
    exception=new IOException(new SyntaxError("xport RankQuery is required for xsort: rq={!xport}"));
  }
  int totalHits=th.intValue();
  SolrParams params=req.getParams();
  String fl=params.get("fl");
  if (fl == null) {
    exception=new IOException(new SyntaxError("export field list (fl) must be specified."));
  }
  String[] fields=fl.split(",");
  for (int i=0; i < fields.length; i++) {
    if (fl.trim().equals("score")) {
      exception=new IOException(new SyntaxError("Scoring is not currently supported with xsort."));
      break;
    }
  }
  FieldWriter[] fieldWriters=null;
  try {
    fieldWriters=getFieldWriters(fields,req.getSearcher());
  }
 catch (  Exception e) {
    exception=e;
  }
  if (exception != null) {
    writeException(exception,writer,true);
    return;
  }
  writer.write("{\"responseHeader\": {\"status\": 0}, \"response\":{\"numFound\":" + totalHits + ", \"docs\":[");
  List<LeafReaderContext> leaves=req.getSearcher().getTopReaderContext().leaves();
  SortDoc sortDoc=getSortDoc(req.getSearcher(),sort.getSort());
  int count=0;
  int queueSize=30000;
  SortQueue queue=new SortQueue(queueSize,sortDoc);
  SortDoc[] outDocs=new SortDoc[queueSize];
  boolean commaNeeded=false;
  while (count < totalHits) {
    queue.reset();
    SortDoc top=queue.top();
    for (int i=0; i < leaves.size(); i++) {
      sortDoc.setNextReader(leaves.get(i));
      DocIdSetIterator it=new BitSetIterator(sets[i],0);
      int docId=-1;
      while ((docId=it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
        sortDoc.setValues(docId);
        if (top.lessThan(sortDoc)) {
          top.setValues(sortDoc);
          top=queue.updateTop();
        }
      }
    }
    int outDocsIndex=-1;
    for (int i=0; i < queueSize; i++) {
      SortDoc s=queue.pop();
      if (s.docId > -1) {
        outDocs[++outDocsIndex]=s;
      }
    }
    count+=(outDocsIndex + 1);
    try {
      for (int i=outDocsIndex; i >= 0; --i) {
        SortDoc s=outDocs[i];
        if (commaNeeded) {
          writer.write(',');
        }
        writer.write('{');
        writeDoc(s,leaves,fieldWriters,sets,writer);
        writer.write('}');
        commaNeeded=true;
        s.reset();
      }
    }
 catch (    Throwable e) {
      Throwable ex=e;
      e.printStackTrace();
      while (ex != null) {
        String m=ex.getMessage();
        if (m != null && m.contains("Broken pipe")) {
          throw new IgnoreException();
        }
        ex=ex.getCause();
      }
      if (e instanceof IOException) {
        throw ((IOException)e);
      }
 else {
        throw new IOException(e);
      }
    }
  }
  writer.write("]}}");
  writer.flush();
}
