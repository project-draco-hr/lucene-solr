{
  this.core=core;
  registerFileStreamResponseWriter();
  registerCloseHook();
  NamedList slave=(NamedList)initArgs.get("slave");
  boolean enableSlave=slave != null && (null == slave.get("enable") || "true".equals(slave.get("enable")));
  if (enableSlave) {
    tempSnapPuller=snapPuller=new SnapPuller(slave,this,core);
    isSlave=true;
  }
  NamedList master=(NamedList)initArgs.get("master");
  boolean enableMaster=master != null && (null == master.get("enable") || "true".equals(master.get("enable")));
  if (enableMaster) {
    includeConfFiles=(String)master.get(CONF_FILES);
    if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {
      List<String> files=Arrays.asList(includeConfFiles.split(","));
      for (      String file : files) {
        if (file.trim().length() == 0)         continue;
        String[] strs=file.split(":");
        confFileNameAlias.add(strs[0],strs.length > 1 ? strs[1] : null);
      }
      LOG.info("Replication enabled for following config files: " + includeConfFiles);
    }
    List backup=master.getAll("backupAfter");
    boolean backupOnCommit=backup.contains("commit");
    boolean backupOnOptimize=backup.contains("optimize");
    List replicateAfter=master.getAll(REPLICATE_AFTER);
    replicateOnCommit=replicateAfter.contains("commit");
    replicateOnOptimize=replicateAfter.contains("optimize");
    if (replicateOnOptimize || backupOnOptimize) {
      core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize,replicateOnOptimize));
    }
    if (replicateOnCommit || backupOnCommit) {
      replicateOnCommit=true;
      core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit,replicateOnCommit));
    }
    if (replicateAfter.contains("startup")) {
      replicateOnStart=true;
      RefCounted<SolrIndexSearcher> s=core.getNewestSearcher(false);
      try {
        if (core.getUpdateHandler() instanceof DirectUpdateHandler2) {
          ((DirectUpdateHandler2)core.getUpdateHandler()).forceOpenWriter();
        }
 else {
          LOG.warn("The update handler being used is not an instance or sub-class of DirectUpdateHandler2. " + "Replicate on Startup cannot work.");
        }
        if (s.get().getReader().getIndexCommit() != null)         if (s.get().getReader().getIndexCommit().getGeneration() != 1L)         indexCommitPoint=s.get().getReader().getIndexCommit();
      }
 catch (      IOException e) {
        LOG.warn("Unable to get IndexCommit on startup",e);
      }
 finally {
        s.decref();
      }
    }
    String reserve=(String)master.get(RESERVE);
    if (reserve != null && !reserve.trim().equals("")) {
      reserveCommitDuration=SnapPuller.readInterval(reserve);
    }
    LOG.info("Commits will be reserved for  " + reserveCommitDuration);
    isMaster=true;
  }
}
