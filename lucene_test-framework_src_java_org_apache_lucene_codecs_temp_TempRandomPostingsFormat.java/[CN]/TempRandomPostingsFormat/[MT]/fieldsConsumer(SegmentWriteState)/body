{
  int minSkipInterval;
  if (state.segmentInfo.getDocCount() > 1000000) {
    minSkipInterval=3;
  }
 else {
    minSkipInterval=2;
  }
  int skipInterval=_TestUtil.nextInt(seedRandom,minSkipInterval,10);
  if (LuceneTestCase.VERBOSE) {
    System.out.println("MockRandomCodec: skipInterval=" + skipInterval);
  }
  final long seed=seedRandom.nextLong();
  if (LuceneTestCase.VERBOSE) {
    System.out.println("MockRandomCodec: writing to seg=" + state.segmentInfo.name + " formatID="+ state.segmentSuffix+ " seed="+ seed);
  }
  final String seedFileName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,SEED_EXT);
  final IndexOutput out=state.directory.createOutput(seedFileName,state.context);
  try {
    out.writeLong(seed);
  }
  finally {
    out.close();
  }
  final Random random=new Random(seed);
  random.nextInt();
  TempPostingsWriterBase postingsWriter;
  if (random.nextBoolean()) {
    postingsWriter=new TempSepPostingsWriter(state,new MockIntStreamFactory(random),skipInterval);
  }
 else {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing Standard postings");
    }
    postingsWriter=new TempPostingsWriter(state,skipInterval);
  }
  if (random.nextBoolean()) {
    final int totTFCutoff=_TestUtil.nextInt(random,1,20);
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing pulsing postings with totTFCutoff=" + totTFCutoff);
    }
    postingsWriter=new TempPulsingPostingsWriter(state,totTFCutoff,postingsWriter);
  }
  final FieldsConsumer fields;
  final int t1=random.nextInt(4);
  if (t1 == 0) {
    boolean success=false;
    try {
      fields=new TempFSTTermsWriter(state,postingsWriter);
      success=true;
    }
  finally {
      if (!success) {
        postingsWriter.close();
      }
    }
  }
 else   if (t1 == 1) {
    boolean success=false;
    try {
      fields=new TempFSTOrdTermsWriter(state,postingsWriter);
      success=true;
    }
  finally {
      if (!success) {
        postingsWriter.close();
      }
    }
  }
 else   if (t1 == 2) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing BlockTree terms dict");
    }
    final int minTermsInBlock=_TestUtil.nextInt(random,2,100);
    final int maxTermsInBlock=Math.max(2,(minTermsInBlock - 1) * 2 + random.nextInt(100));
    boolean success=false;
    try {
      fields=new TempBlockTreeTermsWriter(state,postingsWriter,minTermsInBlock,maxTermsInBlock);
      success=true;
    }
  finally {
      if (!success) {
        postingsWriter.close();
      }
    }
  }
 else {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockRandomCodec: writing Block terms dict");
    }
    boolean success=false;
    final TermsIndexWriterBase indexWriter;
    try {
      if (random.nextBoolean()) {
        int termIndexInterval=_TestUtil.nextInt(random,1,100);
        if (LuceneTestCase.VERBOSE) {
          System.out.println("MockRandomCodec: fixed-gap terms index (tii=" + termIndexInterval + ")");
        }
        indexWriter=new FixedGapTermsIndexWriter(state,termIndexInterval);
      }
 else {
        final VariableGapTermsIndexWriter.IndexTermSelector selector;
        final int n2=random.nextInt(3);
        if (n2 == 0) {
          final int tii=_TestUtil.nextInt(random,1,100);
          selector=new VariableGapTermsIndexWriter.EveryNTermSelector(tii);
          if (LuceneTestCase.VERBOSE) {
            System.out.println("MockRandomCodec: variable-gap terms index (tii=" + tii + ")");
          }
        }
 else         if (n2 == 1) {
          final int docFreqThresh=_TestUtil.nextInt(random,2,100);
          final int tii=_TestUtil.nextInt(random,1,100);
          selector=new VariableGapTermsIndexWriter.EveryNOrDocFreqTermSelector(docFreqThresh,tii);
        }
 else {
          final long seed2=random.nextLong();
          final int gap=_TestUtil.nextInt(random,2,40);
          if (LuceneTestCase.VERBOSE) {
            System.out.println("MockRandomCodec: random-gap terms index (max gap=" + gap + ")");
          }
          selector=new VariableGapTermsIndexWriter.IndexTermSelector(){
            final Random rand=new Random(seed2);
            @Override public boolean isIndexTerm(            BytesRef term,            TermStats stats){
              return rand.nextInt(gap) == gap / 2;
            }
            @Override public void newField(            FieldInfo fieldInfo){
            }
          }
;
        }
        indexWriter=new VariableGapTermsIndexWriter(state,selector);
      }
      success=true;
    }
  finally {
      if (!success) {
        postingsWriter.close();
      }
    }
    success=false;
    try {
      fields=new TempBlockTermsWriter(indexWriter,state,postingsWriter);
      success=true;
    }
  finally {
      if (!success) {
        try {
          postingsWriter.close();
        }
  finally {
          indexWriter.close();
        }
      }
    }
  }
  return fields;
}
