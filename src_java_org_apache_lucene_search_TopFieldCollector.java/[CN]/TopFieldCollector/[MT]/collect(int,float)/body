{
  if (score > 0.0f) {
    maxScore=Math.max(maxScore,score);
    totalHits++;
    if (queueFull) {
      if (numComparators == 1) {
        final int cmp=reverseMul1 * comparator1.compareBottom(doc,score);
        if (cmp < 0) {
          return;
        }
 else         if (cmp == 0 && doc + currentDocBase > bottom.docID) {
          return;
        }
        comparator1.copy(bottom.slot,doc,score);
        updateBottom(doc,score);
        comparator1.setBottom(bottom.slot);
      }
 else {
        for (int i=0; ; i++) {
          final int c=reverseMul[i] * comparators[i].compareBottom(doc,score);
          if (c < 0) {
            return;
          }
 else           if (c > 0) {
            break;
          }
 else           if (i == numComparators - 1) {
            if (doc + currentDocBase > bottom.docID) {
              return;
            }
 else {
              break;
            }
          }
        }
        for (int i=0; i < numComparators; i++) {
          comparators[i].copy(bottom.slot,doc,score);
        }
        updateBottom(doc,score);
        for (int i=0; i < numComparators; i++) {
          comparators[i].setBottom(bottom.slot);
        }
      }
    }
 else {
      final int slot=totalHits - 1;
      if (numComparators == 1) {
        comparator1.copy(slot,doc,score);
        add(slot,doc,score);
        if (queueFull) {
          comparator1.setBottom(bottom.slot);
        }
      }
 else {
        for (int i=0; i < numComparators; i++) {
          comparators[i].copy(slot,doc,score);
        }
        add(slot,doc,score);
        if (queueFull) {
          for (int i=0; i < numComparators; i++) {
            comparators[i].setBottom(bottom.slot);
          }
        }
      }
    }
  }
}
