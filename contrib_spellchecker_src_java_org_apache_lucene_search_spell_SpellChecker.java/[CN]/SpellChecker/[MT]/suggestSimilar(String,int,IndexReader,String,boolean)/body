{
  float min=this.minScore;
  final TRStringDistance sd=new TRStringDistance(word);
  final int lengthWord=word.length();
  final int goalFreq=(morePopular && ir != null) ? ir.docFreq(new Term(field,word)) : 0;
  if (!morePopular && goalFreq > 0) {
    return new String[]{word};
  }
  BooleanQuery query=new BooleanQuery();
  String[] grams;
  String key;
  for (int ng=getMin(lengthWord); ng <= getMax(lengthWord); ng++) {
    key="gram" + ng;
    grams=formGrams(word,ng);
    if (grams.length == 0) {
      continue;
    }
    if (bStart > 0) {
      add(query,"start" + ng,grams[0],bStart);
    }
    if (bEnd > 0) {
      add(query,"end" + ng,grams[grams.length - 1],bEnd);
    }
    for (int i=0; i < grams.length; i++) {
      add(query,key,grams[i]);
    }
  }
  Hits hits=searcher.search(query);
  SuggestWordQueue sugQueue=new SuggestWordQueue(numSug);
  int stop=Math.min(hits.length(),10 * numSug);
  SuggestWord sugWord=new SuggestWord();
  for (int i=0; i < stop; i++) {
    sugWord.string=hits.doc(i).get(F_WORD);
    if (sugWord.string.equals(word)) {
      continue;
    }
    sugWord.score=1.0f - ((float)sd.getDistance(sugWord.string) / Math.min(sugWord.string.length(),lengthWord));
    if (sugWord.score < min) {
      continue;
    }
    if (ir != null) {
      sugWord.freq=ir.docFreq(new Term(field,sugWord.string));
      if ((morePopular && goalFreq > sugWord.freq) || sugWord.freq < 1) {
        continue;
      }
    }
    sugQueue.insert(sugWord);
    if (sugQueue.size() == numSug) {
      min=((SuggestWord)sugQueue.top()).score;
    }
    sugWord=new SuggestWord();
  }
  String[] list=new String[sugQueue.size()];
  for (int i=sugQueue.size() - 1; i >= 0; i--) {
    list[i]=((SuggestWord)sugQueue.pop()).string;
  }
  return list;
}
