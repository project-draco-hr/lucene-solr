{
  final int ncats=atLeast(100000);
  final int range=ncats * 3;
  final AtomicInteger numCats=new AtomicInteger(ncats);
  final Directory dir=newDirectory();
  final ConcurrentHashMap<String,String> values=new ConcurrentHashMap<String,String>();
  final double d=random().nextDouble();
  final TaxonomyWriterCache cache;
  if (d < 0.7) {
    cache=new Cl2oTaxonomyWriterCache(1024,0.15f,3);
  }
 else   if (TEST_NIGHTLY && d > 0.98) {
    cache=NO_OP_CACHE;
  }
 else {
    cache=new LruTaxonomyWriterCache(ncats / 10);
  }
  if (VERBOSE) {
    System.out.println("TEST: use cache=" + cache);
  }
  final DirectoryTaxonomyWriter tw=new DirectoryTaxonomyWriter(dir,OpenMode.CREATE,cache);
  Thread[] addThreads=new Thread[atLeast(4)];
  for (int z=0; z < addThreads.length; z++) {
    addThreads[z]=new Thread(){
      @Override public void run(){
        Random random=random();
        while (numCats.decrementAndGet() > 0) {
          try {
            int value=random.nextInt(range);
            FacetLabel cp=new FacetLabel(Integer.toString(value / 1000),Integer.toString(value / 10000),Integer.toString(value / 100000),Integer.toString(value));
            int ord=tw.addCategory(cp);
            assertTrue("invalid parent for ordinal " + ord + ", category "+ cp,tw.getParent(ord) != -1);
            String l1=FacetsConfig.pathToString(cp.components,1);
            String l2=FacetsConfig.pathToString(cp.components,2);
            String l3=FacetsConfig.pathToString(cp.components,3);
            String l4=FacetsConfig.pathToString(cp.components,4);
            values.put(l1,l1);
            values.put(l2,l2);
            values.put(l3,l3);
            values.put(l4,l4);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
;
  }
  for (  Thread t : addThreads)   t.start();
  for (  Thread t : addThreads)   t.join();
  tw.close();
  DirectoryTaxonomyReader dtr=new DirectoryTaxonomyReader(dir);
  if (values.size() + 1 != dtr.getSize()) {
    for (    String value : values.keySet()) {
      FacetLabel label=new FacetLabel(FacetsConfig.stringToPath(value));
      if (dtr.getOrdinal(label) == -1) {
        System.out.println("FAIL: path=" + label + " not recognized");
      }
    }
    fail("mismatch number of categories");
  }
  int[] parents=dtr.getParallelTaxonomyArrays().parents();
  for (  String cat : values.keySet()) {
    FacetLabel cp=new FacetLabel(FacetsConfig.stringToPath(cat));
    assertTrue("category not found " + cp,dtr.getOrdinal(cp) > 0);
    int level=cp.length;
    int parentOrd=0;
    FacetLabel path=new FacetLabel();
    for (int i=0; i < level; i++) {
      path=cp.subpath(i + 1);
      int ord=dtr.getOrdinal(path);
      assertEquals("invalid parent for cp=" + path,parentOrd,parents[ord]);
      parentOrd=ord;
    }
  }
  IOUtils.close(dtr,dir);
}
