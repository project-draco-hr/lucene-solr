{
  final int ncats=atLeast(100000);
  final int range=ncats * 3;
  final AtomicInteger numCats=new AtomicInteger(ncats);
  final Directory dir=newDirectory();
  final ConcurrentHashMap<String,String> values=new ConcurrentHashMap<String,String>();
  final double d=random().nextDouble();
  final TaxonomyWriterCache cache;
  if (d < 0.7) {
    cache=new Cl2oTaxonomyWriterCache(1024,0.15f,3);
  }
 else   if (TEST_NIGHTLY && d > 0.98) {
    cache=NO_OP_CACHE;
  }
 else {
    cache=new LruTaxonomyWriterCache(ncats / 10);
  }
  final DirectoryTaxonomyWriter tw=new DirectoryTaxonomyWriter(dir,OpenMode.CREATE,cache);
  Thread[] addThreads=new Thread[atLeast(4)];
  for (int z=0; z < addThreads.length; z++) {
    addThreads[z]=new Thread(){
      @Override public void run(){
        Random random=random();
        while (numCats.decrementAndGet() > 0) {
          try {
            int value=random.nextInt(range);
            CategoryPath cp=new CategoryPath(Integer.toString(value / 1000),Integer.toString(value / 10000),Integer.toString(value / 100000),Integer.toString(value));
            int ord=tw.addCategory(cp);
            assertTrue("invalid parent for ordinal " + ord + ", category "+ cp,tw.getParent(ord) != -1);
            String l1=cp.toString('/',1);
            String l2=cp.toString('/',2);
            String l3=cp.toString('/',3);
            String l4=cp.toString('/',4);
            values.put(l1,l1);
            values.put(l2,l2);
            values.put(l3,l3);
            values.put(l4,l4);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
;
  }
  for (  Thread t : addThreads)   t.start();
  for (  Thread t : addThreads)   t.join();
  tw.close();
  DirectoryTaxonomyReader dtr=new DirectoryTaxonomyReader(dir);
  assertEquals("mismatch number of categories",values.size() + 1,dtr.getSize());
  int[] parents=dtr.getParallelTaxonomyArrays().parents();
  for (  String cat : values.keySet()) {
    CategoryPath cp=new CategoryPath(cat,'/');
    assertTrue("category not found " + cp,dtr.getOrdinal(cp) > 0);
    int level=cp.length();
    int parentOrd=0;
    CategoryPath path=new CategoryPath();
    for (int i=0; i < level; i++) {
      path.add(cp.getComponent(i));
      int ord=dtr.getOrdinal(path);
      assertEquals("invalid parent for cp=" + path,parentOrd,parents[ord]);
      parentOrd=ord;
    }
  }
  dtr.close();
  dir.close();
}
