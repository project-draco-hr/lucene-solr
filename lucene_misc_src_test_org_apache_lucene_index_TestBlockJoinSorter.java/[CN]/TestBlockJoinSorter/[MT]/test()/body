{
  final int numParents=atLeast(200);
  IndexWriterConfig cfg=newIndexWriterConfig(new MockAnalyzer(random()));
  cfg.setMergePolicy(newLogMergePolicy());
  final RandomIndexWriter writer=new RandomIndexWriter(random(),newDirectory(),cfg);
  final Document parentDoc=new Document();
  final NumericDocValuesField parentVal=new NumericDocValuesField("parent_val",0L);
  parentDoc.add(parentVal);
  final StringField parent=new StringField("parent","true",Store.YES);
  parentDoc.add(parent);
  for (int i=0; i < numParents; ++i) {
    List<Document> documents=new ArrayList<>();
    final int numChildren=random().nextInt(10);
    for (int j=0; j < numChildren; ++j) {
      final Document childDoc=new Document();
      childDoc.add(new NumericDocValuesField("child_val",random().nextInt(5)));
      documents.add(childDoc);
    }
    parentVal.setLongValue(random().nextInt(50));
    documents.add(parentDoc);
    writer.addDocuments(documents);
  }
  writer.forceMerge(1);
  final DirectoryReader indexReader=writer.getReader();
  writer.close();
  final LeafReader reader=getOnlySegmentReader(indexReader);
  final Filter parentsFilter=new BitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("parent","true"))));
  final FixedBitSet parentBits=(FixedBitSet)parentsFilter.getDocIdSet(reader.getContext(),null).bits();
  final NumericDocValues parentValues=reader.getNumericDocValues("parent_val");
  final NumericDocValues childValues=reader.getNumericDocValues("child_val");
  final Sort parentSort=new Sort(new SortField("parent_val",SortField.Type.LONG));
  final Sort childSort=new Sort(new SortField("child_val",SortField.Type.LONG));
  final Sort sort=new Sort(new SortField("custom",new BlockJoinComparatorSource(parentsFilter,parentSort,childSort)));
  final Sorter sorter=new Sorter(sort);
  final Sorter.DocMap docMap=sorter.sort(reader);
  assertEquals(reader.maxDoc(),docMap.size());
  int[] children=new int[1];
  int numChildren=0;
  int previousParent=-1;
  for (int i=0; i < docMap.size(); ++i) {
    final int oldID=docMap.newToOld(i);
    if (parentBits.get(oldID)) {
      for (int j=0; j < numChildren; ++j) {
        assertEquals(oldID,parentBits.nextSetBit(children[j]));
      }
      for (int j=1; j < numChildren; ++j) {
        final int doc1=children[j - 1];
        final int doc2=children[j];
        if (childValues.get(doc1) == childValues.get(doc2)) {
          assertTrue(doc1 < doc2);
        }
 else {
          assertTrue(childValues.get(doc1) < childValues.get(doc2));
        }
      }
      if (previousParent != -1) {
        if (parentValues.get(previousParent) == parentValues.get(oldID)) {
          assertTrue(previousParent < oldID);
        }
 else {
          assertTrue(parentValues.get(previousParent) < parentValues.get(oldID));
        }
      }
      previousParent=oldID;
      numChildren=0;
    }
 else {
      children=ArrayUtil.grow(children,numChildren + 1);
      children[numChildren++]=oldID;
    }
  }
  indexReader.close();
  writer.w.getDirectory().close();
}
