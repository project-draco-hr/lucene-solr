{
  final float maxDiff=1e-5f;
  final int lastDoc[]={-1};
  s.search(q,new Collector(){
    private Scorer scorer;
    private IndexReader reader;
    public void setScorer(    Scorer scorer) throws IOException {
      this.scorer=scorer;
    }
    public void collect(    int doc) throws IOException {
      float score=scorer.score();
      try {
        for (int i=lastDoc[0] + 1; i <= doc; i++) {
          Weight w=q.weight(s);
          Scorer scorer=w.scorer(reader,true,false);
          Assert.assertTrue("query collected " + doc + " but skipTo("+ i+ ") says no more docs!",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);
          Assert.assertEquals("query collected " + doc + " but skipTo("+ i+ ") got to "+ scorer.docID(),doc,scorer.docID());
          float skipToScore=scorer.score();
          Assert.assertEquals("unstable skipTo(" + i + ") score!",skipToScore,scorer.score(),maxDiff);
          Assert.assertEquals("query assigned doc " + doc + " a score of <"+ score+ "> but skipTo("+ i+ ") has <"+ skipToScore+ ">!",score,skipToScore,maxDiff);
        }
        lastDoc[0]=doc;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    public void setNextReader(    IndexReader reader,    int docBase){
      this.reader=reader;
      lastDoc[0]=-1;
    }
    public boolean acceptsDocsOutOfOrder(){
      return false;
    }
  }
);
  List readerList=new ArrayList();
  ReaderUtil.gatherSubReaders(readerList,s.getIndexReader());
  IndexReader[] readers=(IndexReader[])readerList.toArray(new IndexReader[0]);
  for (int i=0; i < readers.length; i++) {
    IndexReader reader=readers[i];
    Weight w=q.weight(s);
    Scorer scorer=w.scorer(reader,true,false);
    if (scorer != null) {
      boolean more=scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
      if (more && lastDoc[0] != -1)       Assert.assertFalse("query's last doc was " + lastDoc[0] + " but skipTo("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
    }
  }
}
