{
  final float maxDiff=1e-5f;
  final int lastDoc[]={-1};
  s.search(q,new Collector(){
    private int base=0;
    private Scorer scorer;
    public void setScorer(    Scorer scorer) throws IOException {
      this.scorer=scorer;
    }
    public void collect(    int doc) throws IOException {
      doc=doc + base;
      float score=scorer.score();
      try {
        for (int i=lastDoc[0] + 1; i <= doc; i++) {
          QueryWeight w=q.queryWeight(s);
          Scorer scorer=w.scorer(s.getIndexReader(),true,false);
          Assert.assertTrue("query collected " + doc + " but skipTo("+ i+ ") says no more docs!",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);
          Assert.assertEquals("query collected " + doc + " but skipTo("+ i+ ") got to "+ scorer.docID(),doc,scorer.docID());
          float skipToScore=scorer.score();
          Assert.assertEquals("unstable skipTo(" + i + ") score!",skipToScore,scorer.score(),maxDiff);
          Assert.assertEquals("query assigned doc " + doc + " a score of <"+ score+ "> but skipTo("+ i+ ") has <"+ skipToScore+ ">!",score,skipToScore,maxDiff);
        }
        lastDoc[0]=doc;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    public void setNextReader(    IndexReader reader,    int docBase){
      base=docBase;
    }
    public boolean acceptsDocsOutOfOrder(){
      return false;
    }
  }
);
  QueryWeight w=q.queryWeight(s);
  Scorer scorer=w.scorer(s.getIndexReader(),true,false);
  boolean more=scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
  if (more)   Assert.assertFalse("query's last doc was " + lastDoc[0] + " but skipTo("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
}
