{
  if (BooleanQuery.getUseScorer14())   return;
  final int skip_op=0;
  final int next_op=1;
  final int orders[][]={{skip_op},{next_op},{skip_op,next_op},{next_op,skip_op},{skip_op,skip_op,next_op,next_op},{next_op,next_op,skip_op,skip_op},{skip_op,skip_op,skip_op,next_op,next_op}};
  for (int k=0; k < orders.length; k++) {
    final int order[]=orders[k];
    final int opidx[]={0};
    final Weight w=q.weight(s);
    final Scorer scorer=w.scorer(s.getIndexReader());
    if (scorer instanceof BooleanScorer || scorer instanceof BooleanScorer2) {
      return;
    }
    final int[] sdoc=new int[]{-1};
    final float maxDiff=1e-5f;
    s.search(q,new HitCollector(){
      public void collect(      int doc,      float score){
        try {
          int op=order[(opidx[0]++) % order.length];
          boolean more=op == skip_op ? scorer.skipTo(sdoc[0] + 1) : scorer.next();
          sdoc[0]=scorer.doc();
          float scorerScore=scorer.score();
          float scoreDiff=Math.abs(score - scorerScore);
          if (more == false || doc != sdoc[0] || scoreDiff > maxDiff) {
            StringBuffer sbord=new StringBuffer();
            for (int i=0; i < order.length; i++)             sbord.append(order[i] == skip_op ? " skip()" : " next()");
            throw new RuntimeException("ERROR matching docs:" + "\n\tscorer.more=" + more + " doc="+ sdoc[0]+ " scorerScore="+ scorerScore+ " scoreDiff="+ scoreDiff+ " maxDiff="+ maxDiff+ "\n\thitCollector.doc="+ doc+ " score="+ score+ "\n\t Scorer="+ scorer+ "\n\t Query="+ q+ "\n\t Searcher="+ s+ "\n\t Order="+ sbord);
          }
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
);
    int op=order[(opidx[0]++) % order.length];
    boolean more=op == skip_op ? scorer.skipTo(sdoc[0] + 1) : scorer.next();
    TestCase.assertFalse(more);
  }
}
