{
  if (BooleanQuery.getAllowDocsOutOfOrder())   return;
  final int skip_op=0;
  final int next_op=1;
  final int orders[][]={{next_op},{skip_op},{skip_op,next_op},{next_op,skip_op},{skip_op,skip_op,next_op,next_op},{next_op,next_op,skip_op,skip_op},{skip_op,skip_op,skip_op,next_op,next_op}};
  for (int k=0; k < orders.length; k++) {
    final int order[]=orders[k];
    final int opidx[]={0};
    final QueryWeight w=q.queryWeight(s);
    final Scorer scorer=w.scorer(s.getIndexReader(),true,false);
    final int[] sdoc=new int[]{-1};
    final float maxDiff=1e-5f;
    s.search(q,new Collector(){
      private int base=0;
      private Scorer sc;
      public void setScorer(      Scorer scorer) throws IOException {
        this.sc=scorer;
      }
      public void collect(      int doc) throws IOException {
        doc=doc + base;
        float score=sc.score();
        try {
          int op=order[(opidx[0]++) % order.length];
          boolean more=op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;
          sdoc[0]=scorer.docID();
          float scorerScore=scorer.score();
          float scorerScore2=scorer.score();
          float scoreDiff=Math.abs(score - scorerScore);
          float scorerDiff=Math.abs(scorerScore2 - scorerScore);
          if (!more || doc != sdoc[0] || scoreDiff > maxDiff || scorerDiff > maxDiff) {
            StringBuffer sbord=new StringBuffer();
            for (int i=0; i < order.length; i++)             sbord.append(order[i] == skip_op ? " skip()" : " next()");
            throw new RuntimeException("ERROR matching docs:" + "\n\t" + (doc != sdoc[0] ? "--> " : "") + "doc="+ sdoc[0]+ "\n\t"+ (!more ? "--> " : "")+ "tscorer.more="+ more+ "\n\t"+ (scoreDiff > maxDiff ? "--> " : "")+ "scorerScore="+ scorerScore+ " scoreDiff="+ scoreDiff+ " maxDiff="+ maxDiff+ "\n\t"+ (scorerDiff > maxDiff ? "--> " : "")+ "scorerScore2="+ scorerScore2+ " scorerDiff="+ scorerDiff+ "\n\thitCollector.doc="+ doc+ " score="+ score+ "\n\t Scorer="+ scorer+ "\n\t Query="+ q+ "  "+ q.getClass().getName()+ "\n\t Searcher="+ s+ "\n\t Order="+ sbord+ "\n\t Op="+ (op == skip_op ? " skip()" : " next()"));
          }
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      public void setNextReader(      IndexReader reader,      int docBase){
        base=docBase;
      }
      public boolean acceptsDocsOutOfOrder(){
        return true;
      }
    }
);
    int op=order[(opidx[0]++) % order.length];
    boolean more=(op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;
    Assert.assertFalse(more);
  }
}
