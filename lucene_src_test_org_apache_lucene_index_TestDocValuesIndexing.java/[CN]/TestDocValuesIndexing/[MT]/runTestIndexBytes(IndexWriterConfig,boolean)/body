{
  final Directory d=newDirectory();
  IndexWriter w=new IndexWriter(d,cfg);
  final List<Type> byteVariantList=new ArrayList<Type>(BYTES);
  Collections.shuffle(byteVariantList,random);
  final int numValues=50 + atLeast(10);
  for (  Type byteIndexValue : byteVariantList) {
    List<Closeable> closeables=new ArrayList<Closeable>();
    final int bytesSize=1 + atLeast(50);
    FixedBitSet deleted=indexValues(w,numValues,byteIndexValue,byteVariantList,withDeletions,bytesSize);
    final IndexReader r=IndexReader.open(w,withDeletions);
    assertEquals(0,r.numDeletedDocs());
    final int numRemainingValues=numValues - deleted.cardinality();
    final int base=r.numDocs() - numRemainingValues;
    DocValues bytesReader=getDocValues(r,byteIndexValue.name());
    assertNotNull("field " + byteIndexValue.name() + " returned null reader - maybe merged failed",bytesReader);
    Source bytes=getSource(bytesReader);
    byte upto=0;
    for (int i=0; i < base; i++) {
      BytesRef br=bytes.getBytes(i,new BytesRef());
      String msg=" field: " + byteIndexValue.name() + " at index: "+ i+ " base: "+ base+ " numDocs:"+ r.numDocs();
switch (byteIndexValue) {
case BYTES_VAR_STRAIGHT:
case BYTES_FIXED_STRAIGHT:
case BYTES_FIXED_DEREF:
case BYTES_FIXED_SORTED:
        assertNotNull("expected none null - " + msg,br);
      if (br.length != 0) {
        assertEquals("expected zero bytes of length " + bytesSize + " - "+ msg+ br.utf8ToString(),bytesSize,br.length);
        for (int j=0; j < br.length; j++) {
          assertEquals("Byte at index " + j + " doesn't match - "+ msg,0,br.bytes[br.offset + j]);
        }
      }
    break;
default :
  assertNotNull("expected none null - " + msg,br);
assertEquals(byteIndexValue + "",0,br.length);
}
}
assertEquals(base + numRemainingValues,r.numDocs());
int v=0;
for (int i=base; i < r.numDocs(); i++) {
String msg=" field: " + byteIndexValue.name() + " at index: "+ i+ " base: "+ base+ " numDocs:"+ r.numDocs()+ " bytesSize: "+ bytesSize+ " src: "+ bytes;
while (withDeletions && deleted.get(v++)) {
upto+=bytesSize;
}
BytesRef br=bytes.getBytes(i,new BytesRef());
assertTrue(msg,br.length > 0);
for (int j=0; j < br.length; j++, upto++) {
if (!(br.bytes.length > br.offset + j)) br=bytes.getBytes(i,new BytesRef());
assertTrue("BytesRef index exceeded [" + msg + "] offset: "+ br.offset+ " length: "+ br.length+ " index: "+ (br.offset + j),br.bytes.length > br.offset + j);
assertEquals("SourceRef Byte at index " + j + " doesn't match - "+ msg,upto,br.bytes[br.offset + j]);
}
}
closeables.add(r);
for (Closeable toClose : closeables) {
toClose.close();
}
}
w.close();
d.close();
}
