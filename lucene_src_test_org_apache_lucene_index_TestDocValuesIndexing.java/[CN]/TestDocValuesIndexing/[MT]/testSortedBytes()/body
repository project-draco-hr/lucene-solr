{
  Type[] types=new Type[]{Type.BYTES_FIXED_SORTED,Type.BYTES_VAR_SORTED};
  for (  Type type : types) {
    boolean fixed=type == Type.BYTES_FIXED_SORTED;
    final Directory d=newDirectory();
    IndexWriterConfig cfg=newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random));
    IndexWriter w=new IndexWriter(d,cfg);
    Comparator<BytesRef> comp=BytesRef.getUTF8SortedAsUnicodeComparator();
    int numDocs=atLeast(100);
    BytesRefHash hash=new BytesRefHash();
    Map<String,String> docToString=new HashMap<String,String>();
    int len=1 + random.nextInt(50);
    for (int i=0; i < numDocs; i++) {
      Document doc=new Document();
      doc.add(newField("id","" + i,TextField.TYPE_STORED));
      DocValuesField f=new DocValuesField("field");
      String string=fixed ? _TestUtil.randomFixedByteLengthUnicodeString(random,len) : _TestUtil.randomRealisticUnicodeString(random,1,len);
      hash.add(new BytesRef(string));
      docToString.put("" + i,string);
      f.setBytes(new BytesRef(string),type,comp);
      doc.add(f);
      w.addDocument(doc);
    }
    if (rarely()) {
      w.commit();
    }
    int numDocsNoValue=atLeast(10);
    for (int i=0; i < numDocsNoValue; i++) {
      Document doc=new Document();
      doc.add(newField("id","noValue",TextField.TYPE_STORED));
      w.addDocument(doc);
    }
    BytesRef bytesRef=new BytesRef(fixed ? len : 0);
    bytesRef.offset=0;
    bytesRef.length=fixed ? len : 0;
    hash.add(bytesRef);
    if (rarely()) {
      w.commit();
    }
    for (int i=0; i < numDocs; i++) {
      Document doc=new Document();
      String id="" + i + numDocs;
      doc.add(newField("id",id,TextField.TYPE_STORED));
      DocValuesField f=new DocValuesField("field");
      String string=fixed ? _TestUtil.randomFixedByteLengthUnicodeString(random,len) : _TestUtil.randomRealisticUnicodeString(random,1,len);
      hash.add(new BytesRef(string));
      docToString.put(id,string);
      f.setBytes(new BytesRef(string),type,comp);
      doc.add(f);
      w.addDocument(doc);
    }
    w.commit();
    IndexReader reader=w.getReader();
    DocValues docValues=MultiDocValues.getDocValues(reader,"field");
    Source source=getSource(docValues);
    SortedSource asSortedSource=source.asSortedSource();
    int[] sort=hash.sort(comp);
    BytesRef expected=new BytesRef();
    BytesRef actual=new BytesRef();
    assertEquals(hash.size(),asSortedSource.getValueCount());
    for (int i=0; i < hash.size(); i++) {
      hash.get(sort[i],expected);
      asSortedSource.getByOrd(i,actual);
      assertEquals(expected.utf8ToString(),actual.utf8ToString());
      int ord=asSortedSource.getByValue(expected,actual);
      assertEquals(i,ord);
    }
    reader=new SlowMultiReaderWrapper(reader);
    Set<Entry<String,String>> entrySet=docToString.entrySet();
    for (    Entry<String,String> entry : entrySet) {
      int docId=docId(reader,new Term("id",entry.getKey()));
      expected.copyChars(entry.getValue());
      assertEquals(expected,asSortedSource.getBytes(docId,actual));
    }
    reader.close();
    w.close();
    d.close();
  }
}
