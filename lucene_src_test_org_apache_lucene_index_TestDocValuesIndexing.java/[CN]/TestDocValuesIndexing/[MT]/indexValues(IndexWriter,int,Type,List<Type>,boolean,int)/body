{
  final boolean isNumeric=NUMERICS.contains(value);
  FixedBitSet deleted=new FixedBitSet(numValues);
  Document doc=new Document();
  DocValuesField valField=new DocValuesField(value.name());
  doc.add(valField);
  final BytesRef bytesRef=new BytesRef();
  final String idBase=value.name() + "_";
  final byte[] b=new byte[bytesSize];
  if (bytesRef != null) {
    bytesRef.bytes=b;
    bytesRef.length=b.length;
    bytesRef.offset=0;
  }
  byte upto=0;
  for (int i=0; i < numValues; i++) {
    if (isNumeric) {
switch (value) {
case VAR_INTS:
        valField.setInt((long)i);
      break;
case FIXED_INTS_16:
    valField.setInt((short)i,random.nextInt(10) != 0);
  break;
case FIXED_INTS_32:
valField.setInt(i,random.nextInt(10) != 0);
break;
case FIXED_INTS_64:
valField.setInt((long)i,random.nextInt(10) != 0);
break;
case FIXED_INTS_8:
valField.setInt((byte)(0xFF & (i % 128)),random.nextInt(10) != 0);
break;
case FLOAT_32:
valField.setFloat(2.0f * i);
break;
case FLOAT_64:
valField.setFloat(2.0d * i);
break;
default :
fail("unexpected value " + value);
}
}
 else {
for (int j=0; j < b.length; j++) {
b[j]=upto++;
}
if (bytesRef != null) {
valField.setBytes(bytesRef,value);
}
}
doc.removeFields("id");
doc.add(new Field("id",idBase + i,StringField.TYPE_STORED));
w.addDocument(doc);
if (i % 7 == 0) {
if (withDeletions && random.nextBoolean()) {
Type val=valueVarList.get(random.nextInt(1 + valueVarList.indexOf(value)));
final int randInt=val == value ? random.nextInt(1 + i) : random.nextInt(numValues);
w.deleteDocuments(new Term("id",val.name() + "_" + randInt));
if (val == value) {
deleted.set(randInt);
}
}
if (random.nextInt(10) == 0) {
w.commit();
}
}
}
w.commit();
if (withDeletions || random.nextBoolean()) {
w.forceMerge(1,true);
}
return deleted;
}
