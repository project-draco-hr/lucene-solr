{
  for (int i=0; i < unsupportedNames.length; i++) {
    if (VERBOSE) {
      System.out.println("TEST: index " + unsupportedNames[i]);
    }
    unzip(getDataFile("unsupported." + unsupportedNames[i] + ".zip"),unsupportedNames[i]);
    String fullPath=fullDir(unsupportedNames[i]);
    Directory dir=newFSDirectory(new File(fullPath));
    IndexReader reader=null;
    IndexWriter writer=null;
    try {
      reader=IndexReader.open(dir);
      fail("IndexReader.open should not pass for " + unsupportedNames[i]);
    }
 catch (    IndexFormatTooOldException e) {
    }
 finally {
      if (reader != null)       reader.close();
      reader=null;
    }
    try {
      writer=new IndexWriter(dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer()).setMergeScheduler(new SerialMergeScheduler()));
      if (random.nextBoolean()) {
        writer.optimize();
      }
 else {
        reader=writer.getReader();
      }
      fail("IndexWriter creation should not pass for " + unsupportedNames[i]);
    }
 catch (    IndexFormatTooOldException e) {
      if (VERBOSE) {
        System.out.println("TEST: got expected exc:");
        e.printStackTrace(System.out);
      }
    }
 finally {
      if (reader != null)       reader.close();
      reader=null;
      if (writer != null) {
        try {
          writer.close();
        }
 catch (        IndexFormatTooOldException e) {
          writer.close(false);
        }
      }
      writer=null;
    }
    ByteArrayOutputStream bos=new ByteArrayOutputStream(1024);
    CheckIndex checker=new CheckIndex(dir);
    checker.setInfoStream(new PrintStream(bos));
    CheckIndex.Status indexStatus=checker.checkIndex();
    assertFalse(indexStatus.clean);
    assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));
    dir.close();
    rmDir(unsupportedNames[i]);
  }
}
