{
  final int bi=(int)(pos >> chunkSizePower);
  try {
    final ByteBuffer b=buffers[bi];
    b.position((int)(pos & chunkSizeMask));
    this.curBufIndex=bi;
    this.curBuf=b;
  }
 catch (  ArrayIndexOutOfBoundsException aioobe) {
    if (pos < 0L) {
      throw new IllegalArgumentException("Seeking to negative position: " + this);
    }
    throw new EOFException("seek past EOF: " + this);
  }
catch (  IllegalArgumentException iae) {
    if (pos < 0L) {
      throw new IllegalArgumentException("Seeking to negative position: " + this);
    }
    throw new EOFException("seek past EOF: " + this);
  }
catch (  NullPointerException npe) {
    throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
  }
}
