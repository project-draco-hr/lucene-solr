{
  NumericEntry entry=numerics.get(field.name);
  data.seek(entry.offset);
switch (entry.format) {
case TABLE_COMPRESSED:
    int size=data.readVInt();
  if (size > 256) {
    throw new CorruptIndexException("TABLE_COMPRESSED cannot have more than 256 distinct values, input=" + data);
  }
final long decode[]=new long[size];
for (int i=0; i < decode.length; i++) {
decode[i]=data.readLong();
}
final int formatID=data.readVInt();
final int bitsPerValue=data.readVInt();
final PackedInts.Reader ordsReader=PackedInts.getReaderNoHeader(data,PackedInts.Format.byId(formatID),entry.packedIntsVersion,maxDoc,bitsPerValue);
ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());
numericInfo.put(field.name,ordsReader);
return new NumericDocValues(){
@Override public long get(int docID){
return decode[(int)ordsReader.get(docID)];
}
}
;
case DELTA_COMPRESSED:
final int blockSize=data.readVInt();
final BlockPackedReader reader=new BlockPackedReader(data,entry.packedIntsVersion,blockSize,maxDoc,false);
ramBytesUsed.addAndGet(reader.ramBytesUsed());
numericInfo.put(field.name,reader);
return reader;
case UNCOMPRESSED:
final byte bytes[]=new byte[maxDoc];
data.readBytes(bytes,0,bytes.length);
ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(bytes));
numericInfo.put(field.name,Accountables.namedAccountable("byte array",maxDoc));
return new NumericDocValues(){
@Override public long get(int docID){
return bytes[docID];
}
}
;
case GCD_COMPRESSED:
final long min=data.readLong();
final long mult=data.readLong();
final int quotientBlockSize=data.readVInt();
final BlockPackedReader quotientReader=new BlockPackedReader(data,entry.packedIntsVersion,quotientBlockSize,maxDoc,false);
ramBytesUsed.addAndGet(quotientReader.ramBytesUsed());
numericInfo.put(field.name,quotientReader);
return new NumericDocValues(){
@Override public long get(int docID){
return min + mult * quotientReader.get(docID);
}
}
;
default :
throw new AssertionError();
}
}
