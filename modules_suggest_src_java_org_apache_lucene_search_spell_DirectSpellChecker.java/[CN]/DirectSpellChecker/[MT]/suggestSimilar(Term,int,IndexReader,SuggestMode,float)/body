{
  final CharsRef spare=new CharsRef();
  String text=term.text();
  if (minQueryLength > 0 && text.codePointCount(0,text.length()) < minQueryLength)   return new SuggestWord[0];
  if (lowerCaseTerms) {
    term=new Term(term.field(),text.toLowerCase(Locale.ENGLISH));
  }
  int docfreq=ir.docFreq(term);
  if (suggestMode == SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {
    return new SuggestWord[0];
  }
  int maxDoc=ir.maxDoc();
  if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {
    return new SuggestWord[0];
  }
 else   if (docfreq > (int)Math.ceil(maxQueryFrequency * (float)maxDoc)) {
    return new SuggestWord[0];
  }
  if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR)   docfreq=0;
  if (thresholdFrequency >= 1f) {
    docfreq=Math.max(docfreq,(int)thresholdFrequency);
  }
 else   if (thresholdFrequency > 0f) {
    docfreq=Math.max(docfreq,(int)(thresholdFrequency * (float)maxDoc) - 1);
  }
  Collection<ScoreTerm> terms=null;
  int inspections=numSug * maxInspections;
  terms=suggestSimilar(term,inspections,ir,docfreq,1,accuracy,spare);
  if (maxEdits > 1 && terms.size() < inspections) {
    HashSet<ScoreTerm> moreTerms=new HashSet<ScoreTerm>();
    moreTerms.addAll(terms);
    moreTerms.addAll(suggestSimilar(term,inspections,ir,docfreq,maxEdits,accuracy,spare));
    terms=moreTerms;
  }
  SuggestWord suggestions[]=new SuggestWord[terms.size()];
  int index=suggestions.length - 1;
  for (  ScoreTerm s : terms) {
    SuggestWord suggestion=new SuggestWord();
    if (s.termAsString == null) {
      UnicodeUtil.UTF8toUTF16(s.term,spare);
      s.termAsString=spare.toString();
    }
    suggestion.string=s.termAsString;
    suggestion.score=s.score;
    suggestion.freq=s.docfreq;
    suggestions[index--]=suggestion;
  }
  ArrayUtil.mergeSort(suggestions,Collections.reverseOrder(comparator));
  if (numSug < suggestions.length) {
    SuggestWord trimmed[]=new SuggestWord[numSug];
    System.arraycopy(suggestions,0,trimmed,0,numSug);
    suggestions=trimmed;
  }
  return suggestions;
}
