{
  final IndexInput in=dir.openInput(IndexFileNames.segmentFileName(segment,segmentSuffix,VariableGapTermsIndexWriter.TERMS_INDEX_EXTENSION),new IOContext(context,true));
  this.segment=segment;
  boolean success=false;
  try {
    version=readHeader(in);
    if (version >= VariableGapTermsIndexWriter.VERSION_CHECKSUM) {
      CodecUtil.checksumEntireFile(in);
    }
    seekDir(in,dirOffset);
    final int numFields=in.readVInt();
    if (numFields < 0) {
      throw new CorruptIndexException("invalid numFields: " + numFields + " (resource="+ in+ ")");
    }
    for (int i=0; i < numFields; i++) {
      final int field=in.readVInt();
      final long indexStart=in.readVLong();
      final FieldInfo fieldInfo=fieldInfos.fieldInfo(field);
      FieldIndexData previous=fields.put(fieldInfo.name,new FieldIndexData(in,fieldInfo,indexStart));
      if (previous != null) {
        throw new CorruptIndexException("duplicate field: " + fieldInfo.name + " (resource="+ in+ ")");
      }
    }
    success=true;
  }
  finally {
    if (success) {
      IOUtils.close(in);
    }
 else {
      IOUtils.closeWhileHandlingException(in);
    }
  }
}
