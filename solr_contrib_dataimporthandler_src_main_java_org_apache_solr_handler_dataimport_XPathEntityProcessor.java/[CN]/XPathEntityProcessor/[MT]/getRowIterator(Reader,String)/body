{
  final AtomicReference<Exception> exp=new AtomicReference<Exception>();
  final BlockingQueue<Map<String,Object>> blockingQueue=new ArrayBlockingQueue<Map<String,Object>>(blockingQueueSize);
  final AtomicBoolean isEnd=new AtomicBoolean(false);
  final AtomicBoolean throwExp=new AtomicBoolean(true);
  publisherThread=new Thread(){
    public void run(){
      try {
        xpathReader.streamRecords(data,new XPathRecordReader.Handler(){
          @SuppressWarnings("unchecked") public void handle(          Map<String,Object> record,          String xpath){
            if (isEnd.get()) {
              throwExp.set(false);
              throw new RuntimeException("BREAK");
            }
            Map<String,Object> row;
            try {
              row=readRow(record,xpath);
            }
 catch (            Exception e) {
              isEnd.set(true);
              return;
            }
            offer(row);
          }
        }
);
      }
 catch (      Exception e) {
        if (throwExp.get())         exp.set(e);
      }
 finally {
        closeIt(data);
        if (!isEnd.get()) {
          offer(END_MARKER);
        }
      }
    }
    private void offer(    Map<String,Object> row){
      try {
        while (!blockingQueue.offer(row,blockingQueueTimeOut,blockingQueueTimeOutUnits)) {
          if (isEnd.get())           return;
          LOG.debug("Timeout elapsed writing records.  Perhaps buffer size should be increased.");
        }
      }
 catch (      InterruptedException e) {
        return;
      }
 finally {
synchronized (this) {
          notifyAll();
        }
      }
    }
  }
;
  publisherThread.start();
  return new Iterator<Map<String,Object>>(){
    private Map<String,Object> lastRow;
    int count=0;
    public boolean hasNext(){
      return !isEnd.get();
    }
    public Map<String,Object> next(){
      Map<String,Object> row;
      do {
        try {
          row=blockingQueue.poll(blockingQueueTimeOut,blockingQueueTimeOutUnits);
          if (row == null) {
            LOG.debug("Timeout elapsed reading records.");
          }
        }
 catch (        InterruptedException e) {
          LOG.debug("Caught InterruptedException while waiting for row.  Aborting.");
          isEnd.set(true);
          return null;
        }
      }
 while (row == null);
      if (row == END_MARKER) {
        isEnd.set(true);
        if (exp.get() != null) {
          String msg="Parsing failed for xml, url:" + s + " rows processed in this xml:"+ count;
          if (lastRow != null)           msg+=" last row in this xml:" + lastRow;
          if (ABORT.equals(onError)) {
            wrapAndThrow(SEVERE,exp.get(),msg);
          }
 else           if (SKIP.equals(onError)) {
            wrapAndThrow(DataImportHandlerException.SKIP,exp.get());
          }
 else {
            LOG.warn(msg,exp.get());
          }
        }
        return null;
      }
      count++;
      return lastRow=row;
    }
    public void remove(){
    }
  }
;
}
