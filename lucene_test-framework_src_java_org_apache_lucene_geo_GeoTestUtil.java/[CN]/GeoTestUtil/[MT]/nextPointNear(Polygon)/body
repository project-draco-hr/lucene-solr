{
  double polyLats[]=polygon.getPolyLats();
  double polyLons[]=polygon.getPolyLons();
  Polygon holes[]=polygon.getHoles();
  if (holes.length > 0 && random().nextInt(3) == 0) {
    return nextPointNear(holes[random().nextInt(holes.length)]);
  }
  int surpriseMe=random().nextInt(97);
  if (surpriseMe == 0) {
    return new double[]{nextLatitude(),nextLongitude()};
  }
 else   if (surpriseMe < 5) {
    return new double[]{nextLatitudeBetween(polygon.minLat,polygon.maxLat),nextLongitudeBetween(polygon.minLon,polygon.maxLon)};
  }
 else   if (surpriseMe < 20) {
    int vertex=random().nextInt(polyLats.length - 1);
    return new double[]{nextLatitudeNear(polyLats[vertex],polyLats[vertex + 1] - polyLats[vertex]),nextLongitudeNear(polyLons[vertex],polyLons[vertex + 1] - polyLons[vertex])};
  }
 else   if (surpriseMe < 30) {
    Polygon container=boxPolygon(new Rectangle(polygon.minLat,polygon.maxLat,polygon.minLon,polygon.maxLon));
    double containerLats[]=container.getPolyLats();
    double containerLons[]=container.getPolyLons();
    int startVertex=random().nextInt(containerLats.length - 1);
    return nextPointAroundLine(containerLats[startVertex],containerLons[startVertex],containerLats[startVertex + 1],containerLons[startVertex + 1]);
  }
 else {
    int startVertex=random().nextInt(polyLats.length - 1);
    int endVertex=random().nextBoolean() ? startVertex + 1 : random().nextInt(polyLats.length - 1);
    return nextPointAroundLine(polyLats[startVertex],polyLons[startVertex],polyLats[endVertex],polyLons[endVertex]);
  }
}
