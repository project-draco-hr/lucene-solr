{
  int trueProps=parseProperties(props,true);
  int falseProps=parseProperties(props,false);
  int p=ft.properties;
  if (on(falseProps,STORED)) {
    int pp=STORED | BINARY | COMPRESSED;
    if (on(pp,trueProps)) {
      throw new RuntimeException("SchemaField: " + name + " conflicting stored field options:"+ props);
    }
    p&=~pp;
  }
  if (on(falseProps,INDEXED)) {
    int pp=(INDEXED | OMIT_NORMS | OMIT_TF| STORE_TERMVECTORS| STORE_TERMPOSITIONS| STORE_TERMOFFSETS| SORT_MISSING_FIRST| SORT_MISSING_LAST);
    if (on(pp,trueProps)) {
      throw new RuntimeException("SchemaField: " + name + " conflicting indexed field options:"+ props);
    }
    p&=~pp;
  }
  if (on(falseProps,STORE_TERMVECTORS)) {
    int pp=(STORE_TERMVECTORS | STORE_TERMPOSITIONS | STORE_TERMOFFSETS);
    if (on(pp,trueProps)) {
      throw new RuntimeException("SchemaField: " + name + " conflicting termvector field options:"+ props);
    }
    p&=~pp;
  }
  if (on(trueProps,SORT_MISSING_FIRST)) {
    p&=~SORT_MISSING_LAST;
  }
  if (on(trueProps,SORT_MISSING_LAST)) {
    p&=~SORT_MISSING_FIRST;
  }
  p&=~falseProps;
  p|=trueProps;
  String defaultValue=null;
  if (props.containsKey("default")) {
    defaultValue=(String)props.get("default");
  }
  return new SchemaField(name,ft,p,defaultValue);
}
