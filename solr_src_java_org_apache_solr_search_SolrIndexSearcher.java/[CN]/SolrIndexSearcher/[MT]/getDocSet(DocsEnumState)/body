{
  int largestPossible=deState.termsEnum.docFreq();
  boolean useCache=filterCache != null && largestPossible >= deState.minSetSizeCached;
  TermQuery key=null;
  if (useCache) {
    key=new TermQuery(new Term(deState.fieldName,new BytesRef(deState.termsEnum.term())));
    DocSet result=filterCache.get(key);
    if (result != null)     return result;
  }
  int smallSetSize=maxDoc() >> 6;
  int scratchSize=Math.min(smallSetSize,largestPossible);
  if (deState.scratch == null || deState.scratch.length < scratchSize)   deState.scratch=new int[scratchSize];
  final int[] docs=deState.scratch;
  int upto=0;
  int bitsSet=0;
  OpenBitSet obs=null;
  DocsEnum docsEnum=deState.termsEnum.docs(deState.deletedDocs,deState.docsEnum);
  if (deState.docsEnum == null) {
    deState.docsEnum=docsEnum;
  }
  if (docsEnum instanceof MultiDocsEnum) {
    MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
    int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
    for (int subindex=0; subindex < numSubs; subindex++) {
      MultiDocsEnum.EnumWithSlice sub=subs[subindex];
      if (sub.docsEnum == null)       continue;
      DocsEnum.BulkReadResult bulk=sub.docsEnum.getBulkResult();
      int base=sub.slice.start;
      for (; ; ) {
        int nDocs=sub.docsEnum.read();
        if (nDocs == 0)         break;
        int[] docArr=bulk.docs.ints;
        int end=bulk.docs.offset + nDocs;
        if (upto + nDocs > docs.length) {
          if (obs == null)           obs=new OpenBitSet(maxDoc());
          for (int i=bulk.docs.offset; i < end; i++) {
            obs.fastSet(docArr[i] + base);
          }
          bitsSet+=nDocs;
        }
 else {
          for (int i=bulk.docs.offset; i < end; i++) {
            docs[upto++]=docArr[i] + base;
          }
        }
      }
    }
  }
 else {
    DocsEnum.BulkReadResult bulk=docsEnum.getBulkResult();
    for (; ; ) {
      int nDocs=docsEnum.read();
      if (nDocs == 0)       break;
      int[] docArr=bulk.docs.ints;
      int end=bulk.docs.offset + nDocs;
      if (upto + nDocs > docs.length) {
        if (obs == null)         obs=new OpenBitSet(maxDoc());
        for (int i=bulk.docs.offset; i < end; i++) {
          obs.fastSet(docArr[i]);
        }
        bitsSet+=nDocs;
      }
 else {
        for (int i=bulk.docs.offset; i < end; i++) {
          docs[upto++]=docArr[i];
        }
      }
    }
  }
  DocSet result;
  if (obs != null) {
    for (int i=0; i < upto; i++) {
      obs.fastSet(docs[i]);
    }
    bitsSet+=upto;
    result=new BitDocSet(obs,bitsSet);
  }
 else {
    result=upto == 0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs,upto));
  }
  if (useCache) {
    filterCache.put(key,result);
  }
  return result;
}
