{
  DocListAndSet out=new DocListAndSet();
  qr.setDocListAndSet(out);
  DocSet filter=cmd.getFilter() != null ? cmd.getFilter() : getDocSet(cmd.getFilterList());
  int maxDoc=maxDoc();
  boolean needScores=(cmd.getFlags() & GET_SCORES) != 0;
  boolean getDocSet=(cmd.getFlags() & GET_DOCSET) != 0;
  boolean getDocList=(cmd.getFlags() & GET_DOCLIST) != 0;
  Query query=QueryUtils.makeQueryable(cmd.getQuery());
  final Filter luceneFilter=filter == null ? null : filter.getTopFilter();
  Sort sort=cmd.getSort();
  if (sort == null)   sort=new Sort();
  List<GroupCollector> collectors=new ArrayList<GroupCollector>(cmd.groupCommands.size());
  for (  Grouping.Command groupCommand : cmd.groupCommands) {
    if (groupCommand instanceof Grouping.CommandFunc) {
      Grouping.CommandFunc gc=(Grouping.CommandFunc)groupCommand;
      Map context=ValueSource.newContext();
      gc.groupBy.createWeight(context,this);
      TopGroupCollector collector;
      int groupsToCollect=gc.numGroups < 0 ? maxDoc : gc.offset + gc.numGroups;
      if (groupsToCollect < 0 || groupsToCollect > maxDoc)       groupsToCollect=maxDoc;
      if (gc.groupSort != null && gc.groupSort != sort) {
        collector=new TopGroupSortCollector(gc.groupBy,context,sort,gc.groupSort,groupsToCollect);
      }
 else {
        collector=new TopGroupCollector(gc.groupBy,context,sort,groupsToCollect);
      }
      collectors.add(collector);
      gc.context=context;
      gc.collector=collector;
    }
    if (groupCommand instanceof Grouping.CommandQuery) {
      int docsToCollect=groupCommand.docsPerGroup < 0 ? maxDoc : groupCommand.groupOffset + groupCommand.docsPerGroup;
      if (docsToCollect < 0 || docsToCollect > maxDoc)       docsToCollect=maxDoc;
      DocSet groupFilt=getDocSet(((Grouping.CommandQuery)groupCommand).query);
      TopFieldCollector collector=TopFieldCollector.create(groupCommand.groupSort == null ? sort : groupCommand.groupSort,docsToCollect,false,needScores,needScores,true);
      collectors.add(new FilterCollector(groupFilt,collector));
    }
  }
  Collector allCollectors=MultiCollector.wrap(collectors.toArray(new Collector[collectors.size()]));
  DocSetCollector setCollector=null;
  if (getDocSet) {
    setCollector=new DocSetDelegateCollector(maxDoc() >> 6,maxDoc(),allCollectors);
    allCollectors=setCollector;
  }
  search(query,luceneFilter,allCollectors);
  if (getDocSet) {
    qr.docListAndSet.docSet=setCollector.getDocSet();
  }
  int numPhase2=0;
  List<Phase2GroupCollector> phase2Collectors=new ArrayList<Phase2GroupCollector>(cmd.groupCommands.size());
  for (  Grouping.Command groupCommand : cmd.groupCommands) {
    if (groupCommand instanceof Grouping.CommandFunc) {
      Grouping.CommandFunc gc=(Grouping.CommandFunc)groupCommand;
      Sort collectorSort=gc.groupSort == null ? sort : gc.groupSort;
      int docsToCollect=groupCommand.docsPerGroup < 0 ? maxDoc : groupCommand.groupOffset + groupCommand.docsPerGroup;
      if (docsToCollect < 0 || docsToCollect > maxDoc)       docsToCollect=maxDoc;
      Phase2GroupCollector collector=new Phase2GroupCollector((TopGroupCollector)gc.collector,gc.groupBy,gc.context,collectorSort,docsToCollect,needScores,groupCommand.offset);
      phase2Collectors.add(collector);
      numPhase2++;
    }
 else     if (groupCommand instanceof Grouping.CommandQuery) {
      phase2Collectors.add(null);
    }
 else {
      phase2Collectors.add(null);
    }
  }
  if (numPhase2 > 0)   search(query,luceneFilter,MultiCollector.wrap(phase2Collectors.toArray(new Collector[phase2Collectors.size()])));
  Set<Integer> idSet=new LinkedHashSet<Integer>();
  int maxMatches=0;
  float maxScore=Float.NEGATIVE_INFINITY;
  NamedList grouped=new SimpleOrderedMap();
  for (int cmdnum=0; cmdnum < cmd.groupCommands.size(); cmdnum++) {
    Grouping.Command groupCommand=cmd.groupCommands.get(cmdnum);
    GroupCollector gcollector=collectors.get(cmdnum);
    NamedList groupResult=new SimpleOrderedMap();
    grouped.add(groupCommand.key,groupResult);
    int this_matches=gcollector.getMatches();
    groupResult.add("matches",this_matches);
    maxMatches=Math.max(maxMatches,this_matches);
    if (groupCommand instanceof Grouping.CommandQuery) {
      int docsToCollect=groupCommand.docsPerGroup < 0 ? maxDoc : groupCommand.groupOffset + groupCommand.docsPerGroup;
      if (docsToCollect < 0 || docsToCollect > maxDoc)       docsToCollect=maxDoc;
      TopDocs topDocs=((FilterCollector)gcollector).getTopFieldCollector().topDocs(0,docsToCollect);
      int ids[]=new int[topDocs.scoreDocs.length];
      float[] scores=needScores ? new float[topDocs.scoreDocs.length] : null;
      for (int i=0; i < ids.length; i++) {
        ids[i]=topDocs.scoreDocs[i].doc;
        if (scores != null)         scores[i]=topDocs.scoreDocs[i].score;
      }
      float score=topDocs.getMaxScore();
      maxScore=Math.max(maxScore,score);
      DocSlice docs=new DocSlice(groupCommand.groupOffset,Math.max(0,ids.length - groupCommand.groupOffset),ids,scores,topDocs.totalHits,score);
      groupResult.add("doclist",docs);
      if (getDocList) {
        DocIterator iter=docs.iterator();
        while (iter.hasNext())         idSet.add(iter.nextDoc());
      }
      continue;
    }
    Grouping.CommandFunc groupCommandFunc=(Grouping.CommandFunc)groupCommand;
    TopGroupCollector collector=(TopGroupCollector)gcollector;
    Phase2GroupCollector collector2=phase2Collectors.get(cmdnum);
    if (collector.orderedGroups == null)     collector.buildSet();
    List groupList=new ArrayList();
    groupResult.add("groups",groupList);
    int skipCount=groupCommand.offset;
    for (    SearchGroup group : collector.orderedGroups) {
      if (skipCount > 0) {
        skipCount--;
        continue;
      }
      NamedList nl=new SimpleOrderedMap();
      groupList.add(nl);
      nl.add("groupValue",group.groupValue.toObject());
      SearchGroupDocs groupDocs=collector2.groupMap.get(group.groupValue);
      int docsToCollect=groupCommand.docsPerGroup < 0 ? maxDoc : groupCommand.groupOffset + groupCommand.docsPerGroup;
      if (docsToCollect < 0 || docsToCollect > maxDoc)       docsToCollect=maxDoc;
      TopDocs topDocs=groupDocs.collector.topDocs(0,docsToCollect);
      int ids[]=new int[topDocs.scoreDocs.length];
      float[] scores=needScores ? new float[topDocs.scoreDocs.length] : null;
      for (int i=0; i < ids.length; i++) {
        ids[i]=topDocs.scoreDocs[i].doc;
        if (scores != null)         scores[i]=topDocs.scoreDocs[i].score;
      }
      float score=topDocs.getMaxScore();
      maxScore=Math.max(maxScore,score);
      DocSlice docs=new DocSlice(groupCommand.groupOffset,Math.max(0,ids.length - groupCommand.groupOffset),ids,scores,topDocs.totalHits,score);
      nl.add("doclist",docs);
      if (getDocList) {
        DocIterator iter=docs.iterator();
        while (iter.hasNext())         idSet.add(iter.nextDoc());
      }
    }
  }
  qr.groupedResults=grouped;
  if (getDocList) {
    int sz=idSet.size();
    int[] ids=new int[sz];
    int idx=0;
    for (    int val : idSet) {
      ids[idx++]=val;
    }
    qr.docListAndSet.docList=new DocSlice(0,sz,ids,null,maxMatches,maxScore);
  }
}
