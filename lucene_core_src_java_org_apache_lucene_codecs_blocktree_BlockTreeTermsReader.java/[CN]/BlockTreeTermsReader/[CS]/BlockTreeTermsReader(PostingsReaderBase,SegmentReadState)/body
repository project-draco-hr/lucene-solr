{
  this.postingsReader=postingsReader;
  this.segment=state.segmentInfo.name;
  String termsFileName=IndexFileNames.segmentFileName(segment,state.segmentSuffix,BlockTreeTermsWriter.TERMS_EXTENSION);
  in=state.directory.openInput(termsFileName,state.context);
  boolean success=false;
  IndexInput indexIn=null;
  try {
    version=readHeader(in);
    String indexFileName=IndexFileNames.segmentFileName(segment,state.segmentSuffix,BlockTreeTermsWriter.TERMS_INDEX_EXTENSION);
    indexIn=state.directory.openInput(indexFileName,state.context);
    int indexVersion=readIndexHeader(indexIn);
    if (indexVersion != version) {
      throw new CorruptIndexException("mixmatched version files: " + in + "="+ version+ ","+ indexIn+ "="+ indexVersion,indexIn);
    }
    CodecUtil.checksumEntireFile(indexIn);
    postingsReader.init(in,state);
    CodecUtil.retrieveChecksum(in);
    seekDir(in,dirOffset);
    seekDir(indexIn,indexDirOffset);
    final int numFields=in.readVInt();
    if (numFields < 0) {
      throw new CorruptIndexException("invalid numFields: " + numFields,in);
    }
    for (int i=0; i < numFields; i++) {
      final int field=in.readVInt();
      final long numTerms=in.readVLong();
      if (numTerms <= 0) {
        throw new CorruptIndexException("Illegal numTerms for field number: " + field,in);
      }
      final int numBytes=in.readVInt();
      if (numBytes < 0) {
        throw new CorruptIndexException("invalid rootCode for field number: " + field + ", numBytes="+ numBytes,in);
      }
      final BytesRef rootCode=new BytesRef(new byte[numBytes]);
      in.readBytes(rootCode.bytes,0,numBytes);
      rootCode.length=numBytes;
      final FieldInfo fieldInfo=state.fieldInfos.fieldInfo(field);
      if (fieldInfo == null) {
        throw new CorruptIndexException("invalid field number: " + field,in);
      }
      final long sumTotalTermFreq=fieldInfo.getIndexOptions() == IndexOptions.DOCS_ONLY ? -1 : in.readVLong();
      final long sumDocFreq=in.readVLong();
      final int docCount=in.readVInt();
      final int longsSize=in.readVInt();
      if (longsSize < 0) {
        throw new CorruptIndexException("invalid longsSize for field: " + fieldInfo.name + ", longsSize="+ longsSize,in);
      }
      BytesRef minTerm=readBytesRef(in);
      BytesRef maxTerm=readBytesRef(in);
      if (docCount < 0 || docCount > state.segmentInfo.getDocCount()) {
        throw new CorruptIndexException("invalid docCount: " + docCount + " maxDoc: "+ state.segmentInfo.getDocCount(),in);
      }
      if (sumDocFreq < docCount) {
        throw new CorruptIndexException("invalid sumDocFreq: " + sumDocFreq + " docCount: "+ docCount,in);
      }
      if (sumTotalTermFreq != -1 && sumTotalTermFreq < sumDocFreq) {
        throw new CorruptIndexException("invalid sumTotalTermFreq: " + sumTotalTermFreq + " sumDocFreq: "+ sumDocFreq,in);
      }
      final long indexStartFP=indexIn.readVLong();
      FieldReader previous=fields.put(fieldInfo.name,new FieldReader(this,fieldInfo,numTerms,rootCode,sumTotalTermFreq,sumDocFreq,docCount,indexStartFP,longsSize,indexIn,minTerm,maxTerm));
      if (previous != null) {
        throw new CorruptIndexException("duplicate field: " + fieldInfo.name,in);
      }
    }
    indexIn.close();
    success=true;
  }
  finally {
    if (!success) {
      IOUtils.closeWhileHandlingException(indexIn,this);
    }
  }
}
