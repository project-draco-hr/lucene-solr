{
  String zkDir=createTempDir("zkData").getAbsolutePath();
  final int nodeCount=random().nextInt(50) + 50;
  final int coreCount=random().nextInt(100) + 100;
  final int sliceCount=random().nextInt(20) + 1;
  ZkTestServer server=new ZkTestServer(zkDir);
  SolrZkClient zkClient=null;
  ZkStateReader reader=null;
  SolrZkClient overseerClient=null;
  final MockZKController[] controllers=new MockZKController[nodeCount];
  final ExecutorService[] nodeExecutors=new ExecutorService[nodeCount];
  try {
    server.run();
    AbstractZkTestCase.tryCleanSolrZkNode(server.getZkHost());
    AbstractZkTestCase.makeSolrZkNode(server.getZkHost());
    zkClient=new SolrZkClient(server.getZkAddress(),TIMEOUT);
    zkClient.makePath(ZkStateReader.LIVE_NODES_ZKNODE,true);
    overseerClient=electNewOverseer(server.getZkAddress());
    reader=new ZkStateReader(zkClient);
    reader.createClusterStateWatchersAndUpdate();
    for (int i=0; i < nodeCount; i++) {
      controllers[i]=new MockZKController(server.getZkAddress(),"node" + i);
    }
    for (int i=0; i < nodeCount; i++) {
      nodeExecutors[i]=Executors.newFixedThreadPool(1,new DefaultSolrThreadFactory("testShardAssignment"));
    }
    final String[] ids=new String[coreCount];
    for (int i=0; i < coreCount; i++) {
      final int slot=i;
      Runnable coreStarter=new Runnable(){
        @Override public void run(){
          final String coreName="core" + slot;
          try {
            ids[slot]=controllers[slot % nodeCount].publishState(collection,coreName,"node" + slot,ZkStateReader.ACTIVE,sliceCount);
          }
 catch (          Throwable e) {
            e.printStackTrace();
            fail("register threw exception:" + e.getClass());
          }
        }
      }
;
      nodeExecutors[i % nodeCount].submit(coreStarter);
    }
    for (int i=0; i < nodeCount; i++) {
      nodeExecutors[i].shutdown();
    }
    for (int i=0; i < nodeCount; i++) {
      while (!nodeExecutors[i].awaitTermination(100,TimeUnit.MILLISECONDS))       ;
    }
    int cloudStateSliceCount=0;
    for (int i=0; i < 40; i++) {
      cloudStateSliceCount=0;
      reader.updateClusterState(true);
      ClusterState state=reader.getClusterState();
      Map<String,Slice> slices=state.getSlicesMap("collection1");
      if (slices != null) {
        for (        String name : slices.keySet()) {
          cloudStateSliceCount+=slices.get(name).getReplicasMap().size();
        }
        if (coreCount == cloudStateSliceCount)         break;
      }
      Thread.sleep(200);
    }
    assertEquals("Unable to verify all cores have been assigned an id in cloudstate",coreCount,cloudStateSliceCount);
    int assignedCount=0;
    for (int i=0; i < 240; i++) {
      assignedCount=0;
      for (int j=0; j < coreCount; j++) {
        if (ids[j] != null) {
          assignedCount++;
        }
      }
      if (coreCount == assignedCount) {
        break;
      }
      Thread.sleep(1000);
    }
    assertEquals("Unable to verify all cores have been returned an id",coreCount,assignedCount);
    final HashMap<String,AtomicInteger> counters=new HashMap<>();
    for (int i=1; i < sliceCount + 1; i++) {
      counters.put("shard" + i,new AtomicInteger());
    }
    for (int i=0; i < coreCount; i++) {
      final AtomicInteger ai=counters.get(ids[i]);
      assertNotNull("could not find counter for shard:" + ids[i],ai);
      ai.incrementAndGet();
    }
    for (    String counter : counters.keySet()) {
      int count=counters.get(counter).intValue();
      int expectedCount=coreCount / sliceCount;
      int min=expectedCount - 1;
      int max=expectedCount + 1;
      if (count < min || count > max) {
        fail("Unevenly assigned shard ids, " + counter + " had "+ count+ ", expected: "+ min+ "-"+ max);
      }
    }
    for (int i=0; i < sliceCount; i++) {
      assertNotNull(reader.getLeaderUrl("collection1","shard" + (i + 1),15000));
    }
  }
  finally {
    if (DEBUG) {
      if (controllers[0] != null) {
        zkClient.printLayoutToStdOut();
      }
    }
    close(zkClient);
    close(overseerClient);
    close(reader);
    for (int i=0; i < controllers.length; i++)     if (controllers[i] != null) {
      controllers[i].close();
    }
    server.shutdown();
    for (int i=0; i < nodeCount; i++) {
      if (nodeExecutors[i] != null) {
        nodeExecutors[i].shutdownNow();
      }
    }
  }
}
