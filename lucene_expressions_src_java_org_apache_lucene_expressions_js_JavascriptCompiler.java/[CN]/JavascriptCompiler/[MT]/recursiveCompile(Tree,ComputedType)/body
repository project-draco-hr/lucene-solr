{
  int type=current.getType();
  String text=current.getText();
switch (type) {
case JavascriptParser.AT_CALL:
    Tree identifier=current.getChild(0);
  String call=identifier.getText();
int arguments=current.getChildCount() - 1;
Method method=functions.get(call);
if (method == null) {
throw new IllegalArgumentException("Unrecognized method call (" + call + ").");
}
int arity=method.getParameterTypes().length;
if (arguments != arity && arity != -1) {
throw new IllegalArgumentException("Expected (" + arity + ") arguments for method call ("+ call+ "), but found ("+ arguments+ ").");
}
for (int argument=1; argument <= arguments; ++argument) {
recursiveCompile(current.getChild(argument),ComputedType.DOUBLE);
}
String klass=Type.getInternalName(method.getDeclaringClass());
String name=method.getName();
String descriptor=Type.getMethodDescriptor(method);
methodVisitor.visitMethodInsn(INVOKESTATIC,klass,name,descriptor);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.ID:
int index;
if (externalsMap.containsKey(text)) {
index=externalsMap.get(text);
}
 else {
index=externalsMap.size();
externalsMap.put(text,index);
}
methodVisitor.visitVarInsn(ALOAD,2);
switch (index) {
case 0:
methodVisitor.visitInsn(ICONST_0);
break;
case 1:
methodVisitor.visitInsn(ICONST_1);
break;
case 2:
methodVisitor.visitInsn(ICONST_2);
break;
case 3:
methodVisitor.visitInsn(ICONST_3);
break;
case 4:
methodVisitor.visitInsn(ICONST_4);
break;
case 5:
methodVisitor.visitInsn(ICONST_5);
break;
default :
if (index < 128) {
methodVisitor.visitIntInsn(BIPUSH,index);
}
 else if (index < 16384) {
methodVisitor.visitIntInsn(SIPUSH,index);
}
 else {
methodVisitor.visitLdcInsn(index);
}
break;
}
methodVisitor.visitInsn(AALOAD);
methodVisitor.visitVarInsn(ILOAD,1);
methodVisitor.visitMethodInsn(INVOKEVIRTUAL,FUNCTION_VALUES_TYPE.getInternalName(),"doubleVal",DOUBLE_VAL_METHOD_DESC);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.HEX:
long hex=Long.parseLong(text.substring(2),16);
if (expected == ComputedType.INT) {
methodVisitor.visitLdcInsn((int)hex);
}
 else if (expected == ComputedType.LONG) {
methodVisitor.visitLdcInsn(hex);
}
 else {
methodVisitor.visitLdcInsn((double)hex);
}
break;
case JavascriptParser.OCTAL:
long octal=Long.parseLong(text.substring(1),8);
if (expected == ComputedType.INT) {
methodVisitor.visitLdcInsn((int)octal);
}
 else if (expected == ComputedType.LONG) {
methodVisitor.visitLdcInsn(octal);
}
 else {
methodVisitor.visitLdcInsn((double)octal);
}
break;
case JavascriptParser.DECIMAL:
double decimal=Double.parseDouble(text);
methodVisitor.visitLdcInsn(decimal);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_NEGATE:
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
methodVisitor.visitInsn(DNEG);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_ADD:
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DADD);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_SUBTRACT:
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DSUB);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_MULTIPLY:
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(Opcodes.DMUL);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_DIVIDE:
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DDIV);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_MODULO:
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DREM);
typeCompile(expected,ComputedType.DOUBLE);
break;
case JavascriptParser.AT_BIT_SHL:
recursiveCompile(current.getChild(0),ComputedType.LONG);
recursiveCompile(current.getChild(1),ComputedType.INT);
methodVisitor.visitInsn(LSHL);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_BIT_SHR:
recursiveCompile(current.getChild(0),ComputedType.LONG);
recursiveCompile(current.getChild(1),ComputedType.INT);
methodVisitor.visitInsn(LSHR);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_BIT_SHU:
recursiveCompile(current.getChild(0),ComputedType.LONG);
recursiveCompile(current.getChild(1),ComputedType.INT);
methodVisitor.visitInsn(LUSHR);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_BIT_AND:
recursiveCompile(current.getChild(0),ComputedType.LONG);
recursiveCompile(current.getChild(1),ComputedType.LONG);
methodVisitor.visitInsn(LAND);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_BIT_OR:
recursiveCompile(current.getChild(0),ComputedType.LONG);
recursiveCompile(current.getChild(1),ComputedType.LONG);
methodVisitor.visitInsn(LOR);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_BIT_XOR:
recursiveCompile(current.getChild(0),ComputedType.LONG);
recursiveCompile(current.getChild(1),ComputedType.LONG);
methodVisitor.visitInsn(LXOR);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_BIT_NOT:
recursiveCompile(current.getChild(0),ComputedType.LONG);
methodVisitor.visitLdcInsn(new Long(-1));
methodVisitor.visitInsn(LXOR);
typeCompile(expected,ComputedType.LONG);
break;
case JavascriptParser.AT_COMP_EQ:
Label labelEqTrue=new Label();
Label labelEqReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFEQ,labelEqTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelEqReturn);
methodVisitor.visitLabel(labelEqTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelEqReturn);
break;
case JavascriptParser.AT_COMP_NEQ:
Label labelNeqTrue=new Label();
Label labelNeqReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFNE,labelNeqTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelNeqReturn);
methodVisitor.visitLabel(labelNeqTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelNeqReturn);
break;
case JavascriptParser.AT_COMP_LT:
Label labelLtTrue=new Label();
Label labelLtReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DCMPG);
methodVisitor.visitJumpInsn(IFLT,labelLtTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelLtReturn);
methodVisitor.visitLabel(labelLtTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelLtReturn);
break;
case JavascriptParser.AT_COMP_GT:
Label labelGtTrue=new Label();
Label labelGtReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFGT,labelGtTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelGtReturn);
methodVisitor.visitLabel(labelGtTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelGtReturn);
break;
case JavascriptParser.AT_COMP_LTE:
Label labelLteTrue=new Label();
Label labelLteReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DCMPG);
methodVisitor.visitJumpInsn(IFLE,labelLteTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelLteReturn);
methodVisitor.visitLabel(labelLteTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelLteReturn);
break;
case JavascriptParser.AT_COMP_GTE:
Label labelGteTrue=new Label();
Label labelGteReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.DOUBLE);
recursiveCompile(current.getChild(1),ComputedType.DOUBLE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFGE,labelGteTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelGteReturn);
methodVisitor.visitLabel(labelGteTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelGteReturn);
break;
case JavascriptParser.AT_BOOL_NOT:
Label labelNotTrue=new Label();
Label labelNotReturn=new Label();
recursiveCompile(current.getChild(0),ComputedType.INT);
methodVisitor.visitJumpInsn(IFEQ,labelNotTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelNotReturn);
methodVisitor.visitLabel(labelNotTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelNotReturn);
break;
case JavascriptParser.AT_BOOL_AND:
Label andFalse=new Label();
Label andEnd=new Label();
recursiveCompile(current.getChild(0),ComputedType.INT);
methodVisitor.visitJumpInsn(IFEQ,andFalse);
recursiveCompile(current.getChild(1),ComputedType.INT);
methodVisitor.visitJumpInsn(IFEQ,andFalse);
truthCompile(expected,true);
methodVisitor.visitJumpInsn(GOTO,andEnd);
methodVisitor.visitLabel(andFalse);
truthCompile(expected,false);
methodVisitor.visitLabel(andEnd);
break;
case JavascriptParser.AT_BOOL_OR:
Label orTrue=new Label();
Label orEnd=new Label();
recursiveCompile(current.getChild(0),ComputedType.INT);
methodVisitor.visitJumpInsn(IFNE,orTrue);
recursiveCompile(current.getChild(1),ComputedType.INT);
methodVisitor.visitJumpInsn(IFNE,orTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,orEnd);
methodVisitor.visitLabel(orTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(orEnd);
break;
case JavascriptParser.AT_COND_QUE:
Label condFalse=new Label();
Label condEnd=new Label();
recursiveCompile(current.getChild(0),ComputedType.INT);
methodVisitor.visitJumpInsn(IFEQ,condFalse);
recursiveCompile(current.getChild(1),expected);
methodVisitor.visitJumpInsn(GOTO,condEnd);
methodVisitor.visitLabel(condFalse);
recursiveCompile(current.getChild(2),expected);
methodVisitor.visitLabel(condEnd);
break;
default :
throw new IllegalStateException("Unknown operation specified: (" + current.getText() + ").");
}
}
