{
  int type=current.getType();
  String text=current.getText();
switch (type) {
case JavascriptParser.AT_CALL:
    Tree identifier=current.getChild(0);
  String call=identifier.getText();
int arguments=current.getChildCount() - 1;
Method method=functions.get(call);
if (method == null) {
throw new IllegalArgumentException("Unrecognized method call (" + call + ").");
}
int arity=method.getParameterTypes().length;
if (arguments != arity) {
throw new IllegalArgumentException("Expected (" + arity + ") arguments for method call ("+ call+ "), but found ("+ arguments+ ").");
}
for (int argument=1; argument <= arguments; ++argument) {
recursiveCompile(current.getChild(argument),Type.DOUBLE_TYPE);
}
methodVisitor.invokeStatic(Type.getType(method.getDeclaringClass()),org.objectweb.asm.commons.Method.getMethod(method));
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.ID:
int index;
if (externalsMap.containsKey(text)) {
index=externalsMap.get(text);
}
 else {
index=externalsMap.size();
externalsMap.put(text,index);
}
methodVisitor.loadArg(1);
methodVisitor.push(index);
methodVisitor.arrayLoad(FUNCTION_VALUES_TYPE);
methodVisitor.loadArg(0);
methodVisitor.invokeVirtual(FUNCTION_VALUES_TYPE,DOUBLE_VAL_METHOD);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.HEX:
long hex=Long.parseLong(text.substring(2),16);
if (expected == Type.INT_TYPE) {
methodVisitor.push((int)hex);
}
 else if (expected == Type.LONG_TYPE) {
methodVisitor.push(hex);
}
 else {
methodVisitor.push((double)hex);
}
break;
case JavascriptParser.OCTAL:
long octal=Long.parseLong(text.substring(1),8);
if (expected == Type.INT_TYPE) {
methodVisitor.push((int)octal);
}
 else if (expected == Type.LONG_TYPE) {
methodVisitor.push(octal);
}
 else {
methodVisitor.push((double)octal);
}
break;
case JavascriptParser.DECIMAL:
double decimal=Double.parseDouble(text);
methodVisitor.push(decimal);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_NEGATE:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DNEG);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_ADD:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DADD);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_SUBTRACT:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DSUB);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_MULTIPLY:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(Opcodes.DMUL);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_DIVIDE:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DDIV);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_MODULO:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DREM);
methodVisitor.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_BIT_SHL:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
methodVisitor.visitInsn(LSHL);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_SHR:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
methodVisitor.visitInsn(LSHR);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_SHU:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
methodVisitor.visitInsn(LUSHR);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_AND:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.LONG_TYPE);
methodVisitor.visitInsn(LAND);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_OR:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.LONG_TYPE);
methodVisitor.visitInsn(LOR);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_XOR:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.LONG_TYPE);
methodVisitor.visitInsn(LXOR);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_NOT:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
methodVisitor.visitLdcInsn(new Long(-1));
methodVisitor.visitInsn(LXOR);
methodVisitor.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_COMP_EQ:
Label labelEqTrue=new Label();
Label labelEqReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFEQ,labelEqTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelEqReturn);
methodVisitor.visitLabel(labelEqTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelEqReturn);
break;
case JavascriptParser.AT_COMP_NEQ:
Label labelNeqTrue=new Label();
Label labelNeqReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFNE,labelNeqTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelNeqReturn);
methodVisitor.visitLabel(labelNeqTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelNeqReturn);
break;
case JavascriptParser.AT_COMP_LT:
Label labelLtTrue=new Label();
Label labelLtReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DCMPG);
methodVisitor.visitJumpInsn(IFLT,labelLtTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelLtReturn);
methodVisitor.visitLabel(labelLtTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelLtReturn);
break;
case JavascriptParser.AT_COMP_GT:
Label labelGtTrue=new Label();
Label labelGtReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFGT,labelGtTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelGtReturn);
methodVisitor.visitLabel(labelGtTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelGtReturn);
break;
case JavascriptParser.AT_COMP_LTE:
Label labelLteTrue=new Label();
Label labelLteReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DCMPG);
methodVisitor.visitJumpInsn(IFLE,labelLteTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelLteReturn);
methodVisitor.visitLabel(labelLteTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelLteReturn);
break;
case JavascriptParser.AT_COMP_GTE:
Label labelGteTrue=new Label();
Label labelGteReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
methodVisitor.visitInsn(DCMPL);
methodVisitor.visitJumpInsn(IFGE,labelGteTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelGteReturn);
methodVisitor.visitLabel(labelGteTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelGteReturn);
break;
case JavascriptParser.AT_BOOL_NOT:
Label labelNotTrue=new Label();
Label labelNotReturn=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
methodVisitor.visitJumpInsn(IFEQ,labelNotTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,labelNotReturn);
methodVisitor.visitLabel(labelNotTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(labelNotReturn);
break;
case JavascriptParser.AT_BOOL_AND:
Label andFalse=new Label();
Label andEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
methodVisitor.visitJumpInsn(IFEQ,andFalse);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
methodVisitor.visitJumpInsn(IFEQ,andFalse);
truthCompile(expected,true);
methodVisitor.visitJumpInsn(GOTO,andEnd);
methodVisitor.visitLabel(andFalse);
truthCompile(expected,false);
methodVisitor.visitLabel(andEnd);
break;
case JavascriptParser.AT_BOOL_OR:
Label orTrue=new Label();
Label orEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
methodVisitor.visitJumpInsn(IFNE,orTrue);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
methodVisitor.visitJumpInsn(IFNE,orTrue);
truthCompile(expected,false);
methodVisitor.visitJumpInsn(GOTO,orEnd);
methodVisitor.visitLabel(orTrue);
truthCompile(expected,true);
methodVisitor.visitLabel(orEnd);
break;
case JavascriptParser.AT_COND_QUE:
Label condFalse=new Label();
Label condEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
methodVisitor.visitJumpInsn(IFEQ,condFalse);
recursiveCompile(current.getChild(1),expected);
methodVisitor.visitJumpInsn(GOTO,condEnd);
methodVisitor.visitLabel(condFalse);
recursiveCompile(current.getChild(2),expected);
methodVisitor.visitLabel(condEnd);
break;
default :
throw new IllegalStateException("Unknown operation specified: (" + current.getText() + ").");
}
}
