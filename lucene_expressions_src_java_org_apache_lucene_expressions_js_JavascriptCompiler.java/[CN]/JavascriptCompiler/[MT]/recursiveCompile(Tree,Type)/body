{
  int type=current.getType();
  String text=current.getText();
switch (type) {
case JavascriptParser.AT_CALL:
    Tree identifier=current.getChild(0);
  String call=identifier.getText();
int arguments=current.getChildCount() - 1;
Method method=functions.get(call);
if (method == null) {
throw new IllegalArgumentException("Unrecognized method call (" + call + ").");
}
int arity=method.getParameterTypes().length;
if (arguments != arity) {
throw new IllegalArgumentException("Expected (" + arity + ") arguments for method call ("+ call+ "), but found ("+ arguments+ ").");
}
for (int argument=1; argument <= arguments; ++argument) {
recursiveCompile(current.getChild(argument),Type.DOUBLE_TYPE);
}
gen.invokeStatic(Type.getType(method.getDeclaringClass()),org.objectweb.asm.commons.Method.getMethod(method));
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.ID:
int index;
if (externalsMap.containsKey(text)) {
index=externalsMap.get(text);
}
 else {
index=externalsMap.size();
externalsMap.put(text,index);
}
gen.loadArg(1);
gen.push(index);
gen.arrayLoad(FUNCTION_VALUES_TYPE);
gen.loadArg(0);
gen.invokeVirtual(FUNCTION_VALUES_TYPE,DOUBLE_VAL_METHOD);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.HEX:
pushLong(expected,Long.parseLong(text.substring(2),16));
break;
case JavascriptParser.OCTAL:
pushLong(expected,Long.parseLong(text.substring(1),8));
break;
case JavascriptParser.DECIMAL:
gen.push(Double.parseDouble(text));
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_NEGATE:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
gen.visitInsn(DNEG);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_ADD:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DADD);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_SUBTRACT:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DSUB);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_MULTIPLY:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(Opcodes.DMUL);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_DIVIDE:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DDIV);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_MODULO:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DREM);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case JavascriptParser.AT_BIT_SHL:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitInsn(LSHL);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_SHR:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitInsn(LSHR);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_SHU:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitInsn(LUSHR);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_AND:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.LONG_TYPE);
gen.visitInsn(LAND);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_OR:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.LONG_TYPE);
gen.visitInsn(LOR);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_XOR:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
recursiveCompile(current.getChild(1),Type.LONG_TYPE);
gen.visitInsn(LXOR);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_BIT_NOT:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
gen.visitLdcInsn(new Long(-1));
gen.visitInsn(LXOR);
gen.cast(Type.LONG_TYPE,expected);
break;
case JavascriptParser.AT_COMP_EQ:
Label labelEqTrue=new Label();
Label labelEqReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DCMPL);
gen.visitJumpInsn(IFEQ,labelEqTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelEqReturn);
gen.visitLabel(labelEqTrue);
pushBoolean(expected,true);
gen.visitLabel(labelEqReturn);
break;
case JavascriptParser.AT_COMP_NEQ:
Label labelNeqTrue=new Label();
Label labelNeqReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DCMPL);
gen.visitJumpInsn(IFNE,labelNeqTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelNeqReturn);
gen.visitLabel(labelNeqTrue);
pushBoolean(expected,true);
gen.visitLabel(labelNeqReturn);
break;
case JavascriptParser.AT_COMP_LT:
Label labelLtTrue=new Label();
Label labelLtReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DCMPG);
gen.visitJumpInsn(IFLT,labelLtTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelLtReturn);
gen.visitLabel(labelLtTrue);
pushBoolean(expected,true);
gen.visitLabel(labelLtReturn);
break;
case JavascriptParser.AT_COMP_GT:
Label labelGtTrue=new Label();
Label labelGtReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DCMPL);
gen.visitJumpInsn(IFGT,labelGtTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelGtReturn);
gen.visitLabel(labelGtTrue);
pushBoolean(expected,true);
gen.visitLabel(labelGtReturn);
break;
case JavascriptParser.AT_COMP_LTE:
Label labelLteTrue=new Label();
Label labelLteReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DCMPG);
gen.visitJumpInsn(IFLE,labelLteTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelLteReturn);
gen.visitLabel(labelLteTrue);
pushBoolean(expected,true);
gen.visitLabel(labelLteReturn);
break;
case JavascriptParser.AT_COMP_GTE:
Label labelGteTrue=new Label();
Label labelGteReturn=new Label();
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
recursiveCompile(current.getChild(1),Type.DOUBLE_TYPE);
gen.visitInsn(DCMPL);
gen.visitJumpInsn(IFGE,labelGteTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelGteReturn);
gen.visitLabel(labelGteTrue);
pushBoolean(expected,true);
gen.visitLabel(labelGteReturn);
break;
case JavascriptParser.AT_BOOL_NOT:
Label labelNotTrue=new Label();
Label labelNotReturn=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(IFEQ,labelNotTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,labelNotReturn);
gen.visitLabel(labelNotTrue);
pushBoolean(expected,true);
gen.visitLabel(labelNotReturn);
break;
case JavascriptParser.AT_BOOL_AND:
Label andFalse=new Label();
Label andEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(IFEQ,andFalse);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitJumpInsn(IFEQ,andFalse);
pushBoolean(expected,true);
gen.visitJumpInsn(GOTO,andEnd);
gen.visitLabel(andFalse);
pushBoolean(expected,false);
gen.visitLabel(andEnd);
break;
case JavascriptParser.AT_BOOL_OR:
Label orTrue=new Label();
Label orEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(IFNE,orTrue);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitJumpInsn(IFNE,orTrue);
pushBoolean(expected,false);
gen.visitJumpInsn(GOTO,orEnd);
gen.visitLabel(orTrue);
pushBoolean(expected,true);
gen.visitLabel(orEnd);
break;
case JavascriptParser.AT_COND_QUE:
Label condFalse=new Label();
Label condEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(IFEQ,condFalse);
recursiveCompile(current.getChild(1),expected);
gen.visitJumpInsn(GOTO,condEnd);
gen.visitLabel(condFalse);
recursiveCompile(current.getChild(2),expected);
gen.visitLabel(condEnd);
break;
default :
throw new IllegalStateException("Unknown operation specified: (" + current.getText() + ").");
}
}
