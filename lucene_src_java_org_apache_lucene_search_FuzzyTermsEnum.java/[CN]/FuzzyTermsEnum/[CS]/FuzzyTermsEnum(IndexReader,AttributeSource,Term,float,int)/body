{
  if (minSimilarity >= 1.0f && minSimilarity != (int)minSimilarity)   throw new IllegalArgumentException("fractional edit distances are not allowed");
  if (minSimilarity < 0.0f)   throw new IllegalArgumentException("minimumSimilarity cannot be less than 0");
  if (prefixLength < 0)   throw new IllegalArgumentException("prefixLength cannot be less than 0");
  this.reader=reader;
  this.term=term;
  final String utf16=term.text();
  this.termText=new int[utf16.codePointCount(0,utf16.length())];
  for (int cp, i=0, j=0; i < utf16.length(); i+=Character.charCount(cp))   termText[j++]=cp=utf16.codePointAt(i);
  this.termLength=termText.length;
  this.dfaAtt=atts.addAttribute(LevenshteinAutomataAttribute.class);
  this.realPrefixLength=prefixLength > termLength ? termLength : prefixLength;
  if (minSimilarity >= 1f) {
    this.minSimilarity=1 - (minSimilarity + 1) / this.termLength;
    maxEdits=(int)minSimilarity;
    raw=true;
  }
 else {
    this.minSimilarity=minSimilarity;
    maxEdits=initialMaxDistance(this.minSimilarity,termLength);
    raw=false;
  }
  this.scale_factor=1.0f / (1.0f - this.minSimilarity);
  this.maxBoostAtt=atts.addAttribute(MultiTermQuery.MaxNonCompetitiveBoostAttribute.class);
  bottom=maxBoostAtt.getMaxNonCompetitiveBoost();
  bottomTerm=maxBoostAtt.getCompetitiveTerm();
  bottomChanged(null,true);
}
