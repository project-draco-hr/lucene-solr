{
  final int m=length;
  final int n=text.length;
  if (n == 0) {
    return prefixLen == 0 ? 0.0f : 1.0f - ((float)m / prefixLen);
  }
  if (m == 0) {
    return prefixLen == 0 ? 0.0f : 1.0f - ((float)n / prefixLen);
  }
  final int maxDistance=getMaxDistance(m);
  if (maxDistance < Math.abs(m - n)) {
    return 0.0f;
  }
  if (d[0].length <= m) {
    growDistanceArray(m);
  }
  for (int i=0; i <= n; i++)   d[i][0]=i;
  for (int j=0; j <= m; j++)   d[0][j]=j;
  for (int i=1; i <= n; i++) {
    int bestPossibleEditDistance=m;
    final char s_i=text[i - 1];
    for (int j=1; j <= m; j++) {
      if (s_i != target[offset + j - 1]) {
        d[i][j]=min(d[i - 1][j],d[i][j - 1],d[i - 1][j - 1]) + 1;
      }
 else {
        d[i][j]=min(d[i - 1][j] + 1,d[i][j - 1] + 1,d[i - 1][j - 1]);
      }
      bestPossibleEditDistance=Math.min(bestPossibleEditDistance,d[i][j]);
    }
    if (i > maxDistance && bestPossibleEditDistance > maxDistance) {
      return 0.0f;
    }
  }
  return 1.0f - ((float)d[n][m] / (float)(prefixLen + Math.min(n,m)));
}
