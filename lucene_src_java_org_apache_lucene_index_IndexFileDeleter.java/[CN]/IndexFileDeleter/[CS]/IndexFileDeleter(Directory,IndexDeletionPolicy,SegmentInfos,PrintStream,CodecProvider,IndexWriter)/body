{
  this.infoStream=infoStream;
  this.writer=writer;
  final String currentSegmentsFile=segmentInfos.getCurrentSegmentFileName();
  if (infoStream != null) {
    message("init: current segments file is \"" + currentSegmentsFile + "\"; deletionPolicy="+ policy);
  }
  this.policy=policy;
  this.directory=directory;
  long currentGen=segmentInfos.getGeneration();
  indexFilenameFilter=new IndexFileNameFilter(codecs);
  CommitPoint currentCommitPoint=null;
  String[] files=null;
  try {
    files=directory.listAll();
  }
 catch (  NoSuchDirectoryException e) {
    files=new String[0];
  }
  for (  String fileName : files) {
    if ((indexFilenameFilter.accept(null,fileName)) && !fileName.endsWith("write.lock") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {
      getRefCount(fileName);
      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {
        if (infoStream != null) {
          message("init: load commit \"" + fileName + "\"");
        }
        SegmentInfos sis=new SegmentInfos(codecs);
        try {
          sis.read(directory,fileName,codecs);
        }
 catch (        FileNotFoundException e) {
          if (infoStream != null) {
            message("init: hit FileNotFoundException when loading commit \"" + fileName + "\"; skipping this commit point");
          }
          sis=null;
        }
catch (        IOException e) {
          if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen) {
            throw e;
          }
 else {
            sis=null;
          }
        }
        if (sis != null) {
          final SegmentInfos infos=sis;
          for (          SegmentInfo segmentInfo : infos) {
            try {
              segmentInfo.getFieldInfos();
            }
 catch (            FileNotFoundException e) {
              refresh(segmentInfo.name);
              sis=null;
              if (infoStream != null) {
                message("init: hit FileNotFoundException when loading commit \"" + fileName + "\"; skipping this commit point");
              }
            }
          }
        }
        if (sis != null) {
          final CommitPoint commitPoint=new CommitPoint(commitsToDelete,directory,sis);
          if (sis.getGeneration() == segmentInfos.getGeneration()) {
            currentCommitPoint=commitPoint;
          }
          commits.add(commitPoint);
          incRef(sis,true);
          if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {
            lastSegmentInfos=sis;
          }
        }
      }
    }
  }
  if (currentCommitPoint == null && currentSegmentsFile != null) {
    SegmentInfos sis=new SegmentInfos(codecs);
    try {
      sis.read(directory,currentSegmentsFile,codecs);
    }
 catch (    IOException e) {
      throw new CorruptIndexException("failed to locate current segments_N file");
    }
    if (infoStream != null) {
      message("forced open of current segments file " + segmentInfos.getCurrentSegmentFileName());
    }
    currentCommitPoint=new CommitPoint(commitsToDelete,directory,sis);
    commits.add(currentCommitPoint);
    incRef(sis,true);
  }
  CollectionUtil.mergeSort(commits);
  for (  Map.Entry<String,RefCount> entry : refCounts.entrySet()) {
    RefCount rc=entry.getValue();
    final String fileName=entry.getKey();
    if (0 == rc.count) {
      if (infoStream != null) {
        message("init: removing unreferenced file \"" + fileName + "\"");
      }
      deleteFile(fileName);
    }
  }
  if (currentSegmentsFile != null) {
    policy.onInit(commits);
  }
  checkpoint(segmentInfos,false);
  startingCommitDeleted=currentCommitPoint == null ? false : currentCommitPoint.isDeleted();
  deleteCommits();
}
