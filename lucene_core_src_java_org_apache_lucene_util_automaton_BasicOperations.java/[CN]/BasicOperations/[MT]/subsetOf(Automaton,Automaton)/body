{
  if (a1 == a2)   return true;
  if (a1.isSingleton()) {
    if (a2.isSingleton())     return a1.singleton.equals(a2.singleton);
    return BasicOperations.run(a2,a1.singleton);
  }
  a2.determinize();
  Transition[][] transitions1=a1.getSortedTransitions();
  Transition[][] transitions2=a2.getSortedTransitions();
  LinkedList<StatePair> worklist=new LinkedList<StatePair>();
  HashSet<StatePair> visited=new HashSet<StatePair>();
  StatePair p=new StatePair(a1.initial,a2.initial);
  worklist.add(p);
  visited.add(p);
  while (worklist.size() > 0) {
    p=worklist.removeFirst();
    if (p.s1.accept && !p.s2.accept) {
      return false;
    }
    Transition[] t1=transitions1[p.s1.number];
    Transition[] t2=transitions2[p.s2.number];
    for (int n1=0, b2=0; n1 < t1.length; n1++) {
      while (b2 < t2.length && t2[b2].max < t1[n1].min)       b2++;
      int min1=t1[n1].min, max1=t1[n1].max;
      for (int n2=b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++) {
        if (t2[n2].min > min1) {
          return false;
        }
        if (t2[n2].max < Character.MAX_CODE_POINT)         min1=t2[n2].max + 1;
 else {
          min1=Character.MAX_CODE_POINT;
          max1=Character.MIN_CODE_POINT;
        }
        StatePair q=new StatePair(t1[n1].to,t2[n2].to);
        if (!visited.contains(q)) {
          worklist.add(q);
          visited.add(q);
        }
      }
      if (min1 <= max1) {
        return false;
      }
    }
  }
  return true;
}
