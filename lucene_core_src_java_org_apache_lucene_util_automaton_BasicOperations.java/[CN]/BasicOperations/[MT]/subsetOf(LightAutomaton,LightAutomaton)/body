{
  if (a1.isDeterministic() == false) {
    throw new IllegalArgumentException("a1 must be deterministic");
  }
  if (a2.isDeterministic() == false) {
    throw new IllegalArgumentException("a2 must be deterministic");
  }
  Transition[][] transitions1=a1.getSortedTransitions();
  Transition[][] transitions2=a2.getSortedTransitions();
  LinkedList<LightStatePair> worklist=new LinkedList<>();
  HashSet<LightStatePair> visited=new HashSet<>();
  LightStatePair p=new LightStatePair(0,0);
  worklist.add(p);
  visited.add(p);
  while (worklist.size() > 0) {
    p=worklist.removeFirst();
    if (a1.isAccept(p.s1) && a2.isAccept(p.s2) == false) {
      return false;
    }
    Transition[] t1=transitions1[p.s1];
    Transition[] t2=transitions2[p.s2];
    for (int n1=0, b2=0; n1 < t1.length; n1++) {
      while (b2 < t2.length && t2[b2].max < t1[n1].min) {
        b2++;
      }
      int min1=t1[n1].min, max1=t1[n1].max;
      for (int n2=b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++) {
        if (t2[n2].min > min1) {
          return false;
        }
        if (t2[n2].max < Character.MAX_CODE_POINT) {
          min1=t2[n2].max + 1;
        }
 else {
          min1=Character.MAX_CODE_POINT;
          max1=Character.MIN_CODE_POINT;
        }
        LightStatePair q=new LightStatePair(t1[n1].dest,t2[n2].dest);
        if (!visited.contains(q)) {
          worklist.add(q);
          visited.add(q);
        }
      }
      if (min1 <= max1) {
        return false;
      }
    }
  }
  return true;
}
