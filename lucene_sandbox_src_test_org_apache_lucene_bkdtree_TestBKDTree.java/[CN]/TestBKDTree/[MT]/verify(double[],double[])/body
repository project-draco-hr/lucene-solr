{
  int maxPointsInLeaf=TestUtil.nextInt(random(),16,2048);
  int maxPointsSortInHeap=TestUtil.nextInt(random(),maxPointsInLeaf,1024 * 1024);
  IndexWriterConfig iwc=newIndexWriterConfig();
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < lats.length / 100) {
    iwc.setMaxBufferedDocs(lats.length / 100);
  }
  final DocValuesFormat dvFormat=new BKDTreeDocValuesFormat(maxPointsInLeaf,maxPointsSortInHeap);
  Codec codec=new Lucene53Codec(){
    @Override public DocValuesFormat getDocValuesFormatForField(    String field){
      if (field.equals("point")) {
        return dvFormat;
      }
 else {
        return super.getDocValuesFormatForField(field);
      }
    }
  }
;
  iwc.setCodec(codec);
  Directory dir;
  if (lats.length > 100000) {
    dir=newFSDirectory(createTempDir("TestBKDTree"));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < lats.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(lats[id]) == false) {
      doc.add(new BKDPointField("point",lats[id],lons[id]));
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w,true);
  w.close();
  IndexSearcher s=newSearcher(r,false);
  int numThreads=TestUtil.nextInt(random(),2,5);
  List<Thread> threads=new ArrayList<>();
  final int iters=atLeast(100);
  final CountDownLatch startingGun=new CountDownLatch(1);
  final AtomicBoolean failed=new AtomicBoolean();
  for (int i=0; i < numThreads; i++) {
    Thread thread=new Thread(){
      @Override public void run(){
        try {
          _run();
        }
 catch (        Exception e) {
          failed.set(true);
          throw new RuntimeException(e);
        }
      }
      private void _run() throws Exception {
        startingGun.await();
        NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
        for (int iter=0; iter < iters && failed.get() == false; iter++) {
          double lat0=randomLat();
          double lat1=randomLat();
          double lon0=randomLon();
          double lon1=randomLon();
          if (lat1 < lat0) {
            double x=lat0;
            lat0=lat1;
            lat1=x;
          }
          if (lon1 < lon0) {
            double x=lon0;
            lon0=lon1;
            lon1=x;
          }
          if (VERBOSE) {
            System.out.println("\nTEST: iter=" + iter + " lat="+ lat0+ " TO "+ lat1+ " lon="+ lon0+ " TO "+ lon1);
          }
          Query query;
          if (random().nextBoolean()) {
            query=new BKDPointInBBoxQuery("point",lat0,lat1,lon0,lon1);
          }
 else {
            double[] lats=new double[5];
            double[] lons=new double[5];
            lats[0]=lat0;
            lons[0]=lon0;
            lats[1]=lat1;
            lons[1]=lon0;
            lats[2]=lat1;
            lons[2]=lon1;
            lats[3]=lat0;
            lons[3]=lon1;
            lats[4]=lat0;
            lons[4]=lon0;
            query=new BKDPointInPolygonQuery("point",lats,lons);
          }
          if (VERBOSE) {
            System.out.println("  using query: " + query);
          }
          final FixedBitSet hits=new FixedBitSet(r.maxDoc());
          s.search(query,new SimpleCollector(){
            private int docBase;
            @Override public boolean needsScores(){
              return false;
            }
            @Override protected void doSetNextReader(            LeafReaderContext context) throws IOException {
              docBase=context.docBase;
            }
            @Override public void collect(            int doc){
              hits.set(docBase + doc);
            }
          }
);
          if (VERBOSE) {
            System.out.println("  hitCount: " + hits.cardinality());
          }
          for (int docID=0; docID < r.maxDoc(); docID++) {
            int id=(int)docIDToID.get(docID);
            boolean expected=deleted.contains(id) == false && rectContainsPointEnc(lat0,lat1,lon0,lon1,lats[id],lons[id]);
            if (hits.get(docID) != expected) {
              if (query instanceof BKDPointInPolygonQuery && (Math.abs(lat0 - lats[id]) < TOLERANCE || Math.abs(lat1 - lats[id]) < TOLERANCE || Math.abs(lon0 - lons[id]) < TOLERANCE || Math.abs(lon1 - lons[id]) < TOLERANCE)) {
              }
 else {
                fail(Thread.currentThread().getName() + ": iter=" + iter+ " id="+ id+ " docID="+ docID+ " lat="+ lats[id]+ " lon="+ lons[id]+ " (bbox: lat="+ lat0+ " TO "+ lat1+ " lon="+ lon0+ " TO "+ lon1+ ") expected "+ expected+ " but got: "+ hits.get(docID)+ " deleted?="+ deleted.contains(id)+ " query="+ query);
              }
            }
          }
        }
      }
    }
;
    thread.setName("T" + i);
    thread.start();
    threads.add(thread);
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  IOUtils.close(r,dir);
}
