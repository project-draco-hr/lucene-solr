{
  int numValues=docValues.length;
  if (VERBOSE) {
    System.out.println("TEST: numValues=" + numValues + " numDims="+ numDims+ " numBytesPerDim="+ numBytesPerDim+ " maxPointsInLeafNode="+ maxPointsInLeafNode+ " maxMB="+ maxMB);
  }
  List<Long> toMerge=null;
  List<Integer> docIDBases=null;
  int seg=0;
  BKDWriter w=new BKDWriter(numValues,dir,"_" + seg,numDims,numBytesPerDim,maxPointsInLeafNode,maxMB,docValues.length,false);
  IndexOutput out=dir.createOutput("bkd",IOContext.DEFAULT);
  IndexInput in=null;
  boolean success=false;
  try {
    byte[] scratch=new byte[numBytesPerDim * numDims];
    int lastDocIDBase=0;
    boolean useMerge=numDims == 1 && numValues >= 10 && random().nextBoolean();
    int valuesInThisSeg;
    if (useMerge) {
      valuesInThisSeg=TestUtil.nextInt(random(),numValues / 10,numValues);
    }
 else {
      valuesInThisSeg=0;
    }
    int segCount=0;
    for (int ord=0; ord < numValues; ord++) {
      int docID;
      if (docIDs == null) {
        docID=ord;
      }
 else {
        docID=docIDs[ord];
      }
      if (VERBOSE) {
        System.out.println("  ord=" + ord + " docID="+ docID+ " lastDocIDBase="+ lastDocIDBase);
      }
      for (int dim=0; dim < numDims; dim++) {
        if (VERBOSE) {
          System.out.println("    " + dim + " -> "+ new BytesRef(docValues[ord][dim]));
        }
        System.arraycopy(docValues[ord][dim],0,scratch,dim * numBytesPerDim,numBytesPerDim);
      }
      w.add(scratch,docID - lastDocIDBase);
      segCount++;
      if (useMerge && segCount == valuesInThisSeg) {
        if (toMerge == null) {
          toMerge=new ArrayList<>();
          docIDBases=new ArrayList<>();
        }
        docIDBases.add(lastDocIDBase);
        toMerge.add(w.finish(out));
        valuesInThisSeg=TestUtil.nextInt(random(),numValues / 10,numValues / 2);
        segCount=0;
        seg++;
        maxPointsInLeafNode=TestUtil.nextInt(random(),50,1000);
        maxMB=(float)3.0 + (3 * random().nextDouble());
        w=new BKDWriter(numValues,dir,"_" + seg,numDims,numBytesPerDim,maxPointsInLeafNode,maxMB,docValues.length,false);
        lastDocIDBase=docID;
      }
    }
    long indexFP;
    if (toMerge != null) {
      if (segCount > 0) {
        docIDBases.add(lastDocIDBase);
        toMerge.add(w.finish(out));
      }
      out.close();
      in=dir.openInput("bkd",IOContext.DEFAULT);
      seg++;
      w=new BKDWriter(numValues,dir,"_" + seg,numDims,numBytesPerDim,maxPointsInLeafNode,maxMB,docValues.length,false);
      List<BKDReader> readers=new ArrayList<>();
      for (      long fp : toMerge) {
        in.seek(fp);
        readers.add(new BKDReader(in));
      }
      out=dir.createOutput("bkd2",IOContext.DEFAULT);
      indexFP=w.merge(out,null,readers,docIDBases);
      out.close();
      in.close();
      in=dir.openInput("bkd2",IOContext.DEFAULT);
    }
 else {
      indexFP=w.finish(out);
      out.close();
      in=dir.openInput("bkd",IOContext.DEFAULT);
    }
    in.seek(indexFP);
    BKDReader r=new BKDReader(in);
    int iters=atLeast(100);
    for (int iter=0; iter < iters; iter++) {
      if (VERBOSE) {
        System.out.println("\nTEST: iter=" + iter);
      }
      byte[][] queryMin=new byte[numDims][];
      byte[][] queryMax=new byte[numDims][];
      for (int dim=0; dim < numDims; dim++) {
        queryMin[dim]=new byte[numBytesPerDim];
        random().nextBytes(queryMin[dim]);
        queryMax[dim]=new byte[numBytesPerDim];
        random().nextBytes(queryMax[dim]);
        if (StringHelper.compare(numBytesPerDim,queryMin[dim],0,queryMax[dim],0) > 0) {
          byte[] x=queryMin[dim];
          queryMin[dim]=queryMax[dim];
          queryMax[dim]=x;
        }
      }
      final BitSet hits=new BitSet();
      r.intersect(new IntersectVisitor(){
        @Override public void visit(        int docID){
          hits.set(docID);
        }
        @Override public void visit(        int docID,        byte[] packedValue){
          for (int dim=0; dim < numDims; dim++) {
            if (StringHelper.compare(numBytesPerDim,packedValue,dim * numBytesPerDim,queryMin[dim],0) < 0 || StringHelper.compare(numBytesPerDim,packedValue,dim * numBytesPerDim,queryMax[dim],0) > 0) {
              return;
            }
          }
          hits.set(docID);
        }
        @Override public Relation compare(        byte[] minPacked,        byte[] maxPacked){
          boolean crosses=false;
          for (int dim=0; dim < numDims; dim++) {
            if (StringHelper.compare(numBytesPerDim,maxPacked,dim * numBytesPerDim,queryMin[dim],0) < 0 || StringHelper.compare(numBytesPerDim,minPacked,dim * numBytesPerDim,queryMax[dim],0) > 0) {
              return Relation.CELL_OUTSIDE_QUERY;
            }
 else             if (StringHelper.compare(numBytesPerDim,minPacked,dim * numBytesPerDim,queryMin[dim],0) < 0 || StringHelper.compare(numBytesPerDim,maxPacked,dim * numBytesPerDim,queryMax[dim],0) > 0) {
              crosses=true;
            }
          }
          if (crosses) {
            return Relation.CELL_CROSSES_QUERY;
          }
 else {
            return Relation.CELL_INSIDE_QUERY;
          }
        }
      }
);
      BitSet expected=new BitSet();
      for (int ord=0; ord < numValues; ord++) {
        boolean matches=true;
        for (int dim=0; dim < numDims; dim++) {
          byte[] x=docValues[ord][dim];
          if (StringHelper.compare(numBytesPerDim,x,0,queryMin[dim],0) < 0 || StringHelper.compare(numBytesPerDim,x,0,queryMax[dim],0) > 0) {
            matches=false;
            break;
          }
        }
        if (matches) {
          int docID;
          if (docIDs == null) {
            docID=ord;
          }
 else {
            docID=docIDs[ord];
          }
          expected.set(docID);
        }
      }
      int limit=Math.max(expected.length(),hits.length());
      for (int docID=0; docID < limit; docID++) {
        assertEquals("docID=" + docID,expected.get(docID),hits.get(docID));
      }
    }
    in.close();
    dir.deleteFile("bkd");
    if (toMerge != null) {
      dir.deleteFile("bkd2");
    }
    success=true;
  }
  finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(w,in,out);
      IOUtils.deleteFilesIgnoringExceptions(dir,"bkd","bkd2");
    }
  }
}
