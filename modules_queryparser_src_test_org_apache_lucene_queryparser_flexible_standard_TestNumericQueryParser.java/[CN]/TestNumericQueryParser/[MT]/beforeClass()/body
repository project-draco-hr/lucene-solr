{
  ANALYZER=new MockAnalyzer(random);
  qp=new StandardQueryParser(ANALYZER);
  final HashMap<String,Number> randomNumberMap=new HashMap<String,Number>();
  SimpleDateFormat dateFormat;
  long randomDate;
  boolean dateFormatSanityCheckPass;
  int count=0;
  do {
    if (count > 100) {
      fail("This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.");
    }
    dateFormatSanityCheckPass=true;
    LOCALE=randomLocale(random);
    TIMEZONE=randomTimeZone(random);
    DATE_STYLE=randomDateStyle(random);
    TIME_STYLE=randomDateStyle(random);
    dateFormat=(SimpleDateFormat)DateFormat.getDateTimeInstance(DATE_STYLE,TIME_STYLE,LOCALE);
    dateFormat.applyPattern(dateFormat.toPattern() + " G s Z yyyy");
    dateFormat.setTimeZone(TIMEZONE);
    DATE_FORMAT=new NumberDateFormat(dateFormat);
    do {
      randomDate=random.nextLong();
      randomDate=randomDate % 3400000000000l;
      randomDate=(randomDate / 1000L) * 1000L;
      randomDate=Math.abs(randomDate);
    }
 while (randomDate == 0L);
    dateFormatSanityCheckPass&=checkDateFormatSanity(dateFormat,randomDate);
    dateFormatSanityCheckPass&=checkDateFormatSanity(dateFormat,0);
    dateFormatSanityCheckPass&=checkDateFormatSanity(dateFormat,-randomDate);
    count++;
  }
 while (!dateFormatSanityCheckPass);
  NUMBER_FORMAT=NumberFormat.getNumberInstance(LOCALE);
  NUMBER_FORMAT.setMaximumFractionDigits((random.nextInt() & 20) + 1);
  NUMBER_FORMAT.setMinimumFractionDigits((random.nextInt() & 20) + 1);
  NUMBER_FORMAT.setMaximumIntegerDigits((random.nextInt() & 20) + 1);
  NUMBER_FORMAT.setMinimumIntegerDigits((random.nextInt() & 20) + 1);
  double randomDouble;
  long randomLong;
  int randomInt;
  float randomFloat;
  while ((randomLong=normalizeNumber(Math.abs(random.nextLong())).longValue()) == 0L)   ;
  while ((randomDouble=normalizeNumber(Math.abs(random.nextDouble())).doubleValue()) == 0.0)   ;
  while ((randomFloat=normalizeNumber(Math.abs(random.nextFloat())).floatValue()) == 0.0f)   ;
  while ((randomInt=normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)   ;
  randomNumberMap.put(NumericField.DataType.LONG.name(),randomLong);
  randomNumberMap.put(NumericField.DataType.INT.name(),randomInt);
  randomNumberMap.put(NumericField.DataType.FLOAT.name(),randomFloat);
  randomNumberMap.put(NumericField.DataType.DOUBLE.name(),randomDouble);
  randomNumberMap.put(DATE_FIELD_NAME,randomDate);
  RANDOM_NUMBER_MAP=Collections.unmodifiableMap(randomNumberMap);
  directory=newDirectory();
  RandomIndexWriter writer=new RandomIndexWriter(random,directory,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)).setMaxBufferedDocs(_TestUtil.nextInt(random,50,1000)).setMergePolicy(newLogMergePolicy()));
  Document doc=new Document();
  HashMap<String,NumericConfig> numericConfigMap=new HashMap<String,NumericConfig>();
  HashMap<String,NumericField> numericFieldMap=new HashMap<String,NumericField>();
  qp.setNumericConfigMap(numericConfigMap);
  for (  NumericField.DataType type : NumericField.DataType.values()) {
    numericConfigMap.put(type.name(),new NumericConfig(PRECISION_STEP,NUMBER_FORMAT,type));
    NumericField field=new NumericField(type.name(),PRECISION_STEP,Field.Store.YES,true);
    numericFieldMap.put(type.name(),field);
    doc.add(field);
  }
  numericConfigMap.put(DATE_FIELD_NAME,new NumericConfig(PRECISION_STEP,DATE_FORMAT,NumericField.DataType.LONG));
  NumericField dateField=new NumericField(DATE_FIELD_NAME,PRECISION_STEP,Field.Store.YES,true);
  numericFieldMap.put(DATE_FIELD_NAME,dateField);
  doc.add(dateField);
  for (  NumberType numberType : NumberType.values()) {
    setFieldValues(numberType,numericFieldMap);
    if (VERBOSE)     System.out.println("Indexing document: " + doc);
    writer.addDocument(doc);
  }
  reader=writer.getReader();
  searcher=newSearcher(reader);
  writer.close();
}
