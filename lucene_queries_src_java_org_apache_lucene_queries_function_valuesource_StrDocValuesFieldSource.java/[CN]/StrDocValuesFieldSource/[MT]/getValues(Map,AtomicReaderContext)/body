{
  final DocValues.Source source=getSource(readerContext.reader(),DocValues.Type.BYTES_VAR_SORTED);
  final Bits liveDocs=readerContext.reader().getLiveDocs();
switch (source.getType()) {
case BYTES_FIXED_DEREF:
case BYTES_FIXED_STRAIGHT:
case BYTES_VAR_DEREF:
case BYTES_VAR_STRAIGHT:
    return new DVStrValues(this,source,liveDocs);
case BYTES_FIXED_SORTED:
case BYTES_VAR_SORTED:
  final DocValues.SortedSource sortedSource=source.asSortedSource();
if (sortedSource.hasPackedDocToOrd()) {
  final PackedInts.Reader docToOrd=sortedSource.getDocToOrd();
  return new DVStrValues(this,source,liveDocs){
    @Override public int ordVal(    int doc){
      return (int)docToOrd.get(doc);
    }
    @Override public int numOrd(){
      return sortedSource.getValueCount();
    }
  }
;
}
return new DVStrValues(this,source,liveDocs){
@Override public int ordVal(int doc){
  return sortedSource.ord(doc);
}
@Override public int numOrd(){
  return sortedSource.getValueCount();
}
}
;
default :
throw new IllegalStateException(getClass().getSimpleName() + " only works with binary types, not " + source.getType());
}
}
