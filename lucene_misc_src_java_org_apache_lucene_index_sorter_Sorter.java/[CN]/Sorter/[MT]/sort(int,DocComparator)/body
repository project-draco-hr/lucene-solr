{
  boolean sorted=true;
  for (int i=1; i < maxDoc; ++i) {
    if (comparator.compare(i - 1,i) > 0) {
      sorted=false;
      break;
    }
  }
  if (sorted) {
    return null;
  }
  final int[] docs=new int[maxDoc];
  for (int i=0; i < maxDoc; i++) {
    docs[i]=i;
  }
  DocValueSorter sorter=new DocValueSorter(docs,comparator);
  sorter.sort(0,docs.length);
  final PackedLongValues.Builder newToOldBuilder=PackedLongValues.monotonicBuilder(PackedInts.COMPACT);
  for (int i=0; i < maxDoc; ++i) {
    newToOldBuilder.add(docs[i]);
  }
  final PackedLongValues newToOld=newToOldBuilder.build();
  for (int i=0; i < maxDoc; ++i) {
    docs[(int)newToOld.get(i)]=i;
  }
  final PackedLongValues.Builder oldToNewBuilder=PackedLongValues.monotonicBuilder(PackedInts.COMPACT);
  for (int i=0; i < maxDoc; ++i) {
    oldToNewBuilder.add(docs[i]);
  }
  final PackedLongValues oldToNew=oldToNewBuilder.build();
  return new Sorter.DocMap(){
    @Override public int oldToNew(    int docID){
      return (int)oldToNew.get(docID);
    }
    @Override public int newToOld(    int docID){
      return (int)newToOld.get(docID);
    }
    @Override public int size(){
      return maxDoc;
    }
  }
;
}
