{
  this.metrics=metrics;
  numberOfBlocksPerBank=slabSize / blockSize;
  int numberOfBanks=(int)(totalMemory / slabSize);
  banks=new ByteBuffer[numberOfBanks];
  locks=new BlockLocks[numberOfBanks];
  lockCounters=new AtomicInteger[numberOfBanks];
  maxEntries=(numberOfBlocksPerBank * numberOfBanks) - 1;
  for (int i=0; i < numberOfBanks; i++) {
    if (directAllocation) {
      banks[i]=ByteBuffer.allocateDirect(numberOfBlocksPerBank * blockSize);
    }
 else {
      banks[i]=ByteBuffer.allocate(numberOfBlocksPerBank * blockSize);
    }
    locks[i]=new BlockLocks(numberOfBlocksPerBank);
    lockCounters[i]=new AtomicInteger();
  }
  EvictionListener<BlockCacheKey,BlockCacheLocation> listener=new EvictionListener<BlockCacheKey,BlockCacheLocation>(){
    @Override public void onEviction(    BlockCacheKey key,    BlockCacheLocation location){
      releaseLocation(location);
    }
  }
;
  cache=new ConcurrentLinkedHashMap.Builder<BlockCacheKey,BlockCacheLocation>().maximumWeightedCapacity(maxEntries).listener(listener).build();
  this.blockSize=blockSize;
}
