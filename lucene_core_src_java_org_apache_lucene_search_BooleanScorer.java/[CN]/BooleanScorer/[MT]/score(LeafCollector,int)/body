{
  boolean more;
  Bucket tmp;
  FakeScorer fs=new FakeScorer();
  collector.setScorer(fs);
  do {
    bucketTable.first=null;
    while (current != null) {
      if ((current.bits & PROHIBITED_MASK) == 0) {
        if (current.doc >= max) {
          tmp=current;
          current=current.next;
          tmp.next=bucketTable.first;
          bucketTable.first=tmp;
          continue;
        }
        if (current.coord >= minNrShouldMatch) {
          fs.score=(float)(current.score * coordFactors[current.coord]);
          fs.doc=current.doc;
          fs.freq=current.coord;
          collector.collect(current.doc);
        }
      }
      current=current.next;
    }
    if (bucketTable.first != null) {
      current=bucketTable.first;
      bucketTable.first=current.next;
      return true;
    }
    more=false;
    end+=BucketTable.SIZE;
    for (SubScorer sub=scorers; sub != null; sub=sub.next) {
      if (sub.more) {
        sub.more=sub.scorer.score(sub.collector,end);
        more|=sub.more;
      }
    }
    current=bucketTable.first;
  }
 while (current != null || more);
  return false;
}
