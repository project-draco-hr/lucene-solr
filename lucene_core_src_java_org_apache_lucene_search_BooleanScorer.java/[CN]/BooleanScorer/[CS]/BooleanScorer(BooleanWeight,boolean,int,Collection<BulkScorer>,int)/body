{
  if (minShouldMatch < 1 || minShouldMatch > scorers.size()) {
    throw new IllegalArgumentException("minShouldMatch should be within 1..num_scorers. Got " + minShouldMatch);
  }
  for (int i=0; i < buckets.length; i++) {
    buckets[i]=new Bucket();
  }
  this.leads=new BulkScorerAndDoc[scorers.size()];
  this.head=new HeadPriorityQueue(scorers.size() - minShouldMatch + 1);
  this.tail=new TailPriorityQueue(minShouldMatch - 1);
  this.minShouldMatch=minShouldMatch;
  for (  BulkScorer scorer : scorers) {
    final BulkScorerAndDoc evicted=tail.insertWithOverflow(new BulkScorerAndDoc(scorer));
    if (evicted != null) {
      head.add(evicted);
    }
  }
  this.cost=cost(scorers,minShouldMatch);
  coordFactors=new float[scorers.size() + 1];
  for (int i=0; i < coordFactors.length; i++) {
    coordFactors[i]=disableCoord ? 1.0f : weight.coord(i,maxCoord);
  }
}
