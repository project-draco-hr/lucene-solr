{
  if (minShouldMatch < 1 || minShouldMatch > scorers.size()) {
    throw new IllegalArgumentException("minShouldMatch should be within 1..num_scorers. Got " + minShouldMatch);
  }
  if (scorers.size() <= 1) {
    throw new IllegalArgumentException("This scorer can only be used with two scorers or more, got " + scorers.size());
  }
  for (int i=0; i < buckets.length; i++) {
    buckets[i]=new Bucket();
  }
  this.leads=new BulkScorerAndDoc[scorers.size()];
  this.head=new HeadPriorityQueue(scorers.size() - minShouldMatch + 1);
  this.tail=new TailPriorityQueue(minShouldMatch - 1);
  this.minShouldMatch=minShouldMatch;
  for (  BulkScorer scorer : scorers) {
    if (needsScores == false) {
      scorer=BooleanWeight.disableScoring(scorer);
    }
    final BulkScorerAndDoc evicted=tail.insertWithOverflow(new BulkScorerAndDoc(scorer));
    if (evicted != null) {
      head.add(evicted);
    }
  }
  this.cost=cost(scorers,minShouldMatch);
}
