{
  final int docCountCutoff=(int)((docCountPercent / 100.) * reader.maxDoc());
  final int termCountLimit=Math.min(BooleanQuery.getMaxClauseCount(),termCountCutoff);
  final CutOffTermCollector col=new CutOffTermCollector(docCountCutoff,termCountLimit);
  collectTerms(reader,query,col);
  final int size=col.pendingTerms.size();
  if (col.hasCutOff) {
    return MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE.rewrite(reader,query);
  }
 else {
    final BooleanQuery bq=getTopLevelQuery();
    if (size > 0) {
      final BytesRefHash pendingTerms=col.pendingTerms;
      final int sort[]=pendingTerms.sort(BytesRef.getUTF8SortedAsUnicodeComparator());
      for (int i=0; i < size; i++) {
        final int pos=sort[i];
        addClause(bq,new Term(query.field,pendingTerms.get(pos,new BytesRef())),1,1.0f,col.array.termState[pos]);
      }
    }
    final Query result=new ConstantScoreQuery(bq);
    result.setBoost(query.getBoost());
    return result;
  }
}
