{
  boolean clearRequestInfo=false;
  solrCoreState.getCommitLock().lock();
  try {
    SolrQueryRequest req=new LocalSolrQueryRequest(core,new ModifiableSolrParams());
    SolrQueryResponse rsp=new SolrQueryResponse();
    if (SolrRequestInfo.getRequestInfo() == null) {
      clearRequestInfo=true;
      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req,rsp));
    }
    if (!commitOnClose) {
      if (writer != null) {
        writer.rollback();
      }
      if (ulog != null)       ulog.close(false);
      return;
    }
    boolean tryToCommit=writer != null && ulog != null && ulog.hasUncommittedChanges() && ulog.getState() == UpdateLog.State.ACTIVE;
    try {
      if (tryToCommit) {
        log.info("Committing on IndexWriter close.");
        CommitUpdateCommand cmd=new CommitUpdateCommand(req,false);
        cmd.openSearcher=false;
        cmd.waitSearcher=false;
        cmd.softCommit=false;
synchronized (solrCoreState.getUpdateLock()) {
          ulog.preCommit(cmd);
        }
        final Map<String,String> commitData=new HashMap<>();
        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,String.valueOf(System.currentTimeMillis()));
        writer.setCommitData(commitData);
        writer.commit();
synchronized (solrCoreState.getUpdateLock()) {
          ulog.postCommit(cmd);
        }
      }
    }
 catch (    Throwable th) {
      log.error("Error in final commit",th);
      if (th instanceof OutOfMemoryError) {
        throw (OutOfMemoryError)th;
      }
    }
    try {
      if (ulog != null)       ulog.close(false);
    }
 catch (    Throwable th) {
      log.error("Error closing log files",th);
      if (th instanceof OutOfMemoryError) {
        throw (OutOfMemoryError)th;
      }
    }
    if (writer != null) {
      writer.close();
    }
  }
  finally {
    solrCoreState.getCommitLock().unlock();
    if (clearRequestInfo)     SolrRequestInfo.clearRequestInfo();
  }
}
