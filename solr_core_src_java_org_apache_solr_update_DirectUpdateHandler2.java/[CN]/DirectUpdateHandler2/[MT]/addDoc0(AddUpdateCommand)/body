{
  int rc=-1;
  RefCounted<IndexWriter> iw=solrCoreState.getIndexWriter(core);
  try {
    IndexWriter writer=iw.get();
    addCommands.incrementAndGet();
    addCommandsCumulative.incrementAndGet();
    if (idField == null) {
      cmd.overwrite=false;
    }
    try {
      IndexSchema schema=cmd.getReq().getSchema();
      if (cmd.overwrite) {
        List<UpdateLog.DBQ> deletesAfter=null;
        if (ulog != null && cmd.version > 0) {
          deletesAfter=ulog.getDBQNewer(cmd.version);
        }
        if (deletesAfter != null) {
          log.info("Reordered DBQs detected.  Update=" + cmd + " DBQs="+ deletesAfter);
          List<Query> dbqList=new ArrayList<>(deletesAfter.size());
          for (          UpdateLog.DBQ dbq : deletesAfter) {
            try {
              DeleteUpdateCommand tmpDel=new DeleteUpdateCommand(cmd.req);
              tmpDel.query=dbq.q;
              tmpDel.version=-dbq.version;
              dbqList.add(getQuery(tmpDel));
            }
 catch (            Exception e) {
              log.error("Exception parsing reordered query : " + dbq,e);
            }
          }
          addAndDelete(cmd,dbqList);
        }
 else {
          Term updateTerm;
          Term idTerm=new Term(cmd.isBlock() ? "_root_" : idField.getName(),cmd.getIndexedId());
          boolean del=false;
          if (cmd.updateTerm == null) {
            updateTerm=idTerm;
          }
 else {
            del=true;
            updateTerm=cmd.updateTerm;
          }
          if (cmd.isBlock()) {
            writer.updateDocuments(updateTerm,cmd);
          }
 else {
            Document luceneDocument=cmd.getLuceneDocument();
            writer.updateDocument(updateTerm,luceneDocument);
          }
          if (del) {
            BooleanQuery bq=new BooleanQuery();
            bq.add(new BooleanClause(new TermQuery(updateTerm),Occur.MUST_NOT));
            bq.add(new BooleanClause(new TermQuery(idTerm),Occur.MUST));
            writer.deleteDocuments(new DeleteByQueryWrapper(bq,core.getLatestSchema()));
          }
          if (ulog != null)           ulog.add(cmd);
        }
      }
 else {
        if (cmd.isBlock()) {
          writer.addDocuments(cmd);
        }
 else {
          writer.addDocument(cmd.getLuceneDocument());
        }
        if (ulog != null)         ulog.add(cmd);
      }
      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {
        if (commitWithinSoftCommit) {
          commitTracker.addedDocument(-1);
          softCommitTracker.addedDocument(cmd.commitWithin);
        }
 else {
          softCommitTracker.addedDocument(-1);
          commitTracker.addedDocument(cmd.commitWithin);
        }
      }
      rc=1;
    }
  finally {
      if (rc != 1) {
        numErrors.incrementAndGet();
        numErrorsCumulative.incrementAndGet();
      }
 else {
        numDocsPending.incrementAndGet();
      }
    }
  }
  finally {
    iw.decref();
  }
  return rc;
}
