{
  int valueCount=hash.size();
  final int maxDoc=state.segmentInfo.getDocCount();
  int emptyOrd=-1;
  if (pendingIndex < maxDoc) {
    emptyOrd=hash.add(EMPTY);
    if (emptyOrd < 0) {
      emptyOrd=-emptyOrd - 1;
    }
  }
  int[] sortedValues=hash.sort(BytesRef.getUTF8SortedAsUnicodeComparator());
  final int sortedValueRamUsage=RamUsageEstimator.NUM_BYTES_ARRAY_HEADER + RamUsageEstimator.NUM_BYTES_INT * valueCount;
  iwBytesUsed.addAndGet(sortedValueRamUsage);
  final int[] ordMap=new int[valueCount];
  BytesRef scratch=new BytesRef();
  for (int ord=0; ord < valueCount; ord++) {
    consumer.addValue(hash.get(sortedValues[ord],scratch));
    ordMap[sortedValues[ord]]=ord;
  }
  final int bufferedDocCount=pendingIndex;
  for (int docID=0; docID < bufferedDocCount; docID++) {
    consumer.addDoc(ordMap[pending[docID]]);
  }
  for (int docID=bufferedDocCount; docID < maxDoc; docID++) {
    consumer.addDoc(ordMap[emptyOrd]);
  }
  iwBytesUsed.addAndGet(-sortedValueRamUsage);
  reset();
}
