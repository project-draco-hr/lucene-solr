{
  for (int iter=0; iter < 3; iter++) {
    if (VERBOSE) {
      System.out.println("TEST: iter=" + iter);
    }
    final int numDocs=_TestUtil.nextInt(random,100,1000) * RANDOM_MULTIPLIER;
    final int numGroups=_TestUtil.nextInt(random,1,numDocs);
    if (VERBOSE) {
      System.out.println("TEST: numDocs=" + numDocs + " numGroups="+ numGroups);
    }
    final List<BytesRef> groups=new ArrayList<BytesRef>();
    for (int i=0; i < numGroups; i++) {
      groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));
    }
    final String[] contentStrings=new String[]{"a","b","c","d"};
    Directory dir=newDirectory();
    RandomIndexWriter w=new RandomIndexWriter(random,dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)));
    Document doc=new Document();
    Document docNoGroup=new Document();
    Field group=newField("group","",Field.Index.NOT_ANALYZED);
    doc.add(group);
    Field sort1=newField("sort1","",Field.Index.NOT_ANALYZED);
    doc.add(sort1);
    docNoGroup.add(sort1);
    Field sort2=newField("sort2","",Field.Index.NOT_ANALYZED);
    doc.add(sort2);
    docNoGroup.add(sort2);
    Field content=newField("content","",Field.Index.NOT_ANALYZED);
    doc.add(content);
    docNoGroup.add(content);
    NumericField id=new NumericField("id");
    doc.add(id);
    docNoGroup.add(id);
    final GroupDoc[] groupDocs=new GroupDoc[numDocs];
    for (int i=0; i < numDocs; i++) {
      final BytesRef groupValue;
      if (random.nextInt(24) == 17) {
        groupValue=null;
      }
 else {
        groupValue=groups.get(random.nextInt(groups.size()));
      }
      final GroupDoc groupDoc=new GroupDoc(i,groupValue,groups.get(random.nextInt(groups.size())),groups.get(random.nextInt(groups.size())),contentStrings[random.nextInt(contentStrings.length)]);
      if (VERBOSE) {
        System.out.println("  doc content=" + groupDoc.content + " id="+ i+ " group="+ (groupDoc.group == null ? "null" : groupDoc.group.utf8ToString())+ " sort1="+ groupDoc.sort1.utf8ToString()+ " sort2="+ groupDoc.sort2.utf8ToString());
      }
      groupDocs[i]=groupDoc;
      if (groupDoc.group != null) {
        group.setValue(groupDoc.group.utf8ToString());
      }
      sort1.setValue(groupDoc.sort1.utf8ToString());
      sort2.setValue(groupDoc.sort2.utf8ToString());
      content.setValue(groupDoc.content);
      id.setIntValue(groupDoc.id);
      if (groupDoc.group == null) {
        w.addDocument(docNoGroup);
      }
 else {
        w.addDocument(doc);
      }
    }
    final IndexReader r=w.getReader();
    w.close();
    final Directory dir2=newDirectory();
    final IndexReader r2=getDocBlockReader(dir2,groupDocs);
    final Filter lastDocInBlock=new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("groupend","x"))));
    final IndexSearcher s=new IndexSearcher(r);
    final IndexSearcher s2=new IndexSearcher(r2);
    final int[] docIDToID=FieldCache.DEFAULT.getInts(r,"id");
    final int[] docIDToID2=FieldCache.DEFAULT.getInts(r2,"id");
    try {
      for (int searchIter=0; searchIter < 100; searchIter++) {
        if (VERBOSE) {
          System.out.println("TEST: searchIter=" + searchIter);
        }
        final String searchTerm=contentStrings[random.nextInt(contentStrings.length)];
        final boolean fillFields=random.nextBoolean();
        final boolean getScores=random.nextBoolean();
        final boolean getMaxScores=random.nextBoolean();
        final Sort groupSort=getRandomSort();
        final Sort docSort=getRandomSort();
        final int topNGroups=_TestUtil.nextInt(random,1,30);
        final int docsPerGroup=_TestUtil.nextInt(random,1,50);
        final int groupOffset=_TestUtil.nextInt(random,0,(topNGroups - 1) / 2);
        final int docOffset=_TestUtil.nextInt(random,0,docsPerGroup - 1);
        final boolean doCache=random.nextBoolean();
        final boolean doAllGroups=random.nextBoolean();
        if (VERBOSE) {
          System.out.println("TEST: groupSort=" + groupSort + " docSort="+ docSort+ " searchTerm="+ searchTerm+ " topNGroups="+ topNGroups+ " groupOffset="+ groupOffset+ " docOffset="+ docOffset+ " doCache="+ doCache+ " docsPerGroup="+ docsPerGroup+ " doAllGroups="+ doAllGroups);
        }
        final TermAllGroupsCollector allGroupsCollector;
        if (doAllGroups) {
          allGroupsCollector=new TermAllGroupsCollector("group");
        }
 else {
          allGroupsCollector=null;
        }
        final TermFirstPassGroupingCollector c1=new TermFirstPassGroupingCollector("group",groupSort,groupOffset + topNGroups);
        final CachingCollector cCache;
        final Collector c;
        final boolean useWrappingCollector=random.nextBoolean();
        if (doCache) {
          final double maxCacheMB=random.nextDouble();
          if (VERBOSE) {
            System.out.println("TEST: maxCacheMB=" + maxCacheMB);
          }
          if (useWrappingCollector) {
            if (doAllGroups) {
              cCache=CachingCollector.create(c1,true,maxCacheMB);
              c=MultiCollector.wrap(cCache,allGroupsCollector);
            }
 else {
              c=cCache=CachingCollector.create(c1,true,maxCacheMB);
            }
          }
 else {
            c=cCache=CachingCollector.create(false,true,maxCacheMB);
          }
        }
 else {
          cCache=null;
          if (doAllGroups) {
            c=MultiCollector.wrap(c1,allGroupsCollector);
          }
 else {
            c=c1;
          }
        }
        s.search(new TermQuery(new Term("content",searchTerm)),c);
        if (doCache && !useWrappingCollector) {
          if (cCache.isCached()) {
            cCache.replay(c1);
            if (doAllGroups) {
              cCache.replay(allGroupsCollector);
            }
          }
 else {
            s.search(new TermQuery(new Term("content",searchTerm)),c1);
            if (doAllGroups) {
              s.search(new TermQuery(new Term("content",searchTerm)),allGroupsCollector);
            }
          }
        }
        final Collection<SearchGroup<BytesRef>> topGroups=c1.getTopGroups(groupOffset,fillFields);
        final TopGroups groupsResult;
        if (topGroups != null) {
          if (VERBOSE) {
            System.out.println("TEST: topGroups");
            for (            SearchGroup<BytesRef> searchGroup : topGroups) {
              System.out.println("  " + (searchGroup.groupValue == null ? "null" : searchGroup.groupValue.utf8ToString()) + ": "+ Arrays.deepToString(searchGroup.sortValues));
            }
          }
          final TermSecondPassGroupingCollector c2=new TermSecondPassGroupingCollector("group",topGroups,groupSort,docSort,docOffset + docsPerGroup,getScores,getMaxScores,fillFields);
          if (doCache) {
            if (cCache.isCached()) {
              if (VERBOSE) {
                System.out.println("TEST: cache is intact");
              }
              cCache.replay(c2);
            }
 else {
              if (VERBOSE) {
                System.out.println("TEST: cache was too large");
              }
              s.search(new TermQuery(new Term("content",searchTerm)),c2);
            }
          }
 else {
            s.search(new TermQuery(new Term("content",searchTerm)),c2);
          }
          if (doAllGroups) {
            TopGroups<BytesRef> tempTopGroups=c2.getTopGroups(docOffset);
            groupsResult=new TopGroups<BytesRef>(tempTopGroups,allGroupsCollector.getGroupCount());
          }
 else {
            groupsResult=c2.getTopGroups(docOffset);
          }
        }
 else {
          groupsResult=null;
          if (VERBOSE) {
            System.out.println("TEST:   no results");
          }
        }
        final TopGroups<BytesRef> expectedGroups=slowGrouping(groupDocs,searchTerm,fillFields,getScores,getMaxScores,doAllGroups,groupSort,docSort,topNGroups,docsPerGroup,groupOffset,docOffset);
        if (VERBOSE) {
          if (expectedGroups == null) {
            System.out.println("TEST: no expected groups");
          }
 else {
            System.out.println("TEST: expected groups");
            for (            GroupDocs<BytesRef> gd : expectedGroups.groups) {
              System.out.println("  group=" + (gd.groupValue == null ? "null" : gd.groupValue.utf8ToString()));
              for (              ScoreDoc sd : gd.scoreDocs) {
                System.out.println("    id=" + sd.doc);
              }
            }
          }
        }
        assertEquals(docIDToID,expectedGroups,groupsResult,true);
        final boolean needsScores=getScores || getMaxScores || docSort == null;
        final BlockGroupingCollector c3=new BlockGroupingCollector(groupSort,groupOffset + topNGroups,needsScores,lastDocInBlock);
        final TermAllGroupsCollector allGroupsCollector2;
        final Collector c4;
        if (doAllGroups) {
          allGroupsCollector2=new TermAllGroupsCollector("group");
          c4=MultiCollector.wrap(c3,allGroupsCollector2);
        }
 else {
          allGroupsCollector2=null;
          c4=c3;
        }
        s2.search(new TermQuery(new Term("content",searchTerm)),c4);
        @SuppressWarnings("unchecked") final TopGroups<BytesRef> tempTopGroups2=c3.getTopGroups(docSort,groupOffset,docOffset,docOffset + docsPerGroup,fillFields);
        final TopGroups groupsResult2;
        if (doAllGroups && tempTopGroups2 != null) {
          assertEquals((int)tempTopGroups2.totalGroupCount,allGroupsCollector2.getGroupCount());
          groupsResult2=new TopGroups<BytesRef>(tempTopGroups2,allGroupsCollector2.getGroupCount());
        }
 else {
          groupsResult2=tempTopGroups2;
        }
        assertEquals(docIDToID2,expectedGroups,groupsResult2,false);
      }
    }
  finally {
      FieldCache.DEFAULT.purge(r);
      FieldCache.DEFAULT.purge(r2);
    }
    r.close();
    dir.close();
    r2.close();
    dir2.close();
  }
}
