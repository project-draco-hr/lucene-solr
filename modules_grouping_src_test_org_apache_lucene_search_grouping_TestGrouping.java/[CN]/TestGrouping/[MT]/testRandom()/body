{
  for (int iter=0; iter < 3; iter++) {
    if (VERBOSE) {
      System.out.println("TEST: iter=" + iter);
    }
    final int numDocs=_TestUtil.nextInt(random,100,1000) * RANDOM_MULTIPLIER;
    final int numGroups=_TestUtil.nextInt(random,1,numDocs);
    if (VERBOSE) {
      System.out.println("TEST: numDocs=" + numDocs + " numGroups="+ numGroups);
    }
    final List<BytesRef> groups=new ArrayList<BytesRef>();
    for (int i=0; i < numGroups; i++) {
      groups.add(new BytesRef(_TestUtil.randomRealisticUnicodeString(random)));
    }
    final String[] contentStrings=new String[_TestUtil.nextInt(random,2,20)];
    if (VERBOSE) {
      System.out.println("TEST: create fake content");
    }
    for (int contentIDX=0; contentIDX < contentStrings.length; contentIDX++) {
      final StringBuilder sb=new StringBuilder();
      sb.append("real" + random.nextInt(3)).append(' ');
      final int fakeCount=random.nextInt(10);
      for (int fakeIDX=0; fakeIDX < fakeCount; fakeIDX++) {
        sb.append("fake ");
      }
      contentStrings[contentIDX]=sb.toString();
      if (VERBOSE) {
        System.out.println("  content=" + sb.toString());
      }
    }
    Directory dir=newDirectory();
    RandomIndexWriter w=new RandomIndexWriter(random,dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)));
    Document doc=new Document();
    Document docNoGroup=new Document();
    Field group=newField("group","",Field.Index.NOT_ANALYZED);
    doc.add(group);
    Field sort1=newField("sort1","",Field.Index.NOT_ANALYZED);
    doc.add(sort1);
    docNoGroup.add(sort1);
    Field sort2=newField("sort2","",Field.Index.NOT_ANALYZED);
    doc.add(sort2);
    docNoGroup.add(sort2);
    Field content=newField("content","",Field.Index.ANALYZED);
    doc.add(content);
    docNoGroup.add(content);
    NumericField id=new NumericField("id");
    doc.add(id);
    docNoGroup.add(id);
    final GroupDoc[] groupDocs=new GroupDoc[numDocs];
    for (int i=0; i < numDocs; i++) {
      final BytesRef groupValue;
      if (random.nextInt(24) == 17) {
        groupValue=null;
      }
 else {
        groupValue=groups.get(random.nextInt(groups.size()));
      }
      final GroupDoc groupDoc=new GroupDoc(i,groupValue,groups.get(random.nextInt(groups.size())),groups.get(random.nextInt(groups.size())),contentStrings[random.nextInt(contentStrings.length)]);
      if (VERBOSE) {
        System.out.println("  doc content=" + groupDoc.content + " id="+ i+ " group="+ (groupDoc.group == null ? "null" : groupDoc.group.utf8ToString())+ " sort1="+ groupDoc.sort1.utf8ToString()+ " sort2="+ groupDoc.sort2.utf8ToString());
      }
      groupDocs[i]=groupDoc;
      if (groupDoc.group != null) {
        group.setValue(groupDoc.group.utf8ToString());
      }
      sort1.setValue(groupDoc.sort1.utf8ToString());
      sort2.setValue(groupDoc.sort2.utf8ToString());
      content.setValue(groupDoc.content);
      id.setIntValue(groupDoc.id);
      if (groupDoc.group == null) {
        w.addDocument(docNoGroup);
      }
 else {
        w.addDocument(doc);
      }
    }
    final GroupDoc[] groupDocsByID=new GroupDoc[groupDocs.length];
    System.arraycopy(groupDocs,0,groupDocsByID,0,groupDocs.length);
    final IndexReader r=w.getReader();
    w.close();
    final int[] docIDToID=FieldCache.DEFAULT.getInts(r,"id");
    IndexReader r2=null;
    Directory dir2=null;
    try {
      final IndexSearcher s=new IndexSearcher(r);
      for (int contentID=0; contentID < 3; contentID++) {
        final ScoreDoc[] hits=s.search(new TermQuery(new Term("content","real" + contentID)),numDocs).scoreDocs;
        for (        ScoreDoc hit : hits) {
          final GroupDoc gd=groupDocs[docIDToID[hit.doc]];
          assertTrue(gd.score == 0.0);
          gd.score=hit.score;
          assertEquals(gd.id,docIDToID[hit.doc]);
        }
      }
      for (      GroupDoc gd : groupDocs) {
        assertTrue(gd.score != 0.0);
      }
      dir2=newDirectory();
      r2=getDocBlockReader(dir2,groupDocs);
      final Filter lastDocInBlock=new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("groupend","x"))));
      final int[] docIDToID2=FieldCache.DEFAULT.getInts(r2,"id");
      final IndexSearcher s2=new IndexSearcher(r2);
      final Map<String,Map<Float,Float>> scoreMap=new HashMap<String,Map<Float,Float>>();
      for (int contentID=0; contentID < 3; contentID++) {
        final Map<Float,Float> termScoreMap=new HashMap<Float,Float>();
        scoreMap.put("real" + contentID,termScoreMap);
        final ScoreDoc[] hits=s2.search(new TermQuery(new Term("content","real" + contentID)),numDocs).scoreDocs;
        for (        ScoreDoc hit : hits) {
          final GroupDoc gd=groupDocsByID[docIDToID2[hit.doc]];
          assertTrue(gd.score2 == 0.0);
          gd.score2=hit.score;
          assertEquals(gd.id,docIDToID2[hit.doc]);
          termScoreMap.put(gd.score,gd.score2);
        }
      }
      for (int searchIter=0; searchIter < 100; searchIter++) {
        if (VERBOSE) {
          System.out.println("TEST: searchIter=" + searchIter);
        }
        final String searchTerm="real" + random.nextInt(3);
        final boolean fillFields=random.nextBoolean();
        boolean getScores=random.nextBoolean();
        final boolean getMaxScores=random.nextBoolean();
        final Sort groupSort=getRandomSort();
        final Sort docSort=getRandomSort();
        for (        SortField sf : docSort.getSort()) {
          if (sf.getType() == SortField.SCORE) {
            getScores=true;
          }
        }
        for (        SortField sf : groupSort.getSort()) {
          if (sf.getType() == SortField.SCORE) {
            getScores=true;
          }
        }
        final int topNGroups=_TestUtil.nextInt(random,1,30);
        final int docsPerGroup=_TestUtil.nextInt(random,1,50);
        final int groupOffset=_TestUtil.nextInt(random,0,(topNGroups - 1) / 2);
        final int docOffset=_TestUtil.nextInt(random,0,docsPerGroup - 1);
        final boolean doCache=random.nextBoolean();
        final boolean doAllGroups=random.nextBoolean();
        if (VERBOSE) {
          System.out.println("TEST: groupSort=" + groupSort + " docSort="+ docSort+ " searchTerm="+ searchTerm+ " topNGroups="+ topNGroups+ " groupOffset="+ groupOffset+ " docOffset="+ docOffset+ " doCache="+ doCache+ " docsPerGroup="+ docsPerGroup+ " doAllGroups="+ doAllGroups+ " getScores="+ getScores+ " getMaxScores="+ getMaxScores);
        }
        final TermAllGroupsCollector allGroupsCollector;
        if (doAllGroups) {
          allGroupsCollector=new TermAllGroupsCollector("group");
        }
 else {
          allGroupsCollector=null;
        }
        final TermFirstPassGroupingCollector c1=new TermFirstPassGroupingCollector("group",groupSort,groupOffset + topNGroups);
        final CachingCollector cCache;
        final Collector c;
        final boolean useWrappingCollector=random.nextBoolean();
        if (doCache) {
          final double maxCacheMB=random.nextDouble();
          if (VERBOSE) {
            System.out.println("TEST: maxCacheMB=" + maxCacheMB);
          }
          if (useWrappingCollector) {
            if (doAllGroups) {
              cCache=CachingCollector.create(c1,true,maxCacheMB);
              c=MultiCollector.wrap(cCache,allGroupsCollector);
            }
 else {
              c=cCache=CachingCollector.create(c1,true,maxCacheMB);
            }
          }
 else {
            c=cCache=CachingCollector.create(false,true,maxCacheMB);
          }
        }
 else {
          cCache=null;
          if (doAllGroups) {
            c=MultiCollector.wrap(c1,allGroupsCollector);
          }
 else {
            c=c1;
          }
        }
        s.search(new TermQuery(new Term("content",searchTerm)),c);
        if (doCache && !useWrappingCollector) {
          if (cCache.isCached()) {
            cCache.replay(c1);
            if (doAllGroups) {
              cCache.replay(allGroupsCollector);
            }
          }
 else {
            s.search(new TermQuery(new Term("content",searchTerm)),c1);
            if (doAllGroups) {
              s.search(new TermQuery(new Term("content",searchTerm)),allGroupsCollector);
            }
          }
        }
        final Collection<SearchGroup<BytesRef>> topGroups=c1.getTopGroups(groupOffset,fillFields);
        final TopGroups groupsResult;
        if (topGroups != null) {
          if (VERBOSE) {
            System.out.println("TEST: topGroups");
            for (            SearchGroup<BytesRef> searchGroup : topGroups) {
              System.out.println("  " + (searchGroup.groupValue == null ? "null" : searchGroup.groupValue.utf8ToString()) + ": "+ Arrays.deepToString(searchGroup.sortValues));
            }
          }
          final TermSecondPassGroupingCollector c2=new TermSecondPassGroupingCollector("group",topGroups,groupSort,docSort,docOffset + docsPerGroup,getScores,getMaxScores,fillFields);
          if (doCache) {
            if (cCache.isCached()) {
              if (VERBOSE) {
                System.out.println("TEST: cache is intact");
              }
              cCache.replay(c2);
            }
 else {
              if (VERBOSE) {
                System.out.println("TEST: cache was too large");
              }
              s.search(new TermQuery(new Term("content",searchTerm)),c2);
            }
          }
 else {
            s.search(new TermQuery(new Term("content",searchTerm)),c2);
          }
          if (doAllGroups) {
            TopGroups<BytesRef> tempTopGroups=c2.getTopGroups(docOffset);
            groupsResult=new TopGroups<BytesRef>(tempTopGroups,allGroupsCollector.getGroupCount());
          }
 else {
            groupsResult=c2.getTopGroups(docOffset);
          }
        }
 else {
          groupsResult=null;
          if (VERBOSE) {
            System.out.println("TEST:   no results");
          }
        }
        final TopGroups<BytesRef> expectedGroups=slowGrouping(groupDocs,searchTerm,fillFields,getScores,getMaxScores,doAllGroups,groupSort,docSort,topNGroups,docsPerGroup,groupOffset,docOffset);
        if (VERBOSE) {
          if (expectedGroups == null) {
            System.out.println("TEST: no expected groups");
          }
 else {
            System.out.println("TEST: expected groups");
            for (            GroupDocs<BytesRef> gd : expectedGroups.groups) {
              System.out.println("  group=" + (gd.groupValue == null ? "null" : gd.groupValue.utf8ToString()));
              for (              ScoreDoc sd : gd.scoreDocs) {
                System.out.println("    id=" + sd.doc + " score="+ sd.score);
              }
            }
          }
        }
        assertEquals(docIDToID,expectedGroups,groupsResult,true,getScores);
        final boolean needsScores=getScores || getMaxScores || docSort == null;
        final BlockGroupingCollector c3=new BlockGroupingCollector(groupSort,groupOffset + topNGroups,needsScores,lastDocInBlock);
        final TermAllGroupsCollector allGroupsCollector2;
        final Collector c4;
        if (doAllGroups) {
          allGroupsCollector2=new TermAllGroupsCollector("group");
          c4=MultiCollector.wrap(c3,allGroupsCollector2);
        }
 else {
          allGroupsCollector2=null;
          c4=c3;
        }
        s2.search(new TermQuery(new Term("content",searchTerm)),c4);
        @SuppressWarnings("unchecked") final TopGroups<BytesRef> tempTopGroups2=c3.getTopGroups(docSort,groupOffset,docOffset,docOffset + docsPerGroup,fillFields);
        final TopGroups groupsResult2;
        if (doAllGroups && tempTopGroups2 != null) {
          assertEquals((int)tempTopGroups2.totalGroupCount,allGroupsCollector2.getGroupCount());
          groupsResult2=new TopGroups<BytesRef>(tempTopGroups2,allGroupsCollector2.getGroupCount());
        }
 else {
          groupsResult2=tempTopGroups2;
        }
        if (expectedGroups != null) {
          for (          GroupDocs groupDocsHits : expectedGroups.groups) {
            for (            ScoreDoc hit : groupDocsHits.scoreDocs) {
              final GroupDoc gd=groupDocsByID[hit.doc];
              assertEquals(gd.id,hit.doc);
              hit.score=gd.score2;
            }
          }
          final SortField[] sortFields=groupSort.getSort();
          final Map<Float,Float> termScoreMap=scoreMap.get(searchTerm);
          for (int groupSortIDX=0; groupSortIDX < sortFields.length; groupSortIDX++) {
            if (sortFields[groupSortIDX].getType() == SortField.SCORE) {
              for (              GroupDocs groupDocsHits : expectedGroups.groups) {
                if (groupDocsHits.groupSortValues != null) {
                  groupDocsHits.groupSortValues[groupSortIDX]=termScoreMap.get(groupDocsHits.groupSortValues[groupSortIDX]);
                  assertNotNull(groupDocsHits.groupSortValues[groupSortIDX]);
                }
              }
            }
          }
          final SortField[] docSortFields=docSort.getSort();
          for (int docSortIDX=0; docSortIDX < docSortFields.length; docSortIDX++) {
            if (docSortFields[docSortIDX].getType() == SortField.SCORE) {
              for (              GroupDocs groupDocsHits : expectedGroups.groups) {
                for (                ScoreDoc _hit : groupDocsHits.scoreDocs) {
                  FieldDoc hit=(FieldDoc)_hit;
                  if (hit.fields != null) {
                    hit.fields[docSortIDX]=termScoreMap.get(hit.fields[docSortIDX]);
                    assertNotNull(hit.fields[docSortIDX]);
                  }
                }
              }
            }
          }
        }
        assertEquals(docIDToID2,expectedGroups,groupsResult2,false,getScores);
      }
    }
  finally {
      FieldCache.DEFAULT.purge(r);
      if (r2 != null) {
        FieldCache.DEFAULT.purge(r2);
      }
    }
    r.close();
    dir.close();
    r2.close();
    dir2.close();
  }
}
