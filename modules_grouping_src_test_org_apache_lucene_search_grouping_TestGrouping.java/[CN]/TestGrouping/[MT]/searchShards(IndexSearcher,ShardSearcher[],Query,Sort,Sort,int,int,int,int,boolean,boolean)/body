{
  if (VERBOSE) {
    System.out.println("TEST: " + subSearchers.length + " shards: "+ Arrays.toString(subSearchers));
  }
  final Weight w=topSearcher.createNormalizedWeight(query);
  final List<Collection<SearchGroup<BytesRef>>> shardGroups=new ArrayList<Collection<SearchGroup<BytesRef>>>();
  List<AbstractFirstPassGroupingCollector> firstPassGroupingCollectors=new ArrayList<AbstractFirstPassGroupingCollector>();
  for (int shardIDX=0; shardIDX < subSearchers.length; shardIDX++) {
    final AbstractFirstPassGroupingCollector c=createRandomFirstPassCollector("group",groupSort,groupOffset + topNGroups);
    firstPassGroupingCollectors.add(c);
    subSearchers[shardIDX].search(w,c);
    final Collection<SearchGroup<BytesRef>> topGroups=getSearchGroups(c,0,true);
    if (topGroups != null) {
      if (VERBOSE) {
        System.out.println("  shard " + shardIDX + " s="+ subSearchers[shardIDX]+ " "+ topGroups.size()+ " groups:");
        for (        SearchGroup<BytesRef> group : topGroups) {
          System.out.println("    " + groupToString(group.groupValue) + " groupSort="+ Arrays.toString(group.sortValues));
        }
      }
      shardGroups.add(topGroups);
    }
  }
  final Collection<SearchGroup<BytesRef>> mergedTopGroups=SearchGroup.merge(shardGroups,groupOffset,topNGroups,groupSort);
  if (VERBOSE) {
    System.out.println("  merged:");
    if (mergedTopGroups == null) {
      System.out.println("    null");
    }
 else {
      for (      SearchGroup<BytesRef> group : mergedTopGroups) {
        System.out.println("    " + groupToString(group.groupValue) + " groupSort="+ Arrays.toString(group.sortValues));
      }
    }
  }
  if (mergedTopGroups != null) {
    @SuppressWarnings("unchecked") final TopGroups<BytesRef>[] shardTopGroups=new TopGroups[subSearchers.length];
    for (int shardIDX=0; shardIDX < subSearchers.length; shardIDX++) {
      final AbstractSecondPassGroupingCollector c=createSecondPassCollector(firstPassGroupingCollectors.get(shardIDX),"group",mergedTopGroups,groupSort,docSort,docOffset + topNDocs,getScores,getMaxScores,true);
      subSearchers[shardIDX].search(w,c);
      shardTopGroups[shardIDX]=getTopGroups(c,0);
    }
    return TopGroups.merge(shardTopGroups,groupSort,docSort,docOffset,topNDocs);
  }
 else {
    return null;
  }
}
