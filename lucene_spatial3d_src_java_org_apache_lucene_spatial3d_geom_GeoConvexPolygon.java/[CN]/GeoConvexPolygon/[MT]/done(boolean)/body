{
  if (isDone)   throw new IllegalStateException("Can't call done() more than once");
  if (points.size() < 3)   throw new IllegalArgumentException("Polygon needs at least three points.");
  if (isInternalReturnEdge)   isInternalEdges.set(points.size() - 1);
  isDone=true;
  edges=new SidedPlane[points.size()];
  notableEdgePoints=new GeoPoint[points.size()][];
  for (int i=0; i < points.size(); i++) {
    final GeoPoint start=points.get(i);
    final GeoPoint end=points.get(legalIndex(i + 1));
    final Plane planeToFind=new Plane(start,end);
    int endPointIndex=-1;
    for (int j=0; j < points.size(); j++) {
      final int index=legalIndex(j + i + 2);
      if (!planeToFind.evaluateIsZero(points.get(index))) {
        endPointIndex=index;
        break;
      }
    }
    if (endPointIndex == -1) {
      throw new IllegalArgumentException("Polygon points are all coplanar: " + points);
    }
    final GeoPoint check=points.get(endPointIndex);
    final SidedPlane sp=new SidedPlane(check,start,end);
    edges[i]=sp;
    notableEdgePoints[i]=new GeoPoint[]{start,end};
  }
  eitherBounds=new HashMap<>(edges.length);
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    final SidedPlane edge=edges[edgeIndex];
    int bound1Index=legalIndex(edgeIndex + 1);
    while (edges[legalIndex(bound1Index)].isNumericallyIdentical(edge)) {
      bound1Index++;
    }
    int bound2Index=legalIndex(edgeIndex - 1);
    while (edges[legalIndex(bound2Index)].isNumericallyIdentical(edge)) {
      bound2Index--;
    }
    eitherBounds.put(edge,new EitherBound(edges[legalIndex(bound1Index)],edges[legalIndex(bound2Index)]));
  }
  int edgePointCount=1;
  if (holes != null) {
    for (    final GeoPolygon hole : holes) {
      edgePointCount+=hole.getEdgePoints().length;
    }
  }
  edgePoints=new GeoPoint[edgePointCount];
  edgePointCount=0;
  edgePoints[edgePointCount++]=points.get(0);
  if (holes != null) {
    for (    final GeoPolygon hole : holes) {
      final GeoPoint[] holeEdgePoints=hole.getEdgePoints();
      for (      final GeoPoint p : holeEdgePoints) {
        edgePoints[edgePointCount++]=p;
      }
    }
  }
  if (isWithinHoles(points.get(0))) {
    throw new IllegalArgumentException("Polygon edge intersects a polygon hole; not allowed");
  }
}
