{
  if (isDone)   throw new IllegalStateException("Can't call done() more than once");
  if (points.size() < 3)   throw new IllegalArgumentException("Polygon needs at least three points.");
  if (isInternalReturnEdge)   isInternalEdges.set(points.size() - 1);
  isDone=true;
  edges=new SidedPlane[points.size()];
  notableEdgePoints=new GeoPoint[points.size()][];
  for (int i=0; i < points.size(); i++) {
    final GeoPoint start=points.get(i);
    final GeoPoint end=points.get(legalIndex(i + 1));
    final Plane planeToFind=new Plane(start,end);
    int endPointIndex=-1;
    for (int j=0; j < points.size(); j++) {
      final int index=legalIndex(j + i + 2);
      if (!planeToFind.evaluateIsZero(points.get(index))) {
        endPointIndex=index;
        break;
      }
    }
    if (endPointIndex == -1) {
      throw new IllegalArgumentException("Polygon points are all coplanar: " + points);
    }
    final GeoPoint check=points.get(endPointIndex);
    final SidedPlane sp=new SidedPlane(check,start,end);
    edges[i]=sp;
    notableEdgePoints[i]=new GeoPoint[]{start,end};
  }
  eitherBounds=new HashMap<>(edges.length);
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    final SidedPlane edge=edges[edgeIndex];
    int bound1Index=legalIndex(edgeIndex + 1);
    while (edges[legalIndex(bound1Index)].isNumericallyIdentical(edge)) {
      bound1Index++;
    }
    int bound2Index=legalIndex(edgeIndex - 1);
    while (edges[legalIndex(bound2Index)].isNumericallyIdentical(edge)) {
      bound2Index--;
    }
    eitherBounds.put(edge,new EitherBound(edges[legalIndex(bound1Index)],edges[legalIndex(bound2Index)]));
  }
  edgePoints=new GeoPoint[]{points.get(0)};
}
