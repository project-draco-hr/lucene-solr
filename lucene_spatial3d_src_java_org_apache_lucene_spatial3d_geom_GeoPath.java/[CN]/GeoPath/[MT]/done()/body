{
  if (isDone)   throw new IllegalStateException("Can't call done() twice");
  if (points.size() == 0)   throw new IllegalArgumentException("Path must have at least one point");
  isDone=true;
  endPoints=new ArrayList<>(points.size());
  segments=new ArrayList<>(points.size());
  final double cutoffOffset=this.sinAngle * planetModel.getMinimumMagnitude();
  GeoPoint lastPoint=null;
  for (  final GeoPoint end : points) {
    if (lastPoint != null) {
      final Plane normalizedConnectingPlane=new Plane(lastPoint,end);
      if (normalizedConnectingPlane == null) {
        continue;
      }
      segments.add(new PathSegment(planetModel,lastPoint,end,normalizedConnectingPlane,cutoffOffset));
    }
    lastPoint=end;
  }
  if (segments.size() == 0) {
    double lat=points.get(0).getLatitude();
    double lon=points.get(0).getLongitude();
    double upperLat=lat + cutoffAngle;
    double upperLon=lon;
    if (upperLat > Math.PI * 0.5) {
      upperLon+=Math.PI;
      if (upperLon > Math.PI)       upperLon-=2.0 * Math.PI;
      upperLat=Math.PI - upperLat;
    }
    double lowerLat=lat - cutoffAngle;
    double lowerLon=lon;
    if (lowerLat < -Math.PI * 0.5) {
      lowerLon+=Math.PI;
      if (lowerLon > Math.PI)       lowerLon-=2.0 * Math.PI;
      lowerLat=-Math.PI - lowerLat;
    }
    final GeoPoint upperPoint=new GeoPoint(planetModel,upperLat,upperLon);
    final GeoPoint lowerPoint=new GeoPoint(planetModel,lowerLat,lowerLon);
    final GeoPoint point=points.get(0);
    final Plane normalPlane=Plane.constructNormalizedZPlane(upperPoint,lowerPoint,point);
    final SegmentEndpoint onlyEndpoint=new SegmentEndpoint(point,normalPlane,upperPoint,lowerPoint);
    endPoints.add(onlyEndpoint);
    this.edgePoints=new GeoPoint[]{onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel,normalPlane)};
    return;
  }
  for (int i=0; i < segments.size(); i++) {
    final PathSegment currentSegment=segments.get(i);
    if (i == 0) {
      final SegmentEndpoint startEndpoint=new SegmentEndpoint(currentSegment.start,currentSegment.startCutoffPlane,currentSegment.ULHC,currentSegment.LLHC);
      endPoints.add(startEndpoint);
      this.edgePoints=new GeoPoint[]{currentSegment.ULHC};
      continue;
    }
    final PathSegment prevSegment=segments.get(i - 1);
    final SidedPlane candidate1=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,prevSegment.URHC,currentSegment.ULHC,currentSegment.LLHC);
    final SidedPlane candidate2=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,currentSegment.ULHC,currentSegment.LLHC,prevSegment.LRHC);
    final SidedPlane candidate3=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,currentSegment.LLHC,prevSegment.LRHC,prevSegment.URHC);
    final SidedPlane candidate4=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,prevSegment.LRHC,prevSegment.URHC,currentSegment.ULHC);
    if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {
      final SegmentEndpoint midEndpoint=new SegmentEndpoint(currentSegment.start,prevSegment.endCutoffPlane,currentSegment.startCutoffPlane,currentSegment.ULHC,currentSegment.LLHC);
      endPoints.add(midEndpoint);
    }
 else {
      endPoints.add(new SegmentEndpoint(currentSegment.start,prevSegment.endCutoffPlane,currentSegment.startCutoffPlane,prevSegment.URHC,prevSegment.LRHC,currentSegment.ULHC,currentSegment.LLHC,candidate1,candidate2,candidate3,candidate4));
    }
  }
  final PathSegment lastSegment=segments.get(segments.size() - 1);
  endPoints.add(new SegmentEndpoint(lastSegment.end,lastSegment.endCutoffPlane,lastSegment.URHC,lastSegment.LRHC));
}
