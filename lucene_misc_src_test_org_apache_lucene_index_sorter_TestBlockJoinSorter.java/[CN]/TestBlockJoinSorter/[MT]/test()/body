{
  final int numParents=atLeast(200);
  IndexWriterConfig cfg=newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random()));
  cfg.setMergePolicy(newLogMergePolicy());
  final RandomIndexWriter writer=new RandomIndexWriter(random(),newDirectory(),cfg);
  final Document parentDoc=new Document();
  final NumericDocValuesField parentVal=new NumericDocValuesField("parent_val",0L);
  parentDoc.add(parentVal);
  final StringField parent=new StringField("parent","true",Store.YES);
  parentDoc.add(parent);
  for (int i=0; i < numParents; ++i) {
    List<Document> documents=new ArrayList<Document>();
    final int numChildren=random().nextInt(10);
    for (int j=0; j < numChildren; ++j) {
      final Document childDoc=new Document();
      childDoc.add(new NumericDocValuesField("child_val",random().nextInt(5)));
      documents.add(childDoc);
    }
    parentVal.setLongValue(random().nextInt(50));
    documents.add(parentDoc);
    writer.addDocuments(documents);
  }
  writer.forceMerge(1);
  final DirectoryReader indexReader=writer.getReader();
  writer.close();
  final AtomicReader reader=getOnlySegmentReader(indexReader);
  final Filter parentsFilter=new FixedBitSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("parent","true"))));
  final FixedBitSet parentBits=(FixedBitSet)parentsFilter.getDocIdSet(reader.getContext(),null);
  final NumericDocValues parentValues=reader.getNumericDocValues("parent_val");
  final Sorter.DocComparator parentComparator=new Sorter.DocComparator(){
    @Override public int compare(    int docID1,    int docID2){
      assertTrue(parentBits.get(docID1));
      assertTrue(parentBits.get(docID2));
      return Long.compare(parentValues.get(docID1),parentValues.get(docID2));
    }
  }
;
  final NumericDocValues childValues=reader.getNumericDocValues("child_val");
  final Sorter.DocComparator childComparator=new Sorter.DocComparator(){
    @Override public int compare(    int docID1,    int docID2){
      assertFalse(parentBits.get(docID1));
      assertFalse(parentBits.get(docID2));
      return Long.compare(childValues.get(docID1),childValues.get(docID2));
    }
  }
;
  final Sorter sorter=new BlockJoinSorter(parentsFilter){
    @Override public String getID(){
      return "Dummy";
    }
    @Override protected DocComparator getParentComparator(    AtomicReader r){
      assertEquals(reader,r);
      return parentComparator;
    }
    @Override protected DocComparator getChildComparator(    AtomicReader r){
      assertEquals(reader,r);
      return childComparator;
    }
  }
;
  final Sorter.DocMap docMap=sorter.sort(reader);
  assertEquals(reader.maxDoc(),docMap.size());
  int[] children=new int[1];
  int numChildren=0;
  int previousParent=-1;
  for (int i=0; i < docMap.size(); ++i) {
    final int oldID=docMap.newToOld(i);
    if (parentBits.get(oldID)) {
      for (int j=0; j < numChildren; ++j) {
        assertEquals(oldID,parentBits.nextSetBit(children[j]));
      }
      for (int j=1; j < numChildren; ++j) {
        final int doc1=children[j - 1];
        final int doc2=children[j];
        if (childValues.get(doc1) == childValues.get(doc2)) {
          assertTrue(doc1 < doc2);
        }
 else {
          assertTrue(childValues.get(doc1) < childValues.get(doc2));
        }
      }
      if (previousParent != -1) {
        if (parentValues.get(previousParent) == parentValues.get(oldID)) {
          assertTrue(previousParent < oldID);
        }
 else {
          assertTrue(parentValues.get(previousParent) < parentValues.get(oldID));
        }
      }
      previousParent=oldID;
      numChildren=0;
    }
 else {
      children=ArrayUtil.grow(children,numChildren + 1);
      children[numChildren++]=oldID;
    }
  }
  indexReader.close();
  writer.w.getDirectory().close();
}
