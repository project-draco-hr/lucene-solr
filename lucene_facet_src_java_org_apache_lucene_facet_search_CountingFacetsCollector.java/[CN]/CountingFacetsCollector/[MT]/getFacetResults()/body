{
  try {
    countFacets();
    ParallelTaxonomyArrays arrays=taxoReader.getParallelTaxonomyArrays();
    final int[] children=arrays.children();
    final int[] siblings=arrays.siblings();
    List<FacetResult> res=new ArrayList<FacetResult>();
    for (    FacetRequest fr : fsp.facetRequests) {
      int rootOrd=taxoReader.getOrdinal(fr.categoryPath);
      if (rootOrd == TaxonomyReader.INVALID_ORDINAL) {
        continue;
      }
      OrdinalPolicy ordinalPolicy=clp.getOrdinalPolicy(fr.categoryPath.components[0]);
      if (ordinalPolicy == OrdinalPolicy.NO_PARENTS) {
        counts[rootOrd]+=rollupCounts(children[rootOrd],children,siblings);
      }
      FacetResultNode root=new FacetResultNode();
      root.ordinal=rootOrd;
      root.label=fr.categoryPath;
      root.value=counts[rootOrd];
      if (fr.getNumResults() > taxoReader.getSize()) {
        ArrayList<FacetResultNode> nodes=new ArrayList<FacetResultNode>();
        int child=children[rootOrd];
        while (child != TaxonomyReader.INVALID_ORDINAL) {
          int count=counts[child];
          if (count > 0) {
            FacetResultNode node=new FacetResultNode();
            node.label=taxoReader.getPath(child);
            node.value=count;
            nodes.add(node);
          }
          child=siblings[child];
        }
        Collections.sort(nodes,new Comparator<FacetResultNode>(){
          @Override public int compare(          FacetResultNode o1,          FacetResultNode o2){
            int value=(int)(o2.value - o1.value);
            if (value == 0) {
              value=o2.ordinal - o1.ordinal;
            }
            return value;
          }
        }
);
        root.subResults=nodes;
        res.add(new FacetResult(fr,root,nodes.size()));
        continue;
      }
      FacetResultNodeQueue pq=new FacetResultNodeQueue(fr.getNumResults(),true);
      FacetResultNode top=pq.top();
      int child=children[rootOrd];
      int numResults=0;
      while (child != TaxonomyReader.INVALID_ORDINAL) {
        int count=counts[child];
        if (count > top.value) {
          top.value=count;
          top.ordinal=child;
          top=pq.updateTop();
          ++numResults;
        }
        child=siblings[child];
      }
      int pqsize=pq.size();
      int size=numResults < pqsize ? numResults : pqsize;
      for (int i=pqsize - size; i > 0; i--) {
        pq.pop();
      }
      FacetResultNode[] subResults=new FacetResultNode[size];
      for (int i=size - 1; i >= 0; i--) {
        FacetResultNode node=pq.pop();
        node.label=taxoReader.getPath(node.ordinal);
        subResults[i]=node;
      }
      root.subResults=Arrays.asList(subResults);
      res.add(new FacetResult(fr,root,size));
    }
    return res;
  }
  finally {
    facetArrays.free();
  }
}
