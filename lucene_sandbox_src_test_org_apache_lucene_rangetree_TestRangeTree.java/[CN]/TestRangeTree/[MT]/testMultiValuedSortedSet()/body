{
  int numValues=atLeast(10000);
  long[] values=new long[2 * numValues];
  Directory dir=newDirectory();
  IndexWriterConfig iwc=newIndexWriterConfig();
  iwc.setMergePolicy(newLogMergePolicy());
  int maxPointsInLeaf=TestUtil.nextInt(random(),16,2048);
  int maxPointsSortInHeap=TestUtil.nextInt(random(),1024,1024 * 1024);
  Codec codec=TestUtil.alwaysDocValuesFormat(new RangeTreeDocValuesFormat(maxPointsInLeaf,maxPointsSortInHeap));
  iwc.setCodec(codec);
  RandomIndexWriter w=new RandomIndexWriter(random(),dir,iwc);
  for (int docID=0; docID < numValues; docID++) {
    Document doc=new Document();
    values[2 * docID]=randomValue();
    doc.add(new SortedSetDocValuesField("value",longToBytes(values[2 * docID])));
    values[2 * docID + 1]=randomValue();
    doc.add(new SortedSetDocValuesField("value",longToBytes(values[2 * docID + 1])));
    w.addDocument(doc);
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  IndexReader r=w.getReader();
  w.close();
  IndexSearcher s=newSearcher(r,false);
  int iters=atLeast(100);
  for (int iter=0; iter < iters; iter++) {
    long lower=randomValue();
    long upper=randomValue();
    if (upper < lower) {
      long x=lower;
      lower=upper;
      upper=x;
    }
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " value="+ lower+ " TO "+ upper);
    }
    boolean includeLower=random().nextBoolean();
    boolean includeUpper=random().nextBoolean();
    Query query=new SortedSetRangeTreeQuery("value",longToBytes(lower),includeLower,longToBytes(upper),includeUpper);
    final FixedBitSet hits=new FixedBitSet(r.maxDoc());
    s.search(query,new SimpleCollector(){
      private int docBase;
      @Override public boolean needsScores(){
        return false;
      }
      @Override protected void doSetNextReader(      LeafReaderContext context) throws IOException {
        docBase=context.docBase;
      }
      @Override public void collect(      int doc){
        hits.set(docBase + doc);
      }
    }
);
    for (int docID=0; docID < values.length / 2; docID++) {
      long docValue1=values[2 * docID];
      long docValue2=values[2 * docID + 1];
      boolean expected=matches(lower,includeLower,upper,includeUpper,docValue1) || matches(lower,includeLower,upper,includeUpper,docValue2);
      if (hits.get(docID) != expected) {
        fail("docID=" + docID + " docValue1="+ docValue1+ " docValue2="+ docValue2+ " expected "+ expected+ " but got: "+ hits.get(docID));
      }
    }
  }
  r.close();
  dir.close();
}
