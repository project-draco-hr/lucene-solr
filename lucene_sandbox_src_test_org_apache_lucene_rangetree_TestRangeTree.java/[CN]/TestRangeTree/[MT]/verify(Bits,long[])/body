{
  int maxPointsInLeaf=TestUtil.nextInt(random(),16,2048);
  int maxPointsSortInHeap=TestUtil.nextInt(random(),maxPointsInLeaf,1024 * 1024);
  IndexWriterConfig iwc=newIndexWriterConfig();
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < values.length / 100) {
    iwc.setMaxBufferedDocs(values.length / 100);
  }
  final DocValuesFormat dvFormat=new RangeTreeDocValuesFormat(maxPointsInLeaf,maxPointsSortInHeap);
  Codec codec=new Lucene53Codec(){
    @Override public DocValuesFormat getDocValuesFormatForField(    String field){
      if (field.equals("sn_value") || field.equals("ss_value")) {
        return dvFormat;
      }
 else {
        return super.getDocValuesFormatForField(field);
      }
    }
  }
;
  iwc.setCodec(codec);
  Directory dir;
  if (values.length > 100000) {
    dir=newFSDirectory(createTempDir("TestRangeTree"));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < values.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (missing.get(id) == false) {
      doc.add(new SortedNumericDocValuesField("sn_value",values[id]));
      doc.add(new SortedSetDocValuesField("ss_value",longToBytes(values[id])));
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w,true);
  w.close();
  IndexSearcher s=newSearcher(r,false);
  int numThreads=TestUtil.nextInt(random(),2,5);
  if (VERBOSE) {
    System.out.println("TEST: use " + numThreads + " query threads");
  }
  List<Thread> threads=new ArrayList<>();
  final int iters=atLeast(100);
  final CountDownLatch startingGun=new CountDownLatch(1);
  final AtomicBoolean failed=new AtomicBoolean();
  for (int i=0; i < numThreads; i++) {
    Thread thread=new Thread(){
      @Override public void run(){
        try {
          _run();
        }
 catch (        Exception e) {
          failed.set(true);
          throw new RuntimeException(e);
        }
      }
      private void _run() throws Exception {
        startingGun.await();
        NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
        for (int iter=0; iter < iters && failed.get() == false; iter++) {
          long lower=randomValue();
          long upper=randomValue();
          if (upper < lower) {
            long x=lower;
            lower=upper;
            upper=x;
          }
          if (VERBOSE) {
            System.out.println("\n" + Thread.currentThread().getName() + ": TEST: iter="+ iter+ " value="+ lower+ " TO "+ upper);
          }
          boolean includeLower=random().nextBoolean();
          boolean includeUpper=random().nextBoolean();
          Query query;
          if (random().nextBoolean()) {
            query=new NumericRangeTreeQuery("sn_value",lower,includeLower,upper,includeUpper);
          }
 else {
            query=new SortedSetRangeTreeQuery("ss_value",longToBytes(lower),includeLower,longToBytes(upper),includeUpper);
          }
          if (VERBOSE) {
            System.out.println(Thread.currentThread().getName() + ":  using query: " + query);
          }
          final FixedBitSet hits=new FixedBitSet(r.maxDoc());
          s.search(query,new SimpleCollector(){
            private int docBase;
            @Override public boolean needsScores(){
              return false;
            }
            @Override protected void doSetNextReader(            LeafReaderContext context) throws IOException {
              docBase=context.docBase;
            }
            @Override public void collect(            int doc){
              hits.set(docBase + doc);
            }
          }
);
          if (VERBOSE) {
            System.out.println(Thread.currentThread().getName() + ":  hitCount: " + hits.cardinality());
          }
          for (int docID=0; docID < r.maxDoc(); docID++) {
            int id=(int)docIDToID.get(docID);
            boolean expected=missing.get(id) == false && deleted.contains(id) == false && matches(lower,includeLower,upper,includeUpper,values[id]);
            if (hits.get(docID) != expected) {
              fail(Thread.currentThread().getName() + ": iter=" + iter+ " id="+ id+ " docID="+ docID+ " value="+ values[id]+ " (range: "+ lower+ " TO "+ upper+ ") expected "+ expected+ " but got: "+ hits.get(docID)+ " deleted?="+ deleted.contains(id)+ " query="+ query);
            }
          }
        }
      }
    }
;
    thread.setName("T" + i);
    thread.start();
    threads.add(thread);
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  IOUtils.close(r,dir);
}
