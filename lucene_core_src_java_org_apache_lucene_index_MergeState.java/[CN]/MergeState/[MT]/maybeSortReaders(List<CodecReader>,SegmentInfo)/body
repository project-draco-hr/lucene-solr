{
  for (int i=0; i < originalReaders.size(); i++) {
    leafDocMaps[i]=new DocMap(){
      @Override public int get(      int docID){
        return docID;
      }
    }
;
  }
  Sort indexSort=segmentInfo.getIndexSort();
  if (indexSort == null) {
    return originalReaders;
  }
  final Sorter sorter=new Sorter(indexSort);
  List<CodecReader> readers=new ArrayList<>(originalReaders.size());
  for (  CodecReader leaf : originalReaders) {
    Sort segmentSort=leaf.getIndexSort();
    if (segmentSort == null) {
      Sorter.DocMap sortDocMap=sorter.sort(leaf);
      if (sortDocMap != null) {
        if (infoStream.isEnabled("SM")) {
          infoStream.message("SM","segment " + leaf + " is not sorted; wrapping for sort "+ indexSort+ " now");
        }
        leaf=SlowCodecReaderWrapper.wrap(SortingLeafReader.wrap(new MergeReaderWrapper(leaf),sortDocMap));
        leafDocMaps[readers.size()]=new DocMap(){
          @Override public int get(          int docID){
            return sortDocMap.oldToNew(docID);
          }
        }
;
      }
 else {
        if (infoStream.isEnabled("SM")) {
          infoStream.message("SM","segment " + leaf + " is not sorted, but is already accidentally in sort "+ indexSort+ " order");
        }
      }
    }
 else {
      if (segmentSort.equals(indexSort) == false) {
        throw new IllegalArgumentException("index sort mismatch: merged segment has sort=" + indexSort + " but to-be-merged segment has sort="+ segmentSort);
      }
      if (infoStream.isEnabled("SM")) {
        infoStream.message("SM","segment " + leaf + " already sorted");
      }
    }
    readers.add(leaf);
  }
  return readers;
}
