{
  for (int i=0; i < originalReaders.size(); i++) {
    leafDocMaps[i]=new DocMap(){
      @Override public int get(      int docID){
        return docID;
      }
    }
;
  }
  Sort indexSort=segmentInfo.getIndexSort();
  if (indexSort == null) {
    return originalReaders;
  }
  final Sorter sorter=new Sorter(indexSort);
  List<CodecReader> readers=new ArrayList<>(originalReaders.size());
  for (  CodecReader leaf : originalReaders) {
    if (leaf instanceof SegmentReader) {
      SegmentReader segmentReader=(SegmentReader)leaf;
      Sort segmentSort=segmentReader.getSegmentInfo().info.getIndexSort();
      if (segmentSort == null) {
        Sorter.DocMap sortDocMap=sorter.sort(leaf);
        if (sortDocMap != null) {
          leaf=SlowCodecReaderWrapper.wrap(SortingLeafReader.wrap(leaf,sortDocMap));
          leafDocMaps[readers.size()]=new DocMap(){
            @Override public int get(            int docID){
              return sortDocMap.oldToNew(docID);
            }
          }
;
        }
      }
 else       if (segmentSort.equals(indexSort) == false) {
        throw new IllegalArgumentException("index sort mismatch: merged segment has sort=" + indexSort + " but to-be-merged segment has sort="+ segmentSort);
      }
    }
 else {
      throw new IllegalArgumentException("cannot sort index with foreign readers; leaf=" + leaf);
    }
    readers.add(leaf);
  }
  return readers;
}
