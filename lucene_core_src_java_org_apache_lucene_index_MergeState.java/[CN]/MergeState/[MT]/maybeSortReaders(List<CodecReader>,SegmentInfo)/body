{
  for (int i=0; i < originalReaders.size(); i++) {
    leafDocMaps[i]=new DocMap(){
      @Override public int get(      int docID){
        return docID;
      }
    }
;
  }
  Sort indexSort=segmentInfo.getIndexSort();
  if (indexSort == null) {
    return originalReaders;
  }
  final Sorter sorter=new Sorter(indexSort);
  List<CodecReader> readers=new ArrayList<>(originalReaders.size());
  for (  CodecReader leaf : originalReaders) {
    Sort segmentSort=leaf.getIndexSort();
    if (segmentSort == null) {
      long t0=System.nanoTime();
      Sorter.DocMap sortDocMap=sorter.sort(leaf);
      long t1=System.nanoTime();
      double msec=(t1 - t0) / 1000000.0;
      if (sortDocMap != null) {
        if (infoStream.isEnabled("SM")) {
          infoStream.message("SM",String.format(Locale.ROOT,"segment %s is not sorted; wrapping for sort %s now (%.2f msec to sort)",leaf,indexSort,msec));
        }
        leaf=SlowCodecReaderWrapper.wrap(SortingLeafReader.wrap(new MergeReaderWrapper(leaf),sortDocMap));
        leafDocMaps[readers.size()]=new DocMap(){
          @Override public int get(          int docID){
            return sortDocMap.oldToNew(docID);
          }
        }
;
      }
 else {
        if (infoStream.isEnabled("SM")) {
          infoStream.message("SM",String.format(Locale.ROOT,"segment %s is not sorted, but is already accidentally in sort %s order (%.2f msec to sort)",leaf,indexSort,msec));
        }
      }
    }
 else {
      if (segmentSort.equals(indexSort) == false) {
        throw new IllegalArgumentException("index sort mismatch: merged segment has sort=" + indexSort + " but to-be-merged segment has sort="+ segmentSort);
      }
      if (infoStream.isEnabled("SM")) {
        infoStream.message("SM","segment " + leaf + " already sorted");
      }
    }
    readers.add(leaf);
  }
  return readers;
}
