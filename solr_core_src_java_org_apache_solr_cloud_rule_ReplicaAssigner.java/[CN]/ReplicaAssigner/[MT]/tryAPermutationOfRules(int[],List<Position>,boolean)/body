{
  Map<String,Map<String,Object>> nodeVsTagsCopy=getDeepCopy(nodeVsTags,2);
  Map<Position,String> result=new LinkedHashMap<>();
  int startPosition=0;
  Map<String,Map<String,Integer>> copyOfCurrentState=getDeepCopy(shardVsNodes,2);
  List<String> sortedLiveNodes=new ArrayList<>(this.liveNodes);
  Collections.sort(sortedLiveNodes,new Comparator<String>(){
    @Override public int compare(    String n1,    String n2){
      int result=0;
      for (int i=0; i < rulePermutation.length; i++) {
        Rule rule=rules.get(rulePermutation[i]);
        int val=rule.compare(n1,n2,nodeVsTagsCopy,copyOfCurrentState);
        if (val != 0) {
          result=val;
          break;
        }
        if (result == 0) {
          AtomicInteger n1Count=nodeVsCores.get(n1);
          AtomicInteger n2Count=nodeVsCores.get(n2);
          int a=n1Count == null ? 0 : n1Count.get();
          int b=n2Count == null ? 0 : n2Count.get();
          result=a > b ? 1 : a == b ? 0 : -1;
        }
      }
      return result;
    }
  }
);
  forEachPosition:   for (  Position position : positions) {
    forEachNode:     for (int j=0; j < sortedLiveNodes.size(); j++) {
      String liveNode=sortedLiveNodes.get(startPosition % sortedLiveNodes.size());
      startPosition++;
      for (int i=0; i < rulePermutation.length; i++) {
        Rule rule=rules.get(rulePermutation[i]);
        Rule.MatchStatus status=rule.tryAssignNodeToShard(liveNode,copyOfCurrentState,nodeVsTagsCopy,position.shard,fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);
        if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {
          continue forEachNode;
        }
      }
      result.put(position,liveNode);
      Map<String,Integer> nodeNames=copyOfCurrentState.get(position.shard);
      if (nodeNames == null)       copyOfCurrentState.put(position.shard,nodeNames=new HashMap<>());
      Integer n=nodeNames.get(liveNode);
      n=n == null ? 1 : n + 1;
      nodeNames.put(liveNode,n);
      Number coreCount=(Number)nodeVsTagsCopy.get(liveNode).get(ImplicitSnitch.CORES);
      if (coreCount != null) {
        nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES,coreCount.intValue() + 1);
      }
      continue forEachPosition;
    }
    return null;
  }
  if (positions.size() > result.size()) {
    return null;
  }
  for (  Map.Entry<Position,String> e : result.entrySet()) {
    for (int i=0; i < rulePermutation.length; i++) {
      Rule rule=rules.get(rulePermutation[i]);
      Rule.MatchStatus matchStatus=rule.tryAssignNodeToShard(e.getValue(),copyOfCurrentState,nodeVsTagsCopy,e.getKey().shard,fuzzyPhase ? FUZZY_VERIFY : VERIFY);
      if (matchStatus != NODE_CAN_BE_ASSIGNED)       return null;
    }
  }
  return result;
}
