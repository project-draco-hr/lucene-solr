{
  fieldState.reset(docState.doc.getBoost());
  final int maxFieldLength=docState.maxFieldLength;
  final boolean doInvert=consumer.start(fields,count);
  for (int i=0; i < count; i++) {
    final Fieldable field=fields[i];
    if (field.isIndexed() && doInvert) {
      if (fieldState.length > 0)       fieldState.position+=docState.analyzer.getPositionIncrementGap(fieldInfo.name);
      if (!field.isTokenized()) {
        String stringValue=field.stringValue();
        final int valueLength=stringValue.length();
        perThread.singleTokenTokenStream.reinit(stringValue,0,valueLength);
        fieldState.attributeSource=perThread.singleTokenTokenStream;
        perThread.localTokenStream.reset();
        consumer.start(field);
        boolean success=false;
        try {
          consumer.add();
          success=true;
        }
  finally {
          if (!success)           docState.docWriter.setAborting();
        }
        fieldState.offset+=valueLength;
        fieldState.length++;
        fieldState.position++;
      }
 else {
        final TokenStream stream;
        final TokenStream streamValue=field.tokenStreamValue();
        if (streamValue != null)         stream=streamValue;
 else {
          final Reader reader;
          final Reader readerValue=field.readerValue();
          if (readerValue != null)           reader=readerValue;
 else {
            String stringValue=field.stringValue();
            if (stringValue == null)             throw new IllegalArgumentException("field must have either TokenStream, String or Reader value");
            perThread.stringReader.init(stringValue);
            reader=perThread.stringReader;
          }
          stream=docState.analyzer.reusableTokenStream(fieldInfo.name,reader);
        }
        stream.reset();
        try {
          int offsetEnd=fieldState.offset - 1;
          boolean useNewTokenStreamAPI=stream.useNewAPI();
          Token localToken=null;
          if (useNewTokenStreamAPI) {
            fieldState.attributeSource=stream;
          }
 else {
            fieldState.attributeSource=perThread.localTokenStream;
            localToken=perThread.localToken;
          }
          consumer.start(field);
          OffsetAttribute offsetAttribute=(OffsetAttribute)fieldState.attributeSource.addAttribute(OffsetAttribute.class);
          PositionIncrementAttribute posIncrAttribute=(PositionIncrementAttribute)fieldState.attributeSource.addAttribute(PositionIncrementAttribute.class);
          for (; ; ) {
            Token token=null;
            if (useNewTokenStreamAPI) {
              if (!stream.incrementToken())               break;
            }
 else {
              token=stream.next(localToken);
              if (token == null)               break;
              perThread.localTokenStream.set(token);
            }
            final int posIncr=posIncrAttribute.getPositionIncrement();
            fieldState.position+=posIncr - 1;
            if (posIncr == 0)             fieldState.numOverlap++;
            boolean success=false;
            try {
              consumer.add();
              success=true;
            }
  finally {
              if (!success)               docState.docWriter.setAborting();
            }
            fieldState.position++;
            offsetEnd=fieldState.offset + offsetAttribute.endOffset();
            if (++fieldState.length >= maxFieldLength) {
              if (docState.infoStream != null)               docState.infoStream.println("maxFieldLength " + maxFieldLength + " reached for field "+ fieldInfo.name+ ", ignoring following tokens");
              break;
            }
          }
          fieldState.offset=offsetEnd + 1;
        }
  finally {
          stream.close();
        }
      }
      fieldState.boost*=field.getBoost();
    }
  }
  consumer.finish();
  endConsumer.finish();
}
