{
  fieldState.reset(docState.doc.getBoost());
  final int maxFieldLength=docState.maxFieldLength;
  final boolean doInvert=consumer.start(fields,count);
  for (int i=0; i < count; i++) {
    final Fieldable field=fields[i];
    if (field.isIndexed() && doInvert) {
      if (fieldState.length > 0)       fieldState.position+=docState.analyzer.getPositionIncrementGap(fieldInfo.name);
      if (!field.isTokenized()) {
        String stringValue=field.stringValue();
        final int valueLength=stringValue.length();
        Token token=perThread.localToken.reinit(stringValue,fieldState.offset,fieldState.offset + valueLength);
        boolean success=false;
        try {
          consumer.add(token);
          success=true;
        }
  finally {
          if (!success)           docState.docWriter.setAborting();
        }
        fieldState.offset+=valueLength;
        fieldState.length++;
        fieldState.position++;
      }
 else {
        final TokenStream stream;
        final TokenStream streamValue=field.tokenStreamValue();
        if (streamValue != null)         stream=streamValue;
 else {
          final Reader reader;
          final Reader readerValue=field.readerValue();
          if (readerValue != null)           reader=readerValue;
 else {
            String stringValue=field.stringValue();
            if (stringValue == null)             throw new IllegalArgumentException("field must have either TokenStream, String or Reader value");
            perThread.stringReader.init(stringValue);
            reader=perThread.stringReader;
          }
          stream=docState.analyzer.reusableTokenStream(fieldInfo.name,reader);
        }
        stream.reset();
        try {
          int offsetEnd=fieldState.offset - 1;
          final Token localToken=perThread.localToken;
          for (; ; ) {
            Token token=stream.next(localToken);
            if (token == null)             break;
            fieldState.position+=(token.getPositionIncrement() - 1);
            boolean success=false;
            try {
              consumer.add(token);
              success=true;
            }
  finally {
              if (!success)               docState.docWriter.setAborting();
            }
            fieldState.position++;
            offsetEnd=fieldState.offset + token.endOffset();
            if (++fieldState.length >= maxFieldLength) {
              if (docState.infoStream != null)               docState.infoStream.println("maxFieldLength " + maxFieldLength + " reached for field "+ fieldInfo.name+ ", ignoring following tokens");
              break;
            }
          }
          fieldState.offset=offsetEnd + 1;
        }
  finally {
          stream.close();
        }
      }
      fieldState.boost*=field.getBoost();
    }
  }
  consumer.finish();
  endConsumer.finish();
}
