{
  IndexWriterConfig iwc=newIndexWriterConfig();
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < lats.length / 100) {
    iwc.setMaxBufferedDocs(lats.length / 100);
  }
  Directory dir;
  if (lats.length > 100000) {
    dir=newFSDirectory(createTempDir(getClass().getSimpleName()));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < lats.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(lats[id]) == false) {
      addPointToDoc(FIELD_NAME,doc,lats[id],lons[id]);
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w);
  w.close();
  IndexSearcher s=newSearcher(r,false);
  int numThreads=TestUtil.nextInt(random(),2,5);
  List<Thread> threads=new ArrayList<>();
  final int iters=atLeast(75);
  final CountDownLatch startingGun=new CountDownLatch(1);
  final AtomicBoolean failed=new AtomicBoolean();
  for (int i=0; i < numThreads; i++) {
    Thread thread=new Thread(){
      @Override public void run(){
        try {
          _run();
        }
 catch (        Exception e) {
          failed.set(true);
          throw new RuntimeException(e);
        }
      }
      private void _run() throws Exception {
        startingGun.await();
        NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
        for (int iter=0; iter < iters && failed.get() == false; iter++) {
          if (VERBOSE) {
            System.out.println("\n" + Thread.currentThread().getName() + ": TEST: iter="+ iter+ " s="+ s);
          }
          Query query;
          VerifyHits verifyHits;
          if (random().nextBoolean()) {
            final GeoRect rect=randomRect(small,small == false);
            query=newRectQuery(FIELD_NAME,rect);
            verifyHits=new VerifyHits(){
              @Override protected Boolean shouldMatch(              double pointLat,              double pointLon){
                return rectContainsPoint(rect,pointLat,pointLon);
              }
              @Override protected void describe(              int docID,              double lat,              double lon){
              }
            }
;
          }
 else           if (random().nextBoolean()) {
            final boolean rangeQuery=random().nextBoolean();
            final double centerLat=randomLat(small);
            final double centerLon=randomLon(small);
            double radiusMeters;
            double minRadiusMeters;
            if (small) {
              radiusMeters=random().nextDouble() * 333000 + 1.0;
            }
 else {
              radiusMeters=random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;
            }
            minRadiusMeters=(0.01 + 0.94 * random().nextDouble()) * radiusMeters;
            if (VERBOSE) {
              final DecimalFormat df=new DecimalFormat("#,###.00",DecimalFormatSymbols.getInstance(Locale.ENGLISH));
              System.out.println("  radiusMeters = " + df.format(radiusMeters) + ((rangeQuery == true) ? " minRadiusMeters = " + df.format(minRadiusMeters) : ""));
            }
            try {
              if (rangeQuery == true) {
                query=newDistanceRangeQuery(FIELD_NAME,centerLat,centerLon,minRadiusMeters,radiusMeters);
              }
 else {
                query=newDistanceQuery(FIELD_NAME,centerLat,centerLon,radiusMeters);
              }
            }
 catch (            IllegalArgumentException e) {
              if (e.getMessage().contains("exceeds maxRadius")) {
                continue;
              }
              throw e;
            }
            verifyHits=new VerifyHits(){
              @Override protected Boolean shouldMatch(              double pointLat,              double pointLon){
                if (rangeQuery == false) {
                  return circleContainsPoint(centerLat,centerLon,radiusMeters,pointLat,pointLon);
                }
 else {
                  return distanceRangeContainsPoint(centerLat,centerLon,minRadiusMeters,radiusMeters,pointLat,pointLon);
                }
              }
              @Override protected void describe(              int docID,              double pointLat,              double pointLon){
                double distanceMeters=GeoDistanceUtils.haversin(centerLat,centerLon,pointLat,pointLon);
                System.out.println("  docID=" + docID + " centerLon="+ centerLon+ " centerLat="+ centerLat+ " pointLon="+ pointLon+ " pointLat="+ pointLat+ " distanceMeters="+ distanceMeters+ " vs"+ ((rangeQuery == true) ? " minRadiusMeters=" + minRadiusMeters : "")+ " radiusMeters="+ radiusMeters);
              }
            }
;
          }
 else {
            final GeoRect bbox=randomRect(small,false);
            double[] lats=new double[5];
            double[] lons=new double[5];
            lats[0]=bbox.minLat;
            lons[0]=bbox.minLon;
            lats[1]=bbox.maxLat;
            lons[1]=bbox.minLon;
            lats[2]=bbox.maxLat;
            lons[2]=bbox.maxLon;
            lats[3]=bbox.minLat;
            lons[3]=bbox.maxLon;
            lats[4]=bbox.minLat;
            lons[4]=bbox.minLon;
            query=newPolygonQuery(FIELD_NAME,lats,lons);
            verifyHits=new VerifyHits(){
              @Override protected Boolean shouldMatch(              double pointLat,              double pointLon){
                return polyRectContainsPoint(bbox,pointLat,pointLon);
              }
              @Override protected void describe(              int docID,              double lat,              double lon){
              }
            }
;
          }
          if (query != null) {
            if (VERBOSE) {
              System.out.println("  query=" + query);
            }
            verifyHits.test(failed,small,s,docIDToID,deleted,query,lats,lons);
          }
        }
      }
    }
;
    thread.setName("T" + i);
    thread.start();
    threads.add(thread);
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  IOUtils.close(r,dir);
  assertFalse(failed.get());
}
