{
  IndexWriterConfig iwc=newIndexWriterConfig();
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < lats.length / 100) {
    iwc.setMaxBufferedDocs(lats.length / 100);
  }
  Directory dir;
  if (lats.length > 100000) {
    dir=newFSDirectory(createTempDir(getClass().getSimpleName()));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < lats.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(lats[id]) == false) {
      addPointToDoc(FIELD_NAME,doc,lats[id],lons[id]);
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w);
  w.close();
  IndexSearcher s=newSearcher(r,false);
  final int iters=atLeast(75);
  final AtomicBoolean failed=new AtomicBoolean();
  NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
  for (int iter=0; iter < iters && failed.get() == false; iter++) {
    if (VERBOSE) {
      System.out.println("\n" + Thread.currentThread().getName() + ": TEST: iter="+ iter+ " s="+ s);
    }
    Query query;
    VerifyHits verifyHits;
    if (random().nextBoolean()) {
      final GeoRect rect=randomRect(small,small == false);
      query=newRectQuery(FIELD_NAME,rect.minLat,rect.maxLat,rect.minLon,rect.maxLon);
      verifyHits=new VerifyHits(){
        @Override protected boolean shouldMatch(        double pointLat,        double pointLon){
          return rectContainsPoint(rect,pointLat,pointLon);
        }
        @Override protected void describe(        int docID,        double lat,        double lon){
        }
      }
;
    }
 else     if (random().nextBoolean()) {
      final boolean rangeQuery=random().nextBoolean();
      final double centerLat=randomLat(small);
      final double centerLon=randomLon(small);
      double radiusMeters;
      double minRadiusMeters;
      if (small) {
        radiusMeters=random().nextDouble() * 333000 + 1.0;
      }
 else {
        radiusMeters=random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;
      }
      minRadiusMeters=(0.01 + 0.94 * random().nextDouble()) * radiusMeters;
      if (VERBOSE) {
        final DecimalFormat df=new DecimalFormat("#,###.00",DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        System.out.println("  radiusMeters = " + df.format(radiusMeters) + ((rangeQuery == true) ? " minRadiusMeters = " + df.format(minRadiusMeters) : ""));
      }
      try {
        if (rangeQuery == true) {
          query=newDistanceRangeQuery(FIELD_NAME,centerLat,centerLon,minRadiusMeters,radiusMeters);
        }
 else {
          query=newDistanceQuery(FIELD_NAME,centerLat,centerLon,radiusMeters);
        }
      }
 catch (      IllegalArgumentException e) {
        if (e.getMessage().contains("exceeds maxRadius")) {
          continue;
        }
        throw e;
      }
      verifyHits=new VerifyHits(){
        @Override protected boolean shouldMatch(        double pointLat,        double pointLon){
          if (rangeQuery == false) {
            return circleContainsPoint(centerLat,centerLon,radiusMeters,pointLat,pointLon);
          }
 else {
            return distanceRangeContainsPoint(centerLat,centerLon,minRadiusMeters,radiusMeters,pointLat,pointLon);
          }
        }
        @Override protected void describe(        int docID,        double pointLat,        double pointLon){
          double distanceMeters=SloppyMath.haversinMeters(centerLat,centerLon,pointLat,pointLon);
          System.out.println("  docID=" + docID + " centerLat="+ centerLat+ " centerLon="+ centerLon+ " pointLat="+ pointLat+ " pointLon="+ pointLon+ " distanceMeters="+ distanceMeters+ " vs"+ ((rangeQuery == true) ? " minRadiusMeters=" + minRadiusMeters : "")+ " radiusMeters="+ radiusMeters);
        }
      }
;
    }
 else {
      final GeoRect bbox=randomRect(small,false);
      final double[] polyLats;
      final double[] polyLons;
      if (random().nextBoolean()) {
        polyLats=new double[5];
        polyLons=new double[5];
        polyLats[0]=bbox.minLat;
        polyLons[0]=bbox.minLon;
        polyLats[1]=bbox.maxLat;
        polyLons[1]=bbox.minLon;
        polyLats[2]=bbox.maxLat;
        polyLons[2]=bbox.maxLon;
        polyLats[3]=bbox.minLat;
        polyLons[3]=bbox.maxLon;
        polyLats[4]=bbox.minLat;
        polyLons[4]=bbox.minLon;
      }
 else {
        polyLats=new double[4];
        polyLons=new double[4];
        polyLats[0]=bbox.minLat;
        polyLons[0]=bbox.minLon;
        polyLats[1]=bbox.maxLat;
        polyLons[1]=bbox.minLon;
        polyLats[2]=bbox.maxLat;
        polyLons[2]=bbox.maxLon;
        polyLats[3]=bbox.minLat;
        polyLons[3]=bbox.minLon;
      }
      query=newPolygonQuery(FIELD_NAME,polyLats,polyLons);
      verifyHits=new VerifyHits(){
        @Override protected boolean shouldMatch(        double pointLat,        double pointLon){
          return polygonContainsPoint(polyLats,polyLons,pointLat,pointLon);
        }
        @Override protected void describe(        int docID,        double lat,        double lon){
        }
      }
;
    }
    if (query != null) {
      if (VERBOSE) {
        System.out.println("  query=" + query);
      }
      verifyHits.test(failed,small,s,docIDToID,deleted,query,lats,lons);
    }
  }
  IOUtils.close(r,dir);
}
