{
  IndexWriterConfig iwc=newIndexWriterConfig();
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < lats.length / 100) {
    iwc.setMaxBufferedDocs(lats.length / 100);
  }
  Directory dir;
  if (lats.length > 100000) {
    dir=newFSDirectory(createTempDir(getClass().getSimpleName()));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < lats.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(lats[id]) == false) {
      addPointToDoc(FIELD_NAME,doc,lats[id],lons[id]);
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w);
  w.close();
  IndexSearcher s=newSearcher(r,false);
  final int iters=atLeast(75);
  NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
  Bits liveDocs=MultiFields.getLiveDocs(s.getIndexReader());
  int maxDoc=s.getIndexReader().maxDoc();
  for (int iter=0; iter < iters; iter++) {
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " s="+ s);
    }
    final GeoRect bbox=randomRect(small,false);
    final double[] polyLats;
    final double[] polyLons;
switch (random().nextInt(3)) {
case 0:
      polyLats=new double[5];
    polyLons=new double[5];
  polyLats[0]=bbox.minLat;
polyLons[0]=bbox.minLon;
polyLats[1]=bbox.maxLat;
polyLons[1]=bbox.minLon;
polyLats[2]=bbox.maxLat;
polyLons[2]=bbox.maxLon;
polyLats[3]=bbox.minLat;
polyLons[3]=bbox.maxLon;
polyLats[4]=bbox.minLat;
polyLons[4]=bbox.minLon;
break;
case 1:
polyLats=new double[4];
polyLons=new double[4];
polyLats[0]=bbox.minLat;
polyLons[0]=bbox.minLon;
polyLats[1]=bbox.maxLat;
polyLons[1]=bbox.minLon;
polyLats[2]=bbox.maxLat;
polyLons[2]=bbox.maxLon;
polyLats[3]=bbox.minLat;
polyLons[3]=bbox.minLon;
break;
default :
double[][] res=surpriseMePolygon();
polyLats=res[0];
polyLons=res[1];
break;
}
Query query=newPolygonQuery(FIELD_NAME,polyLats,polyLons);
if (VERBOSE) {
System.out.println("  query=" + query);
}
final FixedBitSet hits=new FixedBitSet(maxDoc);
s.search(query,new SimpleCollector(){
private int docBase;
@Override public boolean needsScores(){
return false;
}
@Override protected void doSetNextReader(LeafReaderContext context) throws IOException {
docBase=context.docBase;
}
@Override public void collect(int doc){
hits.set(docBase + doc);
}
}
);
boolean fail=false;
for (int docID=0; docID < maxDoc; docID++) {
int id=(int)docIDToID.get(docID);
boolean expected;
if (liveDocs != null && liveDocs.get(docID) == false) {
expected=false;
}
 else if (Double.isNaN(lats[id])) {
expected=false;
}
 else {
expected=polygonContainsPoint(polyLats,polyLons,lats[id],lons[id]);
}
if (hits.get(docID) != expected) {
StringBuilder b=new StringBuilder();
if (expected) {
b.append("FAIL: id=" + id + " should match but did not\n");
}
 else {
b.append("FAIL: id=" + id + " should not match but did\n");
}
b.append("  query=" + query + " docID="+ docID+ "\n");
b.append("  lat=" + lats[id] + " lon="+ lons[id]+ "\n");
b.append("  deleted?=" + (liveDocs != null && liveDocs.get(docID) == false));
b.append("  polyLats=" + Arrays.toString(polyLats));
b.append("  polyLons=" + Arrays.toString(polyLons));
if (true) {
fail("wrong hit (first of possibly more):\n\n" + b);
}
 else {
System.out.println(b.toString());
fail=true;
}
}
}
if (fail) {
fail("some hits were wrong");
}
}
IOUtils.close(r,dir);
}
