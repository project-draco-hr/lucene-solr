{
  FieldCache cache=FieldCache.DEFAULT;
  double[] doubles=cache.getDoubles(reader,"theDouble");
  assertSame("Second request to cache return same array",doubles,cache.getDoubles(reader,"theDouble"));
  assertSame("Second request with explicit parser return same array",doubles,cache.getDoubles(reader,"theDouble",FieldCache.DEFAULT_DOUBLE_PARSER));
  assertTrue("doubles Size: " + doubles.length + " is not: "+ NUM_DOCS,doubles.length == NUM_DOCS);
  for (int i=0; i < doubles.length; i++) {
    assertTrue(doubles[i] + " does not equal: " + (Double.MAX_VALUE - i),doubles[i] == (Double.MAX_VALUE - i));
  }
  long[] longs=cache.getLongs(reader,"theLong");
  assertSame("Second request to cache return same array",longs,cache.getLongs(reader,"theLong"));
  assertSame("Second request with explicit parser return same array",longs,cache.getLongs(reader,"theLong",FieldCache.DEFAULT_LONG_PARSER));
  assertTrue("longs Size: " + longs.length + " is not: "+ NUM_DOCS,longs.length == NUM_DOCS);
  for (int i=0; i < longs.length; i++) {
    assertTrue(longs[i] + " does not equal: " + (Long.MAX_VALUE - i)+ " i="+ i,longs[i] == (Long.MAX_VALUE - i));
  }
  byte[] bytes=cache.getBytes(reader,"theByte");
  assertSame("Second request to cache return same array",bytes,cache.getBytes(reader,"theByte"));
  assertSame("Second request with explicit parser return same array",bytes,cache.getBytes(reader,"theByte",FieldCache.DEFAULT_BYTE_PARSER));
  assertTrue("bytes Size: " + bytes.length + " is not: "+ NUM_DOCS,bytes.length == NUM_DOCS);
  for (int i=0; i < bytes.length; i++) {
    assertTrue(bytes[i] + " does not equal: " + (Byte.MAX_VALUE - i),bytes[i] == (byte)(Byte.MAX_VALUE - i));
  }
  short[] shorts=cache.getShorts(reader,"theShort");
  assertSame("Second request to cache return same array",shorts,cache.getShorts(reader,"theShort"));
  assertSame("Second request with explicit parser return same array",shorts,cache.getShorts(reader,"theShort",FieldCache.DEFAULT_SHORT_PARSER));
  assertTrue("shorts Size: " + shorts.length + " is not: "+ NUM_DOCS,shorts.length == NUM_DOCS);
  for (int i=0; i < shorts.length; i++) {
    assertTrue(shorts[i] + " does not equal: " + (Short.MAX_VALUE - i),shorts[i] == (short)(Short.MAX_VALUE - i));
  }
  int[] ints=cache.getInts(reader,"theInt");
  assertSame("Second request to cache return same array",ints,cache.getInts(reader,"theInt"));
  assertSame("Second request with explicit parser return same array",ints,cache.getInts(reader,"theInt",FieldCache.DEFAULT_INT_PARSER));
  assertTrue("ints Size: " + ints.length + " is not: "+ NUM_DOCS,ints.length == NUM_DOCS);
  for (int i=0; i < ints.length; i++) {
    assertTrue(ints[i] + " does not equal: " + (Integer.MAX_VALUE - i),ints[i] == (Integer.MAX_VALUE - i));
  }
  float[] floats=cache.getFloats(reader,"theFloat");
  assertSame("Second request to cache return same array",floats,cache.getFloats(reader,"theFloat"));
  assertSame("Second request with explicit parser return same array",floats,cache.getFloats(reader,"theFloat",FieldCache.DEFAULT_FLOAT_PARSER));
  assertTrue("floats Size: " + floats.length + " is not: "+ NUM_DOCS,floats.length == NUM_DOCS);
  for (int i=0; i < floats.length; i++) {
    assertTrue(floats[i] + " does not equal: " + (Float.MAX_VALUE - i),floats[i] == (Float.MAX_VALUE - i));
  }
  FieldCache.DocTermsIndex termsIndex=cache.getTermsIndex(reader,"theRandomUnicodeString");
  assertSame("Second request to cache return same array",termsIndex,cache.getTermsIndex(reader,"theRandomUnicodeString"));
  assertTrue("doubles Size: " + termsIndex.size() + " is not: "+ NUM_DOCS,termsIndex.size() == NUM_DOCS);
  final BytesRef br=new BytesRef();
  for (int i=0; i < NUM_DOCS; i++) {
    final BytesRef term=termsIndex.getTerm(i,br);
    final String s=term == null ? null : term.utf8ToString();
    assertTrue("for doc " + i + ": "+ s+ " does not equal: "+ unicodeStrings[i],unicodeStrings[i] == null || unicodeStrings[i].equals(s));
  }
  int nTerms=termsIndex.numOrd();
  TermsEnum tenum=termsIndex.getTermsEnum();
  BytesRef val=new BytesRef();
  for (int i=1; i < nTerms; i++) {
    BytesRef val1=tenum.next();
    BytesRef val2=termsIndex.lookup(i,val);
    assertEquals(val2,val1);
  }
  for (int i=0; i < 100 * RANDOM_MULTIPLIER; i++) {
    int k=_TestUtil.nextInt(random,1,nTerms - 1);
    BytesRef val1=termsIndex.lookup(k,val);
    assertEquals(TermsEnum.SeekStatus.FOUND,tenum.seek(val1));
    assertEquals(val1,tenum.term());
  }
  termsIndex=cache.getTermsIndex(reader,"bogusfield");
  FieldCache.DocTerms terms=cache.getTerms(reader,"theRandomUnicodeString");
  assertSame("Second request to cache return same array",terms,cache.getTerms(reader,"theRandomUnicodeString"));
  assertTrue("doubles Size: " + terms.size() + " is not: "+ NUM_DOCS,terms.size() == NUM_DOCS);
  for (int i=0; i < NUM_DOCS; i++) {
    final BytesRef term=terms.getTerm(i,br);
    final String s=term == null ? null : term.utf8ToString();
    assertTrue("for doc " + i + ": "+ s+ " does not equal: "+ unicodeStrings[i],unicodeStrings[i] == null || unicodeStrings[i].equals(s));
  }
  terms=cache.getTerms(reader,"bogusfield");
  FieldCache.DEFAULT.purge(reader);
}
