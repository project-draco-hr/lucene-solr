{
  FieldCache cache=FieldCache.DEFAULT;
  double[] doubles=cache.getDoubles(reader,"theDouble",random.nextBoolean());
  assertSame("Second request to cache return same array",doubles,cache.getDoubles(reader,"theDouble",random.nextBoolean()));
  assertSame("Second request with explicit parser return same array",doubles,cache.getDoubles(reader,"theDouble",FieldCache.DEFAULT_DOUBLE_PARSER,random.nextBoolean()));
  assertTrue("doubles Size: " + doubles.length + " is not: "+ NUM_DOCS,doubles.length == NUM_DOCS);
  for (int i=0; i < doubles.length; i++) {
    assertTrue(doubles[i] + " does not equal: " + (Double.MAX_VALUE - i),doubles[i] == (Double.MAX_VALUE - i));
  }
  long[] longs=cache.getLongs(reader,"theLong",random.nextBoolean());
  assertSame("Second request to cache return same array",longs,cache.getLongs(reader,"theLong",random.nextBoolean()));
  assertSame("Second request with explicit parser return same array",longs,cache.getLongs(reader,"theLong",FieldCache.DEFAULT_LONG_PARSER,random.nextBoolean()));
  assertTrue("longs Size: " + longs.length + " is not: "+ NUM_DOCS,longs.length == NUM_DOCS);
  for (int i=0; i < longs.length; i++) {
    assertTrue(longs[i] + " does not equal: " + (Long.MAX_VALUE - i)+ " i="+ i,longs[i] == (Long.MAX_VALUE - i));
  }
  byte[] bytes=cache.getBytes(reader,"theByte",random.nextBoolean());
  assertSame("Second request to cache return same array",bytes,cache.getBytes(reader,"theByte",random.nextBoolean()));
  assertSame("Second request with explicit parser return same array",bytes,cache.getBytes(reader,"theByte",FieldCache.DEFAULT_BYTE_PARSER,random.nextBoolean()));
  assertTrue("bytes Size: " + bytes.length + " is not: "+ NUM_DOCS,bytes.length == NUM_DOCS);
  for (int i=0; i < bytes.length; i++) {
    assertTrue(bytes[i] + " does not equal: " + (Byte.MAX_VALUE - i),bytes[i] == (byte)(Byte.MAX_VALUE - i));
  }
  short[] shorts=cache.getShorts(reader,"theShort",random.nextBoolean());
  assertSame("Second request to cache return same array",shorts,cache.getShorts(reader,"theShort",random.nextBoolean()));
  assertSame("Second request with explicit parser return same array",shorts,cache.getShorts(reader,"theShort",FieldCache.DEFAULT_SHORT_PARSER,random.nextBoolean()));
  assertTrue("shorts Size: " + shorts.length + " is not: "+ NUM_DOCS,shorts.length == NUM_DOCS);
  for (int i=0; i < shorts.length; i++) {
    assertTrue(shorts[i] + " does not equal: " + (Short.MAX_VALUE - i),shorts[i] == (short)(Short.MAX_VALUE - i));
  }
  int[] ints=cache.getInts(reader,"theInt",random.nextBoolean());
  assertSame("Second request to cache return same array",ints,cache.getInts(reader,"theInt",random.nextBoolean()));
  assertSame("Second request with explicit parser return same array",ints,cache.getInts(reader,"theInt",FieldCache.DEFAULT_INT_PARSER,random.nextBoolean()));
  assertTrue("ints Size: " + ints.length + " is not: "+ NUM_DOCS,ints.length == NUM_DOCS);
  for (int i=0; i < ints.length; i++) {
    assertTrue(ints[i] + " does not equal: " + (Integer.MAX_VALUE - i),ints[i] == (Integer.MAX_VALUE - i));
  }
  float[] floats=cache.getFloats(reader,"theFloat",random.nextBoolean());
  assertSame("Second request to cache return same array",floats,cache.getFloats(reader,"theFloat",random.nextBoolean()));
  assertSame("Second request with explicit parser return same array",floats,cache.getFloats(reader,"theFloat",FieldCache.DEFAULT_FLOAT_PARSER,random.nextBoolean()));
  assertTrue("floats Size: " + floats.length + " is not: "+ NUM_DOCS,floats.length == NUM_DOCS);
  for (int i=0; i < floats.length; i++) {
    assertTrue(floats[i] + " does not equal: " + (Float.MAX_VALUE - i),floats[i] == (Float.MAX_VALUE - i));
  }
  Bits docsWithField=cache.getDocsWithField(reader,"theLong");
  assertSame("Second request to cache return same array",docsWithField,cache.getDocsWithField(reader,"theLong"));
  assertTrue("docsWithField(theLong) must be class Bits.MatchAllBits",docsWithField instanceof Bits.MatchAllBits);
  assertTrue("docsWithField(theLong) Size: " + docsWithField.length() + " is not: "+ NUM_DOCS,docsWithField.length() == NUM_DOCS);
  for (int i=0; i < docsWithField.length(); i++) {
    assertTrue(docsWithField.get(i));
  }
  docsWithField=cache.getDocsWithField(reader,"sparse");
  assertSame("Second request to cache return same array",docsWithField,cache.getDocsWithField(reader,"sparse"));
  assertFalse("docsWithField(sparse) must not be class Bits.MatchAllBits",docsWithField instanceof Bits.MatchAllBits);
  assertTrue("docsWithField(sparse) Size: " + docsWithField.length() + " is not: "+ NUM_DOCS,docsWithField.length() == NUM_DOCS);
  for (int i=0; i < docsWithField.length(); i++) {
    assertEquals(i % 2 == 0,docsWithField.get(i));
  }
  FieldCache.DocTermsIndex termsIndex=cache.getTermsIndex(reader,"theRandomUnicodeString");
  assertSame("Second request to cache return same array",termsIndex,cache.getTermsIndex(reader,"theRandomUnicodeString"));
  assertTrue("doubles Size: " + termsIndex.size() + " is not: "+ NUM_DOCS,termsIndex.size() == NUM_DOCS);
  final BytesRef br=new BytesRef();
  for (int i=0; i < NUM_DOCS; i++) {
    final BytesRef term=termsIndex.getTerm(i,br);
    final String s=term == null ? null : term.utf8ToString();
    assertTrue("for doc " + i + ": "+ s+ " does not equal: "+ unicodeStrings[i],unicodeStrings[i] == null || unicodeStrings[i].equals(s));
  }
  int nTerms=termsIndex.numOrd();
  TermsEnum tenum=termsIndex.getTermsEnum();
  BytesRef val=new BytesRef();
  for (int i=1; i < nTerms; i++) {
    BytesRef val1=tenum.next();
    BytesRef val2=termsIndex.lookup(i,val);
    assertEquals(val2,val1);
  }
  int num=atLeast(100);
  for (int i=0; i < num; i++) {
    int k=_TestUtil.nextInt(random,1,nTerms - 1);
    BytesRef val1=termsIndex.lookup(k,val);
    assertEquals(TermsEnum.SeekStatus.FOUND,tenum.seekCeil(val1));
    assertEquals(val1,tenum.term());
  }
  termsIndex=cache.getTermsIndex(reader,"bogusfield");
  FieldCache.DocTerms terms=cache.getTerms(reader,"theRandomUnicodeString");
  assertSame("Second request to cache return same array",terms,cache.getTerms(reader,"theRandomUnicodeString"));
  assertTrue("doubles Size: " + terms.size() + " is not: "+ NUM_DOCS,terms.size() == NUM_DOCS);
  for (int i=0; i < NUM_DOCS; i++) {
    final BytesRef term=terms.getTerm(i,br);
    final String s=term == null ? null : term.utf8ToString();
    assertTrue("for doc " + i + ": "+ s+ " does not equal: "+ unicodeStrings[i],unicodeStrings[i] == null || unicodeStrings[i].equals(s));
  }
  terms=cache.getTerms(reader,"bogusfield");
  DocTermOrds termOrds=cache.getDocTermOrds(reader,"theRandomUnicodeMultiValuedField");
  TermsEnum termsEnum=termOrds.getOrdTermsEnum(reader);
  assertSame("Second request to cache return same DocTermOrds",termOrds,cache.getDocTermOrds(reader,"theRandomUnicodeMultiValuedField"));
  DocTermOrds.TermOrdsIterator reuse=null;
  for (int i=0; i < NUM_DOCS; i++) {
    reuse=termOrds.lookup(i,reuse);
    final int[] buffer=new int[5];
    List<BytesRef> values=new ArrayList<BytesRef>(new LinkedHashSet<BytesRef>(Arrays.asList(multiValued[i])));
    for (; ; ) {
      int chunk=reuse.read(buffer);
      if (chunk == 0) {
        for (int ord=0; ord < values.size(); ord++) {
          BytesRef term=values.get(ord);
          assertNull(String.format("Document[%d] misses field must be null. Has value %s for ord %d",i,term,ord),term);
        }
        break;
      }
      for (int idx=0; idx < chunk; idx++) {
        int key=buffer[idx];
        termsEnum.seekExact((long)key);
        String actual=termsEnum.term().utf8ToString();
        String expected=values.get(idx).utf8ToString();
        if (!expected.equals(actual)) {
          reuse=termOrds.lookup(i,reuse);
          reuse.read(buffer);
        }
        assertTrue(String.format("Expected value %s for doc %d and ord %d, but was %s",expected,i,idx,actual),expected.equals(actual));
      }
      if (chunk <= buffer.length) {
        break;
      }
    }
  }
  termOrds=cache.getDocTermOrds(reader,"bogusfield");
  FieldCache.DEFAULT.purge(reader);
}
