{
  IndexIterationContext context=new IndexIterationContext();
  int numRandomValues=nDocs / 2;
  context.randomUniqueValues=new String[numRandomValues];
  Set<String> trackSet=new HashSet<String>();
  context.randomFrom=new boolean[numRandomValues];
  for (int i=0; i < numRandomValues; i++) {
    String uniqueRandomValue;
    do {
      uniqueRandomValue=_TestUtil.randomRealisticUnicodeString(random());
    }
 while ("".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));
    trackSet.add(uniqueRandomValue);
    context.randomFrom[i]=random().nextBoolean();
    context.randomUniqueValues[i]=uniqueRandomValue;
  }
  RandomDoc[] docs=new RandomDoc[nDocs];
  for (int i=0; i < nDocs; i++) {
    String id=Integer.toString(i);
    int randomI=random().nextInt(context.randomUniqueValues.length);
    String value=context.randomUniqueValues[randomI];
    Document document=new Document();
    document.add(newField(random(),"id",id,TextField.TYPE_UNSTORED));
    document.add(newField(random(),"value",value,TextField.TYPE_UNSTORED));
    boolean from=context.randomFrom[randomI];
    int numberOfLinkValues=multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;
    docs[i]=new RandomDoc(id,numberOfLinkValues,value,from);
    for (int j=0; j < numberOfLinkValues; j++) {
      String linkValue=context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];
      docs[i].linkValues.add(linkValue);
      if (from) {
        if (!context.fromDocuments.containsKey(linkValue)) {
          context.fromDocuments.put(linkValue,new ArrayList<RandomDoc>());
        }
        if (!context.randomValueFromDocs.containsKey(value)) {
          context.randomValueFromDocs.put(value,new ArrayList<RandomDoc>());
        }
        context.fromDocuments.get(linkValue).add(docs[i]);
        context.randomValueFromDocs.get(value).add(docs[i]);
        document.add(newField(random(),"from",linkValue,TextField.TYPE_UNSTORED));
      }
 else {
        if (!context.toDocuments.containsKey(linkValue)) {
          context.toDocuments.put(linkValue,new ArrayList<RandomDoc>());
        }
        if (!context.randomValueToDocs.containsKey(value)) {
          context.randomValueToDocs.put(value,new ArrayList<RandomDoc>());
        }
        context.toDocuments.get(linkValue).add(docs[i]);
        context.randomValueToDocs.get(value).add(docs[i]);
        document.add(newField(random(),"to",linkValue,TextField.TYPE_UNSTORED));
      }
    }
    final RandomIndexWriter w;
    if (from) {
      w=fromWriter;
    }
 else {
      w=toWriter;
    }
    w.addDocument(document);
    if (random().nextInt(10) == 4) {
      w.commit();
    }
    if (VERBOSE) {
      System.out.println("Added document[" + docs[i].id + "]: "+ document);
    }
  }
  IndexSearcher fromSearcher=newSearcher(fromWriter.getReader());
  IndexSearcher toSearcher=newSearcher(toWriter.getReader());
  for (int i=0; i < context.randomUniqueValues.length; i++) {
    String uniqueRandomValue=context.randomUniqueValues[i];
    final String fromField;
    final String toField;
    final Map<String,Map<Integer,JoinScore>> queryVals;
    if (context.randomFrom[i]) {
      fromField="from";
      toField="to";
      queryVals=context.fromHitsToJoinScore;
    }
 else {
      fromField="to";
      toField="from";
      queryVals=context.toHitsToJoinScore;
    }
    final Map<BytesRef,JoinScore> joinValueToJoinScores=new HashMap<BytesRef,JoinScore>();
    if (multipleValuesPerDocument) {
      fromSearcher.search(new TermQuery(new Term("value",uniqueRandomValue)),new Collector(){
        private Scorer scorer;
        private DocTermOrds docTermOrds;
        private TermsEnum docTermsEnum;
        private DocTermOrds.TermOrdsIterator reuse;
        public void collect(        int doc) throws IOException {
          if (docTermOrds.isEmpty()) {
            return;
          }
          reuse=docTermOrds.lookup(doc,reuse);
          int[] buffer=new int[5];
          int chunk;
          do {
            chunk=reuse.read(buffer);
            if (chunk == 0) {
              return;
            }
            for (int idx=0; idx < chunk; idx++) {
              int key=buffer[idx];
              docTermsEnum.seekExact((long)key);
              BytesRef joinValue=docTermsEnum.term();
              if (joinValue == null) {
                continue;
              }
              JoinScore joinScore=joinValueToJoinScores.get(joinValue);
              if (joinScore == null) {
                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue),joinScore=new JoinScore());
              }
              joinScore.addScore(scorer.score());
            }
          }
 while (chunk >= buffer.length);
        }
        public void setNextReader(        AtomicReaderContext context) throws IOException {
          docTermOrds=FieldCache.DEFAULT.getDocTermOrds(context.reader(),fromField);
          docTermsEnum=docTermOrds.getOrdTermsEnum(context.reader());
          reuse=null;
        }
        public void setScorer(        Scorer scorer) throws IOException {
          this.scorer=scorer;
        }
        public boolean acceptsDocsOutOfOrder(){
          return false;
        }
      }
);
    }
 else {
      fromSearcher.search(new TermQuery(new Term("value",uniqueRandomValue)),new Collector(){
        private Scorer scorer;
        private FieldCache.DocTerms terms;
        private final BytesRef spare=new BytesRef();
        public void collect(        int doc) throws IOException {
          BytesRef joinValue=terms.getTerm(doc,spare);
          if (joinValue == null) {
            return;
          }
          JoinScore joinScore=joinValueToJoinScores.get(joinValue);
          if (joinScore == null) {
            joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue),joinScore=new JoinScore());
          }
          joinScore.addScore(scorer.score());
        }
        public void setNextReader(        AtomicReaderContext context) throws IOException {
          terms=FieldCache.DEFAULT.getTerms(context.reader(),fromField);
        }
        public void setScorer(        Scorer scorer) throws IOException {
          this.scorer=scorer;
        }
        public boolean acceptsDocsOutOfOrder(){
          return false;
        }
      }
);
    }
    final Map<Integer,JoinScore> docToJoinScore=new HashMap<Integer,JoinScore>();
    if (multipleValuesPerDocument) {
      toSearcher.search(new MatchAllDocsQuery(),new Collector(){
        private DocTermOrds docTermOrds;
        private TermsEnum docTermsEnum;
        private DocTermOrds.TermOrdsIterator reuse;
        private int docBase;
        public void collect(        int doc) throws IOException {
          if (docTermOrds.isEmpty()) {
            return;
          }
          reuse=docTermOrds.lookup(doc,reuse);
          int[] buffer=new int[5];
          int chunk;
          do {
            chunk=reuse.read(buffer);
            if (chunk == 0) {
              return;
            }
            for (int idx=0; idx < chunk; idx++) {
              int key=buffer[idx];
              docTermsEnum.seekExact((long)key);
              JoinScore joinScore=joinValueToJoinScores.get(docTermsEnum.term());
              if (joinScore == null) {
                continue;
              }
              Integer basedDoc=docBase + doc;
              if (!docToJoinScore.containsKey(basedDoc)) {
                docToJoinScore.put(basedDoc,joinScore);
              }
            }
          }
 while (chunk >= buffer.length);
        }
        public void setNextReader(        AtomicReaderContext context) throws IOException {
          docBase=context.docBase;
          docTermOrds=FieldCache.DEFAULT.getDocTermOrds(context.reader(),toField);
          docTermsEnum=docTermOrds.getOrdTermsEnum(context.reader());
          reuse=null;
        }
        public boolean acceptsDocsOutOfOrder(){
          return false;
        }
        public void setScorer(        Scorer scorer) throws IOException {
        }
      }
);
    }
 else {
      toSearcher.search(new MatchAllDocsQuery(),new Collector(){
        private FieldCache.DocTerms terms;
        private int docBase;
        private final BytesRef spare=new BytesRef();
        public void collect(        int doc) throws IOException {
          JoinScore joinScore=joinValueToJoinScores.get(terms.getTerm(doc,spare));
          if (joinScore == null) {
            return;
          }
          docToJoinScore.put(docBase + doc,joinScore);
        }
        public void setNextReader(        AtomicReaderContext context) throws IOException {
          terms=FieldCache.DEFAULT.getTerms(context.reader(),toField);
          docBase=context.docBase;
        }
        public boolean acceptsDocsOutOfOrder(){
          return false;
        }
        public void setScorer(        Scorer scorer) throws IOException {
        }
      }
);
    }
    queryVals.put(uniqueRandomValue,docToJoinScore);
  }
  fromSearcher.getIndexReader().close();
  toSearcher.getIndexReader().close();
  return context;
}
