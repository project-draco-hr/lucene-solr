{
  IndexIterationContext context=new IndexIterationContext();
  int numRandomValues=nDocs / 2;
  context.randomUniqueValues=new String[numRandomValues];
  Set<String> trackSet=new HashSet<>();
  context.randomFrom=new boolean[numRandomValues];
  for (int i=0; i < numRandomValues; i++) {
    String uniqueRandomValue;
    do {
      uniqueRandomValue=TestUtil.randomRealisticUnicodeString(random());
    }
 while ("".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));
    trackSet.add(uniqueRandomValue);
    context.randomFrom[i]=random().nextBoolean();
    context.randomUniqueValues[i]=uniqueRandomValue;
  }
  RandomDoc[] docs=new RandomDoc[nDocs];
  for (int i=0; i < nDocs; i++) {
    String id=Integer.toString(i);
    int randomI=random().nextInt(context.randomUniqueValues.length);
    String value=context.randomUniqueValues[randomI];
    Document document=new Document();
    document.add(newTextField(random(),"id",id,Field.Store.NO));
    document.add(newTextField(random(),"value",value,Field.Store.NO));
    boolean from=context.randomFrom[randomI];
    int numberOfLinkValues=multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;
    docs[i]=new RandomDoc(id,numberOfLinkValues,value,from);
    for (int j=0; j < numberOfLinkValues; j++) {
      String linkValue=context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];
      docs[i].linkValues.add(linkValue);
      if (from) {
        if (!context.fromDocuments.containsKey(linkValue)) {
          context.fromDocuments.put(linkValue,new ArrayList<RandomDoc>());
        }
        if (!context.randomValueFromDocs.containsKey(value)) {
          context.randomValueFromDocs.put(value,new ArrayList<RandomDoc>());
        }
        context.fromDocuments.get(linkValue).add(docs[i]);
        context.randomValueFromDocs.get(value).add(docs[i]);
        document.add(newTextField(random(),"from",linkValue,Field.Store.NO));
      }
 else {
        if (!context.toDocuments.containsKey(linkValue)) {
          context.toDocuments.put(linkValue,new ArrayList<RandomDoc>());
        }
        if (!context.randomValueToDocs.containsKey(value)) {
          context.randomValueToDocs.put(value,new ArrayList<RandomDoc>());
        }
        context.toDocuments.get(linkValue).add(docs[i]);
        context.randomValueToDocs.get(value).add(docs[i]);
        document.add(newTextField(random(),"to",linkValue,Field.Store.NO));
      }
    }
    final RandomIndexWriter w;
    if (from) {
      w=fromWriter;
    }
 else {
      w=toWriter;
    }
    w.addDocument(document);
    if (random().nextInt(10) == 4) {
      w.commit();
    }
    if (VERBOSE) {
      System.out.println("Added document[" + docs[i].id + "]: "+ document);
    }
  }
  IndexSearcher fromSearcher=newSearcher(fromWriter.getReader());
  IndexSearcher toSearcher=newSearcher(toWriter.getReader());
  for (int i=0; i < context.randomUniqueValues.length; i++) {
    String uniqueRandomValue=context.randomUniqueValues[i];
    final String fromField;
    final String toField;
    final Map<String,Map<Integer,JoinScore>> queryVals;
    if (context.randomFrom[i]) {
      fromField="from";
      toField="to";
      queryVals=context.fromHitsToJoinScore;
    }
 else {
      fromField="to";
      toField="from";
      queryVals=context.toHitsToJoinScore;
    }
    final Map<BytesRef,JoinScore> joinValueToJoinScores=new HashMap<>();
    if (multipleValuesPerDocument) {
      fromSearcher.search(new TermQuery(new Term("value",uniqueRandomValue)),new Collector(){
        private Scorer scorer;
        private SortedSetDocValues docTermOrds;
        final BytesRef joinValue=new BytesRef();
        @Override public void collect(        int doc) throws IOException {
          docTermOrds.setDocument(doc);
          long ord;
          while ((ord=docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {
            docTermOrds.lookupOrd(ord,joinValue);
            JoinScore joinScore=joinValueToJoinScores.get(joinValue);
            if (joinScore == null) {
              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue),joinScore=new JoinScore());
            }
            joinScore.addScore(scorer.score());
          }
        }
        @Override public void setNextReader(        AtomicReaderContext context) throws IOException {
          docTermOrds=FieldCache.DEFAULT.getDocTermOrds(context.reader(),fromField);
        }
        @Override public void setScorer(        Scorer scorer){
          this.scorer=scorer;
        }
        @Override public boolean acceptsDocsOutOfOrder(){
          return false;
        }
      }
);
    }
 else {
      fromSearcher.search(new TermQuery(new Term("value",uniqueRandomValue)),new Collector(){
        private Scorer scorer;
        private BinaryDocValues terms;
        private Bits docsWithField;
        private final BytesRef spare=new BytesRef();
        @Override public void collect(        int doc) throws IOException {
          terms.get(doc,spare);
          BytesRef joinValue=spare;
          if (joinValue.length == 0 && !docsWithField.get(doc)) {
            return;
          }
          JoinScore joinScore=joinValueToJoinScores.get(joinValue);
          if (joinScore == null) {
            joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue),joinScore=new JoinScore());
          }
          joinScore.addScore(scorer.score());
        }
        @Override public void setNextReader(        AtomicReaderContext context) throws IOException {
          terms=FieldCache.DEFAULT.getTerms(context.reader(),fromField,true);
          docsWithField=FieldCache.DEFAULT.getDocsWithField(context.reader(),fromField);
        }
        @Override public void setScorer(        Scorer scorer){
          this.scorer=scorer;
        }
        @Override public boolean acceptsDocsOutOfOrder(){
          return false;
        }
      }
);
    }
    final Map<Integer,JoinScore> docToJoinScore=new HashMap<>();
    if (multipleValuesPerDocument) {
      if (scoreDocsInOrder) {
        AtomicReader slowCompositeReader=SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());
        Terms terms=slowCompositeReader.terms(toField);
        if (terms != null) {
          DocsEnum docsEnum=null;
          TermsEnum termsEnum=null;
          SortedSet<BytesRef> joinValues=new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());
          joinValues.addAll(joinValueToJoinScores.keySet());
          for (          BytesRef joinValue : joinValues) {
            termsEnum=terms.iterator(termsEnum);
            if (termsEnum.seekExact(joinValue)) {
              docsEnum=termsEnum.docs(slowCompositeReader.getLiveDocs(),docsEnum,DocsEnum.FLAG_NONE);
              JoinScore joinScore=joinValueToJoinScores.get(joinValue);
              for (int doc=docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=docsEnum.nextDoc()) {
                if (!docToJoinScore.containsKey(doc)) {
                  docToJoinScore.put(doc,joinScore);
                }
              }
            }
          }
        }
      }
 else {
        toSearcher.search(new MatchAllDocsQuery(),new Collector(){
          private SortedSetDocValues docTermOrds;
          private final BytesRef scratch=new BytesRef();
          private int docBase;
          @Override public void collect(          int doc) throws IOException {
            docTermOrds.setDocument(doc);
            long ord;
            while ((ord=docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {
              docTermOrds.lookupOrd(ord,scratch);
              JoinScore joinScore=joinValueToJoinScores.get(scratch);
              if (joinScore == null) {
                continue;
              }
              Integer basedDoc=docBase + doc;
              if (!docToJoinScore.containsKey(basedDoc)) {
                docToJoinScore.put(basedDoc,joinScore);
              }
            }
          }
          @Override public void setNextReader(          AtomicReaderContext context) throws IOException {
            docBase=context.docBase;
            docTermOrds=FieldCache.DEFAULT.getDocTermOrds(context.reader(),toField);
          }
          @Override public boolean acceptsDocsOutOfOrder(){
            return false;
          }
          @Override public void setScorer(          Scorer scorer){
          }
        }
);
      }
    }
 else {
      toSearcher.search(new MatchAllDocsQuery(),new Collector(){
        private BinaryDocValues terms;
        private int docBase;
        private final BytesRef spare=new BytesRef();
        @Override public void collect(        int doc){
          terms.get(doc,spare);
          JoinScore joinScore=joinValueToJoinScores.get(spare);
          if (joinScore == null) {
            return;
          }
          docToJoinScore.put(docBase + doc,joinScore);
        }
        @Override public void setNextReader(        AtomicReaderContext context) throws IOException {
          terms=FieldCache.DEFAULT.getTerms(context.reader(),toField,false);
          docBase=context.docBase;
        }
        @Override public boolean acceptsDocsOutOfOrder(){
          return false;
        }
        @Override public void setScorer(        Scorer scorer){
        }
      }
);
    }
    queryVals.put(uniqueRandomValue,docToJoinScore);
  }
  fromSearcher.getIndexReader().close();
  toSearcher.getIndexReader().close();
  return context;
}
