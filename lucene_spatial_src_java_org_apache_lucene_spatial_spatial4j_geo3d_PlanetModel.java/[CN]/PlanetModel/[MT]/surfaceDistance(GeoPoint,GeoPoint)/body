{
  final double latA=p1.getLatitude();
  final double lonA=p1.getLongitude();
  final double latB=p2.getLatitude();
  final double lonB=p2.getLongitude();
  final double L=lonB - lonA;
  final double oF=1.0 - this.flattening;
  final double U1=Math.atan(oF * Math.tan(latA));
  final double U2=Math.atan(oF * Math.tan(latB));
  final double sU1=Math.sin(U1);
  final double cU1=Math.cos(U1);
  final double sU2=Math.sin(U2);
  final double cU2=Math.cos(U2);
  double sigma, sinSigma, cosSigma;
  double cos2Alpha, cos2SigmaM;
  double lambda=L;
  double iters=100;
  do {
    final double sinLambda=Math.sin(lambda);
    final double cosLambda=Math.cos(lambda);
    sinSigma=Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda) * (cU1 * sU2 - sU1 * cU2 * cosLambda));
    if (Math.abs(sinSigma) < Vector.MINIMUM_RESOLUTION)     return 0.0;
    cosSigma=sU1 * sU2 + cU1 * cU2 * cosLambda;
    sigma=Math.atan2(sinSigma,cosSigma);
    final double sinAlpha=cU1 * cU2 * sinLambda / sinSigma;
    cos2Alpha=1.0 - sinAlpha * sinAlpha;
    cos2SigmaM=cosSigma - 2.0 * sU1 * sU2 / cos2Alpha;
    final double c=this.flattening * 0.625 * cos2Alpha* (4.0 + this.flattening * (4.0 - 3.0 * cos2Alpha));
    final double lambdaP=lambda;
    lambda=L + (1.0 - c) * this.flattening * sinAlpha* (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM)));
    if (Math.abs(lambda - lambdaP) < Vector.MINIMUM_RESOLUTION)     break;
  }
 while (--iters > 0);
  if (iters == 0)   return 0.0;
  final double uSq=cos2Alpha * this.squareRatio;
  final double A=1.0 + uSq * 0.00006103515625 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));
  final double B=uSq * 0.0009765625 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));
  final double deltaSigma=B * sinSigma * (cos2SigmaM + B * 0.25 * (cosSigma * (-1.0 + 2.0 * cos2SigmaM * cos2SigmaM) - B * 0.16666666666666666666667 * cos2SigmaM* (-3.0 + 4.0 * sinSigma * sinSigma)* (-3.0 + 4.0 * cos2SigmaM * cos2SigmaM)));
  return this.c * A * (sigma - deltaSigma);
}
