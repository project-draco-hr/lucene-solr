{
  int i_C=0, i_I=0, i_W=0, i_O=0;
  int laps=0;
  int MINLAPSPERCASE=20;
  while (i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE || i_O < MINLAPSPERCASE) {
    laps++;
    double cX=randRange(-180,179);
    double cY=randRange(-90,90);
    double cR=randRange(0,180);
    double cR_dist=ctx.getDistCalc().distance(ctx.makePoint(0,0),0,cR);
    Circle c=ctx.makeCircle(cX,cY,cR_dist);
    double rX=randRange(-180,179);
    double rW=randRange(0,360);
    double rY1=randRange(-90,90);
    double rY2=randRange(-90,90);
    double rYmin=Math.min(rY1,rY2);
    double rYmax=Math.max(rY1,rY2);
    Rectangle r=ctx.makeRect(rX,rX + rW,rYmin,rYmax);
    SpatialRelation ic=c.relate(r,ctx);
    Point p;
switch (ic) {
case CONTAINS:
      i_C++;
    p=randomPointWithin(LuceneTestCase.random,r,ctx);
  Assert.assertEquals(CONTAINS,c.relate(p,ctx));
break;
case INTERSECTS:
i_I++;
break;
case WITHIN:
i_W++;
p=randomPointWithin(LuceneTestCase.random,c,ctx);
Assert.assertEquals(CONTAINS,r.relate(p,ctx));
break;
case DISJOINT:
i_O++;
p=randomPointWithin(LuceneTestCase.random,r,ctx);
Assert.assertEquals(DISJOINT,c.relate(p,ctx));
break;
default :
Assert.fail("" + ic);
}
}
}
