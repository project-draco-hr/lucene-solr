{
  SinkTokenizer theDetector=new SinkTokenizer(null){
    public void add(    Token t){
      if (t != null && t.term().equalsIgnoreCase("The")) {
        super.add(t);
      }
    }
  }
;
  SinkTokenizer dogDetector=new SinkTokenizer(null){
    public void add(    Token t){
      if (t != null && t.term().equalsIgnoreCase("Dogs")) {
        super.add(t);
      }
    }
  }
;
  TokenStream source1=new CachingTokenFilter(new TeeTokenFilter(new TeeTokenFilter(new WhitespaceTokenizer(new StringReader(buffer1.toString())),theDetector),dogDetector));
  TokenStream source2=new TeeTokenFilter(new TeeTokenFilter(new WhitespaceTokenizer(new StringReader(buffer2.toString())),theDetector),dogDetector);
  int i=0;
  final Token reusableToken=new Token();
  for (Token nextToken=source1.next(reusableToken); nextToken != null; nextToken=source1.next(reusableToken)) {
    assertTrue(nextToken.term() + " is not equal to " + tokens1[i],nextToken.term().equals(tokens1[i]) == true);
    i++;
  }
  assertTrue(i + " does not equal: " + tokens1.length,i == tokens1.length);
  assertTrue("theDetector Size: " + theDetector.getTokens().size() + " is not: "+ 2,theDetector.getTokens().size() == 2);
  assertTrue("dogDetector Size: " + dogDetector.getTokens().size() + " is not: "+ 1,dogDetector.getTokens().size() == 1);
  i=0;
  for (Token nextToken=source2.next(reusableToken); nextToken != null; nextToken=source2.next(reusableToken)) {
    assertTrue(nextToken.term() + " is not equal to " + tokens2[i],nextToken.term().equals(tokens2[i]) == true);
    i++;
  }
  assertTrue(i + " does not equal: " + tokens2.length,i == tokens2.length);
  assertTrue("theDetector Size: " + theDetector.getTokens().size() + " is not: "+ 4,theDetector.getTokens().size() == 4);
  assertTrue("dogDetector Size: " + dogDetector.getTokens().size() + " is not: "+ 2,dogDetector.getTokens().size() == 2);
  i=0;
  for (Token nextToken=theDetector.next(reusableToken); nextToken != null; nextToken=theDetector.next(reusableToken)) {
    assertTrue(nextToken.term() + " is not equal to " + "The",nextToken.term().equalsIgnoreCase("The") == true);
    i++;
  }
  assertTrue(i + " does not equal: " + theDetector.getTokens().size(),i == theDetector.getTokens().size());
  i=0;
  for (Token nextToken=dogDetector.next(reusableToken); nextToken != null; nextToken=dogDetector.next(reusableToken)) {
    assertTrue(nextToken.term() + " is not equal to " + "Dogs",nextToken.term().equalsIgnoreCase("Dogs") == true);
    i++;
  }
  assertTrue(i + " does not equal: " + dogDetector.getTokens().size(),i == dogDetector.getTokens().size());
  source1.reset();
  TokenStream lowerCasing=new LowerCaseFilter(source1);
  i=0;
  for (Token nextToken=lowerCasing.next(reusableToken); nextToken != null; nextToken=lowerCasing.next(reusableToken)) {
    assertTrue(nextToken.term() + " is not equal to " + tokens1[i].toLowerCase(),nextToken.term().equals(tokens1[i].toLowerCase()) == true);
    i++;
  }
  assertTrue(i + " does not equal: " + tokens1.length,i == tokens1.length);
}
