{
  if (shardGroups.length == 0) {
    return null;
  }
  int totalHitCount=0;
  int totalGroupedHitCount=0;
  final int numGroups=shardGroups[0].groups.length;
  for (  TopGroups<T> shard : shardGroups) {
    if (numGroups != shard.groups.length) {
      throw new IllegalArgumentException("number of groups differs across shards; you must pass same top groups to all shards' second-pass collector");
    }
    totalHitCount+=shard.totalHitCount;
    totalGroupedHitCount+=shard.totalGroupedHitCount;
  }
  @SuppressWarnings("unchecked") final GroupDocs<T>[] mergedGroupDocs=new GroupDocs[numGroups];
  final TopDocs[] shardTopDocs=new TopDocs[shardGroups.length];
  for (int groupIDX=0; groupIDX < numGroups; groupIDX++) {
    final T groupValue=shardGroups[0].groups[groupIDX].groupValue;
    float maxScore=Float.MIN_VALUE;
    int totalHits=0;
    for (int shardIDX=0; shardIDX < shardGroups.length; shardIDX++) {
      final TopGroups<T> shard=shardGroups[shardIDX];
      final GroupDocs shardGroupDocs=shard.groups[groupIDX];
      if (groupValue == null) {
        if (shardGroupDocs.groupValue != null) {
          throw new IllegalArgumentException("group values differ across shards; you must pass same top groups to all shards' second-pass collector");
        }
      }
 else       if (!groupValue.equals(shardGroupDocs.groupValue)) {
        throw new IllegalArgumentException("group values differ across shards; you must pass same top groups to all shards' second-pass collector");
      }
      shardTopDocs[shardIDX]=new TopDocs(shardGroupDocs.totalHits,shardGroupDocs.scoreDocs,shardGroupDocs.maxScore);
      maxScore=Math.max(maxScore,shardGroupDocs.maxScore);
      totalHits+=shardGroupDocs.totalHits;
    }
    final TopDocs.TopDocsAndShards mergedTopDocs=TopDocs.merge(docSort,docOffset + docTopN,shardTopDocs);
    final ScoreDoc[] mergedScoreDocs;
    final int[] mergedShardIndex;
    if (docOffset == 0) {
      mergedScoreDocs=mergedTopDocs.scoreDocs;
      mergedShardIndex=mergedTopDocs.shardIndex;
    }
 else     if (docOffset >= mergedTopDocs.scoreDocs.length) {
      mergedScoreDocs=new ScoreDoc[0];
      mergedShardIndex=new int[0];
    }
 else {
      mergedScoreDocs=new ScoreDoc[mergedTopDocs.scoreDocs.length - docOffset];
      System.arraycopy(mergedTopDocs.scoreDocs,docOffset,mergedScoreDocs,0,mergedTopDocs.scoreDocs.length - docOffset);
      mergedShardIndex=new int[mergedTopDocs.scoreDocs.length - docOffset];
      System.arraycopy(mergedTopDocs.shardIndex,docOffset,mergedShardIndex,0,mergedTopDocs.scoreDocs.length - docOffset);
    }
    mergedGroupDocs[groupIDX]=new GroupDocsAndShards<T>(maxScore,totalHits,mergedScoreDocs,groupValue,shardGroups[0].groups[groupIDX].groupSortValues,mergedShardIndex);
  }
  return new TopGroups<T>(groupSort.getSort(),docSort == null ? null : docSort.getSort(),totalHitCount,totalGroupedHitCount,mergedGroupDocs);
}
