{
  final long[] arr=new long[RandomInts.randomIntBetween(random(),1,1000000)];
  float[] ratioOptions=new float[]{PackedInts.DEFAULT,PackedInts.COMPACT,PackedInts.FAST};
  for (  int bpv : new int[]{0,1,63,64,RandomInts.randomIntBetween(random(),2,62)}) {
    for (    DataType dataType : DataType.values()) {
      final int pageSize=1 << TestUtil.nextInt(random(),6,20);
      final int initialPageCount=TestUtil.nextInt(random(),0,16);
      float acceptableOverheadRatio=ratioOptions[TestUtil.nextInt(random(),0,ratioOptions.length - 1)];
      AbstractAppendingLongBuffer buf;
      final int inc;
switch (dataType) {
case PACKED:
        buf=new AppendingPackedLongBuffer(initialPageCount,pageSize,acceptableOverheadRatio);
      inc=0;
    break;
case DELTA_PACKED:
  buf=new AppendingDeltaPackedLongBuffer(initialPageCount,pageSize,acceptableOverheadRatio);
inc=0;
break;
case MONOTONIC:
buf=new MonotonicAppendingLongBuffer(initialPageCount,pageSize,acceptableOverheadRatio);
inc=TestUtil.nextInt(random(),-1000,1000);
break;
default :
throw new RuntimeException("added a type and forgot to add it here?");
}
if (bpv == 0) {
arr[0]=random().nextLong();
for (int i=1; i < arr.length; ++i) {
arr[i]=arr[i - 1] + inc;
}
}
 else if (bpv == 64) {
for (int i=0; i < arr.length; ++i) {
arr[i]=random().nextLong();
}
}
 else {
final long minValue=TestUtil.nextLong(random(),Long.MIN_VALUE,Long.MAX_VALUE - PackedInts.maxValue(bpv));
for (int i=0; i < arr.length; ++i) {
arr[i]=minValue + inc * i + random().nextLong() & PackedInts.maxValue(bpv);
}
}
for (int i=0; i < arr.length; ++i) {
buf.add(arr[i]);
}
assertEquals(arr.length,buf.size());
if (random().nextBoolean()) {
buf.freeze();
if (random().nextBoolean()) {
buf.freeze();
}
}
assertEquals(arr.length,buf.size());
for (int i=0; i < arr.length; ++i) {
assertEquals(arr[i],buf.get(i));
}
final AbstractAppendingLongBuffer.Iterator it=buf.iterator();
for (int i=0; i < arr.length; ++i) {
if (random().nextBoolean()) {
assertTrue(it.hasNext());
}
assertEquals(arr[i],it.next());
}
assertFalse(it.hasNext());
long[] target=new long[arr.length + 1024];
for (int i=0; i < arr.length; i+=TestUtil.nextInt(random(),0,10000)) {
int lenToRead=random().nextInt(buf.pageSize() * 2) + 1;
lenToRead=Math.min(lenToRead,target.length - i);
int lenToCheck=Math.min(lenToRead,arr.length - i);
int off=i;
while (off < arr.length && lenToRead > 0) {
int read=buf.get(off,target,off,lenToRead);
assertTrue(read > 0);
assertTrue(read <= lenToRead);
lenToRead-=read;
off+=read;
}
for (int j=0; j < lenToCheck; j++) {
assertEquals(arr[j + i],target[j + i]);
}
}
final long expectedBytesUsed=RamUsageTester.sizeOf(buf);
final long computedBytesUsed=buf.ramBytesUsed();
assertEquals(expectedBytesUsed,computedBytesUsed);
}
}
}
