{
  if (!rb.doExpand) {
    return;
  }
  SolrQueryRequest req=rb.req;
  SolrParams params=req.getParams();
  boolean isShard=params.getBool(ShardParams.IS_SHARD,false);
  String ids=params.get(ShardParams.IDS);
  if (ids == null && isShard) {
    return;
  }
  String field=params.get(ExpandParams.EXPAND_FIELD);
  if (field == null) {
    List<Query> filters=rb.getFilters();
    if (filters != null) {
      for (      Query q : filters) {
        if (q instanceof CollapsingQParserPlugin.CollapsingPostFilter) {
          CollapsingQParserPlugin.CollapsingPostFilter cp=(CollapsingQParserPlugin.CollapsingPostFilter)q;
          field=cp.getField();
        }
      }
    }
  }
  if (field == null) {
    throw new IOException("Expand field is null.");
  }
  String sortParam=params.get(ExpandParams.EXPAND_SORT);
  String[] fqs=params.getParams(ExpandParams.EXPAND_FQ);
  String qs=params.get(ExpandParams.EXPAND_Q);
  int limit=params.getInt(ExpandParams.EXPAND_ROWS,5);
  Sort sort=null;
  if (sortParam != null) {
    sort=QueryParsing.parseSortSpec(sortParam,rb.req).getSort();
  }
  Query query;
  if (qs == null) {
    query=rb.getQuery();
  }
 else {
    try {
      QParser parser=QParser.getParser(qs,null,req);
      query=parser.getQuery();
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  List<Query> newFilters=new ArrayList<>();
  if (fqs == null) {
    List<Query> filters=rb.getFilters();
    if (filters != null) {
      for (      Query q : filters) {
        if (!(q instanceof CollapsingQParserPlugin.CollapsingPostFilter)) {
          newFilters.add(q);
        }
      }
    }
  }
 else {
    try {
      for (      String fq : fqs) {
        if (fq != null && fq.trim().length() != 0 && !fq.equals("*:*")) {
          QParser fqp=QParser.getParser(fq,null,req);
          newFilters.add(fqp.getQuery());
        }
      }
    }
 catch (    Exception e) {
      throw new IOException(e);
    }
  }
  SolrIndexSearcher searcher=req.getSearcher();
  LeafReader reader=searcher.getLeafReader();
  SortedDocValues values=DocValues.getSorted(reader,field);
  FixedBitSet groupBits=new FixedBitSet(values.getValueCount());
  DocList docList=rb.getResults().docList;
  IntOpenHashSet collapsedSet=new IntOpenHashSet(docList.size() * 2);
  DocIterator idit=docList.iterator();
  while (idit.hasNext()) {
    int doc=idit.nextDoc();
    int ord=values.getOrd(doc);
    if (ord > -1) {
      groupBits.set(ord);
      collapsedSet.add(doc);
    }
  }
  Collector collector;
  if (sort != null)   sort=sort.rewrite(searcher);
  GroupExpandCollector groupExpandCollector=new GroupExpandCollector(values,groupBits,collapsedSet,limit,sort);
  SolrIndexSearcher.ProcessedFilter pfilter=searcher.getProcessedFilter(null,newFilters);
  if (pfilter.postFilter != null) {
    pfilter.postFilter.setLastDelegate(groupExpandCollector);
    collector=pfilter.postFilter;
  }
 else {
    collector=groupExpandCollector;
  }
  searcher.search(query,pfilter.filter,collector);
  IntObjectMap groups=groupExpandCollector.getGroups();
  Map<String,DocSlice> outMap=new HashMap<>();
  CharsRefBuilder charsRef=new CharsRefBuilder();
  FieldType fieldType=searcher.getSchema().getField(field).getType();
  for (  IntObjectCursor cursor : (Iterable<IntObjectCursor>)groups) {
    int ord=cursor.key;
    TopDocsCollector topDocsCollector=(TopDocsCollector)cursor.value;
    TopDocs topDocs=topDocsCollector.topDocs();
    ScoreDoc[] scoreDocs=topDocs.scoreDocs;
    if (scoreDocs.length > 0) {
      int[] docs=new int[scoreDocs.length];
      float[] scores=new float[scoreDocs.length];
      for (int i=0; i < docs.length; i++) {
        ScoreDoc scoreDoc=scoreDocs[i];
        docs[i]=scoreDoc.doc;
        scores[i]=scoreDoc.score;
      }
      DocSlice slice=new DocSlice(0,docs.length,docs,scores,topDocs.totalHits,topDocs.getMaxScore());
      final BytesRef bytesRef=values.lookupOrd(ord);
      fieldType.indexedToReadable(bytesRef,charsRef);
      String group=charsRef.toString();
      outMap.put(group,slice);
    }
  }
  rb.rsp.add("expanded",outMap);
}
