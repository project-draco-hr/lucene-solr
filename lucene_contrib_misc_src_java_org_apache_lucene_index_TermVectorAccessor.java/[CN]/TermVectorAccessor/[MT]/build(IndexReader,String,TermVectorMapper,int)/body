{
  if (tokens == null) {
    tokens=new ArrayList<BytesRef>(500);
    positions=new ArrayList<int[]>(500);
    frequencies=new ArrayList<Integer>(500);
  }
 else {
    tokens.clear();
    frequencies.clear();
    positions.clear();
  }
  final Bits liveDocs=MultiFields.getLiveDocs(indexReader);
  Terms terms=MultiFields.getTerms(indexReader,field);
  boolean anyTerms=false;
  if (terms != null) {
    TermsEnum termsEnum=terms.iterator();
    DocsEnum docs=null;
    DocsAndPositionsEnum postings=null;
    while (true) {
      BytesRef text=termsEnum.next();
      if (text != null) {
        anyTerms=true;
        if (!mapper.isIgnoringPositions()) {
          docs=postings=termsEnum.docsAndPositions(liveDocs,postings);
        }
 else {
          docs=termsEnum.docs(liveDocs,docs);
        }
        int docID=docs.advance(documentNumber);
        if (docID == documentNumber) {
          frequencies.add(Integer.valueOf(docs.freq()));
          tokens.add(new BytesRef(text));
          if (!mapper.isIgnoringPositions()) {
            int[] positions=new int[docs.freq()];
            for (int i=0; i < positions.length; i++) {
              positions[i]=postings.nextPosition();
            }
            this.positions.add(positions);
          }
 else {
            positions.add(null);
          }
        }
      }
 else {
        break;
      }
    }
    if (anyTerms) {
      mapper.setDocumentNumber(documentNumber);
      mapper.setExpectations(field,tokens.size(),false,!mapper.isIgnoringPositions());
      for (int i=0; i < tokens.size(); i++) {
        mapper.map(tokens.get(i),frequencies.get(i).intValue(),(TermVectorOffsetInfo[])null,positions.get(i));
      }
    }
  }
}
