{
  final String collection=message.getStr(ZkStateReader.COLLECTION_PROP);
  String coreNodeName=message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);
  if (coreNodeName == null) {
    coreNodeName=getAssignedCoreNodeName(state,message);
    if (coreNodeName != null) {
      log.info("node=" + coreNodeName + " is already registered");
    }
 else {
      coreNodeName=Assign.assignNode(collection,state);
    }
    message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,coreNodeName);
  }
  Integer numShards=message.getStr(ZkStateReader.NUM_SHARDS_PROP) != null ? Integer.parseInt(message.getStr(ZkStateReader.NUM_SHARDS_PROP)) : null;
  log.info("Update state numShards={} message={}",numShards,message);
  boolean collectionExists=state.getCollections().contains(collection);
  if (!collectionExists && numShards != null) {
    state=createCollection(state,collection,numShards);
  }
  String sliceName=message.getStr(ZkStateReader.SHARD_ID_PROP);
  if (sliceName == null) {
    sliceName=getAssignedId(state,coreNodeName,message);
    if (sliceName != null) {
      log.info("shard=" + sliceName + " is already registered");
    }
  }
  if (sliceName == null) {
    if (collectionExists) {
      numShards=state.getCollectionStates().get(collection).getSlices().size();
      log.info("Collection already exists with " + ZkStateReader.NUM_SHARDS_PROP + "="+ numShards);
    }
    sliceName=Assign.assignShard(collection,state,numShards);
    log.info("Assigning new node to shard shard=" + sliceName);
  }
  Slice slice=state.getSlice(collection,sliceName);
  Map<String,Object> replicaProps=new LinkedHashMap<String,Object>();
  replicaProps.putAll(message.getProperties());
  if (slice != null) {
    String sliceState=slice.getState();
    Replica oldReplica=slice.getReplicasMap().get(coreNodeName);
    if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {
      replicaProps.put(ZkStateReader.LEADER_PROP,oldReplica.get(ZkStateReader.LEADER_PROP));
    }
  }
  replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);
  replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);
  replicaProps.remove(ZkStateReader.SHARD_ID_PROP);
  replicaProps.remove(ZkStateReader.COLLECTION_PROP);
  replicaProps.remove(QUEUE_OPERATION);
  Set<Entry<String,Object>> entrySet=replicaProps.entrySet();
  List<String> removeKeys=new ArrayList<String>();
  for (  Entry<String,Object> entry : entrySet) {
    if (entry.getValue() == null) {
      removeKeys.add(entry.getKey());
    }
  }
  for (  String removeKey : removeKeys) {
    replicaProps.remove(removeKey);
  }
  replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);
  String shardRange=(String)replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);
  String shardState=(String)replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);
  Replica replica=new Replica(coreNodeName,replicaProps);
  Map<String,Object> sliceProps=null;
  Map<String,Replica> replicas;
  if (slice != null) {
    sliceProps=slice.getProperties();
    replicas=slice.getReplicasCopy();
  }
 else {
    replicas=new HashMap<String,Replica>(1);
    sliceProps=new HashMap<String,Object>();
    sliceProps.put(Slice.RANGE,shardRange);
    sliceProps.put(Slice.STATE,shardState);
  }
  replicas.put(replica.getName(),replica);
  slice=new Slice(sliceName,replicas,sliceProps);
  ClusterState newClusterState=updateSlice(state,collection,slice);
  return newClusterState;
}
