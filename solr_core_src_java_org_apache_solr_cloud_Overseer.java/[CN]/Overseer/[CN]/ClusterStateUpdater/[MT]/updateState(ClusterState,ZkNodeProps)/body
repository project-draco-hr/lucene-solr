{
  final String collection=message.getStr(ZkStateReader.COLLECTION_PROP);
  if (!checkCollectionKeyExistence(message))   return clusterState;
  Integer numShards=message.getInt(ZkStateReader.NUM_SHARDS_PROP,null);
  List<String> shardNames=new ArrayList<>();
  boolean collectionExists=clusterState.hasCollection(collection);
  if (!collectionExists && numShards != null) {
    getShardNames(numShards,shardNames);
    clusterState=createCollection(clusterState,collection,shardNames,message);
  }
  String sliceName=message.getStr(ZkStateReader.SHARD_ID_PROP);
  String coreNodeName=message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);
  if (coreNodeName == null) {
    coreNodeName=getAssignedCoreNodeName(clusterState,message);
    if (coreNodeName != null) {
      log.info("node=" + coreNodeName + " is already registered");
    }
 else {
      coreNodeName=Assign.assignNode(collection,clusterState);
    }
    message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,coreNodeName);
  }
  if (sliceName == null) {
    sliceName=getAssignedId(clusterState,coreNodeName,message);
    if (sliceName != null) {
      log.info("shard=" + sliceName + " is already registered");
    }
  }
  if (sliceName == null) {
    if (collectionExists) {
      numShards=clusterState.getCollection(collection).getSlices().size();
      log.info("Collection already exists with " + ZkStateReader.NUM_SHARDS_PROP + "="+ numShards);
    }
    sliceName=Assign.assignShard(collection,clusterState,numShards);
    log.info("Assigning new node to shard shard=" + sliceName);
  }
  Slice slice=clusterState.getSlice(collection,sliceName);
  Map<String,Object> replicaProps=new LinkedHashMap<>();
  replicaProps.putAll(message.getProperties());
  if (slice != null) {
    Replica oldReplica=slice.getReplicasMap().get(coreNodeName);
    if (oldReplica != null) {
      if (oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {
        replicaProps.put(ZkStateReader.LEADER_PROP,oldReplica.get(ZkStateReader.LEADER_PROP));
      }
      for (      Map.Entry<String,Object> ent : oldReplica.getProperties().entrySet()) {
        if (ent.getKey().startsWith(COLL_PROP_PREFIX)) {
          replicaProps.put(ent.getKey(),ent.getValue());
        }
      }
    }
  }
  replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);
  replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);
  replicaProps.remove(ZkStateReader.SHARD_ID_PROP);
  replicaProps.remove(ZkStateReader.COLLECTION_PROP);
  replicaProps.remove(QUEUE_OPERATION);
  Set<Entry<String,Object>> entrySet=replicaProps.entrySet();
  List<String> removeKeys=new ArrayList<>();
  for (  Entry<String,Object> entry : entrySet) {
    if (entry.getValue() == null) {
      removeKeys.add(entry.getKey());
    }
  }
  for (  String removeKey : removeKeys) {
    replicaProps.remove(removeKey);
  }
  replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);
  String shardRange=(String)replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);
  String shardState=(String)replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);
  String shardParent=(String)replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);
  Replica replica=new Replica(coreNodeName,replicaProps);
  Map<String,Object> sliceProps=null;
  Map<String,Replica> replicas;
  if (slice != null) {
    clusterState=checkAndCompleteShardSplit(clusterState,collection,coreNodeName,sliceName,replicaProps);
    slice=clusterState.getSlice(collection,sliceName);
    sliceProps=slice.getProperties();
    replicas=slice.getReplicasCopy();
  }
 else {
    replicas=new HashMap<>(1);
    sliceProps=new HashMap<>();
    sliceProps.put(Slice.RANGE,shardRange);
    sliceProps.put(Slice.STATE,shardState);
    sliceProps.put(Slice.PARENT,shardParent);
  }
  replicas.put(replica.getName(),replica);
  slice=new Slice(sliceName,replicas,sliceProps);
  ClusterState newClusterState=updateSlice(clusterState,collection,slice);
  return newClusterState;
}
