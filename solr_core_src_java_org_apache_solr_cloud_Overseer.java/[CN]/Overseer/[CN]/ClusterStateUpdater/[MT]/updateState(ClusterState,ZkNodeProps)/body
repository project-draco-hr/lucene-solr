{
  final String collection=message.getStr(ZkStateReader.COLLECTION_PROP);
  checkCollection(message,collection);
  Integer numShards=message.getInt(ZkStateReader.NUM_SHARDS_PROP,null);
  log.info("Update state numShards={} message={}",numShards,message);
  List<String> shardNames=new ArrayList<String>();
  boolean collectionExists=state.hasCollection(collection);
  if (!collectionExists && numShards != null) {
    getShardNames(numShards,shardNames);
    state=createCollection(state,collection,shardNames,message);
  }
  String sliceName=message.getStr(ZkStateReader.SHARD_ID_PROP);
  String coreNodeName=message.getStr(ZkStateReader.CORE_NODE_NAME_PROP);
  if (coreNodeName == null) {
    coreNodeName=getAssignedCoreNodeName(state,message);
    if (coreNodeName != null) {
      log.info("node=" + coreNodeName + " is already registered");
    }
 else {
      coreNodeName=Assign.assignNode(collection,state);
    }
    message.getProperties().put(ZkStateReader.CORE_NODE_NAME_PROP,coreNodeName);
  }
  if (sliceName == null) {
    sliceName=getAssignedId(state,coreNodeName,message);
    if (sliceName != null) {
      log.info("shard=" + sliceName + " is already registered");
    }
  }
  if (sliceName == null) {
    if (collectionExists) {
      numShards=state.getCollection(collection).getSlices().size();
      log.info("Collection already exists with " + ZkStateReader.NUM_SHARDS_PROP + "="+ numShards);
    }
    sliceName=Assign.assignShard(collection,state,numShards);
    log.info("Assigning new node to shard shard=" + sliceName);
  }
  Slice slice=state.getSlice(collection,sliceName);
  Map<String,Object> replicaProps=new LinkedHashMap<String,Object>();
  replicaProps.putAll(message.getProperties());
  if (slice != null) {
    Replica oldReplica=slice.getReplicasMap().get(coreNodeName);
    if (oldReplica != null && oldReplica.containsKey(ZkStateReader.LEADER_PROP)) {
      replicaProps.put(ZkStateReader.LEADER_PROP,oldReplica.get(ZkStateReader.LEADER_PROP));
    }
  }
  replicaProps.remove(ZkStateReader.NUM_SHARDS_PROP);
  replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);
  replicaProps.remove(ZkStateReader.SHARD_ID_PROP);
  replicaProps.remove(ZkStateReader.COLLECTION_PROP);
  replicaProps.remove(QUEUE_OPERATION);
  Set<Entry<String,Object>> entrySet=replicaProps.entrySet();
  List<String> removeKeys=new ArrayList<String>();
  for (  Entry<String,Object> entry : entrySet) {
    if (entry.getValue() == null) {
      removeKeys.add(entry.getKey());
    }
  }
  for (  String removeKey : removeKeys) {
    replicaProps.remove(removeKey);
  }
  replicaProps.remove(ZkStateReader.CORE_NODE_NAME_PROP);
  String shardRange=(String)replicaProps.remove(ZkStateReader.SHARD_RANGE_PROP);
  String shardState=(String)replicaProps.remove(ZkStateReader.SHARD_STATE_PROP);
  String shardParent=(String)replicaProps.remove(ZkStateReader.SHARD_PARENT_PROP);
  Replica replica=new Replica(coreNodeName,replicaProps);
  Map<String,Object> sliceProps=null;
  Map<String,Replica> replicas;
  if (slice != null) {
    state=checkAndCompleteShardSplit(state,collection,coreNodeName,sliceName,replicaProps);
    slice=state.getSlice(collection,sliceName);
    sliceProps=slice.getProperties();
    replicas=slice.getReplicasCopy();
  }
 else {
    replicas=new HashMap<String,Replica>(1);
    sliceProps=new HashMap<String,Object>();
    sliceProps.put(Slice.RANGE,shardRange);
    sliceProps.put(Slice.STATE,shardState);
    sliceProps.put(Slice.PARENT,shardParent);
  }
  replicas.put(replica.getName(),replica);
  slice=new Slice(sliceName,replicas,sliceProps);
  ClusterState newClusterState=updateSlice(state,collection,slice);
  return newClusterState;
}
