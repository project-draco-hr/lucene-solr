{
  LeaderStatus isLeader=amILeader();
  while (isLeader == LeaderStatus.DONT_KNOW) {
    log.debug("am_i_leader unclear {}",isLeader);
    isLeader=amILeader();
  }
  if (!this.isClosed && LeaderStatus.YES == isLeader) {
synchronized (reader.getUpdateLock()) {
      try {
        byte[] head=workQueue.peek();
        if (head != null) {
          reader.updateClusterState(true);
          ClusterState clusterState=reader.getClusterState();
          log.info("Replaying operations from work queue.");
          ZkStateWriter zkStateWriter=new ZkStateWriter(reader,stats);
          while (head != null) {
            isLeader=amILeader();
            if (LeaderStatus.NO == isLeader) {
              break;
            }
 else             if (LeaderStatus.YES == isLeader) {
              final ZkNodeProps message=ZkNodeProps.load(head);
              final String operation=message.getStr(QUEUE_OPERATION);
              final TimerContext timerContext=stats.time(operation);
              try {
                ZkWriteCommand zkWriteCommand=processMessage(clusterState,message,operation,workQueue.getStats().getQueueLength());
                clusterState=zkStateWriter.enqueueUpdate(clusterState,zkWriteCommand);
                stats.success(operation);
              }
 catch (              Exception e) {
                log.error("Overseer could not process the current clusterstate state update message, skipping the message.",e);
                stats.error(operation);
              }
 finally {
                timerContext.stop();
              }
              if (zkStateWriter.hasPendingUpdates()) {
                clusterState=zkStateWriter.writePendingUpdates();
              }
              workQueue.poll();
            }
 else {
              log.info("am_i_leader unclear {}",isLeader);
            }
            head=workQueue.peek();
          }
        }
      }
 catch (      KeeperException e) {
        if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
          log.warn("Solr cannot talk to ZK, exiting Overseer work queue loop",e);
          return;
        }
        log.error("Exception in Overseer work queue loop",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      }
catch (      Exception e) {
        log.error("Exception in Overseer work queue loop",e);
      }
    }
  }
  log.info("Starting to work on the main queue");
  int lastStateFormat=-1;
  String lastCollectionName=null;
  try {
    ZkStateWriter zkStateWriter=new ZkStateWriter(reader,stats);
    ClusterState clusterState=null;
    boolean refreshClusterState=true;
    while (!this.isClosed) {
      isLeader=amILeader();
      if (LeaderStatus.NO == isLeader) {
        break;
      }
 else       if (LeaderStatus.YES != isLeader) {
        log.debug("am_i_leader unclear {}",isLeader);
        continue;
      }
      DistributedQueue.QueueEvent head=null;
      try {
        head=stateUpdateQueue.peek(true);
      }
 catch (      KeeperException e) {
        if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
          log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop",e);
          return;
        }
        log.error("Exception in Overseer main queue loop",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      }
catch (      Exception e) {
        log.error("Exception in Overseer main queue loop",e);
      }
synchronized (reader.getUpdateLock()) {
        try {
          if (refreshClusterState) {
            reader.updateClusterState(true);
            clusterState=reader.getClusterState();
            refreshClusterState=false;
            byte[] data=workQueue.peek();
            while (data != null) {
              final ZkNodeProps message=ZkNodeProps.load(data);
              final String operation=message.getStr(QUEUE_OPERATION);
              final TimerContext timerContext=stats.time(operation);
              try {
                ZkWriteCommand zkWriteCommand=processMessage(clusterState,message,operation,workQueue.getStats().getQueueLength());
                clusterState=zkStateWriter.enqueueUpdate(clusterState,zkWriteCommand);
                stats.success(operation);
              }
 catch (              Exception e) {
                log.error("Overseer could not process the current clusterstate state update message, skipping the message.",e);
                stats.error(operation);
              }
 finally {
                timerContext.stop();
              }
              if (zkStateWriter.hasPendingUpdates()) {
                clusterState=zkStateWriter.writePendingUpdates();
              }
              workQueue.poll();
              data=workQueue.peek();
            }
          }
          while (head != null) {
            final ZkNodeProps message=ZkNodeProps.load(head.getBytes());
            final String operation=message.getStr(QUEUE_OPERATION);
            String collection=message.getStr(ZkStateReader.COLLECTION_PROP);
            if (collection == null)             collection=message.getStr("name");
            if (collection != null) {
              DocCollection docCollection=clusterState.getCollectionOrNull(collection);
              if (lastStateFormat != -1 && docCollection != null && docCollection.getStateFormat() != lastStateFormat) {
                lastStateFormat=docCollection.getStateFormat();
                break;
              }
              if (docCollection != null) {
                lastStateFormat=docCollection.getStateFormat();
              }
            }
            final TimerContext timerContext=stats.time(operation);
            try {
              ZkWriteCommand zkWriteCommand=processMessage(clusterState,message,operation,stateUpdateQueue.getStats().getQueueLength());
              clusterState=zkStateWriter.enqueueUpdate(clusterState,zkWriteCommand);
              stats.success(operation);
            }
 catch (            Exception e) {
              log.error("Overseer could not process the current clusterstate state update message, skipping the message.",e);
              stats.error(operation);
            }
 finally {
              timerContext.stop();
            }
            workQueue.offer(head.getBytes());
            stateUpdateQueue.poll();
            if (isClosed || System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY,TimeUnit.MILLISECONDS))             break;
            if (!updateNodes.isEmpty() && !collection.equals(lastCollectionName)) {
              lastCollectionName=collection;
              break;
            }
            lastCollectionName=collection;
            head=stateUpdateQueue.peek(100);
          }
          if (zkStateWriter.hasPendingUpdates()) {
            clusterState=zkStateWriter.writePendingUpdates();
            lastUpdatedTime=zkStateWriter.getLastUpdatedTime();
          }
          while (workQueue.poll() != null)           ;
        }
 catch (        KeeperException e) {
          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
            log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop",e);
            return;
          }
          log.error("Exception in Overseer main queue loop",e);
          refreshClusterState=true;
        }
catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
          return;
        }
catch (        Exception e) {
          log.error("Exception in Overseer main queue loop",e);
          refreshClusterState=true;
        }
      }
    }
  }
  finally {
    log.info("Overseer Loop exiting : {}",LeaderElector.getNodeName(myId));
    new Thread("OverseerExitThread"){
      @Override public void run(){
        checkIfIamStillLeader();
      }
    }
.start();
  }
}
