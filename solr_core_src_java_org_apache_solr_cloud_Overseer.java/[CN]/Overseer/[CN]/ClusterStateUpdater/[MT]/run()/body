{
  LeaderStatus isLeader=amILeader();
  while (isLeader == LeaderStatus.DONT_KNOW) {
    log.debug("am_i_leader unclear {}",isLeader);
    isLeader=amILeader();
  }
  if (!this.isClosed && LeaderStatus.YES == isLeader) {
synchronized (reader.getUpdateLock()) {
      try {
        byte[] head=workQueue.peek();
        if (head != null) {
          reader.updateClusterState(true);
          ClusterState clusterState=reader.getClusterState();
          log.info("Replaying operations from work queue.");
          while (head != null) {
            isLeader=amILeader();
            if (LeaderStatus.NO == isLeader) {
              break;
            }
 else             if (LeaderStatus.YES == isLeader) {
              final ZkNodeProps message=ZkNodeProps.load(head);
              final String operation=message.getStr(QUEUE_OPERATION);
              try {
                clusterState=processMessage(clusterState,message,operation);
              }
 catch (              Exception e) {
                log.error("Could not process Overseer message",e);
              }
              zkClient.setData(ZkStateReader.CLUSTER_STATE,ZkStateReader.toJSON(clusterState),true);
              workQueue.poll();
            }
 else {
              log.info("am_i_leader unclear {}",isLeader);
            }
            head=workQueue.peek();
          }
        }
      }
 catch (      KeeperException e) {
        if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
          log.warn("Solr cannot talk to ZK, exiting Overseer work queue loop",e);
          return;
        }
        log.error("Exception in Overseer work queue loop",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      }
catch (      Exception e) {
        log.error("Exception in Overseer work queue loop",e);
      }
    }
  }
  log.info("Starting to work on the main queue");
  while (!this.isClosed) {
    isLeader=amILeader();
    if (LeaderStatus.NO == isLeader) {
      break;
    }
 else     if (LeaderStatus.YES != isLeader) {
      log.debug("am_i_leader unclear {}",isLeader);
      continue;
    }
    DistributedQueue.QueueEvent head=null;
    try {
      head=stateUpdateQueue.peek(true);
    }
 catch (    KeeperException e) {
      if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
        log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop",e);
        return;
      }
      log.error("Exception in Overseer main queue loop",e);
    }
catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      return;
    }
catch (    Exception e) {
      log.error("Exception in Overseer main queue loop",e);
    }
synchronized (reader.getUpdateLock()) {
      try {
        reader.updateClusterState(true);
        ClusterState clusterState=reader.getClusterState();
        while (head != null) {
          final ZkNodeProps message=ZkNodeProps.load(head.getBytes());
          final String operation=message.getStr(QUEUE_OPERATION);
          try {
            clusterState=processMessage(clusterState,message,operation);
          }
 catch (          Exception e) {
            log.error("Could not process Overseer message",e);
          }
          workQueue.offer(head.getBytes());
          stateUpdateQueue.poll();
          if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY,TimeUnit.MILLISECONDS))           break;
          head=stateUpdateQueue.peek(100);
        }
        lastUpdatedTime=System.nanoTime();
        zkClient.setData(ZkStateReader.CLUSTER_STATE,ZkStateReader.toJSON(clusterState),true);
        while (workQueue.poll() != null)         ;
      }
 catch (      KeeperException e) {
        if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
          log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop",e);
          return;
        }
        log.error("Exception in Overseer main queue loop",e);
      }
catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      }
catch (      Exception e) {
        log.error("Exception in Overseer main queue loop",e);
      }
    }
  }
}
