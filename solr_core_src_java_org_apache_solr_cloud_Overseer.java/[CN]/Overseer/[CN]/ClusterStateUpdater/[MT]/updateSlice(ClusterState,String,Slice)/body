{
  final Map<String,Map<String,Slice>> newStates=new LinkedHashMap<String,Map<String,Slice>>();
  newStates.putAll(state.getCollectionStates());
  if (!newStates.containsKey(collection)) {
    newStates.put(collection,new LinkedHashMap<String,Slice>());
  }
  final Map<String,Slice> slices=newStates.get(collection);
  if (!slices.containsKey(slice.getName())) {
    slices.put(slice.getName(),slice);
  }
 else {
    final Map<String,Replica> shards=new LinkedHashMap<String,Replica>();
    final Slice existingSlice=slices.get(slice.getName());
    shards.putAll(existingSlice.getReplicasMap());
    for (    Entry<String,Replica> edit : slice.getReplicasMap().entrySet()) {
      if (existingSlice.getReplicasMap().get(edit.getKey()) != null && existingSlice.getReplicasMap().get(edit.getKey()).containsKey(ZkStateReader.LEADER_PROP)) {
        HashMap<String,Object> newProps=new HashMap<String,Object>();
        newProps.putAll(edit.getValue().getProperties());
        newProps.put(ZkStateReader.LEADER_PROP,existingSlice.getReplicasMap().get(edit.getKey()).getStr(ZkStateReader.LEADER_PROP));
        shards.put(edit.getKey(),new Replica(edit.getKey(),newProps));
      }
 else {
        shards.put(edit.getKey(),edit.getValue());
      }
    }
    final Slice updatedSlice=new Slice(slice.getName(),shards);
    slices.put(slice.getName(),updatedSlice);
  }
  return new ClusterState(state.getLiveNodes(),newStates);
}
