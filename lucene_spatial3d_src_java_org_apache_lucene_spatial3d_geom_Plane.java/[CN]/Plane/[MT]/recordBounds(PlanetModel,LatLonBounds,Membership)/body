{
  final double A=this.x;
  final double B=this.y;
  final double C=this.z;
  if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {
    if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {
      final Plane verticalPlane=constructNormalizedZPlane(A,B);
      final GeoPoint[] points=findIntersections(planetModel,verticalPlane,bounds,NO_BOUNDS);
      for (      final GeoPoint point : points) {
        addPoint(boundsInfo,bounds,point);
      }
    }
 else {
      final GeoPoint[] points=findIntersections(planetModel,normalXPlane,NO_BOUNDS,NO_BOUNDS);
      boundsInfo.addZValue(points[0]);
    }
  }
  if (!boundsInfo.checkNoLongitudeBound()) {
    double a;
    double b;
    double c;
    if (Math.abs(C) < MINIMUM_RESOLUTION) {
      if (Math.abs(D) >= MINIMUM_RESOLUTION) {
        if (Math.abs(A) > Math.abs(B)) {
          a=B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;
          b=2.0 * B * D* planetModel.inverseAbSquared;
          c=D * D * planetModel.inverseAbSquared - A * A;
          double sqrtClause=b * b - 4.0 * a * c;
          if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {
            double y0=-b / (2.0 * a);
            double x0=(-D - B * y0) / A;
            double z0=0.0;
            addPoint(boundsInfo,bounds,new GeoPoint(x0,y0,z0));
          }
 else           if (sqrtClause > 0.0) {
            double sqrtResult=Math.sqrt(sqrtClause);
            double denom=1.0 / (2.0 * a);
            double Hdenom=1.0 / A;
            double y0a=(-b + sqrtResult) * denom;
            double y0b=(-b - sqrtResult) * denom;
            double x0a=(-D - B * y0a) * Hdenom;
            double x0b=(-D - B * y0b) * Hdenom;
            double z0a=0.0;
            double z0b=0.0;
            addPoint(boundsInfo,bounds,new GeoPoint(x0a,y0a,z0a));
            addPoint(boundsInfo,bounds,new GeoPoint(x0b,y0b,z0b));
          }
        }
 else {
          a=B * B * planetModel.inverseAbSquared + A * A * planetModel.inverseAbSquared;
          b=2.0 * A * D* planetModel.inverseAbSquared;
          c=D * D * planetModel.inverseAbSquared - B * B;
          double sqrtClause=b * b - 4.0 * a * c;
          if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {
            double x0=-b / (2.0 * a);
            double y0=(-D - A * x0) / B;
            double z0=0.0;
            addPoint(boundsInfo,bounds,new GeoPoint(x0,y0,z0));
          }
 else           if (sqrtClause > 0.0) {
            double sqrtResult=Math.sqrt(sqrtClause);
            double denom=1.0 / (2.0 * a);
            double Idenom=1.0 / B;
            double x0a=(-b + sqrtResult) * denom;
            double x0b=(-b - sqrtResult) * denom;
            double y0a=(-D - A * x0a) * Idenom;
            double y0b=(-D - A * x0b) * Idenom;
            double z0a=0.0;
            double z0b=0.0;
            addPoint(boundsInfo,bounds,new GeoPoint(x0a,y0a,z0a));
            addPoint(boundsInfo,bounds,new GeoPoint(x0b,y0b,z0b));
          }
        }
      }
    }
 else {
      double E=A * A * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;
      double F=B * B * planetModel.inverseCSquared + C * C * planetModel.inverseAbSquared;
      double G=2.0 * A * B* planetModel.inverseCSquared;
      double H=2.0 * A * D* planetModel.inverseCSquared;
      double I=2.0 * B * D* planetModel.inverseCSquared;
      double J=D * D * planetModel.inverseCSquared - C * C;
      if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {
        if (Math.abs(H) > Math.abs(I)) {
          a=E * I * I - G * H * I + F * H * H;
          b=4.0 * E * I* J - 2.0 * G * H* J;
          c=4.0 * E * J* J - J * H * H;
          double sqrtClause=b * b - 4.0 * a * c;
          if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {
            double y0=-b / (2.0 * a);
            double x0=(-2.0 * J - I * y0) / H;
            double z0=(-A * x0 - B * y0 - D) / C;
            addPoint(boundsInfo,bounds,new GeoPoint(x0,y0,z0));
          }
 else           if (sqrtClause > 0.0) {
            double sqrtResult=Math.sqrt(sqrtClause);
            double denom=1.0 / (2.0 * a);
            double Hdenom=1.0 / H;
            double Cdenom=1.0 / C;
            double y0a=(-b + sqrtResult) * denom;
            double y0b=(-b - sqrtResult) * denom;
            double x0a=(-2.0 * J - I * y0a) * Hdenom;
            double x0b=(-2.0 * J - I * y0b) * Hdenom;
            double z0a=(-A * x0a - B * y0a - D) * Cdenom;
            double z0b=(-A * x0b - B * y0b - D) * Cdenom;
            addPoint(boundsInfo,bounds,new GeoPoint(x0a,y0a,z0a));
            addPoint(boundsInfo,bounds,new GeoPoint(x0b,y0b,z0b));
          }
        }
 else {
          a=E * I * I - G * H * I + F * H * H;
          b=4.0 * F * H* J - 2.0 * G * I* J;
          c=4.0 * F * J* J - J * I * I;
          double sqrtClause=b * b - 4.0 * a * c;
          if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_CUBED) {
            double x0=-b / (2.0 * a);
            double y0=(-2.0 * J - H * x0) / I;
            double z0=(-A * x0 - B * y0 - D) / C;
            addPoint(boundsInfo,bounds,new GeoPoint(x0,y0,z0));
          }
 else           if (sqrtClause > 0.0) {
            double sqrtResult=Math.sqrt(sqrtClause);
            double denom=1.0 / (2.0 * a);
            double Idenom=1.0 / I;
            double Cdenom=1.0 / C;
            double x0a=(-b + sqrtResult) * denom;
            double x0b=(-b - sqrtResult) * denom;
            double y0a=(-2.0 * J - H * x0a) * Idenom;
            double y0b=(-2.0 * J - H * x0b) * Idenom;
            double z0a=(-A * x0a - B * y0a - D) * Cdenom;
            double z0b=(-A * x0b - B * y0b - D) * Cdenom;
            addPoint(boundsInfo,bounds,new GeoPoint(x0a,y0a,z0a));
            addPoint(boundsInfo,bounds,new GeoPoint(x0b,y0b,z0b));
          }
        }
      }
    }
  }
}
