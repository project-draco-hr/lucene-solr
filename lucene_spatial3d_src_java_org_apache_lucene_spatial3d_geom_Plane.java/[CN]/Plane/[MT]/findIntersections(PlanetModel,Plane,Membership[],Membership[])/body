{
  final Vector lineVector=new Vector(y * q.z - z * q.y,z * q.x - x * q.z,x * q.y - y * q.x);
  if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {
    return NO_POINTS;
  }
  double x0;
  double y0;
  double z0;
  final double denomYZ=this.y * q.z - this.z * q.y;
  final double denomXZ=this.x * q.z - this.z * q.x;
  final double denomXY=this.x * q.y - this.y * q.x;
  if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {
    if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {
      return NO_POINTS;
    }
    final double denom=1.0 / denomYZ;
    x0=0.0;
    y0=(-this.D * q.z - this.z * -q.D) * denom;
    z0=(this.y * -q.D + this.D * q.y) * denom;
  }
 else   if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {
    if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {
      return NO_POINTS;
    }
    final double denom=1.0 / denomXZ;
    x0=(-this.D * q.z - this.z * -q.D) * denom;
    y0=0.0;
    z0=(this.x * -q.D + this.D * q.x) * denom;
  }
 else {
    if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {
      return NO_POINTS;
    }
    final double denom=1.0 / denomXY;
    x0=(-this.D * q.y - this.y * -q.D) * denom;
    y0=(this.x * -q.D + this.D * q.x) * denom;
    z0=0.0;
  }
  final double A=lineVector.x * lineVector.x * planetModel.inverseAbSquared + lineVector.y * lineVector.y * planetModel.inverseAbSquared + lineVector.z * lineVector.z * planetModel.inverseCSquared;
  final double B=2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);
  final double C=x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;
  final double BsquaredMinus=B * B - 4.0 * A * C;
  if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {
    final double inverse2A=1.0 / (2.0 * A);
    final double t=-B * inverse2A;
    final double pointX=lineVector.x * t + x0;
    final double pointY=lineVector.y * t + y0;
    final double pointZ=lineVector.z * t + z0;
    for (    final Membership bound : bounds) {
      if (!bound.isWithin(pointX,pointY,pointZ)) {
        return NO_POINTS;
      }
    }
    for (    final Membership bound : moreBounds) {
      if (!bound.isWithin(pointX,pointY,pointZ)) {
        return NO_POINTS;
      }
    }
    return new GeoPoint[]{new GeoPoint(pointX,pointY,pointZ)};
  }
 else   if (BsquaredMinus > 0.0) {
    final double inverse2A=1.0 / (2.0 * A);
    final double sqrtTerm=Math.sqrt(BsquaredMinus);
    final double t1=(-B + sqrtTerm) * inverse2A;
    final double t2=(-B - sqrtTerm) * inverse2A;
    final double point1X=lineVector.x * t1 + x0;
    final double point1Y=lineVector.y * t1 + y0;
    final double point1Z=lineVector.z * t1 + z0;
    final double point2X=lineVector.x * t2 + x0;
    final double point2Y=lineVector.y * t2 + y0;
    final double point2Z=lineVector.z * t2 + z0;
    boolean point1Valid=true;
    boolean point2Valid=true;
    for (    final Membership bound : bounds) {
      if (!bound.isWithin(point1X,point1Y,point1Z)) {
        point1Valid=false;
        break;
      }
    }
    if (point1Valid) {
      for (      final Membership bound : moreBounds) {
        if (!bound.isWithin(point1X,point1Y,point1Z)) {
          point1Valid=false;
          break;
        }
      }
    }
    for (    final Membership bound : bounds) {
      if (!bound.isWithin(point2X,point2Y,point2Z)) {
        point2Valid=false;
        break;
      }
    }
    if (point2Valid) {
      for (      final Membership bound : moreBounds) {
        if (!bound.isWithin(point2X,point2Y,point2Z)) {
          point2Valid=false;
          break;
        }
      }
    }
    if (point1Valid && point2Valid) {
      return new GeoPoint[]{new GeoPoint(point1X,point1Y,point1Z),new GeoPoint(point2X,point2Y,point2Z)};
    }
    if (point1Valid) {
      return new GeoPoint[]{new GeoPoint(point1X,point1Y,point1Z)};
    }
    if (point2Valid) {
      return new GeoPoint[]{new GeoPoint(point2X,point2Y,point2Z)};
    }
    return NO_POINTS;
  }
 else {
    return NO_POINTS;
  }
}
