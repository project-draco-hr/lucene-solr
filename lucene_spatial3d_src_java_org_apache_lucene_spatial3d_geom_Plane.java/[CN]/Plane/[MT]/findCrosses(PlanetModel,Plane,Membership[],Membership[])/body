{
  final Vector lineVector=new Vector(y * q.z - z * q.y,z * q.x - x * q.z,x * q.y - y * q.x);
  if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {
    return NO_POINTS;
  }
  double x0;
  double y0;
  double z0;
  final double denomYZ=this.y * q.z - this.z * q.y;
  final double denomXZ=this.x * q.z - this.z * q.x;
  final double denomXY=this.x * q.y - this.y * q.x;
  if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {
    if (Math.abs(denomYZ) < MINIMUM_RESOLUTION_SQUARED) {
      return NO_POINTS;
    }
    final double denom=1.0 / denomYZ;
    x0=0.0;
    y0=(-this.D * q.z - this.z * -q.D) * denom;
    z0=(this.y * -q.D + this.D * q.y) * denom;
  }
 else   if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {
    if (Math.abs(denomXZ) < MINIMUM_RESOLUTION_SQUARED) {
      return NO_POINTS;
    }
    final double denom=1.0 / denomXZ;
    x0=(-this.D * q.z - this.z * -q.D) * denom;
    y0=0.0;
    z0=(this.x * -q.D + this.D * q.x) * denom;
  }
 else {
    if (Math.abs(denomXY) < MINIMUM_RESOLUTION_SQUARED) {
      return NO_POINTS;
    }
    final double denom=1.0 / denomXY;
    x0=(-this.D * q.y - this.y * -q.D) * denom;
    y0=(this.x * -q.D + this.D * q.x) * denom;
    z0=0.0;
  }
  final double A=lineVector.x * lineVector.x * planetModel.inverseAbSquared + lineVector.y * lineVector.y * planetModel.inverseAbSquared + lineVector.z * lineVector.z * planetModel.inverseCSquared;
  final double B=2.0 * (lineVector.x * x0 * planetModel.inverseAbSquared + lineVector.y * y0 * planetModel.inverseAbSquared + lineVector.z * z0 * planetModel.inverseCSquared);
  final double C=x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;
  final double BsquaredMinus=B * B - 4.0 * A * C;
  if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {
    return NO_POINTS;
  }
 else   if (BsquaredMinus > 0.0) {
    final double inverse2A=1.0 / (2.0 * A);
    final double sqrtTerm=Math.sqrt(BsquaredMinus);
    final double t1=(-B + sqrtTerm) * inverse2A;
    final double t2=(-B - sqrtTerm) * inverse2A;
    GeoPoint point1=new GeoPoint(lineVector.x * t1 + x0,lineVector.y * t1 + y0,lineVector.z * t1 + z0);
    GeoPoint point2=new GeoPoint(lineVector.x * t2 + x0,lineVector.y * t2 + y0,lineVector.z * t2 + z0);
    if (point1.isWithin(bounds,moreBounds)) {
      if (point2.isWithin(bounds,moreBounds))       return new GeoPoint[]{point1,point2};
      return new GeoPoint[]{point1};
    }
    if (point2.isWithin(bounds,moreBounds))     return new GeoPoint[]{point2};
    return NO_POINTS;
  }
 else {
    return NO_POINTS;
  }
}
