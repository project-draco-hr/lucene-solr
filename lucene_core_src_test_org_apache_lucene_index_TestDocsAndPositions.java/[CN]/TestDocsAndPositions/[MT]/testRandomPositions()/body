{
  Directory dir=newDirectory();
  RandomIndexWriter writer=new RandomIndexWriter(random(),dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
  int numDocs=atLeast(47);
  int max=1051;
  int term=random().nextInt(max);
  Integer[][] positionsInDoc=new Integer[numDocs][];
  FieldType customType=new FieldType(TextField.TYPE_UNSTORED);
  customType.setOmitNorms(true);
  for (int i=0; i < numDocs; i++) {
    Document doc=new Document();
    ArrayList<Integer> positions=new ArrayList<Integer>();
    StringBuilder builder=new StringBuilder();
    int num=atLeast(131);
    for (int j=0; j < num; j++) {
      int nextInt=random().nextInt(max);
      builder.append(nextInt).append(" ");
      if (nextInt == term) {
        positions.add(Integer.valueOf(j));
      }
    }
    if (positions.size() == 0) {
      builder.append(term);
      positions.add(num);
    }
    doc.add(newField(fieldName,builder.toString(),customType));
    positionsInDoc[i]=positions.toArray(new Integer[0]);
    writer.addDocument(doc);
  }
  IndexReader reader=writer.getReader();
  writer.close();
  int num=atLeast(13);
  for (int i=0; i < num; i++) {
    BytesRef bytes=new BytesRef("" + term);
    IndexReaderContext topReaderContext=reader.getTopReaderContext();
    AtomicReaderContext[] leaves=topReaderContext.leaves();
    for (    AtomicReaderContext atomicReaderContext : leaves) {
      DocsAndPositionsEnum docsAndPosEnum=getDocsAndPositions(atomicReaderContext.reader(),bytes,null);
      assertNotNull(docsAndPosEnum);
      int initDoc=0;
      int maxDoc=atomicReaderContext.reader().maxDoc();
      if (random().nextBoolean()) {
        initDoc=docsAndPosEnum.nextDoc();
      }
 else {
        initDoc=docsAndPosEnum.advance(random().nextInt(maxDoc));
      }
      do {
        int docID=docsAndPosEnum.docID();
        if (docID == DocIdSetIterator.NO_MORE_DOCS) {
          break;
        }
        Integer[] pos=positionsInDoc[atomicReaderContext.docBase + docID];
        assertEquals(pos.length,docsAndPosEnum.freq());
        final int howMany=random().nextInt(20) == 0 ? pos.length - random().nextInt(pos.length) : pos.length;
        for (int j=0; j < howMany; j++) {
          assertEquals("iteration: " + i + " initDoc: "+ initDoc+ " doc: "+ docID+ " base: "+ atomicReaderContext.docBase+ " positions: "+ Arrays.toString(pos),pos[j].intValue(),docsAndPosEnum.nextPosition());
        }
        if (random().nextInt(10) == 0) {
          docsAndPosEnum.advance(docID + 1 + random().nextInt((maxDoc - docID)));
        }
      }
 while (docsAndPosEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
    }
  }
  reader.close();
  dir.close();
}
