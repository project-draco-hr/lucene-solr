{
  verifyParams(numDims,maxPointsInLeafNode,maxMBSortInHeap,totalPointCount);
  this.tempDir=new TrackingDirectoryWrapper(tempDir);
  this.tempFileNamePrefix=tempFileNamePrefix;
  this.maxPointsInLeafNode=maxPointsInLeafNode;
  this.numDims=numDims;
  this.bytesPerDim=bytesPerDim;
  this.totalPointCount=totalPointCount;
  docsSeen=new FixedBitSet(maxDoc);
  packedBytesLength=numDims * bytesPerDim;
  scratchDiff=new byte[bytesPerDim];
  scratchPackedValue=new byte[packedBytesLength];
  scratch1=new byte[packedBytesLength];
  scratch2=new byte[packedBytesLength];
  commonPrefixLengths=new int[numDims];
  minPackedValue=new byte[packedBytesLength];
  maxPackedValue=new byte[packedBytesLength];
  longOrds=totalPointCount > Integer.MAX_VALUE;
  if (longOrds) {
    bytesPerDoc=packedBytesLength + Long.BYTES + Integer.BYTES;
  }
 else {
    bytesPerDoc=packedBytesLength + Integer.BYTES + Integer.BYTES;
  }
  maxPointsSortInHeap=(int)(0.5 * (maxMBSortInHeap * 1024 * 1024) / (bytesPerDoc * numDims));
  if (maxPointsSortInHeap < maxPointsInLeafNode) {
    throw new IllegalArgumentException("maxMBSortInHeap=" + maxMBSortInHeap + " only allows for maxPointsSortInHeap="+ maxPointsSortInHeap+ ", but this is less than maxPointsInLeafNode="+ maxPointsInLeafNode+ "; either increase maxMBSortInHeap or decrease maxPointsInLeafNode");
  }
  heapPointWriter=new HeapPointWriter(16,maxPointsSortInHeap,packedBytesLength,longOrds);
  this.maxMBSortInHeap=maxMBSortInHeap;
}
