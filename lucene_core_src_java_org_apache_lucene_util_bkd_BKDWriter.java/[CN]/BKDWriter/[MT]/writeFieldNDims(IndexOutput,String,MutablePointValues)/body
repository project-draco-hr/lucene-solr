{
  if (pointCount != 0) {
    throw new IllegalStateException("cannot mix add and writeField");
  }
  if (heapPointWriter == null && tempInput == null) {
    throw new IllegalStateException("already finished");
  }
  heapPointWriter=null;
  long countPerLeaf=pointCount=values.size();
  long innerNodeCount=1;
  while (countPerLeaf > maxPointsInLeafNode) {
    countPerLeaf=(countPerLeaf + 1) / 2;
    innerNodeCount*=2;
  }
  int numLeaves=Math.toIntExact(innerNodeCount);
  checkMaxLeafNodeCount(numLeaves);
  final byte[] splitPackedValues=new byte[numLeaves * (bytesPerDim + 1)];
  final long[] leafBlockFPs=new long[numLeaves];
  Arrays.fill(minPackedValue,(byte)0xff);
  Arrays.fill(maxPackedValue,(byte)0);
  for (int i=0; i < Math.toIntExact(pointCount); ++i) {
    values.getValue(i,scratchBytesRef1);
    for (int dim=0; dim < numDims; dim++) {
      int offset=dim * bytesPerDim;
      if (StringHelper.compare(bytesPerDim,scratchBytesRef1.bytes,scratchBytesRef1.offset + offset,minPackedValue,offset) < 0) {
        System.arraycopy(scratchBytesRef1.bytes,scratchBytesRef1.offset + offset,minPackedValue,offset,bytesPerDim);
      }
      if (StringHelper.compare(bytesPerDim,scratchBytesRef1.bytes,scratchBytesRef1.offset + offset,maxPackedValue,offset) > 0) {
        System.arraycopy(scratchBytesRef1.bytes,scratchBytesRef1.offset + offset,maxPackedValue,offset,bytesPerDim);
      }
    }
    docsSeen.set(values.getDocID(i));
  }
  build(1,numLeaves,values,0,Math.toIntExact(pointCount),out,minPackedValue,maxPackedValue,splitPackedValues,leafBlockFPs,new int[maxPointsInLeafNode]);
  long indexFP=out.getFilePointer();
  writeIndex(out,leafBlockFPs,splitPackedValues);
  return indexFP;
}
