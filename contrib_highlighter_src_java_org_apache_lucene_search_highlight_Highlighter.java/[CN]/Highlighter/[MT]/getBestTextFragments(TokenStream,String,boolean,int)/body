{
  ArrayList docFrags=new ArrayList();
  StringBuffer newText=new StringBuffer();
  TextFragment currentFrag=new TextFragment(newText,newText.length(),docFrags.size());
  fragmentScorer.startFragment(currentFrag);
  docFrags.add(currentFrag);
  FragmentQueue fragQueue=new FragmentQueue(maxNumFragments);
  try {
    org.apache.lucene.analysis.Token token;
    String tokenText;
    int startOffset;
    int endOffset;
    int lastEndOffset=0;
    textFragmenter.start(text);
    TokenGroup tokenGroup=new TokenGroup();
    while ((token=tokenStream.next()) != null) {
      if ((tokenGroup.numTokens > 0) && (tokenGroup.isDistinct(token))) {
        startOffset=tokenGroup.startOffset;
        endOffset=tokenGroup.endOffset;
        tokenText=text.substring(startOffset,endOffset);
        String markedUpText=formatter.highlightTerm(tokenText,tokenGroup);
        if (startOffset > lastEndOffset)         newText.append(text.substring(lastEndOffset,startOffset));
        newText.append(markedUpText);
        lastEndOffset=endOffset;
        tokenGroup.clear();
        if (textFragmenter.isNewFragment(token)) {
          currentFrag.setScore(fragmentScorer.getFragmentScore());
          currentFrag.textEndPos=newText.length();
          currentFrag=new TextFragment(newText,newText.length(),docFrags.size());
          fragmentScorer.startFragment(currentFrag);
          docFrags.add(currentFrag);
        }
      }
      tokenGroup.addToken(token,fragmentScorer.getTokenScore(token));
      if (lastEndOffset > maxDocBytesToAnalyze) {
        break;
      }
    }
    currentFrag.setScore(fragmentScorer.getFragmentScore());
    if (tokenGroup.numTokens > 0) {
      startOffset=tokenGroup.startOffset;
      endOffset=tokenGroup.endOffset;
      tokenText=text.substring(startOffset,endOffset);
      String markedUpText=formatter.highlightTerm(tokenText,tokenGroup);
      if (startOffset > lastEndOffset)       newText.append(text.substring(lastEndOffset,startOffset));
      newText.append(markedUpText);
      lastEndOffset=endOffset;
    }
    if (lastEndOffset < text.length())     newText.append(text.substring(lastEndOffset));
    currentFrag.textEndPos=newText.length();
    int minScore=0;
    for (Iterator i=docFrags.iterator(); i.hasNext(); ) {
      currentFrag=(TextFragment)i.next();
      fragQueue.insert(currentFrag);
    }
    TextFragment frag[]=new TextFragment[fragQueue.size()];
    for (int i=frag.length - 1; i >= 0; i--) {
      frag[i]=(TextFragment)fragQueue.pop();
    }
    if (mergeContiguousFragments) {
      mergeContiguousFragments(frag);
      ArrayList fragTexts=new ArrayList();
      for (int i=0; i < frag.length; i++) {
        if ((frag[i] != null) && (frag[i].getScore() > 0)) {
          fragTexts.add(frag[i]);
        }
      }
      frag=(TextFragment[])fragTexts.toArray(new TextFragment[0]);
    }
    return frag;
  }
  finally {
    if (tokenStream != null) {
      try {
        tokenStream.close();
      }
 catch (      Exception e) {
      }
    }
  }
}
