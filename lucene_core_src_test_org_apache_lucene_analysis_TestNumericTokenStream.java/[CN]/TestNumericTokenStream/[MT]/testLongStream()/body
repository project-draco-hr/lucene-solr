{
  @SuppressWarnings("resource") final NumericTokenStream stream=new NumericTokenStream().setLongValue(lvalue);
  final TermToBytesRefAttribute bytesAtt=stream.getAttribute(TermToBytesRefAttribute.class);
  assertNotNull(bytesAtt);
  final TypeAttribute typeAtt=stream.getAttribute(TypeAttribute.class);
  assertNotNull(typeAtt);
  final NumericTokenStream.NumericTermAttribute numericAtt=stream.getAttribute(NumericTokenStream.NumericTermAttribute.class);
  assertNotNull(numericAtt);
  final BytesRef bytes=bytesAtt.getBytesRef();
  stream.reset();
  assertEquals(64,numericAtt.getValueSize());
  for (int shift=0; shift < 64; shift+=NumericUtils.PRECISION_STEP_DEFAULT) {
    assertTrue("New token is available",stream.incrementToken());
    assertEquals("Shift value wrong",shift,numericAtt.getShift());
    bytesAtt.fillBytesRef();
    assertEquals("Term is incorrectly encoded",lvalue & ~((1L << shift) - 1L),NumericUtils.prefixCodedToLong(bytes));
    assertEquals("Term raw value is incorrectly encoded",lvalue & ~((1L << shift) - 1L),numericAtt.getRawValue());
    assertEquals("Type incorrect",(shift == 0) ? NumericTokenStream.TOKEN_TYPE_FULL_PREC : NumericTokenStream.TOKEN_TYPE_LOWER_PREC,typeAtt.type());
  }
  assertFalse("More tokens available",stream.incrementToken());
  stream.end();
  stream.close();
}
