{
  Directory store=newDirectory();
  IndexWriter writer=new IndexWriter(store,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)));
  Fieldable f1=newField("field","word",Field.Store.YES,Field.Index.ANALYZED);
  Document d1=new Document();
  d1.add(f1);
  writer.addDocument(d1);
  writer.addDocument(d1);
  writer.addDocument(d1);
  writer.addDocument(d1);
  writer.close();
  IndexReader reader=IndexReader.open(store,false);
  Similarity similarity=new DefaultSimilarity();
  reader.setNorm(0,"field",similarity.encodeNormValue(1.0f));
  reader.setNorm(1,"field",similarity.encodeNormValue(2.0f));
  reader.setNorm(2,"field",similarity.encodeNormValue(4.0f));
  reader.setNorm(3,"field",similarity.encodeNormValue(16.0f));
  reader.close();
  final float[] scores=new float[4];
  IndexSearcher is=new IndexSearcher(store,true);
  is.search(new TermQuery(new Term("field","word")),new Collector(){
    private int base=0;
    private Scorer scorer;
    @Override public void setScorer(    Scorer scorer) throws IOException {
      this.scorer=scorer;
    }
    @Override public final void collect(    int doc) throws IOException {
      scores[doc + base]=scorer.score();
    }
    @Override public void setNextReader(    AtomicReaderContext context){
      base=context.docBase;
    }
    @Override public boolean acceptsDocsOutOfOrder(){
      return true;
    }
  }
);
  is.close();
  float lastScore=0.0f;
  for (int i=0; i < 4; i++) {
    assertTrue(scores[i] > lastScore);
    lastScore=scores[i];
  }
  store.close();
}
