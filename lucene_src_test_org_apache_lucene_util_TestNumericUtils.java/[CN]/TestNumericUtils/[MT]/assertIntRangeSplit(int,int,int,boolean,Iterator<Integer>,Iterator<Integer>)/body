{
  final OpenBitSet bits=useBitSet ? new OpenBitSet(upper - lower + 1) : null;
  NumericUtils.splitIntRange(new NumericUtils.IntRangeBuilder(){
    @Override public void addRange(    int min,    int max,    int shift){
      assertTrue("min, max should be inside bounds",min >= lower && min <= upper && max >= lower && max <= upper);
      if (useBitSet)       for (int i=min; i <= max; i++) {
        assertFalse("ranges should not overlap",bits.getAndSet(i - lower));
        if (i == max)         break;
      }
      if (neededBounds == null)       return;
      min^=0x80000000;
      max^=0x80000000;
      assertEquals("shift",neededShifts.next().intValue(),shift);
      assertEquals("inner min bound",neededBounds.next().intValue(),min >>> shift);
      assertEquals("inner max bound",neededBounds.next().intValue(),max >>> shift);
    }
  }
,precisionStep,lower,upper);
  if (useBitSet) {
    bits.flip(0,upper - lower + 1);
    assertTrue("The sub-range concenated should match the whole range",bits.isEmpty());
  }
}
