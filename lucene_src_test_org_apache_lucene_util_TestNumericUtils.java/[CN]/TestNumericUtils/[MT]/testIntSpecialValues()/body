{
  int[] vals=new int[]{Integer.MIN_VALUE,Integer.MIN_VALUE + 1,Integer.MIN_VALUE + 2,-64765767,-4000,-3000,-2000,-1000,-1,0,1,10,300,765878989,Integer.MAX_VALUE - 2,Integer.MAX_VALUE - 1,Integer.MAX_VALUE};
  BytesRef[] prefixVals=new BytesRef[vals.length];
  for (int i=0; i < vals.length; i++) {
    prefixVals[i]=new BytesRef(NumericUtils.BUF_SIZE_INT);
    NumericUtils.intToPrefixCoded(vals[i],0,prefixVals[i]);
    assertEquals("forward and back conversion should generate same int",vals[i],NumericUtils.prefixCodedToInt(prefixVals[i]));
    try {
      NumericUtils.prefixCodedToLong(prefixVals[i]);
      fail("decoding a prefix coded int value as long should fail");
    }
 catch (    NumberFormatException e) {
    }
  }
  for (int i=1; i < prefixVals.length; i++) {
    assertTrue("check sort order",prefixVals[i - 1].compareTo(prefixVals[i]) < 0);
  }
  final BytesRef ref=new BytesRef(NumericUtils.BUF_SIZE_LONG);
  for (int i=0; i < vals.length; i++) {
    for (int j=0; j < 32; j++) {
      NumericUtils.intToPrefixCoded(vals[i],j,ref);
      int prefixVal=NumericUtils.prefixCodedToInt(ref);
      int mask=(1 << j) - 1;
      assertEquals("difference between prefix val and original value for " + vals[i] + " with shift="+ j,vals[i] & mask,vals[i] - prefixVal);
    }
  }
}
