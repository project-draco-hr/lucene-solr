{
  maybeYield();
  if (crashed)   throw new IOException("cannot createOutput after crash");
  init();
synchronized (this) {
    if (preventDoubleWrite && createdFiles.contains(name) && !name.equals("segments.gen"))     throw new IOException("file \"" + name + "\" was already written to");
  }
  if (noDeleteOpenFile && openFiles.containsKey(name))   throw new IOException("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot overwrite");
  if (crashed)   throw new IOException("cannot createOutput after crash");
  unSyncedFiles.add(name);
  createdFiles.add(name);
  if (delegate instanceof RAMDirectory) {
    RAMDirectory ramdir=(RAMDirectory)delegate;
    RAMFile file=new RAMFile(ramdir);
    RAMFile existing=ramdir.fileMap.get(name);
    if (existing != null && !name.equals("segments.gen") && preventDoubleWrite)     throw new IOException("file " + name + " already exists");
 else {
      if (existing != null) {
        ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);
        existing.directory=null;
      }
      ramdir.fileMap.put(name,file);
    }
  }
  IndexOutput io=new MockIndexOutputWrapper(this,delegate.createOutput(name),name);
  openFileHandles.put(io,new RuntimeException("unclosed IndexOutput"));
  openFilesForWrite.add(name);
  return throttledOutput == null ? io : throttledOutput.newFromDelegate(io);
}
