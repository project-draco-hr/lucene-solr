{
  maybeYield();
  if (crashed)   throw new IOException("cannot createOutput after crash");
  init();
synchronized (this) {
    if (preventDoubleWrite && createdFiles.contains(name) && !name.equals("segments.gen"))     throw new IOException("file \"" + name + "\" was already written to");
  }
  if (noDeleteOpenFile && openFiles.containsKey(name))   throw new IOException("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot overwrite");
  if (crashed)   throw new IOException("cannot createOutput after crash");
  unSyncedFiles.add(name);
  createdFiles.add(name);
  if (delegate instanceof RAMDirectory) {
    RAMDirectory ramdir=(RAMDirectory)delegate;
    RAMFile file=new RAMFile(ramdir);
    RAMFile existing=ramdir.fileMap.get(name);
    if (existing != null && !name.equals("segments.gen") && preventDoubleWrite)     throw new IOException("file " + name + " already exists");
 else {
      if (existing != null) {
        ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);
        existing.directory=null;
      }
      ramdir.fileMap.put(name,file);
    }
  }
  IndexOutput io=new MockIndexOutputWrapper(this,delegate.createOutput(name,LuceneTestCase.newIOContext(randomState)),name);
  addFileHandle(io,name,false);
  openFilesForWrite.add(name);
  if (throttling == Throttling.ALWAYS || (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0)) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockDirectoryWrapper: throttling indexOutput");
    }
    return throttledOutput.newFromDelegate(io);
  }
 else {
    return io;
  }
}
