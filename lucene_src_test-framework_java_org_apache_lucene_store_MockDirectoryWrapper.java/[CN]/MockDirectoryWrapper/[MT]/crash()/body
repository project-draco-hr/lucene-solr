{
  crashed=true;
  openFiles=new HashMap<String,Integer>();
  openFilesForWrite=new HashSet<String>();
  openFilesDeleted=new HashSet<String>();
  Iterator<String> it=unSyncedFiles.iterator();
  unSyncedFiles=new HashSet<String>();
  Map<Closeable,Exception> m=new IdentityHashMap<Closeable,Exception>(openFileHandles);
  for (  Closeable f : m.keySet())   try {
    f.close();
  }
 catch (  Exception ignored) {
  }
  while (it.hasNext()) {
    String name=it.next();
    int damage=randomState.nextInt(5);
    String action=null;
    if (damage == 0) {
      action="deleted";
      deleteFile(name,true);
    }
 else     if (damage == 1) {
      action="zeroed";
      long length=fileLength(name);
      byte[] zeroes=new byte[256];
      long upto=0;
      IndexOutput out=delegate.createOutput(name,LuceneTestCase.newIOContext(randomState));
      while (upto < length) {
        final int limit=(int)Math.min(length - upto,zeroes.length);
        out.writeBytes(zeroes,0,limit);
        upto+=limit;
      }
      out.close();
    }
 else     if (damage == 2) {
      action="partially truncated";
      IndexOutput out=delegate.createOutput(name,LuceneTestCase.newIOContext(randomState));
      out.setLength(fileLength(name) / 2);
      out.close();
    }
 else     if (damage == 3) {
      action="didn't change";
    }
 else {
      action="fully truncated";
      deleteFile(name,true);
      IndexOutput out=delegate.createOutput(name,LuceneTestCase.newIOContext(randomState));
      out.setLength(0);
      out.close();
    }
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockDirectoryWrapper: " + action + " unsynced file: "+ name);
    }
  }
}
