{
  maybeYield();
  if (openFiles == null) {
    openFiles=new HashMap<String,Integer>();
    openFilesDeleted=new HashSet<String>();
  }
  if (noDeleteOpenFile && openFiles.size() > 0) {
    Exception cause=null;
    Iterator<Exception> stacktraces=openFileHandles.values().iterator();
    if (stacktraces.hasNext())     cause=stacktraces.next();
    throw new RuntimeException("MockDirectoryWrapper: cannot close: there are still open files: " + openFiles,cause);
  }
  if (noDeleteOpenFile && openLocks.size() > 0) {
    throw new RuntimeException("MockDirectoryWrapper: cannot close: there are still open locks: " + openLocks);
  }
  open=false;
  if (checkIndexOnClose) {
    if (IndexReader.indexExists(this)) {
      if (LuceneTestCase.VERBOSE) {
        System.out.println("\nNOTE: MockDirectoryWrapper: now crash");
      }
      unSyncedFiles.remove("segments.gen");
      crash();
      if (LuceneTestCase.VERBOSE) {
        System.out.println("\nNOTE: MockDirectoryWrapper: now run CheckIndex");
      }
      _TestUtil.checkIndex(this);
    }
  }
  delegate.close();
}
