{
  ANALYZER=new MockAnalyzer(random());
  qp=new StandardQueryParser(ANALYZER);
  final HashMap<String,Number> randomNumberMap=new HashMap<>();
  SimpleDateFormat dateFormat;
  long randomDate;
  boolean dateFormatSanityCheckPass;
  int count=0;
  do {
    if (count > 100) {
      fail("This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.");
    }
    dateFormatSanityCheckPass=true;
    LOCALE=randomLocale(random());
    TIMEZONE=randomTimeZone(random());
    DATE_STYLE=randomDateStyle(random());
    TIME_STYLE=randomDateStyle(random());
    dateFormat=(SimpleDateFormat)DateFormat.getDateTimeInstance(DATE_STYLE,TIME_STYLE,LOCALE);
    dateFormat.applyPattern(dateFormat.toPattern() + " G s Z yyyy");
    dateFormat.setTimeZone(TIMEZONE);
    DATE_FORMAT=new NumberDateFormat(dateFormat);
    do {
      randomDate=random().nextLong();
      randomDate=randomDate % 3400000000000l;
      randomDate=(randomDate / 1000L) * 1000L;
      randomDate=Math.abs(randomDate);
    }
 while (randomDate == 0L);
    dateFormatSanityCheckPass&=checkDateFormatSanity(dateFormat,randomDate);
    dateFormatSanityCheckPass&=checkDateFormatSanity(dateFormat,0);
    dateFormatSanityCheckPass&=checkDateFormatSanity(dateFormat,-randomDate);
    count++;
  }
 while (!dateFormatSanityCheckPass);
  NUMBER_FORMAT=NumberFormat.getNumberInstance(LOCALE);
  NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);
  NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);
  NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);
  NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);
  double randomDouble;
  long randomLong;
  int randomInt;
  float randomFloat;
  while ((randomLong=normalizeNumber(Math.abs(random().nextLong())).longValue()) == 0L)   ;
  while ((randomDouble=normalizeNumber(Math.abs(random().nextDouble())).doubleValue()) == 0.0)   ;
  while ((randomFloat=normalizeNumber(Math.abs(random().nextFloat())).floatValue()) == 0.0f)   ;
  while ((randomInt=normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)   ;
  randomNumberMap.put(LegacyNumericType.LONG.name(),randomLong);
  randomNumberMap.put(FieldType.LegacyNumericType.INT.name(),randomInt);
  randomNumberMap.put(LegacyNumericType.FLOAT.name(),randomFloat);
  randomNumberMap.put(LegacyNumericType.DOUBLE.name(),randomDouble);
  randomNumberMap.put(DATE_FIELD_NAME,randomDate);
  RANDOM_NUMBER_MAP=Collections.unmodifiableMap(randomNumberMap);
  directory=newDirectory();
  RandomIndexWriter writer=new RandomIndexWriter(random(),directory,newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(random(),50,1000)).setMergePolicy(newLogMergePolicy()));
  Document doc=new Document();
  HashMap<String,NumericConfig> numericConfigMap=new HashMap<>();
  HashMap<String,Field> numericFieldMap=new HashMap<>();
  qp.setNumericConfigMap(numericConfigMap);
  for (  LegacyNumericType type : LegacyNumericType.values()) {
    numericConfigMap.put(type.name(),new NumericConfig(PRECISION_STEP,NUMBER_FORMAT,type));
    FieldType ft=new FieldType(LegacyIntField.TYPE_NOT_STORED);
    ft.setNumericType(type);
    ft.setStored(true);
    ft.setNumericPrecisionStep(PRECISION_STEP);
    ft.freeze();
    final Field field;
switch (type) {
case INT:
      field=new LegacyIntField(type.name(),0,ft);
    break;
case FLOAT:
  field=new LegacyFloatField(type.name(),0.0f,ft);
break;
case LONG:
field=new LegacyLongField(type.name(),0l,ft);
break;
case DOUBLE:
field=new LegacyDoubleField(type.name(),0.0,ft);
break;
default :
fail();
field=null;
}
numericFieldMap.put(type.name(),field);
doc.add(field);
}
numericConfigMap.put(DATE_FIELD_NAME,new NumericConfig(PRECISION_STEP,DATE_FORMAT,LegacyNumericType.LONG));
FieldType ft=new FieldType(LegacyLongField.TYPE_NOT_STORED);
ft.setStored(true);
ft.setNumericPrecisionStep(PRECISION_STEP);
LegacyLongField dateField=new LegacyLongField(DATE_FIELD_NAME,0l,ft);
numericFieldMap.put(DATE_FIELD_NAME,dateField);
doc.add(dateField);
for (NumberType numberType : NumberType.values()) {
setFieldValues(numberType,numericFieldMap);
if (VERBOSE) System.out.println("Indexing document: " + doc);
writer.addDocument(doc);
}
reader=writer.getReader();
searcher=newSearcher(reader);
writer.close();
}
