{
  for (int i=0; i < indexedShapes.size(); i++) {
    Shape shape=indexedShapes.get(i);
    adoc("" + i,shape);
    if (havoc && random().nextInt(10) == 0)     commit();
  }
  if (havoc) {
    for (int id=0; id < indexedShapes.size(); id++) {
      if (random().nextInt(10) == 0) {
        deleteDoc("" + id);
        indexedShapes.set(id,null);
      }
    }
  }
  commit();
  for (int queryIdx=0; queryIdx < queryShapes.size(); queryIdx++) {
    final Shape queryShape=queryShapes.get(queryIdx);
    if (havoc)     preQueryHavoc();
    Set<String> expectedIds=new LinkedHashSet<>();
    for (int id=0; id < indexedShapes.size(); id++) {
      Shape indexedShape=indexedShapes.get(id);
      if (indexedShape == null)       continue;
      if (operation.evaluate(indexedShape,queryShape)) {
        expectedIds.add("" + id);
      }
    }
    SpatialArgs args=new SpatialArgs(operation,queryShape);
    Query query=strategy.makeQuery(args);
    SearchResults got=executeQuery(query,100);
    Set<String> remainingExpectedIds=new LinkedHashSet<>(expectedIds);
    for (    SearchResult result : got.results) {
      String id=result.getId();
      if (!remainingExpectedIds.remove(id)) {
        fail("Shouldn't match",id,indexedShapes,queryShape,operation);
      }
    }
    if (!remainingExpectedIds.isEmpty()) {
      String id=remainingExpectedIds.iterator().next();
      fail("Should have matched",id,indexedShapes,queryShape,operation);
    }
  }
}
