{
  final NormsEntry entry=norms.get(field.number);
  if (entry.bytesPerValue == 0) {
    final long value=entry.offset;
    return new NormsIterator(maxDoc){
      @Override public long longValue(){
        return value;
      }
    }
;
  }
 else {
    RandomAccessInput slice;
synchronized (data) {
switch (entry.bytesPerValue) {
case 1:
        slice=data.randomAccessSlice(entry.offset,maxDoc);
      return new NormsIterator(maxDoc){
        @Override public long longValue() throws IOException {
          return slice.readByte(docID);
        }
      }
;
case 2:
    slice=data.randomAccessSlice(entry.offset,maxDoc * 2L);
  return new NormsIterator(maxDoc){
    @Override public long longValue() throws IOException {
      return slice.readShort(((long)docID) << 1L);
    }
  }
;
case 4:
slice=data.randomAccessSlice(entry.offset,maxDoc * 4L);
return new NormsIterator(maxDoc){
@Override public long longValue() throws IOException {
  return slice.readInt(((long)docID) << 2L);
}
}
;
case 8:
slice=data.randomAccessSlice(entry.offset,maxDoc * 8L);
return new NormsIterator(maxDoc){
@Override public long longValue() throws IOException {
return slice.readLong(((long)docID) << 3L);
}
}
;
default :
throw new AssertionError();
}
}
}
}
