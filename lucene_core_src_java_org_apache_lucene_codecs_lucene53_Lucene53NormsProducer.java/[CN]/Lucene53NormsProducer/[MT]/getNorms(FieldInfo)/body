{
  final NormsEntry entry=norms.get(field.number);
  if (entry.bytesPerValue == 0) {
    final long value=entry.offset;
    return new NumericDocValues(){
      @Override public long get(      int docID){
        return value;
      }
    }
;
  }
  RandomAccessInput slice;
synchronized (data) {
switch (entry.bytesPerValue) {
case 1:
      slice=data.randomAccessSlice(entry.offset,maxDoc);
    return new NumericDocValues(){
      @Override public long get(      int docID){
        try {
          return slice.readByte(docID);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
;
case 2:
  slice=data.randomAccessSlice(entry.offset,maxDoc * 2L);
return new NumericDocValues(){
  @Override public long get(  int docID){
    try {
      return slice.readShort(((long)docID) << 1L);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}
;
case 4:
slice=data.randomAccessSlice(entry.offset,maxDoc * 4L);
return new NumericDocValues(){
@Override public long get(int docID){
try {
  return slice.readInt(((long)docID) << 2L);
}
 catch (IOException e) {
  throw new RuntimeException(e);
}
}
}
;
case 8:
slice=data.randomAccessSlice(entry.offset,maxDoc * 8L);
return new NumericDocValues(){
@Override public long get(int docID){
try {
return slice.readLong(((long)docID) << 3L);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
}
}
;
default :
throw new AssertionError();
}
}
}
