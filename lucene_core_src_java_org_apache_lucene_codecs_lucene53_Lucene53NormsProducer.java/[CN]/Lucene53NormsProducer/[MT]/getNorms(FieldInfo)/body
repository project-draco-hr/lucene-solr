{
  final NormsEntry entry=norms.get(field.number);
  LegacyNumericDocValues norms;
  if (entry.bytesPerValue == 0) {
    final long value=entry.offset;
    norms=new LegacyNumericDocValues(){
      @Override public long get(      int docID){
        return value;
      }
    }
;
  }
 else {
    RandomAccessInput slice;
synchronized (data) {
switch (entry.bytesPerValue) {
case 1:
        slice=data.randomAccessSlice(entry.offset,maxDoc);
      norms=new LegacyNumericDocValues(){
        @Override public long get(        int docID){
          try {
            return slice.readByte(docID);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
;
    break;
case 2:
  slice=data.randomAccessSlice(entry.offset,maxDoc * 2L);
norms=new LegacyNumericDocValues(){
  @Override public long get(  int docID){
    try {
      return slice.readShort(((long)docID) << 1L);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}
;
break;
case 4:
slice=data.randomAccessSlice(entry.offset,maxDoc * 4L);
norms=new LegacyNumericDocValues(){
@Override public long get(int docID){
try {
return slice.readInt(((long)docID) << 2L);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
}
}
;
break;
case 8:
slice=data.randomAccessSlice(entry.offset,maxDoc * 8L);
norms=new LegacyNumericDocValues(){
@Override public long get(int docID){
try {
return slice.readLong(((long)docID) << 3L);
}
 catch (IOException e) {
throw new RuntimeException(e);
}
}
}
;
break;
default :
throw new AssertionError();
}
}
}
return new LegacyNumericDocValuesWrapper(new Bits.MatchAllBits(maxDoc),norms);
}
