{
  final OpenBitSet bs=bits;
  return new Filter(){
    @Override public DocIdSet getDocIdSet(    final AtomicReaderContext context,    final Bits acceptDocs) throws IOException {
      AtomicReader reader=context.reader();
      final Bits acceptDocs2=acceptDocs == null ? null : (reader.getLiveDocs() == acceptDocs ? null : acceptDocs);
      if (context.isTopLevel) {
        return BitsFilteredDocIdSet.wrap(bs,acceptDocs);
      }
      final int base=context.docBase;
      final int maxDoc=reader.maxDoc();
      final int max=base + maxDoc;
      return BitsFilteredDocIdSet.wrap(new DocIdSet(){
        @Override public DocIdSetIterator iterator() throws IOException {
          return new DocIdSetIterator(){
            int pos=base - 1;
            int adjustedDoc=-1;
            @Override public int docID(){
              return adjustedDoc;
            }
            @Override public int nextDoc() throws IOException {
              pos=bs.nextSetBit(pos + 1);
              return adjustedDoc=(pos >= 0 && pos < max) ? pos - base : NO_MORE_DOCS;
            }
            @Override public int advance(            int target) throws IOException {
              if (target == NO_MORE_DOCS)               return adjustedDoc=NO_MORE_DOCS;
              pos=bs.nextSetBit(target + base);
              return adjustedDoc=(pos >= 0 && pos < max) ? pos - base : NO_MORE_DOCS;
            }
          }
;
        }
        @Override public boolean isCacheable(){
          return true;
        }
        @Override public Bits bits() throws IOException {
          return new Bits(){
            @Override public boolean get(            int index){
              return bs.fastGet(index + base);
            }
            @Override public int length(){
              return maxDoc;
            }
          }
;
        }
      }
,acceptDocs2);
    }
  }
;
}
