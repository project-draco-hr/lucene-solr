{
  queue.clear();
  numTop=0;
  boolean seekOpt=false;
  if (lastSeek != null && termComp.compare(lastSeek,term) <= 0) {
    seekOpt=true;
  }
  lastSeek=null;
  for (int i=0; i < numSubs; i++) {
    final boolean status;
    if (seekOpt) {
      final BytesRef curTerm=currentSubs[i].current;
      if (curTerm != null) {
        final int cmp=termComp.compare(term,curTerm);
        if (cmp == 0) {
          status=true;
        }
 else         if (cmp < 0) {
          status=false;
        }
 else {
          status=currentSubs[i].terms.seekExact(term,useCache);
        }
      }
 else {
        status=false;
      }
    }
 else {
      status=currentSubs[i].terms.seekExact(term,useCache);
    }
    if (status) {
      top[numTop++]=currentSubs[i];
      current=currentSubs[i].current=currentSubs[i].terms.term();
    }
  }
  return numTop > 0;
}
