{
  final MultiDocsAndPositionsEnum docsAndPositionsEnum;
  if (reuse != null) {
    docsAndPositionsEnum=(MultiDocsAndPositionsEnum)reuse;
  }
 else {
    docsAndPositionsEnum=new MultiDocsAndPositionsEnum();
  }
  final MultiBits multiLiveDocs;
  if (liveDocs instanceof MultiBits) {
    multiLiveDocs=(MultiBits)liveDocs;
  }
 else {
    multiLiveDocs=null;
  }
  int upto=0;
  for (int i=0; i < numTop; i++) {
    final TermsEnumWithSlice entry=top[i];
    final Bits b;
    if (multiLiveDocs != null) {
      final MultiBits.SubResult sub=multiLiveDocs.getMatchingSub(top[i].subSlice);
      if (sub.matches) {
        b=sub.result;
      }
 else {
        b=new BitsSlice(liveDocs,top[i].subSlice);
      }
    }
 else     if (liveDocs != null) {
      b=new BitsSlice(liveDocs,top[i].subSlice);
    }
 else {
      b=null;
    }
    final DocsAndPositionsEnum subPostings=entry.terms.docsAndPositions(b,null);
    if (subPostings != null) {
      subDocsAndPositions[upto].docsAndPositionsEnum=subPostings;
      subDocsAndPositions[upto].slice=entry.subSlice;
      upto++;
    }
 else {
      if (entry.terms.docs(b,null) != null) {
        return null;
      }
    }
  }
  if (upto == 0) {
    return null;
  }
 else {
    return docsAndPositionsEnum.reset(subDocsAndPositions,upto);
  }
}
