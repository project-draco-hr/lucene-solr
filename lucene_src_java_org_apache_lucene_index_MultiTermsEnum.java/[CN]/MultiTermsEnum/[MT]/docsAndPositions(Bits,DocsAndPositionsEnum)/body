{
  final MultiDocsAndPositionsEnum docsAndPositionsEnum;
  if (reuse != null) {
    docsAndPositionsEnum=(MultiDocsAndPositionsEnum)reuse;
  }
 else {
    docsAndPositionsEnum=new MultiDocsAndPositionsEnum();
  }
  final MultiBits multiSkipDocs;
  if (skipDocs instanceof MultiBits) {
    multiSkipDocs=(MultiBits)skipDocs;
  }
 else {
    multiSkipDocs=null;
  }
  int upto=0;
  for (int i=0; i < numTop; i++) {
    final TermsEnumWithSlice entry=top[i];
    final Bits b;
    if (multiSkipDocs != null) {
      final MultiBits.SubResult sub=multiSkipDocs.getMatchingSub(top[i].subSlice);
      if (sub.matches) {
        b=sub.result;
      }
 else {
        b=new BitsSlice(skipDocs,top[i].subSlice);
      }
    }
 else     if (skipDocs != null) {
      b=new BitsSlice(skipDocs,top[i].subSlice);
    }
 else {
      b=null;
    }
    final DocsAndPositionsEnum subPostings=entry.terms.docsAndPositions(b,entry.reusePostings);
    if (subPostings != null) {
      entry.reusePostings=subDocsAndPositions[upto].docsAndPositionsEnum=subPostings;
      subDocsAndPositions[upto].slice=entry.subSlice;
      upto++;
    }
 else {
      if (entry.terms.docs(b,entry.reuseDocs) != null) {
        return null;
      }
    }
  }
  if (upto == 0) {
    return null;
  }
 else {
    return docsAndPositionsEnum.reset(subDocsAndPositions,upto);
  }
}
