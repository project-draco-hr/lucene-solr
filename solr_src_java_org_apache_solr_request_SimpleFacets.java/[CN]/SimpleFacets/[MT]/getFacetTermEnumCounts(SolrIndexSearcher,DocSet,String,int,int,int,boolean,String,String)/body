{
  int minDfFilterCache=params.getFieldInt(field,FacetParams.FACET_ENUM_CACHE_MINDF,0);
  DocSet fastForRandomSet=docs;
  if (minDfFilterCache > 0 && docs instanceof SortedIntDocSet) {
    SortedIntDocSet sset=(SortedIntDocSet)docs;
    fastForRandomSet=new HashDocSet(sset.getDocs(),0,sset.size());
  }
  IndexSchema schema=searcher.getSchema();
  IndexReader r=searcher.getReader();
  FieldType ft=schema.getFieldType(field);
  boolean sortByCount=sort.equals("count") || sort.equals("true");
  final int maxsize=limit >= 0 ? offset + limit : Integer.MAX_VALUE - 1;
  final BoundedTreeSet<CountPair<BytesRef,Integer>> queue=sortByCount ? new BoundedTreeSet<CountPair<BytesRef,Integer>>(maxsize) : null;
  final NamedList res=new NamedList();
  int min=mincount - 1;
  int off=offset;
  int lim=limit >= 0 ? limit : Integer.MAX_VALUE;
  BytesRef startTermBytes=null;
  if (prefix != null) {
    String indexedPrefix=ft.toInternal(prefix);
    startTermBytes=new BytesRef(indexedPrefix);
  }
  Fields fields=MultiFields.getFields(r);
  Terms terms=fields == null ? null : fields.terms(field);
  TermsEnum termsEnum=null;
  BytesRef term=null;
  if (terms != null) {
    termsEnum=terms.iterator();
    if (startTermBytes != null) {
      if (termsEnum.seek(startTermBytes,true) == TermsEnum.SeekStatus.END) {
        termsEnum=null;
      }
 else {
        term=termsEnum.term();
      }
    }
 else {
      term=termsEnum.next();
    }
  }
  Term template=new Term(field);
  DocsEnum docsEnum=null;
  CharArr spare=new CharArr();
  if (docs.size() >= mincount) {
    while (term != null) {
      if (startTermBytes != null && !term.startsWith(startTermBytes))       break;
      int df=termsEnum.docFreq();
      if (df > 0 && df > min) {
        int c;
        if (df >= minDfFilterCache) {
          spare.reset();
          ByteUtils.UTF8toUTF16(term,spare);
          Term t=template.createTerm(spare.toString());
          c=searcher.numDocs(new TermQuery(t),docs);
        }
 else {
          docsEnum=termsEnum.docs(null,docsEnum);
          c=0;
          if (docsEnum instanceof MultiDocsEnum) {
            MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
            int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
            for (int subindex=0; subindex < numSubs; subindex++) {
              MultiDocsEnum.EnumWithSlice sub=subs[subindex];
              if (sub.docsEnum == null)               continue;
              DocsEnum.BulkReadResult bulk=sub.docsEnum.getBulkResult();
              int base=sub.slice.start;
              for (; ; ) {
                int nDocs=sub.docsEnum.read();
                if (nDocs == 0)                 break;
                int[] docArr=bulk.docs.ints;
                int end=bulk.docs.offset + nDocs;
                for (int i=bulk.docs.offset; i < end; i++) {
                  if (fastForRandomSet.exists(docArr[i] + base))                   c++;
                }
              }
            }
          }
 else {
            DocsEnum.BulkReadResult bulk=docsEnum.getBulkResult();
            for (; ; ) {
              int nDocs=docsEnum.read();
              if (nDocs == 0)               break;
              int[] docArr=bulk.docs.ints;
              int end=bulk.docs.offset + nDocs;
              for (int i=bulk.docs.offset; i < end; i++) {
                if (fastForRandomSet.exists(docArr[i]))                 c++;
              }
            }
          }
        }
        if (sortByCount) {
          if (c > min) {
            BytesRef termCopy=new BytesRef(term);
            queue.add(new CountPair<BytesRef,Integer>(termCopy,c));
            if (queue.size() >= maxsize)             min=queue.last().val;
          }
        }
 else {
          if (c >= mincount && --off < 0) {
            if (--lim < 0)             break;
            spare.reset();
            ft.indexedToReadable(term,spare);
            res.add(spare.toString(),c);
          }
        }
      }
      term=termsEnum.next();
    }
  }
  if (sortByCount) {
    for (    CountPair<BytesRef,Integer> p : queue) {
      if (--off >= 0)       continue;
      if (--lim < 0)       break;
      spare.reset();
      ft.indexedToReadable(p.key,spare);
      res.add(spare.toString(),p.val);
    }
  }
  if (missing) {
    res.add(null,getFieldMissingCount(searcher,docs,field));
  }
  return res;
}
