{
  int offset=params.getFieldInt(field,FacetParams.FACET_OFFSET,0);
  int limit=params.getFieldInt(field,FacetParams.FACET_LIMIT,100);
  if (limit == 0)   return new NamedList<Integer>();
  Integer mincount=params.getFieldInt(field,FacetParams.FACET_MINCOUNT);
  if (mincount == null) {
    Boolean zeros=params.getFieldBool(field,FacetParams.FACET_ZEROS);
    mincount=(zeros != null && !zeros) ? 1 : 0;
  }
  boolean missing=params.getFieldBool(field,FacetParams.FACET_MISSING,false);
  String sort=params.getFieldParam(field,FacetParams.FACET_SORT,limit > 0 ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_INDEX);
  String prefix=params.getFieldParam(field,FacetParams.FACET_PREFIX);
  NamedList<Integer> counts;
  SchemaField sf=searcher.getSchema().getField(field);
  FieldType ft=sf.getType();
  String method=params.getFieldParam(field,FacetParams.FACET_METHOD);
  boolean enumMethod=FacetParams.FACET_METHOD_enum.equals(method);
  boolean per_segment=FacetParams.FACET_METHOD_fcs.equals(method);
  if (method == null && ft instanceof BoolField) {
    enumMethod=true;
  }
  boolean multiToken=sf.multiValued() || ft.multiValuedFieldCache();
  if (TrieField.getMainValuePrefix(ft) != null) {
    enumMethod=false;
    multiToken=true;
  }
  if (enumMethod) {
    counts=getFacetTermEnumCounts(searcher,base,field,offset,limit,mincount,missing,sort,prefix);
  }
 else {
    if (multiToken) {
      UnInvertedField uif=UnInvertedField.getUnInvertedField(field,searcher);
      counts=uif.getCounts(searcher,base,offset,limit,mincount,missing,sort,prefix);
    }
 else {
      if (per_segment) {
        PerSegmentSingleValuedFaceting ps=new PerSegmentSingleValuedFaceting(searcher,base,field,offset,limit,mincount,missing,sort,prefix);
        Executor executor=threads == 0 ? directExecutor : facetExecutor;
        ps.setNumThreads(threads);
        counts=ps.getFacetCounts(executor);
      }
 else {
        counts=getFieldCacheCounts(searcher,base,field,offset,limit,mincount,missing,sort,prefix);
      }
    }
  }
  return counts;
}
