{
  ensureOpen();
  try {
    String mergedName=newSegmentName();
    SegmentMerger merger=new SegmentMerger(directory,termIndexInterval,mergedName,null,codecs,payloadProcessorProvider);
    for (    IndexReader reader : readers)     merger.add(reader);
    int docCount=merger.merge();
    SegmentInfo info=null;
synchronized (this) {
      info=new SegmentInfo(mergedName,docCount,directory,false,-1,null,false,merger.hasProx(),merger.getSegmentCodecs());
      setDiagnostics(info,"addIndexes(IndexReader...)");
      segmentInfos.add(info);
      checkpoint();
      docWriter.updateFlushedDocCount(docCount);
    }
    if (mergePolicy instanceof LogMergePolicy && ((LogMergePolicy)mergePolicy).getUseCompoundFile()) {
      List<String> files=null;
synchronized (this) {
        if (segmentInfos.contains(info)) {
          files=info.files();
          deleter.incRef(files);
        }
      }
      if (files != null) {
        try {
          merger.createCompoundFile(mergedName + ".cfs",info);
synchronized (this) {
            info.setUseCompoundFile(true);
            checkpoint();
          }
        }
  finally {
synchronized (this) {
            deleter.decRef(files);
          }
        }
      }
    }
  }
 catch (  OutOfMemoryError oom) {
    handleOOM(oom,"addIndexes(IndexReader...)");
  }
}
