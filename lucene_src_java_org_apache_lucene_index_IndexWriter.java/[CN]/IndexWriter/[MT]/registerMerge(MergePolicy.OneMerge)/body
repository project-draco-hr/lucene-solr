{
  if (merge.registerDone)   return true;
  if (stopMerges) {
    merge.abort();
    throw new MergePolicy.MergeAbortedException("merge is aborted: " + merge.segString(directory));
  }
  final int count=merge.segments.size();
  boolean isExternal=false;
  for (int i=0; i < count; i++) {
    final SegmentInfo info=merge.segments.info(i);
    if (mergingSegments.contains(info)) {
      return false;
    }
    if (segmentInfos.indexOf(info) == -1) {
      return false;
    }
    if (info.dir != directory) {
      isExternal=true;
    }
    if (segmentsToOptimize.contains(info)) {
      merge.optimize=true;
      merge.maxNumSegmentsOptimize=optimizeMaxNumSegments;
    }
  }
  ensureValidMerge(merge);
  pendingMerges.add(merge);
  if (infoStream != null)   message("add merge to pendingMerges: " + merge.segString(directory) + " [total "+ pendingMerges.size()+ " pending]");
  merge.mergeGen=mergeGen;
  merge.isExternal=isExternal;
  for (int i=0; i < count; i++)   mergingSegments.add(merge.segments.info(i));
  merge.registerDone=true;
  return true;
}
