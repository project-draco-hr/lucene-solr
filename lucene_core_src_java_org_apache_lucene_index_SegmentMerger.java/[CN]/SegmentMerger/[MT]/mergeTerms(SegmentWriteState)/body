{
  final List<Fields> fields=new ArrayList<Fields>();
  final List<ReaderUtil.Slice> slices=new ArrayList<ReaderUtil.Slice>();
  int docBase=0;
  for (int readerIndex=0; readerIndex < mergeState.readers.size(); readerIndex++) {
    final MergeState.IndexReaderAndLiveDocs r=mergeState.readers.get(readerIndex);
    final Fields f=r.reader.fields();
    final int maxDoc=r.reader.maxDoc();
    if (f != null) {
      slices.add(new ReaderUtil.Slice(docBase,maxDoc,readerIndex));
      fields.add(f);
    }
    docBase+=maxDoc;
  }
  final FieldsConsumer consumer=codec.postingsFormat().fieldsConsumer(segmentWriteState);
  boolean success=false;
  try {
    consumer.merge(mergeState,new MultiFields(fields.toArray(Fields.EMPTY_ARRAY),slices.toArray(ReaderUtil.Slice.EMPTY_ARRAY)));
    success=true;
  }
  finally {
    if (success) {
      IOUtils.close(consumer);
    }
 else {
      IOUtils.closeWhileHandlingException(consumer);
    }
  }
}
