{
  String metaName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,metaExtension);
  IndexInput in=state.directory.openInput(metaName,state.context);
  this.maxDoc=state.segmentInfo.getDocCount();
  boolean success=false;
  try {
    version=CodecUtil.checkHeader(in,metaCodec,Lucene45DocValuesFormat.VERSION_START,Lucene45DocValuesFormat.VERSION_CURRENT);
    numerics=new HashMap<Integer,NumericEntry>();
    ords=new HashMap<Integer,NumericEntry>();
    ordIndexes=new HashMap<Integer,NumericEntry>();
    binaries=new HashMap<Integer,BinaryEntry>();
    sortedSets=new HashMap<Integer,SortedSetEntry>();
    readFields(in,state.fieldInfos);
    success=true;
  }
  finally {
    if (success) {
      IOUtils.close(in);
    }
 else {
      IOUtils.closeWhileHandlingException(in);
    }
  }
  success=false;
  try {
    String dataName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,dataExtension);
    data=state.directory.openInput(dataName,state.context);
    final int version2=CodecUtil.checkHeader(data,dataCodec,Lucene45DocValuesFormat.VERSION_CURRENT,Lucene45DocValuesFormat.VERSION_CURRENT);
    if (version != version2) {
      throw new CorruptIndexException("Format versions mismatch");
    }
    success=true;
  }
  finally {
    if (!success) {
      IOUtils.closeWhileHandlingException(this.data);
    }
  }
}
