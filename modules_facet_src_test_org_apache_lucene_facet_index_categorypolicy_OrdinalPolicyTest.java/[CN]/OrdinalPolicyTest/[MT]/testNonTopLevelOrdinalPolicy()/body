{
  Directory dir=newDirectory();
  TaxonomyWriter taxonomy=null;
  taxonomy=new DirectoryTaxonomyWriter(dir);
  int[] topLevelOrdinals=new int[10];
  String[] topLevelStrings=new String[10];
  for (int i=0; i < 10; i++) {
    topLevelStrings[i]=Integer.valueOf(random.nextInt(30)).toString();
    topLevelOrdinals[i]=taxonomy.addCategory(new CategoryPath(topLevelStrings[i]));
  }
  int[] nonTopLevelOrdinals=new int[300];
  for (int i=0; i < 300; i++) {
    int nComponents=2 + random.nextInt(10);
    String[] components=new String[nComponents];
    components[0]=topLevelStrings[i % 10];
    for (int j=1; j < components.length; j++) {
      components[j]=(Integer.valueOf(random.nextInt(30))).toString();
    }
    nonTopLevelOrdinals[i]=taxonomy.addCategory(new CategoryPath(components));
  }
  OrdinalPolicy ordinalPolicy=new NonTopLevelOrdinalPolicy();
  ordinalPolicy.init(taxonomy);
  assertFalse("top level ordinal policy should not match root",ordinalPolicy.shouldAdd(TaxonomyReader.ROOT_ORDINAL));
  for (int i=0; i < 10; i++) {
    assertFalse("top level ordinal policy should not match " + topLevelOrdinals[i],ordinalPolicy.shouldAdd(topLevelOrdinals[i]));
  }
  for (int i=0; i < 300; i++) {
    assertTrue("top level ordinal policy should match " + nonTopLevelOrdinals[i],ordinalPolicy.shouldAdd(nonTopLevelOrdinals[i]));
  }
  assertFalse("Should not add illegal ordinal",ordinalPolicy.shouldAdd(100000));
  taxonomy.close();
  dir.close();
}
