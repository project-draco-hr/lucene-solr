{
  IndexWriterConfig iwc=newIndexWriterConfig();
  Directory dir;
  if (lats.length > 100000) {
    dir=newFSDirectory(createTempDir("TestGeoPointQuery"));
    iwc.setCodec(TestUtil.getDefaultCodec());
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < lats.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(lats[id]) == false) {
      if (VERBOSE) {
        System.out.println("  id=" + id + " lat="+ lats[id]+ " lon="+ lons[id]);
      }
      doc.add(new GeoPointField(FIELD_NAME,lons[id],lats[id],Field.Store.NO));
    }
 else     if (VERBOSE) {
      System.out.println("  id=" + id + " skipped");
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  IndexReader r=DirectoryReader.open(w,true);
  w.close();
  IndexSearcher s=newSearcher(r);
  int numThreads=TestUtil.nextInt(random(),2,5);
  List<Thread> threads=new ArrayList<>();
  final int iters=atLeast(10);
  final CountDownLatch startingGun=new CountDownLatch(1);
  for (int i=0; i < numThreads; i++) {
    Thread thread=new Thread(){
      @Override public void run(){
        try {
          _run();
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
      private void _run() throws Exception {
        startingGun.await();
        NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
        for (int iter=0; iter < iters; iter++) {
          if (VERBOSE) {
            System.out.println("\nTEST: iter=" + iter);
          }
          Query query;
          VerifyHits verifyHits;
          if (random().nextBoolean()) {
            GeoBoundingBox bbox=randomBBox();
            query=new GeoPointInBBoxQuery(FIELD_NAME,bbox.minLon,bbox.minLat,bbox.maxLon,bbox.maxLat);
            verifyHits=new VerifyHits(){
              @Override protected Boolean shouldMatch(              double pointLat,              double pointLon){
                long pointHash=GeoUtils.mortonHash(pointLon,pointLat);
                pointLon=GeoUtils.mortonUnhashLon(pointHash);
                pointLat=GeoUtils.mortonUnhashLat(pointHash);
                if (bboxQueryCanBeWrong(bbox,pointLat,pointLon)) {
                  return null;
                }
 else {
                  return rectContainsPointEnc(bbox,pointLat,pointLon);
                }
              }
            }
;
          }
 else           if (random().nextBoolean()) {
            GeoBoundingBox bbox=randomBBox();
            double centerLat=bbox.minLat + ((bbox.maxLat - bbox.minLat) / 2.0);
            double centerLon=bbox.minLon + ((bbox.maxLon - bbox.minLon) / 2.0);
            final double radius=SloppyMath.haversin(centerLat,centerLon,bbox.minLat,centerLon) * 100;
            if (VERBOSE) {
              System.out.println("\t radius = " + radius);
            }
            query=new GeoPointDistanceQuery(FIELD_NAME,centerLon,centerLat,radius);
            verifyHits=new VerifyHits(){
              @Override protected Boolean shouldMatch(              double pointLat,              double pointLon){
                if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {
                  return null;
                }
                if (radiusQueryCanBeWrong(centerLat,centerLon,pointLon,pointLat,radius)) {
                  return null;
                }
 else {
                  return distanceContainsPt(centerLon,centerLat,pointLon,pointLat,radius);
                }
              }
            }
;
          }
 else {
            GeoBoundingBox bbox=randomBBox();
            double[] pLats=new double[5];
            double[] pLons=new double[5];
            pLats[0]=bbox.minLat;
            pLons[0]=bbox.minLon;
            pLats[1]=bbox.maxLat;
            pLons[1]=bbox.minLon;
            pLats[2]=bbox.maxLat;
            pLons[2]=bbox.maxLon;
            pLats[3]=bbox.minLat;
            pLons[3]=bbox.maxLon;
            pLats[4]=bbox.minLat;
            pLons[4]=bbox.minLon;
            query=new GeoPointInPolygonQuery(FIELD_NAME,pLons,pLats);
            verifyHits=new VerifyHits(){
              @Override protected Boolean shouldMatch(              double pointLat,              double pointLon){
                long pointHash=GeoUtils.mortonHash(pointLon,pointLat);
                pointLon=GeoUtils.mortonUnhashLon(pointHash);
                pointLat=GeoUtils.mortonUnhashLat(pointHash);
                if (bboxQueryCanBeWrong(bbox,pointLat,pointLon)) {
                  return null;
                }
 else {
                  return rectContainsPointEnc(bbox,pointLat,pointLon);
                }
              }
            }
;
          }
          verifyHits.test(s,docIDToID,deleted,query,lats,lons);
        }
      }
    }
;
    thread.setName("T" + i);
    thread.start();
    threads.add(thread);
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  IOUtils.close(r,dir);
}
