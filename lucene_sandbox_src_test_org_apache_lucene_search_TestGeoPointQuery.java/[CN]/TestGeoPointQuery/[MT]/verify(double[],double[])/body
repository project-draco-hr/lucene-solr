{
  IndexWriterConfig iwc=newIndexWriterConfig();
  Directory dir;
  if (lats.length > 100000) {
    dir=newFSDirectory(createTempDir("TestGeoPointQuery"));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < lats.length; id++) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(lats[id]) == false) {
      if (VERBOSE) {
        System.out.println("  id=" + id + " lat="+ lats[id]+ " lon="+ lons[id]);
      }
      doc.add(new GeoPointField(FIELD_NAME,lons[id],lats[id],Field.Store.NO));
    }
 else     if (VERBOSE) {
      System.out.println("  id=" + id + " skipped");
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 42) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  IndexReader r=DirectoryReader.open(w,true);
  w.close();
  IndexSearcher s=newSearcher(r);
  int numThreads=TestUtil.nextInt(random(),2,5);
  List<Thread> threads=new ArrayList<>();
  final int iters=atLeast(100);
  final CountDownLatch startingGun=new CountDownLatch(1);
  for (int i=0; i < numThreads; i++) {
    Thread thread=new Thread(){
      @Override public void run(){
        try {
          _run();
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
      private void _run() throws Exception {
        startingGun.await();
        NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
        for (int iter=0; iter < iters; iter++) {
          double lat0=randomLat();
          double lat1=randomLat();
          double lon0=randomLon();
          double lon1=randomLon();
          if (lat1 < lat0) {
            double x=lat0;
            lat0=lat1;
            lat1=x;
          }
          if (lon1 < lon0) {
            double x=lon0;
            lon0=lon1;
            lon1=x;
          }
          if (VERBOSE) {
            System.out.println("\nTEST: iter=" + iter + " lat="+ lat0+ " TO "+ lat1+ " lon="+ lon0+ " TO "+ lon1);
          }
          Query query;
          boolean tooBigBBox=false;
          boolean polySearch=false;
          double bboxLat0=lat0;
          double bboxLat1=lat1;
          double bboxLon0=lon0;
          double bboxLon1=lon1;
          if (random().nextBoolean()) {
            query=new GeoPointInBBoxQuery(FIELD_NAME,lon0,lat0,lon1,lat1);
          }
 else {
            polySearch=true;
            if (random().nextBoolean()) {
              double pct=random().nextDouble() * 0.5;
              double width=lon1 - lon0;
              bboxLon0=Math.max(-180.0,lon0 - width * pct);
              bboxLon1=Math.min(180.0,lon1 + width * pct);
              double height=lat1 - lat0;
              bboxLat0=Math.max(-90.0,lat0 - height * pct);
              bboxLat1=Math.min(90.0,lat1 + height * pct);
              tooBigBBox=true;
            }
            double[] pLats=new double[5];
            double[] pLons=new double[5];
            pLats[0]=bboxLat0;
            pLons[0]=bboxLon0;
            pLats[1]=bboxLat1;
            pLons[1]=bboxLon0;
            pLats[2]=bboxLat1;
            pLons[2]=bboxLon1;
            pLats[3]=bboxLat0;
            pLons[3]=bboxLon1;
            pLats[4]=bboxLat0;
            pLons[4]=bboxLon0;
            query=new GeoPointInPolygonQuery(FIELD_NAME,bboxLon0,bboxLat0,bboxLon1,bboxLat1,pLons,pLats);
          }
          final FixedBitSet hits=new FixedBitSet(r.maxDoc());
          s.search(query,new SimpleCollector(){
            private int docBase;
            @Override public boolean needsScores(){
              return false;
            }
            @Override protected void doSetNextReader(            LeafReaderContext context) throws IOException {
              docBase=context.docBase;
            }
            @Override public void collect(            int doc){
              hits.set(docBase + doc);
            }
          }
);
          for (int docID=0; docID < r.maxDoc(); docID++) {
            int id=(int)docIDToID.get(docID);
            if (polySearch) {
              lat0=bboxLat0;
              lon0=bboxLon0;
              lat1=bboxLat1;
              lon1=bboxLon1;
            }
            final long pointHash=GeoUtils.mortonHash(lons[id],lats[id]);
            final double pointLon=GeoUtils.mortonUnhashLon(pointHash);
            final double pointLat=GeoUtils.mortonUnhashLat(pointHash);
            if (!tolerateIgnorance(lat0,lat1,lon0,lon1,pointLat,pointLon)) {
              boolean expected=(deleted.contains(id) == false) && rectContainsPointEnc(lat0,lat1,lon0,lon1,pointLat,pointLon);
              if (hits.get(docID) != expected) {
                System.out.println(Thread.currentThread().getName() + ": iter=" + iter+ " id="+ id+ " docID="+ docID+ " lat="+ pointLat+ " lon="+ pointLon+ " (bbox: lat="+ lat0+ " TO "+ lat1+ " lon="+ lon0+ " TO "+ lon1+ ") expected "+ expected+ " but got: "+ hits.get(docID)+ " deleted?="+ deleted.contains(id)+ " query="+ query);
                if (tooBigBBox) {
                  System.out.println("  passed too-big bbox: lat=" + bboxLat0 + " TO "+ bboxLat1+ " lon="+ bboxLon0+ " TO "+ bboxLon1);
                }
                fail("wrong result");
              }
            }
          }
        }
      }
    }
;
    thread.setName("T" + i);
    thread.start();
    threads.add(thread);
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  IOUtils.close(r,dir);
}
