{
  int first=segmentInfos.indexOf(merge.segments.info(0));
  if (first == -1)   throw new MergePolicy.MergeException("could not find segment " + merge.segments.info(0).name + " in current index "+ segString(),directory);
  final int numSegments=segmentInfos.size();
  final int numSegmentsToMerge=merge.segments.size();
  for (int i=0; i < numSegmentsToMerge; i++) {
    final SegmentInfo info=merge.segments.info(i);
    if (first + i >= numSegments || !segmentInfos.info(first + i).equals(info)) {
      if (segmentInfos.indexOf(info) == -1)       throw new MergePolicy.MergeException("MergePolicy selected a segment (" + info.name + ") that is not in the current index "+ segString(),directory);
 else       throw new MergePolicy.MergeException("MergePolicy selected non-contiguous segments to merge (" + merge.segString(directory) + " vs "+ segString()+ "), which IndexWriter (currently) cannot handle",directory);
    }
  }
  return first;
}
