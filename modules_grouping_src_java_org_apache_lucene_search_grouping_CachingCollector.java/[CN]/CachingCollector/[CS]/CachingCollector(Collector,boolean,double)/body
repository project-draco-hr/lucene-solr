{
  this.other=other;
  if (cacheScores) {
    cachedScorer=new Scorer(null){
      @Override public float score(){
        return score;
      }
      @Override public int advance(      int target){
        throw new UnsupportedOperationException();
      }
      @Override public int docID(){
        return doc;
      }
      @Override public float freq(){
        throw new UnsupportedOperationException();
      }
      @Override public int nextDoc(){
        throw new UnsupportedOperationException();
      }
    }
;
    cachedScores=new ArrayList<float[]>();
    curScores=new float[128];
    cachedScores.add(curScores);
  }
 else {
    cachedScorer=null;
    cachedScores=null;
  }
  cachedDocs=new ArrayList<int[]>();
  curDocs=new int[128];
  cachedDocs.add(curDocs);
  final int bytesPerDoc;
  if (curScores != null) {
    bytesPerDoc=RamUsageEstimator.NUM_BYTES_INT + RamUsageEstimator.NUM_BYTES_FLOAT;
  }
 else {
    bytesPerDoc=RamUsageEstimator.NUM_BYTES_INT;
  }
  maxDocsToCache=(int)((maxRAMMB * 1024 * 1024) / bytesPerDoc);
}
