{
  Term searchTerm=new Term("content","aaa");
  int START_COUNT=157;
  int END_COUNT=144;
  MockDirectoryWrapper startDir=newDirectory();
  startDir.setNoDeleteOpenFile(false);
  IndexWriter writer=new IndexWriter(startDir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random,MockTokenizer.WHITESPACE,false)));
  for (int i=0; i < 157; i++) {
    Document d=new Document();
    d.add(newField("id",Integer.toString(i),StringField.TYPE_STORED));
    d.add(newField("content","aaa " + i,TextField.TYPE_UNSTORED));
    writer.addDocument(d);
  }
  writer.close();
  long diskUsage=startDir.sizeInBytes();
  long diskFree=diskUsage + 10;
  IOException err=null;
  boolean done=false;
  while (!done) {
    if (VERBOSE) {
      System.out.println("TEST: cycle");
    }
    MockDirectoryWrapper dir=new MockDirectoryWrapper(random,new RAMDirectory(startDir,newIOContext(random)));
    dir.setPreventDoubleWrite(false);
    IndexWriter modifier=new IndexWriter(dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random,MockTokenizer.WHITESPACE,false)).setMaxBufferedDocs(1000).setMaxBufferedDeleteTerms(1000).setMergeScheduler(new ConcurrentMergeScheduler()));
    ((ConcurrentMergeScheduler)modifier.getConfig().getMergeScheduler()).setSuppressExceptions();
    boolean success=false;
    for (int x=0; x < 2; x++) {
      if (VERBOSE) {
        System.out.println("TEST: x=" + x);
      }
      double rate=0.1;
      double diskRatio=((double)diskFree) / diskUsage;
      long thisDiskFree;
      String testName;
      if (0 == x) {
        thisDiskFree=diskFree;
        if (diskRatio >= 2.0) {
          rate/=2;
        }
        if (diskRatio >= 4.0) {
          rate/=2;
        }
        if (diskRatio >= 6.0) {
          rate=0.0;
        }
        if (VERBOSE) {
          System.out.println("\ncycle: " + diskFree + " bytes");
        }
        testName="disk full during reader.close() @ " + thisDiskFree + " bytes";
      }
 else {
        thisDiskFree=0;
        rate=0.0;
        if (VERBOSE) {
          System.out.println("\ncycle: same writer: unlimited disk space");
        }
        testName="reader re-use after disk full";
      }
      dir.setMaxSizeInBytes(thisDiskFree);
      dir.setRandomIOExceptionRate(rate);
      try {
        if (0 == x) {
          int docId=12;
          for (int i=0; i < 13; i++) {
            if (updates) {
              Document d=new Document();
              d.add(newField("id",Integer.toString(i),StringField.TYPE_STORED));
              d.add(newField("content","bbb " + i,TextField.TYPE_UNSTORED));
              modifier.updateDocument(new Term("id",Integer.toString(docId)),d);
            }
 else {
              modifier.deleteDocuments(new Term("id",Integer.toString(docId)));
            }
            docId+=12;
          }
        }
        modifier.close();
        success=true;
        if (0 == x) {
          done=true;
        }
      }
 catch (      IOException e) {
        if (VERBOSE) {
          System.out.println("  hit IOException: " + e);
          e.printStackTrace(System.out);
        }
        err=e;
        if (1 == x) {
          e.printStackTrace();
          fail(testName + " hit IOException after disk space was freed up");
        }
      }
      final double randomIOExceptionRate=dir.getRandomIOExceptionRate();
      final long maxSizeInBytes=dir.getMaxSizeInBytes();
      dir.setRandomIOExceptionRate(0.0);
      dir.setMaxSizeInBytes(0);
      if (!success) {
        if (VERBOSE) {
          System.out.println("TEST: now rollback");
        }
        modifier.rollback();
      }
      if (success) {
        _TestUtil.checkIndex(dir);
        TestIndexWriter.assertNoUnreferencedFiles(dir,"after writer.close");
      }
      dir.setRandomIOExceptionRate(randomIOExceptionRate);
      dir.setMaxSizeInBytes(maxSizeInBytes);
      IndexReader newReader=null;
      try {
        newReader=IndexReader.open(dir);
      }
 catch (      IOException e) {
        e.printStackTrace();
        fail(testName + ":exception when creating IndexReader after disk full during close: " + e);
      }
      IndexSearcher searcher=newSearcher(newReader);
      ScoreDoc[] hits=null;
      try {
        hits=searcher.search(new TermQuery(searchTerm),null,1000).scoreDocs;
      }
 catch (      IOException e) {
        e.printStackTrace();
        fail(testName + ": exception when searching: " + e);
      }
      int result2=hits.length;
      if (success) {
        if (x == 0 && result2 != END_COUNT) {
          fail(testName + ": method did not throw exception but hits.length for search on term 'aaa' is " + result2+ " instead of expected "+ END_COUNT);
        }
 else         if (x == 1 && result2 != START_COUNT && result2 != END_COUNT) {
          fail(testName + ": method did not throw exception but hits.length for search on term 'aaa' is " + result2+ " instead of expected "+ START_COUNT+ " or "+ END_COUNT);
        }
      }
 else {
        if (result2 != START_COUNT && result2 != END_COUNT) {
          err.printStackTrace();
          fail(testName + ": method did throw exception but hits.length for search on term 'aaa' is " + result2+ " instead of expected "+ START_COUNT+ " or "+ END_COUNT);
        }
      }
      searcher.close();
      newReader.close();
      if (result2 == END_COUNT) {
        break;
      }
    }
    dir.close();
    modifier.close();
    diskFree+=10;
  }
  startDir.close();
}
