{
  this.maxDoc=maxDoc;
  this.contexts=new LeafReaderContext[segments];
  this.collapseValues=collapseValues;
  if (collapseValues instanceof MultiDocValues.MultiSortedDocValues) {
    this.multiSortedDocValues=(MultiDocValues.MultiSortedDocValues)collapseValues;
    this.ordinalMap=multiSortedDocValues.mapping;
  }
  int valueCount=collapseValues.getValueCount();
  this.nullPolicy=nullPolicy;
  this.needsScores=needsScores;
  if (funcQuery != null) {
    this.collapseStrategy=new OrdValueSourceStrategy(maxDoc,field,nullPolicy,new int[valueCount],max,this.needsScores,boostDocs,funcQuery,searcher,collapseValues);
  }
 else {
    if (fieldType instanceof TrieIntField) {
      this.collapseStrategy=new OrdIntStrategy(maxDoc,field,nullPolicy,new int[valueCount],max,this.needsScores,boostDocs,collapseValues);
    }
 else     if (fieldType instanceof TrieFloatField) {
      this.collapseStrategy=new OrdFloatStrategy(maxDoc,field,nullPolicy,new int[valueCount],max,this.needsScores,boostDocs,collapseValues);
    }
 else     if (fieldType instanceof TrieLongField) {
      this.collapseStrategy=new OrdLongStrategy(maxDoc,field,nullPolicy,new int[valueCount],max,this.needsScores,boostDocs,collapseValues);
    }
 else {
      throw new IOException("min/max must be either TrieInt, TrieLong, TrieFloat.");
    }
  }
}
