{
  if (DEBUG) {
    System.out.println("LTF.nextToken inputPos=" + inputPos + " outputPos="+ outputPos+ " tokenPending="+ tokenPending);
  }
  Position posData=positions.get(outputPos);
  while (true) {
    if (posData.nextRead < posData.inputTokens.size()) {
      if (DEBUG) {
        System.out.println("  return previously buffered token");
      }
      if (tokenPending) {
        positions.get(inputPos).add(captureState());
        tokenPending=false;
      }
      restoreState(positions.get(outputPos).nextState());
      return true;
    }
    if (inputPos == -1 || outputPos == inputPos) {
      if (tokenPending) {
        if (DEBUG) {
          System.out.println("  pass-through: return pending token");
        }
        tokenPending=false;
        return true;
      }
 else       if (end || !peekToken()) {
        if (DEBUG) {
          System.out.println("  END");
        }
        return false;
      }
    }
 else {
      if (posData.startOffset != -1) {
        if (DEBUG) {
          System.out.println("  call afterPosition");
        }
        afterPosition();
        if (insertPending) {
          if (DEBUG) {
            System.out.println("  return inserted token");
          }
          insertPending=false;
          return true;
        }
      }
      outputPos++;
      if (DEBUG) {
        System.out.println("  next position: outputPos=" + outputPos);
      }
      positions.freeBefore(outputPos);
      posData=positions.get(outputPos);
    }
  }
}
