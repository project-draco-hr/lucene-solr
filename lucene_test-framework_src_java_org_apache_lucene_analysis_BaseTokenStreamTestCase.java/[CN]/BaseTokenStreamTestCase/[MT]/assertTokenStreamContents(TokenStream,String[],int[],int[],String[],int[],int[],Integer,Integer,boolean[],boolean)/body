{
  assertNotNull(output);
  CheckClearAttributesAttribute checkClearAtt=ts.addAttribute(CheckClearAttributesAttribute.class);
  CharTermAttribute termAtt=null;
  if (output.length > 0) {
    assertTrue("has no CharTermAttribute",ts.hasAttribute(CharTermAttribute.class));
    termAtt=ts.getAttribute(CharTermAttribute.class);
  }
  OffsetAttribute offsetAtt=null;
  if (startOffsets != null || endOffsets != null || finalOffset != null) {
    assertTrue("has no OffsetAttribute",ts.hasAttribute(OffsetAttribute.class));
    offsetAtt=ts.getAttribute(OffsetAttribute.class);
  }
  TypeAttribute typeAtt=null;
  if (types != null) {
    assertTrue("has no TypeAttribute",ts.hasAttribute(TypeAttribute.class));
    typeAtt=ts.getAttribute(TypeAttribute.class);
  }
  PositionIncrementAttribute posIncrAtt=null;
  if (posIncrements != null || finalPosInc != null) {
    assertTrue("has no PositionIncrementAttribute",ts.hasAttribute(PositionIncrementAttribute.class));
    posIncrAtt=ts.getAttribute(PositionIncrementAttribute.class);
  }
  PositionLengthAttribute posLengthAtt=null;
  if (posLengths != null) {
    assertTrue("has no PositionLengthAttribute",ts.hasAttribute(PositionLengthAttribute.class));
    posLengthAtt=ts.getAttribute(PositionLengthAttribute.class);
  }
  KeywordAttribute keywordAtt=null;
  if (keywordAtts != null) {
    assertTrue("has no KeywordAttribute",ts.hasAttribute(KeywordAttribute.class));
    keywordAtt=ts.getAttribute(KeywordAttribute.class);
  }
  final Map<Integer,Integer> posToStartOffset=new HashMap<>();
  final Map<Integer,Integer> posToEndOffset=new HashMap<>();
  ts.reset();
  int pos=-1;
  int lastStartOffset=0;
  for (int i=0; i < output.length; i++) {
    ts.clearAttributes();
    termAtt.setEmpty().append("bogusTerm");
    if (offsetAtt != null)     offsetAtt.setOffset(14584724,24683243);
    if (typeAtt != null)     typeAtt.setType("bogusType");
    if (posIncrAtt != null)     posIncrAtt.setPositionIncrement(45987657);
    if (posLengthAtt != null)     posLengthAtt.setPositionLength(45987653);
    if (keywordAtt != null)     keywordAtt.setKeyword((i & 1) == 0);
    checkClearAtt.getAndResetClearCalled();
    assertTrue("token " + i + " does not exist",ts.incrementToken());
    assertTrue("clearAttributes() was not called correctly in TokenStream chain",checkClearAtt.getAndResetClearCalled());
    assertEquals("term " + i,output[i],termAtt.toString());
    if (startOffsets != null) {
      assertEquals("startOffset " + i,startOffsets[i],offsetAtt.startOffset());
    }
    if (endOffsets != null) {
      assertEquals("endOffset " + i,endOffsets[i],offsetAtt.endOffset());
    }
    if (types != null) {
      assertEquals("type " + i,types[i],typeAtt.type());
    }
    if (posIncrements != null) {
      assertEquals("posIncrement " + i,posIncrements[i],posIncrAtt.getPositionIncrement());
    }
    if (posLengths != null) {
      assertEquals("posLength " + i,posLengths[i],posLengthAtt.getPositionLength());
    }
    if (keywordAtts != null) {
      assertEquals("keywordAtt " + i,keywordAtts[i],keywordAtt.isKeyword());
    }
    if (offsetAtt != null) {
      final int startOffset=offsetAtt.startOffset();
      final int endOffset=offsetAtt.endOffset();
      if (finalOffset != null) {
        assertTrue("startOffset must be <= finalOffset",startOffset <= finalOffset.intValue());
        assertTrue("endOffset must be <= finalOffset: got endOffset=" + endOffset + " vs finalOffset="+ finalOffset.intValue(),endOffset <= finalOffset.intValue());
      }
      if (offsetsAreCorrect) {
        assertTrue("offsets must not go backwards startOffset=" + startOffset + " is < lastStartOffset="+ lastStartOffset,offsetAtt.startOffset() >= lastStartOffset);
        lastStartOffset=offsetAtt.startOffset();
      }
      if (offsetsAreCorrect && posLengthAtt != null && posIncrAtt != null) {
        final int posInc=posIncrAtt.getPositionIncrement();
        pos+=posInc;
        final int posLength=posLengthAtt.getPositionLength();
        if (!posToStartOffset.containsKey(pos)) {
          posToStartOffset.put(pos,startOffset);
        }
 else {
          assertEquals("pos=" + pos + " posLen="+ posLength+ " token="+ termAtt,posToStartOffset.get(pos).intValue(),startOffset);
        }
        final int endPos=pos + posLength;
        if (!posToEndOffset.containsKey(endPos)) {
          posToEndOffset.put(endPos,endOffset);
        }
 else {
          assertEquals("pos=" + pos + " posLen="+ posLength+ " token="+ termAtt,posToEndOffset.get(endPos).intValue(),endOffset);
        }
      }
    }
    if (posIncrAtt != null) {
      if (i == 0) {
        assertTrue("first posIncrement must be >= 1",posIncrAtt.getPositionIncrement() >= 1);
      }
 else {
        assertTrue("posIncrement must be >= 0",posIncrAtt.getPositionIncrement() >= 0);
      }
    }
    if (posLengthAtt != null) {
      assertTrue("posLength must be >= 1",posLengthAtt.getPositionLength() >= 1);
    }
  }
  if (ts.incrementToken()) {
    fail("TokenStream has more tokens than expected (expected count=" + output.length + "); extra token="+ termAtt);
  }
  ts.clearAttributes();
  if (termAtt != null)   termAtt.setEmpty().append("bogusTerm");
  if (offsetAtt != null)   offsetAtt.setOffset(14584724,24683243);
  if (typeAtt != null)   typeAtt.setType("bogusType");
  if (posIncrAtt != null)   posIncrAtt.setPositionIncrement(45987657);
  if (posLengthAtt != null)   posLengthAtt.setPositionLength(45987653);
  checkClearAtt.getAndResetClearCalled();
  ts.end();
  assertTrue("super.end()/clearAttributes() was not called correctly in end()",checkClearAtt.getAndResetClearCalled());
  if (finalOffset != null) {
    assertEquals("finalOffset",finalOffset.intValue(),offsetAtt.endOffset());
  }
  if (offsetAtt != null) {
    assertTrue("finalOffset must be >= 0",offsetAtt.endOffset() >= 0);
  }
  if (finalPosInc != null) {
    assertEquals("finalPosInc",finalPosInc.intValue(),posIncrAtt.getPositionIncrement());
  }
  ts.close();
}
