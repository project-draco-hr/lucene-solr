{
  if (VERBOSE) {
    System.out.println(Thread.currentThread().getName() + ": NOTE: BaseTokenStreamTestCase: get first token stream now text=" + text);
  }
  int remainder=random.nextInt(10);
  Reader reader=new StringReader(text);
  TokenStream ts=a.tokenStream("dummy",useCharFilter ? new MockCharFilter(reader,remainder) : reader);
  CharTermAttribute termAtt=ts.getAttribute(CharTermAttribute.class);
  OffsetAttribute offsetAtt=ts.getAttribute(OffsetAttribute.class);
  PositionIncrementAttribute posIncAtt=ts.getAttribute(PositionIncrementAttribute.class);
  PositionLengthAttribute posLengthAtt=ts.getAttribute(PositionLengthAttribute.class);
  TypeAttribute typeAtt=ts.getAttribute(TypeAttribute.class);
  List<String> tokens=new ArrayList<>();
  List<String> types=new ArrayList<>();
  List<Integer> positions=new ArrayList<>();
  List<Integer> positionLengths=new ArrayList<>();
  List<Integer> startOffsets=new ArrayList<>();
  List<Integer> endOffsets=new ArrayList<>();
  ts.reset();
  while (ts.incrementToken()) {
    assertNotNull("has no CharTermAttribute",termAtt);
    tokens.add(termAtt.toString());
    if (typeAtt != null)     types.add(typeAtt.type());
    if (posIncAtt != null)     positions.add(posIncAtt.getPositionIncrement());
    if (posLengthAtt != null)     positionLengths.add(posLengthAtt.getPositionLength());
    if (offsetAtt != null) {
      startOffsets.add(offsetAtt.startOffset());
      endOffsets.add(offsetAtt.endOffset());
    }
  }
  ts.end();
  ts.close();
  if (!tokens.isEmpty()) {
    if (text.length() != 0) {
      final int evilness=random.nextInt(50);
      if (evilness == 17) {
        if (VERBOSE) {
          System.out.println(Thread.currentThread().getName() + ": NOTE: BaseTokenStreamTestCase: re-run analysis w/ exception");
        }
        MockReaderWrapper evilReader=new MockReaderWrapper(random,new StringReader(text));
        evilReader.throwExcAfterChar(random.nextInt(text.length() + 1));
        reader=evilReader;
        try {
          ts=a.tokenStream("dummy",useCharFilter ? new MockCharFilter(evilReader,remainder) : evilReader);
          ts.reset();
          while (ts.incrementToken())           ;
          fail("did not hit exception");
        }
 catch (        RuntimeException re) {
          assertTrue(MockReaderWrapper.isMyEvilException(re));
        }
        try {
          ts.end();
        }
 catch (        IllegalStateException ise) {
          if ("end() called before incrementToken() returned false!".equals(ise.getMessage())) {
          }
 else {
            throw ise;
          }
        }
        ts.close();
      }
 else       if (evilness == 7) {
        final int numTokensToRead=random.nextInt(tokens.size());
        if (VERBOSE) {
          System.out.println(Thread.currentThread().getName() + ": NOTE: BaseTokenStreamTestCase: re-run analysis, only consuming " + numTokensToRead+ " of "+ tokens.size()+ " tokens");
        }
        reader=new StringReader(text);
        ts=a.tokenStream("dummy",useCharFilter ? new MockCharFilter(reader,remainder) : reader);
        ts.reset();
        for (int tokenCount=0; tokenCount < numTokensToRead; tokenCount++) {
          assertTrue(ts.incrementToken());
        }
        try {
          ts.end();
        }
 catch (        IllegalStateException ise) {
          if ("end() called before incrementToken() returned false!".equals(ise.getMessage())) {
          }
 else {
            throw ise;
          }
        }
        ts.close();
      }
    }
  }
  if (VERBOSE) {
    System.out.println(Thread.currentThread().getName() + ": NOTE: BaseTokenStreamTestCase: re-run analysis; " + tokens.size()+ " tokens");
  }
  reader=new StringReader(text);
  long seed=random.nextLong();
  random=new Random(seed);
  if (random.nextInt(30) == 7) {
    if (VERBOSE) {
      System.out.println(Thread.currentThread().getName() + ": NOTE: BaseTokenStreamTestCase: using spoon-feed reader");
    }
    reader=new MockReaderWrapper(random,reader);
  }
  ts=a.tokenStream("dummy",useCharFilter ? new MockCharFilter(reader,remainder) : reader);
  if (typeAtt != null && posIncAtt != null && posLengthAtt != null && offsetAtt != null) {
    assertTokenStreamContents(ts,tokens.toArray(new String[tokens.size()]),toIntArray(startOffsets),toIntArray(endOffsets),types.toArray(new String[types.size()]),toIntArray(positions),toIntArray(positionLengths),text.length(),offsetsAreCorrect);
  }
 else   if (typeAtt != null && posIncAtt != null && offsetAtt != null) {
    assertTokenStreamContents(ts,tokens.toArray(new String[tokens.size()]),toIntArray(startOffsets),toIntArray(endOffsets),types.toArray(new String[types.size()]),toIntArray(positions),null,text.length(),offsetsAreCorrect);
  }
 else   if (posIncAtt != null && posLengthAtt != null && offsetAtt != null) {
    assertTokenStreamContents(ts,tokens.toArray(new String[tokens.size()]),toIntArray(startOffsets),toIntArray(endOffsets),null,toIntArray(positions),toIntArray(positionLengths),text.length(),offsetsAreCorrect);
  }
 else   if (posIncAtt != null && offsetAtt != null) {
    assertTokenStreamContents(ts,tokens.toArray(new String[tokens.size()]),toIntArray(startOffsets),toIntArray(endOffsets),null,toIntArray(positions),null,text.length(),offsetsAreCorrect);
  }
 else   if (offsetAtt != null) {
    assertTokenStreamContents(ts,tokens.toArray(new String[tokens.size()]),toIntArray(startOffsets),toIntArray(endOffsets),null,null,null,text.length(),offsetsAreCorrect);
  }
 else {
    assertTokenStreamContents(ts,tokens.toArray(new String[tokens.size()]));
  }
  if (field != null) {
    reader=new StringReader(text);
    random=new Random(seed);
    if (random.nextInt(30) == 7) {
      if (VERBOSE) {
        System.out.println(Thread.currentThread().getName() + ": NOTE: BaseTokenStreamTestCase: indexing using spoon-feed reader");
      }
      reader=new MockReaderWrapper(random,reader);
    }
    field.setReaderValue(useCharFilter ? new MockCharFilter(reader,remainder) : reader);
  }
}
