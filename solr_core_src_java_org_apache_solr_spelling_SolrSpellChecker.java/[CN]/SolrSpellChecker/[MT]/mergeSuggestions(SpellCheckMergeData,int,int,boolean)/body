{
  float min=0.5f;
  try {
    min=getAccuracy();
  }
 catch (  UnsupportedOperationException uoe) {
  }
  StringDistance sd=null;
  try {
    sd=getStringDistance() == null ? new LevensteinDistance() : getStringDistance();
  }
 catch (  UnsupportedOperationException uoe) {
    sd=new LevensteinDistance();
  }
  SpellingResult result=new SpellingResult();
  for (  Map.Entry<String,HashSet<String>> entry : mergeData.origVsSuggested.entrySet()) {
    String original=entry.getKey();
    Integer numShards=mergeData.origVsShards.get(original);
    if (numShards < mergeData.totalNumberShardResponses && mergeData.isOriginalToQuery(original)) {
      continue;
    }
    HashSet<String> suggested=entry.getValue();
    SuggestWordQueue sugQueue=new SuggestWordQueue(numSug);
    for (    String suggestion : suggested) {
      SuggestWord sug=mergeData.suggestedVsWord.get(suggestion);
      sug.score=sd.getDistance(original,sug.string);
      if (sug.score < min)       continue;
      sugQueue.insertWithOverflow(sug);
      if (sugQueue.size() == numSug) {
        min=sugQueue.top().score;
      }
    }
    SpellCheckResponse.Suggestion suggestion=mergeData.origVsSuggestion.get(original);
    Token token=new Token(original,suggestion.getStartOffset(),suggestion.getEndOffset());
    SuggestWord[] suggestions=new SuggestWord[Math.min(count,sugQueue.size())];
    for (int k=0; k < sugQueue.size() - count; k++)     sugQueue.pop();
    for (int k=Math.min(count,sugQueue.size()) - 1; k >= 0; k--) {
      suggestions[k]=sugQueue.pop();
    }
    if (extendedResults) {
      Integer o=mergeData.origVsFreq.get(original);
      if (o != null)       result.addFrequency(token,o);
      for (      SuggestWord word : suggestions)       result.add(token,word.string,word.freq);
    }
 else {
      List<String> words=new ArrayList<>(sugQueue.size());
      for (      SuggestWord word : suggestions)       words.add(word.string);
      result.add(token,words);
    }
  }
  return result;
}
