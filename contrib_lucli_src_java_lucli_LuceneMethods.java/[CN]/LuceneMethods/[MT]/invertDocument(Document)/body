{
  Map tokenMap=new HashMap();
  final int maxFieldLength=10000;
  Analyzer analyzer=createAnalyzer();
  Iterator fields=doc.getFields().iterator();
  final Token reusableToken=new Token();
  while (fields.hasNext()) {
    Field field=(Field)fields.next();
    String fieldName=field.name();
    if (field.isIndexed()) {
      if (field.isTokenized()) {
        Reader reader;
        if (field.readerValue() != null)         reader=field.readerValue();
 else         if (field.stringValue() != null)         reader=new StringReader(field.stringValue());
 else         throw new IllegalArgumentException("field must have either String or Reader value");
        int position=0;
        TokenStream stream=analyzer.tokenStream(fieldName,reader);
        TermAttribute termAtt=stream.addAttribute(TermAttribute.class);
        PositionIncrementAttribute posIncrAtt=stream.addAttribute(PositionIncrementAttribute.class);
        try {
          while (stream.incrementToken()) {
            position+=(posIncrAtt.getPositionIncrement() - 1);
            position++;
            String name=termAtt.term();
            Integer Count=(Integer)tokenMap.get(name);
            if (Count == null) {
              tokenMap.put(name,new Integer(1));
            }
 else {
              int count=Count.intValue();
              tokenMap.put(name,new Integer(count + 1));
            }
            if (position > maxFieldLength)             break;
          }
        }
  finally {
          stream.close();
        }
      }
    }
  }
  Entry[] sortedHash=getSortedMapEntries(tokenMap);
  for (int ii=0; ii < sortedHash.length && ii < 10; ii++) {
    Entry currentEntry=sortedHash[ii];
    message((ii + 1) + ":" + currentEntry.getKey()+ " "+ currentEntry.getValue());
  }
}
