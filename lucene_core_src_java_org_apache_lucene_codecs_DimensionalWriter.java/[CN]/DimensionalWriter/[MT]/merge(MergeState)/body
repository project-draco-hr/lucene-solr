{
  for (  FieldInfo fieldInfo : mergeState.mergeFieldInfos) {
    if (fieldInfo.getDimensionCount() != 0) {
      writeField(fieldInfo,new DimensionalReader(){
        @Override public void intersect(        String fieldName,        IntersectVisitor mergedVisitor) throws IOException {
          if (fieldName.equals(fieldInfo.name) == false) {
            throw new IllegalArgumentException("field name must match the field being merged");
          }
          for (int i=0; i < mergeState.dimensionalReaders.length; i++) {
            DimensionalReader dimensionalReader=mergeState.dimensionalReaders[i];
            if (dimensionalReader == null) {
              continue;
            }
            MergeState.DocMap docMap=mergeState.docMaps[i];
            int docBase=mergeState.docBase[i];
            dimensionalReader.intersect(fieldInfo.name,new IntersectVisitor(){
              @Override public void visit(              int docID){
                throw new IllegalStateException();
              }
              @Override public void visit(              int docID,              byte[] packedValue) throws IOException {
                int newDocID=docMap.get(docID);
                if (newDocID != -1) {
                  mergedVisitor.visit(docBase + newDocID,packedValue);
                }
              }
              @Override public Relation compare(              byte[] minPackedValue,              byte[] maxPackedValue){
                return Relation.CELL_CROSSES_QUERY;
              }
            }
);
          }
        }
        @Override public void checkIntegrity(){
          throw new UnsupportedOperationException();
        }
        @Override public long ramBytesUsed(){
          return 0L;
        }
        @Override public void close(){
        }
      }
);
    }
  }
}
