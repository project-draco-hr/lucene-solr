{
  final HashSet<SegmentInfo> oldSegments=new HashSet<SegmentInfo>();
  for (  final SegmentInfo si : segmentInfos) {
    if (segmentsToOptimize.contains(si) && shouldUpgradeSegment(si)) {
      oldSegments.add(si);
    }
  }
  if (verbose())   message("findMergesForOptimize: segmentsToUpgrade=" + oldSegments);
  if (oldSegments.isEmpty())   return null;
  MergeSpecification spec=base.findMergesForOptimize(segmentInfos,maxSegmentCount,oldSegments);
  if (spec != null) {
    for (    final OneMerge om : spec.merges) {
      oldSegments.removeAll(om.segments);
    }
  }
  if (!oldSegments.isEmpty()) {
    if (verbose())     message("findMergesForOptimize: " + base.getClass().getSimpleName() + " does not want to merge all old segments, merge remaining ones into new segment: "+ oldSegments);
    final List<SegmentInfo> newInfos=new ArrayList<SegmentInfo>();
    for (    final SegmentInfo si : segmentInfos) {
      if (oldSegments.contains(si)) {
        newInfos.add(si);
      }
    }
    if (spec == null) {
      spec=new MergeSpecification();
    }
    spec.add(new OneMerge(newInfos));
  }
  return spec;
}
