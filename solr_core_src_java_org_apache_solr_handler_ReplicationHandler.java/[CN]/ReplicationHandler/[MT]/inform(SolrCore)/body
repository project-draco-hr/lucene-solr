{
  this.core=core;
  registerFileStreamResponseWriter();
  registerCloseHook();
  Object nbtk=initArgs.get(NUMBER_BACKUPS_TO_KEEP_INIT_PARAM);
  if (nbtk != null) {
    numberBackupsToKeep=Integer.parseInt(nbtk.toString());
  }
 else {
    numberBackupsToKeep=0;
  }
  NamedList slave=(NamedList)initArgs.get("slave");
  boolean enableSlave=isEnabled(slave);
  if (enableSlave) {
    tempSnapPuller=snapPuller=new SnapPuller(slave,this,core);
    isSlave=true;
  }
  NamedList master=(NamedList)initArgs.get("master");
  boolean enableMaster=isEnabled(master);
  if (!enableSlave && !enableMaster) {
    enableMaster=true;
    master=new NamedList<Object>();
  }
  if (enableMaster) {
    includeConfFiles=(String)master.get(CONF_FILES);
    if (includeConfFiles != null && includeConfFiles.trim().length() > 0) {
      List<String> files=Arrays.asList(includeConfFiles.split(","));
      for (      String file : files) {
        if (file.trim().length() == 0)         continue;
        String[] strs=file.trim().split(":");
        confFileNameAlias.add(strs[0],strs.length > 1 ? strs[1] : null);
      }
      LOG.info("Replication enabled for following config files: " + includeConfFiles);
    }
    List backup=master.getAll("backupAfter");
    boolean backupOnCommit=backup.contains("commit");
    boolean backupOnOptimize=!backupOnCommit && backup.contains("optimize");
    List replicateAfter=master.getAll(REPLICATE_AFTER);
    replicateOnCommit=replicateAfter.contains("commit");
    replicateOnOptimize=!replicateOnCommit && replicateAfter.contains("optimize");
    if (!replicateOnCommit && !replicateOnOptimize) {
      replicateOnCommit=true;
    }
    if (replicateOnOptimize) {
      IndexDeletionPolicyWrapper wrapper=core.getDeletionPolicy();
      IndexDeletionPolicy policy=wrapper == null ? null : wrapper.getWrappedDeletionPolicy();
      if (policy instanceof SolrDeletionPolicy) {
        SolrDeletionPolicy solrPolicy=(SolrDeletionPolicy)policy;
        if (solrPolicy.getMaxOptimizedCommitsToKeep() < 1) {
          solrPolicy.setMaxOptimizedCommitsToKeep(1);
        }
      }
 else {
        LOG.warn("Replication can't call setMaxOptimizedCommitsToKeep on " + policy);
      }
    }
    if (replicateOnOptimize || backupOnOptimize) {
      core.getUpdateHandler().registerOptimizeCallback(getEventListener(backupOnOptimize,replicateOnOptimize));
    }
    if (replicateOnCommit || backupOnCommit) {
      replicateOnCommit=true;
      core.getUpdateHandler().registerCommitCallback(getEventListener(backupOnCommit,replicateOnCommit));
    }
    if (replicateAfter.contains("startup")) {
      replicateOnStart=true;
      RefCounted<SolrIndexSearcher> s=core.getNewestSearcher(false);
      try {
        DirectoryReader reader=s == null ? null : s.get().getIndexReader();
        if (reader != null && reader.getIndexCommit() != null && reader.getIndexCommit().getGeneration() != 1L) {
          try {
            if (replicateOnOptimize) {
              Collection<IndexCommit> commits=DirectoryReader.listCommits(reader.directory());
              for (              IndexCommit ic : commits) {
                if (ic.getSegmentCount() == 1) {
                  if (indexCommitPoint == null || indexCommitPoint.getGeneration() < ic.getGeneration())                   indexCommitPoint=ic;
                }
              }
            }
 else {
              indexCommitPoint=reader.getIndexCommit();
            }
          }
  finally {
          }
        }
        core.getUpdateHandler().newIndexWriter(true);
      }
 catch (      IOException e) {
        LOG.warn("Unable to get IndexCommit on startup",e);
      }
 finally {
        if (s != null)         s.decref();
      }
    }
    String reserve=(String)master.get(RESERVE);
    if (reserve != null && !reserve.trim().equals("")) {
      reserveCommitDuration=SnapPuller.readInterval(reserve);
    }
    LOG.info("Commits will be reserved for  " + reserveCommitDuration);
    isMaster=true;
  }
}
