{
  IOException priorE=null;
  IndexInput stream=null, entriesStream=null;
  try {
    stream=handle.openFullSlice();
    final int firstInt=stream.readInt();
    if (firstInt == CodecUtil.CODEC_MAGIC) {
      CodecUtil.checkHeaderNoMagic(stream,CompoundFileWriter.DATA_CODEC,CompoundFileWriter.VERSION_START,CompoundFileWriter.VERSION_START);
      final String entriesFileName=IndexFileNames.segmentFileName(IndexFileNames.stripExtension(name),"",IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);
      entriesStream=dir.openInput(entriesFileName,IOContext.READONCE);
      CodecUtil.checkHeader(entriesStream,CompoundFileWriter.ENTRY_CODEC,CompoundFileWriter.VERSION_START,CompoundFileWriter.VERSION_START);
      final int numEntries=entriesStream.readVInt();
      final Map<String,FileEntry> mapping=new HashMap<String,FileEntry>(numEntries);
      for (int i=0; i < numEntries; i++) {
        final FileEntry fileEntry=new FileEntry();
        final String id=entriesStream.readString();
        FileEntry previous=mapping.put(id,fileEntry);
        if (previous != null) {
          throw new CorruptIndexException("Duplicate cfs entry id=" + id + " in CFS: "+ entriesStream);
        }
        fileEntry.offset=entriesStream.readLong();
        fileEntry.length=entriesStream.readLong();
      }
      return mapping;
    }
 else {
      throw new IndexFormatTooOldException(stream,firstInt,CodecUtil.CODEC_MAGIC,CodecUtil.CODEC_MAGIC);
    }
  }
 catch (  IOException ioe) {
    priorE=ioe;
  }
 finally {
    IOUtils.closeWhileHandlingException(priorE,stream,entriesStream);
  }
  throw new AssertionError("impossible to get here");
}
