{
  if (isDone)   throw new IllegalStateException("Can't call done() more than once");
  if (points.size() < 3)   throw new IllegalArgumentException("Polygon needs at least three points.");
  if (isInternalReturnEdge)   isInternalEdges.set(points.size() - 1);
  isDone=true;
  edges=new SidedPlane[points.size()];
  invertedEdges=new SidedPlane[points.size()];
  notableEdgePoints=new GeoPoint[points.size()][];
  for (int i=0; i < points.size(); i++) {
    final GeoPoint start=points.get(i);
    final GeoPoint end=points.get(legalIndex(i + 1));
    final double distance=start.arcDistance(end);
    if (distance > fullDistance)     fullDistance=distance;
    final GeoPoint check=points.get(legalIndex(i + 2));
    final SidedPlane sp=new SidedPlane(check,false,start,end);
    edges[i]=sp;
    invertedEdges[i]=new SidedPlane(sp);
    notableEdgePoints[i]=new GeoPoint[]{start,end};
  }
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    final SidedPlane edge=edges[edgeIndex];
    for (int pointIndex=0; pointIndex < points.size(); pointIndex++) {
      if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {
        if (edge.isWithin(points.get(pointIndex)))         throw new IllegalArgumentException("Polygon is not concave: Point " + points.get(pointIndex) + " Edge "+ edge);
      }
    }
  }
  eitherBounds=new HashMap<>(edges.length);
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    eitherBounds.put(edges[edgeIndex],new EitherBound(invertedEdges[edgeIndex]));
  }
  edgePoints=new GeoPoint[]{points.get(0)};
}
