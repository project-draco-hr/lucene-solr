{
  if (isDone)   throw new IllegalStateException("Can't call done() more than once");
  if (points.size() < 3)   throw new IllegalArgumentException("Polygon needs at least three points.");
  if (isInternalReturnEdge)   isInternalEdges.set(points.size() - 1);
  isDone=true;
  edges=new SidedPlane[points.size()];
  invertedEdges=new SidedPlane[points.size()];
  notableEdgePoints=new GeoPoint[points.size()][];
  for (int i=0; i < points.size(); i++) {
    final GeoPoint start=points.get(i);
    final GeoPoint end=points.get(legalIndex(i + 1));
    final Plane planeToFind=new Plane(start,end);
    int endPointIndex=-1;
    for (int j=0; j < points.size(); j++) {
      final int index=legalIndex(j + i + 2);
      if (!planeToFind.evaluateIsZero(points.get(index))) {
        endPointIndex=index;
        break;
      }
    }
    if (endPointIndex == -1) {
      throw new IllegalArgumentException("Polygon points are all coplanar");
    }
    final GeoPoint check=points.get(endPointIndex);
    edges[i]=new SidedPlane(check,false,start,end);
    invertedEdges[i]=new SidedPlane(edges[i]);
    notableEdgePoints[i]=new GeoPoint[]{start,end};
  }
  eitherBounds=new HashMap<>(edges.length);
  prevBrotherMap=new HashMap<>(edges.length);
  nextBrotherMap=new HashMap<>(edges.length);
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    final SidedPlane edge=edges[edgeIndex];
    final SidedPlane invertedEdge=invertedEdges[edgeIndex];
    int bound1Index=legalIndex(edgeIndex + 1);
    while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {
      bound1Index++;
    }
    int bound2Index=legalIndex(edgeIndex - 1);
    while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {
      bound2Index--;
    }
    bound1Index=legalIndex(bound1Index);
    bound2Index=legalIndex(bound2Index);
    int startingIndex=bound2Index;
    while (true) {
      startingIndex=legalIndex(startingIndex + 1);
      if (startingIndex == bound1Index) {
        break;
      }
      final GeoPoint interiorPoint=points.get(startingIndex);
      if (!invertedEdges[bound1Index].isWithin(interiorPoint) || !invertedEdges[bound2Index].isWithin(interiorPoint)) {
        throw new IllegalArgumentException("Concave polygon has a side that is more than 180 degrees");
      }
    }
    eitherBounds.put(edge,new EitherBound(invertedEdges[bound1Index],invertedEdges[bound2Index]));
    nextBrotherMap.put(invertedEdge,invertedEdges[bound1Index]);
    prevBrotherMap.put(invertedEdge,invertedEdges[bound2Index]);
  }
  int edgePointCount=1;
  if (holes != null) {
    for (    final GeoPolygon hole : holes) {
      edgePointCount+=hole.getEdgePoints().length;
    }
  }
  edgePoints=new GeoPoint[edgePointCount];
  edgePointCount=0;
  edgePoints[edgePointCount++]=points.get(0);
  if (holes != null) {
    for (    final GeoPolygon hole : holes) {
      final GeoPoint[] holeEdgePoints=hole.getEdgePoints();
      for (      final GeoPoint p : holeEdgePoints) {
        edgePoints[edgePointCount++]=p;
      }
    }
  }
  if (isWithinHoles(points.get(0))) {
    throw new IllegalArgumentException("Polygon edge intersects a polygon hole; not allowed");
  }
}
