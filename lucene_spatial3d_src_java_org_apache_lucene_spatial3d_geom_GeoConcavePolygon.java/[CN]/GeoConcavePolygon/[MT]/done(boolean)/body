{
  if (isDone)   throw new IllegalStateException("Can't call done() more than once");
  if (points.size() < 3)   throw new IllegalArgumentException("Polygon needs at least three points.");
  if (isInternalReturnEdge)   isInternalEdges.set(points.size() - 1);
  isDone=true;
  edges=new SidedPlane[points.size()];
  invertedEdges=new SidedPlane[points.size()];
  notableEdgePoints=new GeoPoint[points.size()][];
  for (int i=0; i < points.size(); i++) {
    final GeoPoint start=points.get(i);
    final GeoPoint end=points.get(legalIndex(i + 1));
    final Plane planeToFind=new Plane(start,end);
    int endPointIndex=-1;
    for (int j=0; j < points.size(); j++) {
      final int index=legalIndex(j + i + 2);
      if (!planeToFind.evaluateIsZero(points.get(index))) {
        endPointIndex=index;
        break;
      }
    }
    if (endPointIndex == -1) {
      throw new IllegalArgumentException("Polygon points are all coplanar");
    }
    final GeoPoint check=points.get(endPointIndex);
    edges[i]=new SidedPlane(check,false,start,end);
    invertedEdges[i]=new SidedPlane(edges[i]);
    notableEdgePoints[i]=new GeoPoint[]{start,end};
  }
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    final SidedPlane edge=edges[edgeIndex];
    for (int pointIndex=0; pointIndex < points.size(); pointIndex++) {
      if (pointIndex != edgeIndex && pointIndex != legalIndex(edgeIndex + 1)) {
        if (edge.isWithin(points.get(pointIndex)))         throw new IllegalArgumentException("Polygon is not concave: Point " + points.get(pointIndex) + " Edge "+ edge);
      }
    }
  }
  eitherBounds=new HashMap<>(edges.length);
  for (int edgeIndex=0; edgeIndex < edges.length; edgeIndex++) {
    final SidedPlane edge=edges[edgeIndex];
    final SidedPlane invertedEdge=invertedEdges[edgeIndex];
    int bound1Index=legalIndex(edgeIndex + 1);
    while (invertedEdges[legalIndex(bound1Index)].isNumericallyIdentical(invertedEdge)) {
      bound1Index++;
    }
    int bound2Index=legalIndex(edgeIndex - 1);
    while (invertedEdges[legalIndex(bound2Index)].isNumericallyIdentical(invertedEdge)) {
      bound2Index--;
    }
    eitherBounds.put(edge,new EitherBound(invertedEdges[legalIndex(bound1Index)],invertedEdges[legalIndex(bound2Index)]));
  }
  edgePoints=new GeoPoint[]{points.get(0)};
}
