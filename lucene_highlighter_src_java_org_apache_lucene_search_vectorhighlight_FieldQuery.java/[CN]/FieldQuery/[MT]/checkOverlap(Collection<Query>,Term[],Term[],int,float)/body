{
  for (int i=1; i < src.length; i++) {
    boolean overlap=true;
    for (int j=i; j < src.length; j++) {
      if ((j - i) < dest.length && !src[j].text().equals(dest[j - i].text())) {
        overlap=false;
        break;
      }
    }
    if (overlap && src.length - i < dest.length) {
      PhraseQuery.Builder pqBuilder=new PhraseQuery.Builder();
      for (      Term srcTerm : src)       pqBuilder.add(srcTerm);
      for (int k=src.length - i; k < dest.length; k++) {
        pqBuilder.add(new Term(src[0].field(),dest[k].text()));
      }
      pqBuilder.setSlop(slop);
      PhraseQuery pq=pqBuilder.build();
      pq.setBoost(boost);
      if (!expandQueries.contains(pq))       expandQueries.add(pq);
    }
  }
}
