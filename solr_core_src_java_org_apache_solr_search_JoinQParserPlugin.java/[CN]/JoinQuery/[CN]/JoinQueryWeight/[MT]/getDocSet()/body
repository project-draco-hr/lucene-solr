{
  OpenBitSet resultBits=null;
  int minDocFreqFrom=Math.max(5,fromSearcher.maxDoc() >> 13);
  int minDocFreqTo=Math.max(5,toSearcher.maxDoc() >> 13);
  int maxSortedIntSize=Math.max(10,toSearcher.maxDoc() >> 10);
  DocSet fromSet=fromSearcher.getDocSet(q);
  fromSetSize=fromSet.size();
  List<DocSet> resultList=new ArrayList<DocSet>(10);
  DocSet fastForRandomSet=fromSet;
  if (minDocFreqFrom > 0 && fromSet instanceof SortedIntDocSet) {
    SortedIntDocSet sset=(SortedIntDocSet)fromSet;
    fastForRandomSet=new HashDocSet(sset.getDocs(),0,sset.size());
  }
  Fields fromFields=fromSearcher.getAtomicReader().fields();
  Fields toFields=fromSearcher == toSearcher ? fromFields : toSearcher.getAtomicReader().fields();
  if (fromFields == null)   return DocSet.EMPTY;
  Terms terms=fromFields.terms(fromField);
  Terms toTerms=toFields.terms(toField);
  if (terms == null || toTerms == null)   return DocSet.EMPTY;
  String prefixStr=TrieField.getMainValuePrefix(fromSearcher.getSchema().getFieldType(fromField));
  BytesRef prefix=prefixStr == null ? null : new BytesRef(prefixStr);
  BytesRef term=null;
  TermsEnum termsEnum=terms.iterator(null);
  TermsEnum toTermsEnum=toTerms.iterator(null);
  SolrIndexSearcher.DocsEnumState fromDeState=null;
  SolrIndexSearcher.DocsEnumState toDeState=null;
  if (prefix == null) {
    term=termsEnum.next();
  }
 else {
    if (termsEnum.seekCeil(prefix,true) != TermsEnum.SeekStatus.END) {
      term=termsEnum.term();
    }
  }
  Bits fromLiveDocs=fromSearcher.getAtomicReader().getLiveDocs();
  Bits toLiveDocs=fromSearcher == toSearcher ? fromLiveDocs : toSearcher.getAtomicReader().getLiveDocs();
  fromDeState=new SolrIndexSearcher.DocsEnumState();
  fromDeState.fieldName=fromField;
  fromDeState.liveDocs=fromLiveDocs;
  fromDeState.termsEnum=termsEnum;
  fromDeState.docsEnum=null;
  fromDeState.minSetSizeCached=minDocFreqFrom;
  toDeState=new SolrIndexSearcher.DocsEnumState();
  toDeState.fieldName=toField;
  toDeState.liveDocs=toLiveDocs;
  toDeState.termsEnum=toTermsEnum;
  toDeState.docsEnum=null;
  toDeState.minSetSizeCached=minDocFreqTo;
  while (term != null) {
    if (prefix != null && !StringHelper.startsWith(term,prefix))     break;
    fromTermCount++;
    boolean intersects=false;
    int freq=termsEnum.docFreq();
    fromTermTotalDf++;
    if (freq < minDocFreqFrom) {
      fromTermDirectCount++;
      fromDeState.docsEnum=fromDeState.termsEnum.docs(null,fromDeState.docsEnum,0);
      DocsEnum docsEnum=fromDeState.docsEnum;
      if (docsEnum instanceof MultiDocsEnum) {
        MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
        int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
        outer:         for (int subindex=0; subindex < numSubs; subindex++) {
          MultiDocsEnum.EnumWithSlice sub=subs[subindex];
          if (sub.docsEnum == null)           continue;
          int base=sub.slice.start;
          int docid;
          while ((docid=sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
            if (fastForRandomSet.exists(docid + base)) {
              intersects=true;
              break outer;
            }
          }
        }
      }
 else {
        int docid;
        while ((docid=docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          if (fastForRandomSet.exists(docid)) {
            intersects=true;
            break;
          }
        }
      }
    }
 else {
      DocSet fromTermSet=fromSearcher.getDocSet(fromDeState);
      intersects=fromSet.intersects(fromTermSet);
    }
    if (intersects) {
      fromTermHits++;
      fromTermHitsTotalDf++;
      TermsEnum.SeekStatus status=toTermsEnum.seekCeil(term);
      if (status == TermsEnum.SeekStatus.END)       break;
      if (status == TermsEnum.SeekStatus.FOUND) {
        toTermHits++;
        int df=toTermsEnum.docFreq();
        toTermHitsTotalDf+=df;
        if (resultBits == null && df + resultListDocs > maxSortedIntSize && resultList.size() > 0) {
          resultBits=new OpenBitSet(toSearcher.maxDoc());
        }
        if (toTermsEnum.docFreq() >= minDocFreqTo || resultBits == null) {
          DocSet toTermSet=toSearcher.getDocSet(toDeState);
          resultListDocs+=toTermSet.size();
          if (resultBits != null) {
            toTermSet.setBitsOn(resultBits);
          }
 else {
            if (toTermSet instanceof BitDocSet) {
              resultBits=(OpenBitSet)((BitDocSet)toTermSet).bits.clone();
            }
 else {
              resultList.add(toTermSet);
            }
          }
        }
 else {
          toTermDirectCount++;
          toDeState.docsEnum=toDeState.termsEnum.docs(toDeState.liveDocs,toDeState.docsEnum,0);
          DocsEnum docsEnum=toDeState.docsEnum;
          if (docsEnum instanceof MultiDocsEnum) {
            MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
            int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
            for (int subindex=0; subindex < numSubs; subindex++) {
              MultiDocsEnum.EnumWithSlice sub=subs[subindex];
              if (sub.docsEnum == null)               continue;
              int base=sub.slice.start;
              int docid;
              while ((docid=sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
                resultListDocs++;
                resultBits.fastSet(docid + base);
              }
            }
          }
 else {
            int docid;
            while ((docid=docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
              resultListDocs++;
              resultBits.fastSet(docid);
            }
          }
        }
      }
    }
    term=termsEnum.next();
  }
  smallSetsDeferred=resultList.size();
  if (resultBits != null) {
    for (    DocSet set : resultList) {
      set.setBitsOn(resultBits);
    }
    return new BitDocSet(resultBits);
  }
  if (resultList.size() == 0) {
    return DocSet.EMPTY;
  }
  if (resultList.size() == 1) {
    return resultList.get(0);
  }
  int sz=0;
  for (  DocSet set : resultList)   sz+=set.size();
  int[] docs=new int[sz];
  int pos=0;
  for (  DocSet set : resultList) {
    System.arraycopy(((SortedIntDocSet)set).getDocs(),0,docs,pos,set.size());
    pos+=set.size();
  }
  Arrays.sort(docs);
  int[] dedup=new int[sz];
  pos=0;
  int last=-1;
  for (  int doc : docs) {
    if (doc != last)     dedup[pos++]=doc;
    last=doc;
  }
  if (pos != dedup.length) {
    dedup=Arrays.copyOf(dedup,pos);
  }
  return new SortedIntDocSet(dedup,dedup.length);
}
