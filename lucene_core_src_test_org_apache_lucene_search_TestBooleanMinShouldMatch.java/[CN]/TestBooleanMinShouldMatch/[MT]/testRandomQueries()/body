{
  String field="data";
  String[] vals={"1","2","3","4","5","6","A","Z","B","Y","Z","X","foo"};
  int maxLev=4;
  TestBoolean2.Callback minNrCB=new TestBoolean2.Callback(){
    public void postCreate(    BooleanQuery q){
      BooleanClause[] c=q.getClauses();
      int opt=0;
      for (int i=0; i < c.length; i++) {
        if (c[i].getOccur() == BooleanClause.Occur.SHOULD)         opt++;
      }
      q.setMinimumNumberShouldMatch(random.nextInt(opt + 2));
    }
  }
;
  int num=atLeast(10);
  for (int i=0; i < num; i++) {
    int lev=random.nextInt(maxLev);
    final long seed=random.nextLong();
    BooleanQuery q1=TestBoolean2.randBoolQuery(new Random(seed),true,lev,field,vals,null);
    BooleanQuery q2=TestBoolean2.randBoolQuery(new Random(seed),true,lev,field,vals,null);
    minNrCB.postCreate(q2);
    TopDocs top1=s.search(q1,null,100);
    TopDocs top2=s.search(q2,null,100);
    if (i < 100) {
      QueryUtils.check(random,q1,s);
      QueryUtils.check(random,q2,s);
    }
    if (top2.totalHits > top1.totalHits) {
      fail("Constrained results not a subset:\n" + CheckHits.topdocsString(top1,0,0) + CheckHits.topdocsString(top2,0,0)+ "for query:"+ q2.toString());
    }
    for (int hit=0; hit < top2.totalHits; hit++) {
      int id=top2.scoreDocs[hit].doc;
      float score=top2.scoreDocs[hit].score;
      boolean found=false;
      for (int other=0; other < top1.totalHits; other++) {
        if (top1.scoreDocs[other].doc == id) {
          found=true;
          float otherScore=top1.scoreDocs[other].score;
          assertEquals("Doc " + id + " scores don't match\n"+ CheckHits.topdocsString(top1,0,0)+ CheckHits.topdocsString(top2,0,0)+ "for query:"+ q2.toString(),score,otherScore,CheckHits.explainToleranceDelta(score,otherScore));
        }
      }
      if (!found)       fail("Doc " + id + " not found\n"+ CheckHits.topdocsString(top1,0,0)+ CheckHits.topdocsString(top2,0,0)+ "for query:"+ q2.toString());
    }
  }
}
