{
  final SolrParams params=req.getParams();
  String cname=params.get(CoreAdminParams.CORE);
  if (cname == null) {
    cname="";
  }
  String nodeName=params.get("nodeName");
  String coreNodeName=params.get("coreNodeName");
  String waitForState=params.get("state");
  Boolean checkLive=params.getBool("checkLive");
  Boolean onlyIfLeader=params.getBool("onlyIfLeader");
  Boolean onlyIfLeaderActive=params.getBool("onlyIfLeaderActive");
  log.info("Going to wait for coreNodeName: " + coreNodeName + ", state: "+ waitForState+ ", checkLive: "+ checkLive+ ", onlyIfLeader: "+ onlyIfLeader+ ", onlyIfLeaderActive: "+ onlyIfLeaderActive);
  int maxTries=0;
  String state=null;
  boolean live=false;
  int retry=0;
  while (true) {
    try (SolrCore core=coreContainer.getCore(cname)){
      if (core == null && retry == 30) {
        throw new SolrException(ErrorCode.BAD_REQUEST,"core not found:" + cname);
      }
      if (core != null) {
        if (onlyIfLeader != null && onlyIfLeader) {
          if (!core.getCoreDescriptor().getCloudDescriptor().isLeader()) {
            throw new SolrException(ErrorCode.BAD_REQUEST,"We are not the leader");
          }
        }
        CloudDescriptor cloudDescriptor=core.getCoreDescriptor().getCloudDescriptor();
        if (retry % 15 == 0) {
          if (retry > 0 && log.isInfoEnabled())           log.info("After " + retry + " seconds, core "+ cname+ " ("+ cloudDescriptor.getShardId()+ " of "+ cloudDescriptor.getCollectionName()+ ") still does not have state: "+ waitForState+ "; forcing ClusterState update from ZooKeeper");
          coreContainer.getZkController().getZkStateReader().updateClusterState(true);
        }
        if (maxTries == 0) {
          int conflictWaitMs=coreContainer.getZkController().getLeaderConflictResolveWait();
          maxTries=(int)Math.round(conflictWaitMs / 1000) + 3;
          log.info("Will wait a max of " + maxTries + " seconds to see "+ cname+ " ("+ cloudDescriptor.getShardId()+ " of "+ cloudDescriptor.getCollectionName()+ ") have state: "+ waitForState);
        }
        ClusterState clusterState=coreContainer.getZkController().getClusterState();
        String collection=cloudDescriptor.getCollectionName();
        Slice slice=clusterState.getSlice(collection,cloudDescriptor.getShardId());
        if (slice != null) {
          ZkNodeProps nodeProps=slice.getReplicasMap().get(coreNodeName);
          if (nodeProps != null) {
            state=nodeProps.getStr(ZkStateReader.STATE_PROP);
            live=clusterState.liveNodesContain(nodeName);
            String localState=cloudDescriptor.getLastPublished();
            boolean leaderDoesNotNeedRecovery=(onlyIfLeader != null && onlyIfLeader && core.getName().equals(nodeProps.getStr("core")) && ZkStateReader.RECOVERING.equals(waitForState) && ZkStateReader.ACTIVE.equals(localState) && ZkStateReader.ACTIVE.equals(state));
            if (leaderDoesNotNeedRecovery) {
              log.warn("Leader " + core.getName() + " ignoring request to be in the recovering state because it is live and active.");
            }
            boolean onlyIfActiveCheckResult=onlyIfLeaderActive != null && onlyIfLeaderActive && (localState == null || !localState.equals(ZkStateReader.ACTIVE));
            log.info("In WaitForState(" + waitForState + "): collection="+ collection+ ", shard="+ slice.getName()+ ", thisCore="+ core.getName()+ ", leaderDoesNotNeedRecovery="+ leaderDoesNotNeedRecovery+ ", isLeader? "+ core.getCoreDescriptor().getCloudDescriptor().isLeader()+ ", live="+ live+ ", checkLive="+ checkLive+ ", currentState="+ state+ ", localState="+ localState+ ", nodeName="+ nodeName+ ", coreNodeName="+ coreNodeName+ ", onlyIfActiveCheckResult="+ onlyIfActiveCheckResult+ ", nodeProps: "+ nodeProps);
            if (!onlyIfActiveCheckResult && nodeProps != null && (state.equals(waitForState) || leaderDoesNotNeedRecovery)) {
              if (checkLive == null) {
                break;
              }
 else               if (checkLive && live) {
                break;
              }
 else               if (!checkLive && !live) {
                break;
              }
            }
          }
        }
      }
      if (retry++ == maxTries) {
        String collection=null;
        String leaderInfo=null;
        String shardId=null;
        try {
          CloudDescriptor cloudDescriptor=core.getCoreDescriptor().getCloudDescriptor();
          collection=cloudDescriptor.getCollectionName();
          shardId=cloudDescriptor.getShardId();
          leaderInfo=coreContainer.getZkController().getZkStateReader().getLeaderUrl(collection,shardId,5000);
        }
 catch (        Exception exc) {
          leaderInfo="Not available due to: " + exc;
        }
        throw new SolrException(ErrorCode.BAD_REQUEST,"I was asked to wait on state " + waitForState + " for "+ shardId+ " in "+ collection+ " on "+ nodeName+ " but I still do not see the requested state. I see state: "+ state+ " live:"+ live+ " leader from ZK: "+ leaderInfo);
      }
      if (coreContainer.isShutDown()) {
        throw new SolrException(ErrorCode.BAD_REQUEST,"Solr is shutting down");
      }
      if (log.isDebugEnabled()) {
        try {
          LocalSolrQueryRequest r=new LocalSolrQueryRequest(core,new ModifiableSolrParams());
          CommitUpdateCommand commitCmd=new CommitUpdateCommand(r,false);
          commitCmd.softCommit=true;
          core.getUpdateHandler().commit(commitCmd);
          RefCounted<SolrIndexSearcher> searchHolder=core.getNewestSearcher(false);
          SolrIndexSearcher searcher=searchHolder.get();
          try {
            log.debug(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + " to replicate " + searcher.search(new MatchAllDocsQuery(),1).totalHits+ " gen:"+ core.getDeletionPolicy().getLatestCommit().getGeneration()+ " data:"+ core.getDataDir());
          }
  finally {
            searchHolder.decref();
          }
        }
 catch (        Exception e) {
          throw new SolrException(ErrorCode.SERVER_ERROR,null,e);
        }
      }
    }
     Thread.sleep(1000);
  }
  log.info("Waited coreNodeName: " + coreNodeName + ", state: "+ waitForState+ ", checkLive: "+ checkLive+ ", onlyIfLeader: "+ onlyIfLeader+ " for: "+ retry+ " seconds.");
}
