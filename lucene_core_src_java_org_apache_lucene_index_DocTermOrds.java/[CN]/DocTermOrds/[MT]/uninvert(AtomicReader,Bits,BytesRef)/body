{
  final FieldInfo info=reader.getFieldInfos().fieldInfo(field);
  if (info != null && info.hasDocValues()) {
    throw new IllegalStateException("Type mismatch: " + field + " was indexed as "+ info.getDocValuesType());
  }
  final long startTime=System.currentTimeMillis();
  prefix=termPrefix == null ? null : BytesRef.deepCopyOf(termPrefix);
  final int maxDoc=reader.maxDoc();
  final int[] index=new int[maxDoc];
  final int[] lastTerm=new int[maxDoc];
  final byte[][] bytes=new byte[maxDoc][];
  final Fields fields=reader.fields();
  if (fields == null) {
    return;
  }
  final Terms terms=fields.terms(field);
  if (terms == null) {
    return;
  }
  final TermsEnum te=terms.iterator(null);
  final BytesRef seekStart=termPrefix != null ? termPrefix : new BytesRef();
  if (te.seekCeil(seekStart) == TermsEnum.SeekStatus.END) {
    return;
  }
  List<BytesRef> indexedTerms=null;
  PagedBytes indexedTermsBytes=null;
  boolean testedOrd=false;
  byte[] tempArr=new byte[12];
  int termNum=0;
  docsEnum=null;
  for (; ; ) {
    final BytesRef t=te.term();
    if (t == null || (termPrefix != null && !StringHelper.startsWith(t,termPrefix))) {
      break;
    }
    if (!testedOrd) {
      try {
        ordBase=(int)te.ord();
      }
 catch (      UnsupportedOperationException uoe) {
        indexedTerms=new ArrayList<>();
        indexedTermsBytes=new PagedBytes(15);
      }
      testedOrd=true;
    }
    visitTerm(te,termNum);
    if (indexedTerms != null && (termNum & indexIntervalMask) == 0) {
      sizeOfIndexedStrings+=t.length;
      BytesRef indexedTerm=new BytesRef();
      indexedTermsBytes.copy(t,indexedTerm);
      indexedTerms.add(indexedTerm);
    }
    final int df=te.docFreq();
    if (df <= maxTermDocFreq) {
      docsEnum=te.docs(liveDocs,docsEnum,DocsEnum.FLAG_NONE);
      int actualDF=0;
      for (; ; ) {
        int doc=docsEnum.nextDoc();
        if (doc == DocIdSetIterator.NO_MORE_DOCS) {
          break;
        }
        actualDF++;
        termInstances++;
        int delta=termNum - lastTerm[doc] + TNUM_OFFSET;
        lastTerm[doc]=termNum;
        int val=index[doc];
        if ((val & 0xff) == 1) {
          int pos=val >>> 8;
          int ilen=vIntSize(delta);
          byte[] arr=bytes[doc];
          int newend=pos + ilen;
          if (newend > arr.length) {
            int newLen=(newend + 3) & 0xfffffffc;
            byte[] newarr=new byte[newLen];
            System.arraycopy(arr,0,newarr,0,pos);
            arr=newarr;
            bytes[doc]=newarr;
          }
          pos=writeInt(delta,arr,pos);
          index[doc]=(pos << 8) | 1;
        }
 else {
          int ipos;
          if (val == 0) {
            ipos=0;
          }
 else           if ((val & 0x0000ff80) == 0) {
            ipos=1;
          }
 else           if ((val & 0x00ff8000) == 0) {
            ipos=2;
          }
 else           if ((val & 0xff800000) == 0) {
            ipos=3;
          }
 else {
            ipos=4;
          }
          int endPos=writeInt(delta,tempArr,ipos);
          if (endPos <= 4) {
            for (int j=ipos; j < endPos; j++) {
              val|=(tempArr[j] & 0xff) << (j << 3);
            }
            index[doc]=val;
          }
 else {
            for (int j=0; j < ipos; j++) {
              tempArr[j]=(byte)val;
              val>>>=8;
            }
            index[doc]=(endPos << 8) | 1;
            bytes[doc]=tempArr;
            tempArr=new byte[12];
          }
        }
      }
      setActualDocFreq(termNum,actualDF);
    }
    termNum++;
    if (te.next() == null) {
      break;
    }
  }
  numTermsInField=termNum;
  long midPoint=System.currentTimeMillis();
  if (termInstances == 0) {
    tnums=null;
  }
 else {
    this.index=index;
    for (int pass=0; pass < 256; pass++) {
      byte[] target=tnums[pass];
      int pos=0;
      if (target != null) {
        pos=target.length;
      }
 else {
        target=new byte[4096];
      }
      for (int docbase=pass << 16; docbase < maxDoc; docbase+=(1 << 24)) {
        int lim=Math.min(docbase + (1 << 16),maxDoc);
        for (int doc=docbase; doc < lim; doc++) {
          int val=index[doc];
          if ((val & 0xff) == 1) {
            int len=val >>> 8;
            index[doc]=(pos << 8) | 1;
            if ((pos & 0xff000000) != 0) {
              throw new IllegalStateException("Too many values for UnInvertedField faceting on field " + field);
            }
            byte[] arr=bytes[doc];
            bytes[doc]=null;
            if (target.length <= pos + len) {
              int newlen=target.length;
              while (newlen <= pos + len)               newlen<<=1;
              byte[] newtarget=new byte[newlen];
              System.arraycopy(target,0,newtarget,0,pos);
              target=newtarget;
            }
            System.arraycopy(arr,0,target,pos,len);
            pos+=len + 1;
          }
        }
      }
      if (pos < target.length) {
        byte[] newtarget=new byte[pos];
        System.arraycopy(target,0,newtarget,0,pos);
        target=newtarget;
      }
      tnums[pass]=target;
      if ((pass << 16) > maxDoc)       break;
    }
  }
  if (indexedTerms != null) {
    indexedTermsArray=indexedTerms.toArray(new BytesRef[indexedTerms.size()]);
  }
  long endTime=System.currentTimeMillis();
  total_time=(int)(endTime - startTime);
  phase1_time=(int)(midPoint - startTime);
}
