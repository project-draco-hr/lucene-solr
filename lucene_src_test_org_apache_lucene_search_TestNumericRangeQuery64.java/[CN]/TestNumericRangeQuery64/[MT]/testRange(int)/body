{
  String field="field" + precisionStep;
  int count=3000;
  long lower=(distance * 3 / 2) + startOffset, upper=lower + count * distance + (distance / 3);
  NumericRangeQuery<Long> q=NumericRangeQuery.newLongRange(field,precisionStep,lower,upper,true,true);
  NumericRangeFilter<Long> f=NumericRangeFilter.newLongRange(field,precisionStep,lower,upper,true,true);
  int lastTerms=0;
  for (byte i=0; i < 3; i++) {
    TopDocs topDocs;
    int terms;
    String type;
    q.clearTotalNumberOfTerms();
    f.clearTotalNumberOfTerms();
switch (i) {
case 0:
      type=" (constant score filter rewrite)";
    q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);
  topDocs=searcher.search(q,null,noDocs,Sort.INDEXORDER);
terms=q.getTotalNumberOfTerms();
break;
case 1:
type=" (constant score boolean rewrite)";
q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE);
topDocs=searcher.search(q,null,noDocs,Sort.INDEXORDER);
terms=q.getTotalNumberOfTerms();
break;
case 2:
type=" (filter)";
topDocs=searcher.search(new MatchAllDocsQuery(),f,noDocs,Sort.INDEXORDER);
terms=f.getTotalNumberOfTerms();
break;
default :
return;
}
if (VERBOSE) System.out.println("Found " + terms + " distinct terms in range for field '"+ field+ "'"+ type+ ".");
ScoreDoc[] sd=topDocs.scoreDocs;
assertNotNull(sd);
assertEquals("Score doc count" + type,count,sd.length);
Document doc=searcher.doc(sd[0].doc);
assertEquals("First doc" + type,2 * distance + startOffset,Long.parseLong(doc.get(field)));
doc=searcher.doc(sd[sd.length - 1].doc);
assertEquals("Last doc" + type,(1 + count) * distance + startOffset,Long.parseLong(doc.get(field)));
if (i > 0 && searcher.getIndexReader().getSequentialSubReaders().length == 1) {
assertEquals("Distinct term number is equal for all query types",lastTerms,terms);
}
lastTerms=terms;
}
}
