{
  maybeYield();
  maybeThrowDeterministicException();
  if (crashed) {
    throw new IOException("cannot rename after crash");
  }
  if (openFiles.containsKey(source)) {
    if (assertNoDeleteOpenFile) {
      throw (AssertionError)fillOpenTrace(new AssertionError("MockDirectoryWrapper: source file \"" + source + "\" is still open: cannot rename"),source,true);
    }
 else     if (noDeleteOpenFile) {
      throw (IOException)fillOpenTrace(new IOException("MockDirectoryWrapper: source file \"" + source + "\" is still open: cannot rename"),source,true);
    }
  }
  if (openFiles.containsKey(dest)) {
    if (assertNoDeleteOpenFile) {
      throw (AssertionError)fillOpenTrace(new AssertionError("MockDirectoryWrapper: dest file \"" + dest + "\" is still open: cannot rename"),dest,true);
    }
 else     if (noDeleteOpenFile) {
      throw (IOException)fillOpenTrace(new IOException("MockDirectoryWrapper: dest file \"" + dest + "\" is still open: cannot rename"),dest,true);
    }
  }
  if (createdFiles.contains(dest)) {
    throw new IOException("MockDirectoryWrapper: dest file \"" + dest + "\" already exists: cannot rename");
  }
  boolean success=false;
  try {
    in.renameFile(source,dest);
    success=true;
  }
  finally {
    if (success) {
      if (unSyncedFiles.contains(source)) {
        unSyncedFiles.remove(source);
        unSyncedFiles.add(dest);
      }
      openFilesDeleted.remove(source);
      triedToDelete.remove(dest);
      createdFiles.add(dest);
    }
  }
}
