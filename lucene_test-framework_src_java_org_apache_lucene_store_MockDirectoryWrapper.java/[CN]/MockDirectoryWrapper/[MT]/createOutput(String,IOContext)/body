{
  maybeThrowDeterministicException();
  maybeThrowIOExceptionOnOpen(name);
  maybeYield();
  if (failOnCreateOutput) {
    maybeThrowDeterministicException();
  }
  if (crashed) {
    throw new IOException("cannot createOutput after crash");
  }
  init();
synchronized (this) {
    if (preventDoubleWrite && createdFiles.contains(name) && !name.equals("segments.gen")) {
      throw new IOException("file \"" + name + "\" was already written to");
    }
  }
  if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {
    if (!assertNoDeleteOpenFile) {
      throw new IOException("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot overwrite");
    }
 else {
      throw new AssertionError("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot overwrite");
    }
  }
  unSyncedFiles.add(name);
  createdFiles.add(name);
  triedToDelete.remove(name);
  if (in instanceof RAMDirectory) {
    RAMDirectory ramdir=(RAMDirectory)in;
    RAMFile file=new RAMFile(ramdir);
    RAMFile existing=ramdir.fileMap.get(name);
    if (existing != null && !name.equals("segments.gen") && preventDoubleWrite) {
      throw new IOException("file " + name + " already exists");
    }
 else {
      if (existing != null) {
        ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);
        existing.directory=null;
      }
      ramdir.fileMap.put(name,file);
    }
  }
  IndexOutput delegateOutput=in.createOutput(name,LuceneTestCase.newIOContext(randomState,context));
  final IndexOutput io=new MockIndexOutputWrapper(this,delegateOutput,name);
  addFileHandle(io,name,Handle.Output);
  openFilesForWrite.add(name);
  if (throttling == Throttling.ALWAYS || (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockDirectoryWrapper: throttling indexOutput (" + name + ")");
    }
    return throttledOutput.newFromDelegate(io);
  }
 else {
    return io;
  }
}
