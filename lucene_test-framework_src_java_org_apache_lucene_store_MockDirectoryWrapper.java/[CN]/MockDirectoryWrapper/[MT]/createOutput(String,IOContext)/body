{
  maybeThrowDeterministicException();
  maybeThrowIOExceptionOnOpen(name);
  maybeYield();
  if (failOnCreateOutput) {
    maybeThrowDeterministicException();
  }
  if (crashed) {
    throw new IOException("cannot createOutput after crash");
  }
  init();
synchronized (this) {
    if (createdFiles.contains(name) && !name.equals("segments.gen")) {
      throw new IOException("file \"" + name + "\" was already written to");
    }
  }
  if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {
    throw new AssertionError("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot overwrite");
  }
  unSyncedFiles.add(name);
  createdFiles.add(name);
  IndexOutput delegateOutput=in.createOutput(name,LuceneTestCase.newIOContext(randomState,context));
  final IndexOutput io=new MockIndexOutputWrapper(this,delegateOutput,name);
  addFileHandle(io,name,Handle.Output);
  openFilesForWrite.add(name);
  if (throttling == Throttling.ALWAYS || (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockDirectoryWrapper: throttling indexOutput (" + name + ")");
    }
    return throttledOutput.newFromDelegate(io);
  }
 else {
    return io;
  }
}
