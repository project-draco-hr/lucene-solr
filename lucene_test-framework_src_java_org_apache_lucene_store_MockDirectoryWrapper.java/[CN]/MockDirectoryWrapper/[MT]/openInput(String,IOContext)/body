{
  maybeThrowDeterministicException();
  maybeThrowIOExceptionOnOpen(name);
  maybeYield();
  if (failOnOpenInput) {
    maybeThrowDeterministicException();
  }
  if (!LuceneTestCase.slowFileExists(in,name)) {
    throw randomState.nextBoolean() ? new FileNotFoundException(name + " in dir=" + in) : new NoSuchFileException(name + " in dir=" + in);
  }
  if (!allowReadingFilesStillOpenForWrite && openFilesForWrite.contains(name) && !name.startsWith("segments")) {
    throw (IOException)fillOpenTrace(new IOException("MockDirectoryWrapper: file \"" + name + "\" is still open for writing"),name,false);
  }
  IndexInput delegateInput=in.openInput(name,LuceneTestCase.newIOContext(randomState,context));
  final IndexInput ii;
  int randomInt=randomState.nextInt(500);
  if (useSlowOpenClosers && randomInt == 0) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockDirectoryWrapper: using SlowClosingMockIndexInputWrapper for file " + name);
    }
    ii=new SlowClosingMockIndexInputWrapper(this,name,delegateInput);
  }
 else   if (useSlowOpenClosers && randomInt == 1) {
    if (LuceneTestCase.VERBOSE) {
      System.out.println("MockDirectoryWrapper: using SlowOpeningMockIndexInputWrapper for file " + name);
    }
    ii=new SlowOpeningMockIndexInputWrapper(this,name,delegateInput);
  }
 else {
    ii=new MockIndexInputWrapper(this,name,delegateInput,null);
  }
  addFileHandle(ii,name,Handle.Input);
  return ii;
}
