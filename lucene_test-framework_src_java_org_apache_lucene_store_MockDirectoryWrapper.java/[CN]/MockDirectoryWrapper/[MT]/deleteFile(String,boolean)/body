{
  maybeYield();
  maybeThrowDeterministicException();
  if (crashed && !forced)   throw new IOException("cannot delete after crash");
  if (unSyncedFiles.contains(name))   unSyncedFiles.remove(name);
  if (!forced && (noDeleteOpenFile || assertNoDeleteOpenFile)) {
    if (openFiles.containsKey(name)) {
      openFilesDeleted.add(name);
      if (!assertNoDeleteOpenFile) {
        throw (IOException)fillOpenTrace(new IOException("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot delete"),name,true);
      }
 else {
        throw (AssertionError)fillOpenTrace(new AssertionError("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot delete"),name,true);
      }
    }
 else {
      openFilesDeleted.remove(name);
    }
  }
  if (!forced && enableVirusScanner && (randomState.nextInt(4) == 0)) {
    triedToDelete.add(name);
    if (LuceneTestCase.VERBOSE) {
      System.out.println(Thread.currentThread().getName() + ": MDW: now refuse to delete file: " + name+ " this="+ this);
    }
    throw new IOException("cannot delete file: " + name + ", a virus scanner has it open (exists?="+ LuceneTestCase.slowFileExists(in,name));
  }
  triedToDelete.remove(name);
  in.deleteFile(name);
}
