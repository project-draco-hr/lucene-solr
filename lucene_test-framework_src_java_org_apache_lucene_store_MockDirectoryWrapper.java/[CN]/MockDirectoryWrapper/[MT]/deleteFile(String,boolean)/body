{
  maybeYield();
  maybeThrowDeterministicException();
  if (crashed && !forced)   throw new IOException("cannot delete after crash");
  if (unSyncedFiles.contains(name))   unSyncedFiles.remove(name);
  if (!forced && (noDeleteOpenFile || assertNoDeleteOpenFile)) {
    if (openFiles.containsKey(name)) {
      openFilesDeleted.add(name);
      if (!assertNoDeleteOpenFile) {
        throw (IOException)fillOpenTrace(new IOException("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot delete"),name,true);
      }
 else {
        throw (AssertionError)fillOpenTrace(new AssertionError("MockDirectoryWrapper: file \"" + name + "\" is still open: cannot delete"),name,true);
      }
    }
 else {
      openFilesDeleted.remove(name);
    }
  }
  in.deleteFile(name);
}
