{
  for (int pass=0; pass < 2; pass++) {
    if (VERBOSE)     System.out.println("TEST: pass=" + pass);
    boolean doAbort=pass == 1;
    long diskFree=200;
    while (true) {
      if (VERBOSE)       System.out.println("TEST: cycle: diskFree=" + diskFree);
      MockDirectoryWrapper dir=new MockDirectoryWrapper(random,new RAMDirectory());
      dir.setMaxSizeInBytes(diskFree);
      IndexWriter writer=new IndexWriter(dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer()));
      MergeScheduler ms=writer.getConfig().getMergeScheduler();
      if (ms instanceof ConcurrentMergeScheduler)       ((ConcurrentMergeScheduler)ms).setSuppressExceptions();
      boolean hitError=false;
      try {
        for (int i=0; i < 200; i++) {
          addDoc(writer);
        }
        writer.commit();
      }
 catch (      IOException e) {
        if (VERBOSE) {
          System.out.println("TEST: exception on addDoc");
          e.printStackTrace(System.out);
        }
        hitError=true;
      }
      if (hitError) {
        if (doAbort) {
          writer.rollback();
        }
 else {
          try {
            writer.close();
          }
 catch (          IOException e) {
            if (VERBOSE) {
              System.out.println("TEST: exception on close");
              e.printStackTrace(System.out);
            }
            dir.setMaxSizeInBytes(0);
            writer.close();
          }
        }
        if (_TestUtil.anyFilesExceptWriteLock(dir)) {
          assertNoUnreferencedFiles(dir,"after disk full during addDocument");
          IndexReader.open(dir,true).close();
        }
        dir.close();
        diskFree+=500;
      }
 else {
        writer.close();
        dir.close();
        break;
      }
    }
  }
}
