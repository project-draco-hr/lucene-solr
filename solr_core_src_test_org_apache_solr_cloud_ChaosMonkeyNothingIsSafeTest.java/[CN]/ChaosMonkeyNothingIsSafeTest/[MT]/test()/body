{
  boolean testSuccessful=false;
  try {
    handle.clear();
    handle.put("timestamp",SKIPVAL);
    ZkStateReader zkStateReader=cloudClient.getZkStateReader();
    for (int j=1; j < sliceCount; j++) {
      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION,"shard" + j,10000);
    }
    waitForRecoveriesToFinish(false);
    del("*:*");
    List<StoppableThread> threads=new ArrayList<>();
    List<StoppableIndexingThread> indexTreads=new ArrayList<>();
    int threadCount=TEST_NIGHTLY ? 3 : 1;
    int i=0;
    for (i=0; i < threadCount; i++) {
      StoppableIndexingThread indexThread=new StoppableIndexingThread(controlClient,cloudClient,Integer.toString(i),true);
      threads.add(indexThread);
      indexTreads.add(indexThread);
      indexThread.start();
    }
    threadCount=1;
    i=0;
    for (i=0; i < threadCount; i++) {
      StoppableSearchThread searchThread=new StoppableSearchThread(cloudClient);
      threads.add(searchThread);
      searchThread.start();
    }
    boolean runFullThrottle=random().nextBoolean();
    if (runFullThrottle) {
      FullThrottleStoppableIndexingThread ftIndexThread=new FullThrottleStoppableIndexingThread(clients,"ft1",true);
      threads.add(ftIndexThread);
      ftIndexThread.start();
    }
    chaosMonkey.startTheMonkey(true,10000);
    try {
      long runLength;
      if (RUN_LENGTH != -1) {
        runLength=RUN_LENGTH;
      }
 else {
        int[] runTimes;
        if (TEST_NIGHTLY) {
          runTimes=new int[]{5000,6000,10000,15000,25000,30000,30000,45000,90000,120000};
        }
 else {
          runTimes=new int[]{5000,7000,15000};
        }
        runLength=runTimes[random().nextInt(runTimes.length - 1)];
      }
      Thread.sleep(runLength);
    }
  finally {
      chaosMonkey.stopTheMonkey();
    }
    restartZk(1000 * (5 + random().nextInt(4)));
    for (    StoppableThread indexThread : threads) {
      indexThread.safeStop();
    }
    for (    StoppableThread indexThread : threads) {
      indexThread.join();
    }
    Thread.sleep(2000);
    waitForThingsToLevelOut(Integer.MAX_VALUE);
    for (int j=1; j < sliceCount; j++) {
      zkStateReader.getLeaderRetry(DEFAULT_COLLECTION,"shard" + j,30000);
    }
    commit();
    zkStateReader.updateLiveNodes();
    assertTrue(zkStateReader.getClusterState().getLiveNodes().size() > 0);
    for (    StoppableThread indexThread : threads) {
      if (indexThread instanceof StoppableIndexingThread && !(indexThread instanceof FullThrottleStoppableIndexingThread)) {
        int failCount=((StoppableIndexingThread)indexThread).getFailCount();
        assertFalse("There were too many update fails (" + failCount + " > "+ FAIL_TOLERANCE+ ") - we expect it can happen, but shouldn't easily",failCount > FAIL_TOLERANCE);
      }
    }
    Set<String> addFails=getAddFails(indexTreads);
    Set<String> deleteFails=getDeleteFails(indexTreads);
    checkShardConsistency(!runFullThrottle,true,addFails,deleteFails);
    long ctrlDocs=controlClient.query(new SolrQuery("*:*")).getResults().getNumFound();
    long cloudClientDocs=cloudClient.query(new SolrQuery("*:*")).getResults().getNumFound();
    assertTrue("Found " + ctrlDocs + " control docs",cloudClientDocs > 0);
    if (VERBOSE)     System.out.println("control docs:" + controlClient.query(new SolrQuery("*:*")).getResults().getNumFound() + "\n\n");
    if (random().nextBoolean()) {
      restartZk(1000 * (5 + random().nextInt(4)));
    }
    try (CloudSolrClient client=createCloudClient("collection1")){
      createCollection(null,"testcollection",1,1,1,client,null,"conf1");
    }
     List<Integer> numShardsNumReplicas=new ArrayList<>(2);
    numShardsNumReplicas.add(1);
    numShardsNumReplicas.add(1);
    checkForCollection("testcollection",numShardsNumReplicas,null);
    testSuccessful=true;
  }
  finally {
    if (!testSuccessful) {
      printLayout();
    }
  }
}
