{
  handle.clear();
  handle.put("QTime",SKIPVAL);
  handle.put("timestamp",SKIPVAL);
  List<StopableIndexingThread> threads=new ArrayList<StopableIndexingThread>();
  int threadCount=1;
  int i=0;
  for (i=0; i < threadCount; i++) {
    StopableIndexingThread indexThread=new StopableIndexingThread(i * 50000,true);
    threads.add(indexThread);
    indexThread.start();
  }
  FullThrottleStopableIndexingThread ftIndexThread=new FullThrottleStopableIndexingThread(clients,i * 50000,true);
  threads.add(ftIndexThread);
  ftIndexThread.start();
  chaosMonkey.startTheMonkey(true,1500);
  try {
    Thread.sleep(atLeast(6000));
  }
  finally {
    chaosMonkey.stopTheMonkey();
  }
  for (  StopableIndexingThread indexThread : threads) {
    indexThread.safeStop();
  }
  for (  StopableIndexingThread indexThread : threads) {
    indexThread.join();
  }
  Thread.sleep(2000);
  waitForThingsToLevelOut();
  for (int j=1; j < sliceCount; j++) {
    zkStateReader.getLeaderProps(DEFAULT_COLLECTION,"shard" + j,10000);
  }
  commit();
  zkStateReader.updateCloudState(true);
  assertTrue(zkStateReader.getCloudState().getLiveNodes().size() > 0);
  checkShardConsistency(false,false);
  long cloudClientDocs=cloudClient.query(new SolrQuery("*:*")).getResults().getNumFound();
  assertTrue(cloudClientDocs > 0);
  if (VERBOSE)   System.out.println("control docs:" + controlClient.query(new SolrQuery("*:*")).getResults().getNumFound() + "\n\n");
}
