{
  taskState.setState(FT_STARTED);
  log=thread.getLog();
  hostManager=((FetcherThread)thread).getHostManager();
  hostResolver=hostManager.getHostResolver();
  base=contextUrl=actURLMessage.getUrl();
  String urlString=actURLMessage.getURLString();
  String host=contextUrl.getHost().toLowerCase();
  HostInfo hi=hostManager.getHostInfo(host);
  if (actURLMessage.linkType == URLMessage.LINKTYPE_REDIRECT) {
    taskState.setState(FT_READY,null);
    hi.releaseLock();
    return;
  }
  NVPair[] headers=((FetcherThread)thread).getDefaultHeaders();
  int numHeaders=((FetcherThread)thread).getUsedDefaultHeaders();
  boolean isIncremental=false;
  if (actURLMessage instanceof WebDocument) {
    isIncremental=true;
    headers[numHeaders]=new NVPair("If-Modified-Since",HTTPClient.Util.httpDate(((WebDocument)actURLMessage).getLastModified()));
  }
  errorLog=thread.getErrorLog();
  int threadNr=((FetcherThread)thread).getThreadNumber();
  log.log("start");
  int hostPos=urlString.indexOf(host);
  int hostLen=host.length();
  if (!hi.isHealthy()) {
    log.log("Bad Host: " + contextUrl + "; returning");
    taskState.setState(FT_READY,null);
    hi.releaseLock();
    return;
  }
  foundUrls=new java.util.LinkedList();
  HTTPConnection conn=null;
  title="";
  int size=1;
  InputStream in=null;
  bytesRead=0;
  try {
    URL ipURL=contextUrl;
    taskState.setState(FT_OPENCONNECTION,urlString);
    log.log("connecting to " + ipURL.getHost());
    taskState.setState(FT_CONNECTING,ipURL);
    conn=new HTTPConnection(host);
    conn.setDefaultTimeout(75000);
    conn.setDefaultAllowUserInteraction(false);
    taskState.setState(this.FT_GETTING,ipURL);
    log.log("getting");
    HTTPResponse response=conn.Get(ipURL.getFile(),"",headers);
    response.setReadIncrement(2720);
    int statusCode=response.getStatusCode();
    byte[] fullBuffer=null;
    String contentType="";
    int contentLength=0;
    Date date=null;
    if (isIncremental) {
      System.out.println("ftask: if modified since: " + HTTPClient.Util.httpDate(((WebDocument)actURLMessage).getLastModified()));
    }
    URL realURL;
switch (statusCode) {
case 404:
case 403:
      if (isIncremental) {
        WebDocument d=(WebDocument)actURLMessage;
        d.setResultCode(statusCode);
        docStorage.store(d);
      }
    break;
case 304:
  System.out.println("ftask: -> not modified");
taskState.setState(FT_STORING,ipURL);
try {
WebDocument doc=(WebDocument)this.actURLMessage;
doc.setModified(false);
docStorage.store(doc);
this.bytesRead+=doc.getSize();
}
 catch (ClassCastException e) {
System.out.println("error while casting to WebDoc: " + actURLMessage.getInfo());
}
break;
case 301:
case 302:
case 303:
case 307:
realURL=response.getEffectiveURI().toURL();
foundUrls.add(new URLMessage(realURL,contextUrl,URLMessage.LINKTYPE_REDIRECT,"",hostResolver));
linkStorage.storeLinks(foundUrls);
break;
default :
realURL=response.getEffectiveURI().toURL();
if (!(realURL.equals(contextUrl))) {
foundUrls.add(new URLMessage(realURL,contextUrl,URLMessage.LINKTYPE_REDIRECT,"",hostResolver));
this.base=this.contextUrl=realURL;
}
if (isIncremental) {
System.out.println("ftask: -> was modified at " + response.getHeaderAsDate("Last-Modified"));
}
taskState.setState(FT_READING,ipURL);
contentType=response.getHeader("Content-Type");
String length=response.getHeader("Content-Length");
date=response.getHeaderAsDate("Last-Modified");
if (length != null) {
contentLength=Integer.parseInt(length);
}
log.log("reading");
realURL=response.getEffectiveURI().toURL();
if (contentType != null && contentType.startsWith("text/html")) {
fullBuffer=response.getData(Constants.FETCHERTASK_MAXFILESIZE);
hi.releaseLock();
if (fullBuffer != null) {
contentLength=fullBuffer.length;
this.bytesRead+=contentLength;
}
if (isInterrupted) {
System.out.println("FetcherTask: interrupted while reading. File truncated");
log.log("interrupted while reading. File truncated");
}
 else {
if (fullBuffer != null) {
taskState.setState(FT_SCANNING,ipURL);
log.log("read file (" + fullBuffer.length + " bytes). Now scanning.");
char[] fullCharBuffer=new char[contentLength];
new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);
Tokenizer tok=new Tokenizer();
tok.setLinkHandler(this);
tok.parse(new SimpleCharArrayReader(fullCharBuffer));
taskState.setState(FT_STORING,ipURL);
linkStorage.storeLinks(foundUrls);
WebDocument d;
if (isIncremental) {
d=((WebDocument)this.actURLMessage);
d.setModified(true);
d.setUrl(contextUrl);
d.setMimeType(contentType);
d.setResultCode(statusCode);
d.setSize(contentLength);
d.setTitle(title);
d.setLastModified(date);
}
 else {
d=new WebDocument(contextUrl,contentType,statusCode,actURLMessage.getReferer(),contentLength,title,date,hostResolver);
}
d.addField("content",fullCharBuffer);
d.addField("contentBytes",fullBuffer);
docStorage.store(d);
}
log.log("scanned");
}
log.log("stored");
}
 else {
taskState.setState(FT_STORING,ipURL);
linkStorage.storeLinks(foundUrls);
WebDocument d=new WebDocument(contextUrl,contentType,statusCode,actURLMessage.getReferer(),0,title,date,hostResolver);
docStorage.store(d);
}
break;
}
}
 catch (InterruptedIOException e) {
errorLog.log("error: Timeout: " + this.actURLMessage.getUrl());
hi.badRequest();
}
catch (FileNotFoundException e) {
taskState.setState(FT_EXCEPTION);
errorLog.log("error: File not Found: " + this.actURLMessage.getUrl());
}
catch (NoRouteToHostException e) {
hi.setReachable(false);
taskState.setState(FT_EXCEPTION);
errorLog.log("error: " + e.getClass().getName() + ": "+ e.getMessage());
}
catch (ConnectException e) {
hi.setReachable(false);
taskState.setState(FT_EXCEPTION);
errorLog.log("error: " + e.getClass().getName() + ": "+ e.getMessage());
}
catch (SocketException e) {
taskState.setState(FT_EXCEPTION);
errorLog.log("error: " + e.getClass().getName() + ": "+ e.getMessage());
}
catch (UnknownHostException e) {
hi.setReachable(false);
taskState.setState(FT_EXCEPTION);
errorLog.log("error: " + e.getClass().getName() + ": "+ e.getMessage());
}
catch (IOException e) {
taskState.setState(FT_EXCEPTION);
errorLog.log("error: IOException: " + e.getClass().getName() + ": "+ e.getMessage());
}
catch (OutOfMemoryError ome) {
taskState.setState(FT_EXCEPTION);
System.out.println("[" + threadNr + "] Task "+ this.taskNr+ " OutOfMemory after "+ size+ " bytes");
errorLog.log("error: OutOfMemory after " + size + " bytes");
}
catch (Throwable e) {
taskState.setState(FT_EXCEPTION);
System.out.println("[" + threadNr + "] "+ e.getMessage()+ " type: "+ e.getClass().getName());
e.printStackTrace();
System.out.println("[" + threadNr + "]: stopping");
errorLog.log("error: " + e.getClass().getName() + ": "+ e.getMessage()+ "; stopping");
}
 finally {
hi.releaseLock();
if (isInterrupted) {
System.out.println("Task was interrupted");
log.log("interrupted");
taskState.setState(FT_INTERRUPTED);
}
}
if (isInterrupted) {
System.out.println("Task: closed everything");
}
taskState.setState(FT_CLOSING);
conn.stop();
taskState.setState(FT_READY);
foundUrls=null;
}
