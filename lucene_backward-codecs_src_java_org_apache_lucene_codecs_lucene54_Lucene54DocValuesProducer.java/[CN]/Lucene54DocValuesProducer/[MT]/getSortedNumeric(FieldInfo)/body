{
  SortedSetEntry ss=sortedNumerics.get(field.name);
  if (ss.format == SORTED_SINGLE_VALUED) {
    NumericEntry numericEntry=numerics.get(field.name);
    final LongValues values=getNumeric(numericEntry);
    if (numericEntry.format == SPARSE_COMPRESSED) {
      SparseNumericDocValues sparseValues=((SparseNumericDocValuesRandomAccessWrapper)values).values;
      return new SortedNumericDocValues(){
        @Override public long nextValue() throws IOException {
          return sparseValues.longValue();
        }
        @Override public int docValueCount(){
          return 1;
        }
        @Override public int docID(){
          return sparseValues.docID();
        }
        @Override public int nextDoc() throws IOException {
          return sparseValues.nextDoc();
        }
        @Override public int advance(        int target) throws IOException {
          return sparseValues.advance(target);
        }
        @Override public boolean advanceExact(        int target) throws IOException {
          return sparseValues.advanceExact(target);
        }
        @Override public long cost(){
          return sparseValues.cost();
        }
      }
;
    }
    final Bits docsWithField=getLiveBits(numericEntry.missingOffset,maxDoc);
    return new SortedNumericDocValues(){
      int docID=-1;
      @Override public int docID(){
        return docID;
      }
      @Override public int nextDoc(){
        while (true) {
          docID++;
          if (docID == maxDoc) {
            docID=NO_MORE_DOCS;
            break;
          }
          if (docsWithField.get(docID)) {
            break;
          }
        }
        return docID;
      }
      @Override public int advance(      int target){
        if (target >= maxDoc) {
          docID=NO_MORE_DOCS;
          return docID;
        }
 else {
          docID=target - 1;
          return nextDoc();
        }
      }
      @Override public boolean advanceExact(      int target) throws IOException {
        docID=target;
        return docsWithField.get(docID);
      }
      @Override public long cost(){
        return 0;
      }
      @Override public int docValueCount(){
        return 1;
      }
      @Override public long nextValue(){
        return values.get(docID);
      }
    }
;
  }
 else   if (ss.format == SORTED_WITH_ADDRESSES) {
    NumericEntry numericEntry=numerics.get(field.name);
    final LongValues values=getNumeric(numericEntry);
    final LongValues ordIndex=getOrdIndexInstance(field,ordIndexes.get(field.name));
    return new SortedNumericDocValues(){
      long startOffset;
      long endOffset;
      int docID=-1;
      long upto;
      @Override public int docID(){
        return docID;
      }
      @Override public int nextDoc(){
        while (true) {
          docID++;
          if (docID == maxDoc) {
            docID=NO_MORE_DOCS;
            return docID;
          }
          startOffset=ordIndex.get(docID);
          endOffset=ordIndex.get(docID + 1L);
          if (endOffset > startOffset) {
            break;
          }
        }
        upto=startOffset;
        return docID;
      }
      @Override public int advance(      int target){
        if (target >= maxDoc) {
          docID=NO_MORE_DOCS;
          return docID;
        }
 else {
          docID=target - 1;
          return nextDoc();
        }
      }
      @Override public boolean advanceExact(      int target) throws IOException {
        docID=target;
        startOffset=ordIndex.get(docID);
        endOffset=ordIndex.get(docID + 1L);
        return endOffset > startOffset;
      }
      @Override public long cost(){
        return 0;
      }
      @Override public int docValueCount(){
        return (int)(endOffset - startOffset);
      }
      @Override public long nextValue(){
        return values.get(upto++);
      }
    }
;
  }
 else   if (ss.format == SORTED_SET_TABLE) {
    NumericEntry entry=ords.get(field.name);
    final LongValues ordinals=getNumeric(entry);
    final long[] table=ss.table;
    final int[] offsets=ss.tableOffsets;
    return new SortedNumericDocValues(){
      int startOffset;
      int endOffset;
      int docID=-1;
      int upto;
      @Override public int docID(){
        return docID;
      }
      @Override public int nextDoc(){
        while (true) {
          docID++;
          if (docID == maxDoc) {
            docID=NO_MORE_DOCS;
            return docID;
          }
          int ord=(int)ordinals.get(docID);
          startOffset=offsets[ord];
          endOffset=offsets[ord + 1];
          if (endOffset > startOffset) {
            break;
          }
        }
        upto=startOffset;
        return docID;
      }
      @Override public int advance(      int target){
        if (target >= maxDoc) {
          docID=NO_MORE_DOCS;
          return docID;
        }
 else {
          docID=target - 1;
          return nextDoc();
        }
      }
      @Override public boolean advanceExact(      int target) throws IOException {
        docID=target;
        int ord=(int)ordinals.get(docID);
        startOffset=offsets[ord];
        endOffset=offsets[ord + 1];
        return endOffset > startOffset;
      }
      @Override public long cost(){
        return 0;
      }
      @Override public int docValueCount(){
        return endOffset - startOffset;
      }
      @Override public long nextValue(){
        return table[upto++];
      }
    }
;
  }
 else {
    throw new AssertionError();
  }
}
