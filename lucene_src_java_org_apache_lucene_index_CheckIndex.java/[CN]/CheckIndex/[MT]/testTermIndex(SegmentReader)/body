{
  final Status.TermIndexStatus status=new Status.TermIndexStatus();
  final int maxDoc=reader.maxDoc();
  final Bits delDocs=reader.getDeletedDocs();
  final IndexSearcher is=new IndexSearcher(reader);
  try {
    if (infoStream != null) {
      infoStream.print("    test: terms, freq, prox...");
    }
    final Fields fields=reader.fields();
    if (fields == null) {
      msg("OK [no fields/terms]");
      return status;
    }
    DocsEnum docs=null;
    DocsAndPositionsEnum postings=null;
    final FieldsEnum fieldsEnum=fields.iterator();
    while (true) {
      final String field=fieldsEnum.next();
      if (field == null) {
        break;
      }
      final TermsEnum terms=fieldsEnum.terms();
      boolean hasOrd=true;
      final long termCountStart=status.termCount;
      BytesRef lastTerm=null;
      Comparator<BytesRef> termComp=terms.getComparator();
      while (true) {
        final BytesRef term=terms.next();
        if (term == null) {
          break;
        }
        if (lastTerm == null) {
          lastTerm=new BytesRef(term);
        }
 else {
          if (termComp.compare(lastTerm,term) >= 0) {
            throw new RuntimeException("terms out of order: lastTerm=" + lastTerm + " term="+ term);
          }
          lastTerm.copy(term);
        }
        final int docFreq=terms.docFreq();
        status.totFreq+=docFreq;
        docs=terms.docs(delDocs,docs);
        postings=terms.docsAndPositions(delDocs,postings);
        if (hasOrd) {
          long ord=-1;
          try {
            ord=terms.ord();
          }
 catch (          UnsupportedOperationException uoe) {
            hasOrd=false;
          }
          if (hasOrd) {
            final long ordExpected=status.termCount - termCountStart;
            if (ord != ordExpected) {
              throw new RuntimeException("ord mismatch: TermsEnum has ord=" + ord + " vs actual="+ ordExpected);
            }
          }
        }
        status.termCount++;
        final DocsEnum docs2;
        if (postings != null) {
          docs2=postings;
        }
 else {
          docs2=docs;
        }
        int lastDoc=-1;
        while (true) {
          final int doc=docs2.nextDoc();
          if (doc == DocIdSetIterator.NO_MORE_DOCS) {
            break;
          }
          final int freq=docs2.freq();
          status.totPos+=freq;
          if (doc <= lastDoc) {
            throw new RuntimeException("term " + term + ": doc "+ doc+ " <= lastDoc "+ lastDoc);
          }
          if (doc >= maxDoc) {
            throw new RuntimeException("term " + term + ": doc "+ doc+ " >= maxDoc "+ maxDoc);
          }
          lastDoc=doc;
          if (freq <= 0) {
            throw new RuntimeException("term " + term + ": doc "+ doc+ ": freq "+ freq+ " is out of bounds");
          }
          int lastPos=-1;
          if (postings != null) {
            for (int j=0; j < freq; j++) {
              final int pos=postings.nextPosition();
              if (pos < -1) {
                throw new RuntimeException("term " + term + ": doc "+ doc+ ": pos "+ pos+ " is out of bounds");
              }
              if (pos < lastPos) {
                throw new RuntimeException("term " + term + ": doc "+ doc+ ": pos "+ pos+ " < lastPos "+ lastPos);
              }
              lastPos=pos;
              if (postings.hasPayload()) {
                postings.getPayload();
              }
            }
          }
        }
        if (reader.hasDeletions()) {
          final DocsEnum docsNoDel=terms.docs(null,docs);
          int count=0;
          while (docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
            count++;
          }
          if (count != docFreq) {
            throw new RuntimeException("term " + term + " docFreq="+ docFreq+ " != tot docs w/o deletions "+ count);
          }
        }
      }
      if (lastTerm != null) {
        if (terms.seek(lastTerm) != TermsEnum.SeekStatus.FOUND) {
          throw new RuntimeException("seek to last term " + lastTerm + " failed");
        }
        is.search(new TermQuery(new Term(field,lastTerm)),1);
      }
      if (hasOrd && status.termCount - termCountStart > 0) {
        long termCount;
        try {
          termCount=fields.terms(field).getUniqueTermCount();
        }
 catch (        UnsupportedOperationException uoe) {
          termCount=-1;
        }
        if (termCount != -1 && termCount != status.termCount - termCountStart) {
          throw new RuntimeException("termCount mismatch " + termCount + " vs "+ (status.termCount - termCountStart));
        }
        int seekCount=(int)Math.min(10000L,termCount);
        if (seekCount > 0) {
          BytesRef[] seekTerms=new BytesRef[seekCount];
          for (int i=seekCount - 1; i >= 0; i--) {
            long ord=i * (termCount / seekCount);
            terms.seek(ord);
            seekTerms[i]=new BytesRef(terms.term());
          }
          long totDocCount=0;
          for (int i=seekCount - 1; i >= 0; i--) {
            if (terms.seek(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {
              throw new RuntimeException("seek to existing term " + seekTerms[i] + " failed");
            }
            docs=terms.docs(delDocs,docs);
            if (docs == null) {
              throw new RuntimeException("null DocsEnum from to existing term " + seekTerms[i]);
            }
            while (docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {
              totDocCount++;
            }
          }
          long totDocCount2=0;
          for (int i=0; i < seekCount; i++) {
            totDocCount2+=is.search(new TermQuery(new Term(field,seekTerms[i])),1).totalHits;
          }
          if (totDocCount != totDocCount2) {
            throw new RuntimeException("search to seek terms produced wrong number of hits: " + totDocCount + " vs "+ totDocCount2);
          }
        }
      }
    }
    msg("OK [" + status.termCount + " terms; "+ status.totFreq+ " terms/docs pairs; "+ status.totPos+ " tokens]");
  }
 catch (  Throwable e) {
    msg("ERROR [" + String.valueOf(e.getMessage()) + "]");
    status.error=e;
    if (infoStream != null) {
      e.printStackTrace(infoStream);
    }
  }
  return status;
}
