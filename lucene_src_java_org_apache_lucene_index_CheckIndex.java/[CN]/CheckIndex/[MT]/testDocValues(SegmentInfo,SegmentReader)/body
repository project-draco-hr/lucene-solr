{
  final Status.DocValuesStatus status=new Status.DocValuesStatus();
  try {
    if (infoStream != null) {
      infoStream.print("    test: DocValues........");
    }
    final FieldInfos fieldInfos=info.getFieldInfos();
    for (    FieldInfo fieldInfo : fieldInfos) {
      if (fieldInfo.hasDocValues()) {
        status.totalValueFields++;
        final PerDocValues perDocValues=reader.perDocValues();
        final IndexDocValues docValues=perDocValues.docValues(fieldInfo.name);
        if (docValues == null) {
          continue;
        }
        final Source values=docValues.getDirectSource();
        final int maxDoc=reader.maxDoc();
        for (int i=0; i < maxDoc; i++) {
switch (fieldInfo.docValues) {
case BYTES_FIXED_SORTED:
case BYTES_VAR_SORTED:
case BYTES_FIXED_DEREF:
case BYTES_FIXED_STRAIGHT:
case BYTES_VAR_DEREF:
case BYTES_VAR_STRAIGHT:
            values.getBytes(i,new BytesRef());
          break;
case FLOAT_32:
case FLOAT_64:
        values.getFloat(i);
      break;
case VAR_INTS:
case FIXED_INTS_16:
case FIXED_INTS_32:
case FIXED_INTS_64:
case FIXED_INTS_8:
    values.getInt(i);
  break;
default :
throw new IllegalArgumentException("Field: " + fieldInfo.name + " - no such DocValues type: "+ fieldInfo.docValues);
}
}
}
}
msg("OK [" + status.docCount + " total doc Count; Num DocValues Fields "+ status.totalValueFields);
}
 catch (Throwable e) {
msg("ERROR [" + String.valueOf(e.getMessage()) + "]");
status.error=e;
if (infoStream != null) {
e.printStackTrace(infoStream);
}
}
return status;
}
