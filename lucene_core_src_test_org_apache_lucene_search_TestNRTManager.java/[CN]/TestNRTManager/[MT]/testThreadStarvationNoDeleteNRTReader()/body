{
  IndexWriterConfig conf=newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random()));
  Directory d=newDirectory();
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch signal=new CountDownLatch(1);
  LatchedIndexWriter _writer=new LatchedIndexWriter(d,conf,latch,signal);
  final NRTManager.TrackingIndexWriter writer=new NRTManager.TrackingIndexWriter(_writer);
  final NRTManager manager=new NRTManager(writer,null,false);
  Document doc=new Document();
  doc.add(newField("test","test",TextField.TYPE_STORED));
  long gen=writer.addDocument(doc);
  manager.maybeRefresh();
  assertFalse(gen < manager.getCurrentSearchingGen());
  Thread t=new Thread(){
    public void run(){
      try {
        signal.await();
        manager.maybeRefresh();
        writer.deleteDocuments(new TermQuery(new Term("foo","barista")));
        manager.maybeRefresh();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
 finally {
        latch.countDown();
      }
    }
  }
;
  t.start();
  _writer.waitAfterUpdate=true;
  final long lastGen=writer.updateDocument(new Term("foo","bar"),doc);
  assertFalse(manager.isSearcherCurrent());
  IndexSearcher searcher=manager.acquire();
  try {
    assertEquals(2,searcher.getIndexReader().numDocs());
  }
  finally {
    manager.release(searcher);
  }
  NRTManagerReopenThread thread=new NRTManagerReopenThread(manager,0.01,0.01);
  thread.start();
  if (VERBOSE) {
    System.out.println("waiting now for generation " + lastGen);
  }
  final AtomicBoolean finished=new AtomicBoolean(false);
  Thread waiter=new Thread(){
    public void run(){
      manager.waitForGeneration(lastGen);
      finished.set(true);
    }
  }
;
  waiter.start();
  manager.maybeRefresh();
  waiter.join(1000);
  if (!finished.get()) {
    waiter.interrupt();
    fail("thread deadlocked on waitForGeneration");
  }
  thread.close();
  thread.join();
  IOUtils.close(manager,_writer,d);
}
