{
switch (random().nextInt(4)) {
case 0:
    predicate=SpatialOperation.Contains;
  break;
case 1:
predicate=SpatialOperation.IsWithin;
break;
default :
predicate=SpatialOperation.Intersects;
break;
}
final SpatialPrefixTree gridQuad=new QuadPrefixTree(ctx,10);
final SpatialPrefixTree gridGeohash=new GeohashPrefixTree(ctx,10);
Collection<SpatialStrategy> strategies=new ArrayList<>();
RecursivePrefixTreeStrategy recursive_geohash=new RecursivePrefixTreeStrategy(gridGeohash,"recursive_geohash");
strategies.add(recursive_geohash);
strategies.add(new TermQueryPrefixTreeStrategy(gridQuad,"termquery_quad"));
strategies.add(PointVectorStrategy.newInstance(ctx,"pointvector"));
strategies.add(PointVectorStrategy.newLegacyInstance(ctx,"pointvector_legacy"));
strategies.add(BBoxStrategy.newInstance(ctx,"bbox"));
strategies.add(BBoxStrategy.newLegacyInstance(ctx,"bbox_legacy"));
final SerializedDVStrategy serialized=new SerializedDVStrategy(ctx,"serialized");
strategies.add(serialized);
strategies.add(new CompositeSpatialStrategy("composite",recursive_geohash,serialized));
for (SpatialStrategy strategy : strategies) {
testEqualsHashcode(strategy);
}
}
