{
  DocSet docs=processor.fcontext.base;
  int baseSize=docs.size();
  int maxDoc=searcher.maxDoc();
  if (baseSize < processor.effectiveMincount) {
    return;
  }
  final int[] index=this.index;
  boolean doNegative=baseSize > maxDoc >> 1 && termInstances > 0 && docs instanceof BitDocSet;
  if (doNegative) {
    FixedBitSet bs=((BitDocSet)docs).getBits().clone();
    bs.flip(0,maxDoc);
    docs=new BitDocSet(bs,maxDoc - baseSize);
  }
  for (  TopTerm tt : bigTerms.values()) {
    counts[tt.termNum]=searcher.numDocs(tt.termQuery,docs);
  }
  if (termInstances > 0) {
    DocIterator iter=docs.iterator();
    while (iter.hasNext()) {
      int doc=iter.nextDoc();
      int code=index[doc];
      if ((code & 0xff) == 1) {
        int pos=code >>> 8;
        int whichArray=(doc >>> 16) & 0xff;
        byte[] arr=tnums[whichArray];
        int tnum=0;
        for (; ; ) {
          int delta=0;
          for (; ; ) {
            byte b=arr[pos++];
            delta=(delta << 7) | (b & 0x7f);
            if ((b & 0x80) == 0)             break;
          }
          if (delta == 0)           break;
          tnum+=delta - TNUM_OFFSET;
          counts[tnum]++;
        }
      }
 else {
        int tnum=0;
        int delta=0;
        for (; ; ) {
          delta=(delta << 7) | (code & 0x7f);
          if ((code & 0x80) == 0) {
            if (delta == 0)             break;
            tnum+=delta - TNUM_OFFSET;
            counts[tnum]++;
            delta=0;
          }
          code>>>=8;
        }
      }
    }
  }
  if (doNegative) {
    for (int i=0; i < numTermsInField; i++) {
      counts[i]=maxTermCounts[i] - counts[i];
    }
  }
  if (processor.allBucketsSlot >= 0) {
    int all=0;
    for (int i=0; i < numTermsInField; i++) {
      all+=counts[i];
    }
    counts[processor.allBucketsSlot]=all;
  }
}
