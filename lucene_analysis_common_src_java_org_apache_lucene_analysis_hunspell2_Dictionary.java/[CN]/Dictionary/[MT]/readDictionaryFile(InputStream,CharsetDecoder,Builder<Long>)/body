{
  BytesRef flagsScratch=new BytesRef();
  IntsRef scratchInts=new IntsRef();
  BufferedReader lines=new BufferedReader(new InputStreamReader(dictionary,decoder));
  String line=lines.readLine();
  File unsorted=File.createTempFile("unsorted","dat",tempDir);
  try (ByteSequencesWriter writer=new ByteSequencesWriter(unsorted)){
    while ((line=lines.readLine()) != null) {
      writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));
    }
  }
   File sorted=File.createTempFile("sorted","dat",tempDir);
  OfflineSorter sorter=new OfflineSorter(new Comparator<BytesRef>(){
    BytesRef scratch1=new BytesRef();
    BytesRef scratch2=new BytesRef();
    @Override public int compare(    BytesRef o1,    BytesRef o2){
      scratch1.bytes=o1.bytes;
      scratch1.offset=o1.offset;
      scratch1.length=o1.length;
      for (int i=scratch1.length - 1; i >= 0; i--) {
        if (scratch1.bytes[scratch1.offset + i] == '/') {
          scratch1.length=i;
          break;
        }
      }
      scratch2.bytes=o2.bytes;
      scratch2.offset=o2.offset;
      scratch2.length=o2.length;
      for (int i=scratch2.length - 1; i >= 0; i--) {
        if (scratch2.bytes[scratch2.offset + i] == '/') {
          scratch2.length=i;
          break;
        }
      }
      return scratch1.compareTo(scratch2);
    }
  }
);
  sorter.sort(unsorted,sorted);
  unsorted.delete();
  ByteSequencesReader reader=new ByteSequencesReader(sorted);
  BytesRef scratchLine=new BytesRef();
  BytesRef currentEntry=new BytesRef();
  char currentFlags[]=new char[0];
  while (reader.read(scratchLine)) {
    line=scratchLine.utf8ToString();
    String entry;
    char wordForm[];
    int flagSep=line.lastIndexOf('/');
    if (flagSep == -1) {
      wordForm=NOFLAGS;
      entry=line;
    }
 else {
      int end=line.indexOf('\t',flagSep);
      if (end == -1)       end=line.length();
      String flagPart=line.substring(flagSep + 1,end);
      if (aliasCount > 0) {
        flagPart=getAliasValue(Integer.parseInt(flagPart));
      }
      wordForm=flagParsingStrategy.parseFlags(flagPart);
      Arrays.sort(wordForm);
      entry=line.substring(0,flagSep);
    }
    BytesRef scratch=new BytesRef(entry);
    int cmp=scratch.compareTo(currentEntry);
    if (cmp < 0) {
      throw new IllegalArgumentException("out of order: " + scratch.utf8ToString() + " < "+ currentEntry.utf8ToString());
    }
 else     if (cmp == 0) {
      currentFlags=merge(currentFlags,wordForm);
    }
 else {
      final int hashCode=encodeFlagsWithHash(flagsScratch,currentFlags);
      int ord=flagLookup.add(flagsScratch,hashCode);
      if (ord < 0) {
        ord=(-ord) - 1;
      }
      UnicodeUtil.UTF8toUTF32(currentEntry,scratchInts);
      words.add(scratchInts,(long)ord);
      currentEntry=scratch;
      currentFlags=wordForm;
    }
  }
  final int hashCode=encodeFlagsWithHash(flagsScratch,currentFlags);
  int ord=flagLookup.add(flagsScratch,hashCode);
  if (ord < 0) {
    ord=(-ord) - 1;
  }
  UnicodeUtil.UTF8toUTF32(currentEntry,scratchInts);
  words.add(scratchInts,(long)ord);
  reader.close();
  sorted.delete();
}
