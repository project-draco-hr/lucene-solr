{
  if (pos < 0L) {
    throw new IllegalArgumentException("Seeking to negative position: " + this);
  }
  pos+=offset;
  final int bi=(int)(pos >> chunkSizePower);
  try {
    if (bi == curBufIndex) {
      curBuf.position((int)(pos & chunkSizeMask));
    }
 else {
      final ByteBuffer b=buffers[bi];
      b.position((int)(pos & chunkSizeMask));
      this.curBufIndex=bi;
      this.curBuf=b;
    }
  }
 catch (  ArrayIndexOutOfBoundsException aioobe) {
    throw new EOFException("seek past EOF: " + this);
  }
catch (  IllegalArgumentException iae) {
    throw new EOFException("seek past EOF: " + this);
  }
catch (  NullPointerException npe) {
    throw new AlreadyClosedException("Already closed: " + this);
  }
}
