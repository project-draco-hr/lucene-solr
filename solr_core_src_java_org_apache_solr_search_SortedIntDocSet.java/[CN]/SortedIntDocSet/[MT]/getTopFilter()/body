{
  return new Filter(){
    int lastEndIdx=0;
    @Override public DocIdSet getDocIdSet(    final AtomicReaderContext context,    final Bits acceptDocs){
      AtomicReader reader=context.reader();
      final Bits acceptDocs2=acceptDocs == null ? null : (reader.getLiveDocs() == acceptDocs ? null : acceptDocs);
      final int base=context.docBase;
      final int maxDoc=reader.maxDoc();
      final int max=base + maxDoc;
      int sidx=Math.max(0,lastEndIdx);
      if (sidx > 0 && docs[sidx - 1] >= base) {
        sidx=0;
      }
      if (sidx < docs.length && docs[sidx] < base) {
        sidx=findIndex(docs,base,sidx,docs.length - 1);
      }
      final int startIdx=sidx;
      int eidx=Math.min(docs.length,startIdx + maxDoc) - 1;
      eidx=findIndex(docs,max,startIdx,eidx) - 1;
      final int endIdx=eidx;
      lastEndIdx=endIdx;
      return BitsFilteredDocIdSet.wrap(new DocIdSet(){
        @Override public DocIdSetIterator iterator(){
          return new DocIdSetIterator(){
            int idx=startIdx;
            int adjustedDoc=-1;
            @Override public int docID(){
              return adjustedDoc;
            }
            @Override public int nextDoc(){
              return adjustedDoc=(idx > endIdx) ? NO_MORE_DOCS : (docs[idx++] - base);
            }
            @Override public int advance(            int target){
              if (idx > endIdx || target == NO_MORE_DOCS)               return adjustedDoc=NO_MORE_DOCS;
              target+=base;
              int rawDoc=docs[idx++];
              if (rawDoc >= target)               return adjustedDoc=rawDoc - base;
              int high=endIdx;
              while (idx <= high) {
                int mid=(idx + high) >>> 1;
                rawDoc=docs[mid];
                if (rawDoc < target) {
                  idx=mid + 1;
                }
 else                 if (rawDoc > target) {
                  high=mid - 1;
                }
 else {
                  idx=mid + 1;
                  return adjustedDoc=rawDoc - base;
                }
              }
              if (idx <= endIdx) {
                return adjustedDoc=docs[idx++] - base;
              }
 else {
                return adjustedDoc=NO_MORE_DOCS;
              }
            }
            @Override public long cost(){
              return docs.length;
            }
          }
;
        }
        @Override public boolean isCacheable(){
          return true;
        }
        @Override public long ramBytesUsed(){
          return RamUsageEstimator.sizeOf(docs);
        }
        @Override public Bits bits(){
          return null;
        }
      }
,acceptDocs2);
    }
  }
;
}
