{
  if (testMethods != null)   return testMethods;
  Random r=new Random(runnerSeed);
  testMethods=new ArrayList<FrameworkMethod>();
  for (  Method m : getTestClass().getJavaClass().getMethods()) {
    final Ignore ignored=m.getAnnotation(Ignore.class);
    if (ignored != null && !m.getName().equals("alwaysIgnoredTestMethod")) {
      System.err.println("NOTE: Ignoring test method '" + m.getName() + "': "+ ignored.value());
    }
    final int mod=m.getModifiers();
    if (m.getAnnotation(Test.class) != null || (m.getName().startsWith("test") && !Modifier.isAbstract(mod) && m.getParameterTypes().length == 0 && m.getReturnType() == Void.TYPE)) {
      if (Modifier.isStatic(mod))       throw new RuntimeException("Test methods must not be static.");
      testMethods.add(new FrameworkMethod(m));
    }
  }
  if (testMethods.isEmpty()) {
    throw new RuntimeException("No runnable methods!");
  }
  if (TEST_NIGHTLY == false) {
    removeAnnotatedTests(Nightly.class,"@nightly");
  }
  if (TEST_WEEKLY == false) {
    removeAnnotatedTests(Weekly.class,"@weekly");
  }
  if (TEST_SLOW == false) {
    removeAnnotatedTests(Slow.class,"@slow");
  }
  Collections.sort(testMethods,new Comparator<FrameworkMethod>(){
    @Override public int compare(    FrameworkMethod f1,    FrameworkMethod f2){
      return f1.getName().compareTo(f2.getName());
    }
  }
);
  Collections.shuffle(testMethods,r);
  return testMethods;
}
