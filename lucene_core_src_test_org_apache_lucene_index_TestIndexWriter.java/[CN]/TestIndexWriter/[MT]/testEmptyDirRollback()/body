{
  assumeFalse("test makes assumptions about file counts",Codec.getDefault() instanceof SimpleTextCodec);
  Directory dir=newDirectory();
  IndexWriter writer=new IndexWriter(dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random())).setMaxBufferedDocs(2).setMergePolicy(newLogMergePolicy()));
  String[] files=dir.listAll();
  final int extraFileCount;
  if (files.length == 1) {
    assertTrue(files[0].endsWith("write.lock"));
    extraFileCount=1;
  }
 else {
    assertEquals(0,files.length);
    extraFileCount=0;
  }
  Document doc=new Document();
  FieldType customType=new FieldType(TextField.TYPE_STORED);
  customType.setStoreTermVectors(true);
  customType.setStoreTermVectorPositions(true);
  customType.setStoreTermVectorOffsets(true);
  doc.add(newField("c","val",customType));
  writer.addDocument(doc);
  int computedExtraFileCount=0;
  for (  String file : dir.listAll()) {
    if (file.lastIndexOf('.') < 0 || !Arrays.asList("fdx","fdt","tvx","tvd","tvf").contains(file.substring(file.lastIndexOf('.') + 1))) {
      ++computedExtraFileCount;
    }
  }
  assertEquals("only the stored and term vector files should exist in the directory",extraFileCount,computedExtraFileCount);
  doc=new Document();
  doc.add(newField("c","val",customType));
  writer.addDocument(doc);
  assertTrue("flush should have occurred and files should have been created",dir.listAll().length > 5 + extraFileCount);
  writer.rollback();
  assertEquals("no files should exist in the directory after rollback",0,dir.listAll().length);
  writer.close();
  assertEquals("expected a no-op close after IW.rollback()",0,dir.listAll().length);
  dir.close();
}
