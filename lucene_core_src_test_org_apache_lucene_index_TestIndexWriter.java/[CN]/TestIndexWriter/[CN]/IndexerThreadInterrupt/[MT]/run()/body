{
  MockDirectoryWrapper dir=new MockDirectoryWrapper(random,new RAMDirectory());
  dir.setPreventDoubleWrite(false);
  IndexWriter w=null;
  while (!finish) {
    try {
      while (!finish) {
        if (w != null) {
          try {
            w.close();
          }
 catch (          AlreadyClosedException ace) {
          }
          w=null;
        }
        IndexWriterConfig conf=newIndexWriterConfig(random,new MockAnalyzer(random)).setMaxBufferedDocs(2);
        w=new IndexWriter(dir,conf);
        Document doc=new Document();
        Field idField=newStringField(random,"id","",Field.Store.NO);
        Field binaryDVField=new BinaryDocValuesField("binarydv",new BytesRef());
        Field numericDVField=new NumericDocValuesField("numericdv",0);
        Field sortedDVField=new SortedDocValuesField("sorteddv",new BytesRef());
        Field sortedSetDVField=new SortedSetDocValuesField("sortedsetdv",new BytesRef());
        doc.add(idField);
        doc.add(newField(random,"field","some text contents",storedTextType));
        doc.add(binaryDVField);
        doc.add(numericDVField);
        doc.add(sortedDVField);
        doc.add(sortedSetDVField);
        for (int i=0; i < 100; i++) {
          idField.setStringValue(Integer.toString(i));
          binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));
          numericDVField.setLongValue(i);
          sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));
          sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));
          int action=random.nextInt(100);
          if (action == 17) {
            w.addIndexes(adder);
          }
 else           if (action % 30 == 0) {
            w.deleteAll();
          }
 else           if (action % 2 == 0) {
            w.updateDocument(new Term("id",idField.stringValue()),doc);
          }
 else {
            w.addDocument(doc);
          }
          if (random.nextInt(3) == 0) {
            IndexReader r=null;
            try {
              r=DirectoryReader.open(w,random.nextBoolean());
              if (random.nextBoolean() && r.maxDoc() > 0) {
                int docid=random.nextInt(r.maxDoc());
                w.tryDeleteDocument(r,docid);
              }
            }
  finally {
              IOUtils.closeWhileHandlingException(r);
            }
          }
          if (i % 10 == 0) {
            w.commit();
          }
          if (random.nextInt(50) == 0) {
            w.forceMerge(1);
          }
        }
        w.close();
        w=null;
        DirectoryReader.open(dir).close();
        allowInterrupt=true;
      }
    }
 catch (    ThreadInterruptedException re) {
      log.println("TEST thread " + id + ": got interrupt");
      re.printStackTrace(log);
      Throwable e=re.getCause();
      assertTrue(e instanceof InterruptedException);
      if (finish) {
        break;
      }
    }
catch (    Throwable t) {
      log.println("thread " + id + " FAILED; unexpected exception");
      t.printStackTrace(log);
      failed=true;
      break;
    }
  }
  if (VERBOSE) {
    log.println("TEST: thread " + id + ": now finish failed="+ failed);
  }
  if (!failed) {
    if (VERBOSE) {
      log.println("TEST: thread " + id + ": now rollback");
    }
    Thread.interrupted();
    if (w != null) {
      try {
        w.rollback();
      }
 catch (      IOException ioe) {
        throw new RuntimeException(ioe);
      }
    }
    try {
      TestUtil.checkIndex(dir);
    }
 catch (    Exception e) {
      failed=true;
      log.println("thread " + id + ": CheckIndex FAILED: unexpected exception");
      e.printStackTrace(log);
    }
    try {
      IndexReader r=DirectoryReader.open(dir);
      r.close();
    }
 catch (    Exception e) {
      failed=true;
      log.println("thread " + id + ": DirectoryReader.open FAILED: unexpected exception");
      e.printStackTrace(log);
    }
  }
  try {
    IOUtils.close(dir);
  }
 catch (  IOException e) {
    failed=true;
    throw new RuntimeException("thread " + id,e);
  }
  try {
    IOUtils.close(adder);
  }
 catch (  IOException e) {
    failed=true;
    throw new RuntimeException("thread " + id,e);
  }
}
