{
  int minBound=(this.min == null) ? Integer.MIN_VALUE : (minInclusive ? this.min.intValue() : (this.min.intValue() + 1));
  int maxBound=(this.max == null) ? Integer.MAX_VALUE : (maxInclusive ? this.max.intValue() : (this.max.intValue() - 1));
  resetLastNumberOfTerms();
  if (minBound > maxBound) {
    return DocIdSet.EMPTY_DOCIDSET;
  }
 else {
    final OpenBitSet bits=new OpenBitSet(reader.maxDoc());
    final TermDocs termDocs=reader.termDocs();
    try {
      TrieUtils.splitIntRange(new TrieUtils.IntRangeBuilder(){
        public final void addRange(        String minPrefixCoded,        String maxPrefixCoded){
          try {
            fillBits(reader,bits,termDocs,minPrefixCoded,maxPrefixCoded);
          }
 catch (          IOException ioe) {
            throw new RuntimeException(ioe);
          }
        }
      }
,precisionStep,minBound,maxBound);
    }
 catch (    RuntimeException e) {
      if (e.getCause() instanceof IOException)       throw (IOException)e.getCause();
      throw e;
    }
 finally {
      termDocs.close();
    }
    return bits;
  }
}
