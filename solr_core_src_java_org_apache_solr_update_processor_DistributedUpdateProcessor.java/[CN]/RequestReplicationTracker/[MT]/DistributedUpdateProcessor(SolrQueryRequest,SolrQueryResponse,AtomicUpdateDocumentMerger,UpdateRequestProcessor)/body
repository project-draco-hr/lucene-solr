{
  super(next);
  this.rsp=rsp;
  this.next=next;
  this.docMerger=docMerger;
  this.idField=req.getSchema().getUniqueKeyField();
  this.updateHandler=req.getCore().getUpdateHandler();
  this.ulog=updateHandler.getUpdateLog();
  this.vinfo=ulog == null ? null : ulog.getVersionInfo();
  versionsStored=this.vinfo != null && this.vinfo.getVersionField() != null;
  returnVersions=req.getParams().getBool(UpdateParams.VERSIONS,false);
  this.req=req;
  DistributedUpdateProcessorFactory.addParamToDistributedRequestWhitelist(this.req,UpdateParams.UPDATE_CHAIN,TEST_DISTRIB_SKIP_SERVERS,VERSION_FIELD);
  CoreDescriptor coreDesc=req.getCore().getCoreDescriptor();
  this.zkEnabled=coreDesc.getCoreContainer().isZooKeeperAware();
  zkController=req.getCore().getCoreDescriptor().getCoreContainer().getZkController();
  if (zkEnabled) {
    cmdDistrib=new SolrCmdDistributor(coreDesc.getCoreContainer().getUpdateShardHandler());
  }
  cloudDesc=coreDesc.getCloudDescriptor();
  if (cloudDesc != null) {
    collection=cloudDesc.getCollectionName();
  }
 else {
    collection=null;
  }
  boolean shouldClone=false;
  UpdateRequestProcessor nextInChain=next;
  while (nextInChain != null) {
    Class<? extends UpdateRequestProcessor> klass=nextInChain.getClass();
    if (klass != LogUpdateProcessorFactory.LogUpdateProcessor.class && klass != RunUpdateProcessor.class && klass != TolerantUpdateProcessor.class) {
      shouldClone=true;
      break;
    }
    nextInChain=nextInChain.next;
  }
  cloneRequiredOnLeader=shouldClone;
}
