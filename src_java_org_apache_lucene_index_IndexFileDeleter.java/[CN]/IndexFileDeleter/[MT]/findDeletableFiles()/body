{
  HashMap current=new HashMap();
  for (int j=0; j < segmentInfos.size(); j++) {
    SegmentInfo segmentInfo=(SegmentInfo)segmentInfos.elementAt(j);
    current.put(segmentInfo.name,segmentInfo);
  }
  String segmentsInfosFileName=segmentInfos.getCurrentSegmentFileName();
  IndexFileNameFilter filter=IndexFileNameFilter.getFilter();
  String[] files=directory.list();
  for (int i=0; i < files.length; i++) {
    if (filter.accept(null,files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {
      String segmentName;
      String extension;
      int loc=files[i].indexOf('.');
      if (loc != -1) {
        extension=files[i].substring(1 + loc);
        segmentName=files[i].substring(0,loc);
      }
 else {
        extension=null;
        segmentName=files[i];
      }
      loc=segmentName.indexOf('_',1);
      if (loc != -1) {
        segmentName=segmentName.substring(0,loc);
      }
      boolean doDelete=false;
      if (!current.containsKey(segmentName)) {
        doDelete=true;
      }
 else {
        SegmentInfo info=(SegmentInfo)current.get(segmentName);
        if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {
          doDelete=true;
        }
 else {
          if ("del".equals(extension)) {
            if (!files[i].equals(info.getDelFileName())) {
              doDelete=true;
            }
          }
 else           if (extension != null && extension.startsWith("s") && extension.matches("s\\d+")) {
            int field=Integer.parseInt(extension.substring(1));
            if (!files[i].equals(info.getNormFileName(field))) {
              doDelete=true;
            }
          }
 else           if ("cfs".equals(extension) && !info.getUseCompoundFile()) {
            doDelete=true;
          }
        }
      }
      if (doDelete) {
        addDeletableFile(files[i]);
        if (infoStream != null) {
          infoStream.println("IndexFileDeleter: file \"" + files[i] + "\" is unreferenced in index and will be deleted on next commit");
        }
      }
    }
  }
}
