{
  DocumentsWriterDeleteQueue queue=new DocumentsWriterDeleteQueue();
  final int size=200 + random().nextInt(500) * RANDOM_MULTIPLIER;
  Integer[] ids=new Integer[size];
  for (int i=0; i < ids.length; i++) {
    ids[i]=random().nextInt();
  }
  DeleteSlice slice1=queue.newSlice();
  DeleteSlice slice2=queue.newSlice();
  BufferedUpdates bd1=new BufferedUpdates();
  BufferedUpdates bd2=new BufferedUpdates();
  int last1=0;
  int last2=0;
  Set<Term> uniqueValues=new HashSet<>();
  for (int j=0; j < ids.length; j++) {
    Integer i=ids[j];
    Term[] term=new Term[]{new Term("id",i.toString())};
    uniqueValues.add(term[0]);
    queue.addDelete(term);
    if (random().nextInt(20) == 0 || j == ids.length - 1) {
      queue.updateSlice(slice1);
      assertTrue(slice1.isTailItem(term));
      slice1.apply(bd1,j);
      assertAllBetween(last1,j,bd1,ids);
      last1=j + 1;
    }
    if (random().nextInt(10) == 5 || j == ids.length - 1) {
      queue.updateSlice(slice2);
      assertTrue(slice2.isTailItem(term));
      slice2.apply(bd2,j);
      assertAllBetween(last2,j,bd2,ids);
      last2=j + 1;
    }
    assertEquals(j + 1,queue.numGlobalTermDeletes());
  }
  assertEquals(uniqueValues,bd1.terms.keySet());
  assertEquals(uniqueValues,bd2.terms.keySet());
  HashSet<Term> frozenSet=new HashSet<>();
  BytesRefBuilder bytesRef=new BytesRefBuilder();
  TermIterator iter=queue.freezeGlobalBuffer(null).termIterator();
  while (iter.next() != null) {
    bytesRef.copyBytes(iter.bytes);
    frozenSet.add(new Term(iter.field(),bytesRef.toBytesRef()));
  }
  assertEquals(uniqueValues,frozenSet);
  assertEquals("num deletes must be 0 after freeze",0,queue.numGlobalTermDeletes());
}
