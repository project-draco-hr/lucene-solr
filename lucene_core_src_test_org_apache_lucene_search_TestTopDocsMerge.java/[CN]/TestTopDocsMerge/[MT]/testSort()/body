{
  IndexReader reader=null;
  Directory dir=null;
  final int numDocs=atLeast(1000);
  final String[] tokens=new String[]{"a","b","c","d","e"};
  if (VERBOSE) {
    System.out.println("TEST: make index");
  }
{
    dir=newDirectory();
    final RandomIndexWriter w=new RandomIndexWriter(random(),dir);
    final String[] content=new String[atLeast(20)];
    for (int contentIDX=0; contentIDX < content.length; contentIDX++) {
      final StringBuilder sb=new StringBuilder();
      final int numTokens=TestUtil.nextInt(random(),1,10);
      for (int tokenIDX=0; tokenIDX < numTokens; tokenIDX++) {
        sb.append(tokens[random().nextInt(tokens.length)]).append(' ');
      }
      content[contentIDX]=sb.toString();
    }
    for (int docIDX=0; docIDX < numDocs; docIDX++) {
      final Document doc=new Document();
      doc.add(newStringField("string",TestUtil.randomRealisticUnicodeString(random()),Field.Store.NO));
      doc.add(newTextField("text",content[random().nextInt(content.length)],Field.Store.NO));
      doc.add(new FloatField("float",random().nextFloat(),Field.Store.NO));
      final int intValue;
      if (random().nextInt(100) == 17) {
        intValue=Integer.MIN_VALUE;
      }
 else       if (random().nextInt(100) == 17) {
        intValue=Integer.MAX_VALUE;
      }
 else {
        intValue=random().nextInt();
      }
      doc.add(new IntField("int",intValue,Field.Store.NO));
      if (VERBOSE) {
        System.out.println("  doc=" + doc);
      }
      w.addDocument(doc);
    }
    reader=w.getReader();
    w.close();
  }
  final IndexSearcher searcher=newSearcher(reader);
  final IndexReaderContext ctx=searcher.getTopReaderContext();
  final ShardSearcher[] subSearchers;
  final int[] docStarts;
  if (ctx instanceof AtomicReaderContext) {
    subSearchers=new ShardSearcher[1];
    docStarts=new int[1];
    subSearchers[0]=new ShardSearcher((AtomicReaderContext)ctx,ctx);
    docStarts[0]=0;
  }
 else {
    final CompositeReaderContext compCTX=(CompositeReaderContext)ctx;
    final int size=compCTX.leaves().size();
    subSearchers=new ShardSearcher[size];
    docStarts=new int[size];
    int docBase=0;
    for (int searcherIDX=0; searcherIDX < subSearchers.length; searcherIDX++) {
      final AtomicReaderContext leave=compCTX.leaves().get(searcherIDX);
      subSearchers[searcherIDX]=new ShardSearcher(leave,compCTX);
      docStarts[searcherIDX]=docBase;
      docBase+=leave.reader().maxDoc();
    }
  }
  final List<SortField> sortFields=new ArrayList<SortField>();
  sortFields.add(new SortField("string",SortField.Type.STRING,true));
  sortFields.add(new SortField("string",SortField.Type.STRING,false));
  sortFields.add(new SortField("int",SortField.Type.INT,true));
  sortFields.add(new SortField("int",SortField.Type.INT,false));
  sortFields.add(new SortField("float",SortField.Type.FLOAT,true));
  sortFields.add(new SortField("float",SortField.Type.FLOAT,false));
  sortFields.add(new SortField(null,SortField.Type.SCORE,true));
  sortFields.add(new SortField(null,SortField.Type.SCORE,false));
  sortFields.add(new SortField(null,SortField.Type.DOC,true));
  sortFields.add(new SortField(null,SortField.Type.DOC,false));
  for (int iter=0; iter < 1000 * RANDOM_MULTIPLIER; iter++) {
    final Query query=new TermQuery(new Term("text",tokens[random().nextInt(tokens.length)]));
    final Sort sort;
    if (random().nextInt(10) == 4) {
      sort=null;
    }
 else {
      final SortField[] randomSortFields=new SortField[TestUtil.nextInt(random(),1,3)];
      for (int sortIDX=0; sortIDX < randomSortFields.length; sortIDX++) {
        randomSortFields[sortIDX]=sortFields.get(random().nextInt(sortFields.size()));
      }
      sort=new Sort(randomSortFields);
    }
    final int numHits=TestUtil.nextInt(random(),1,numDocs + 5);
    if (VERBOSE) {
      System.out.println("TEST: search query=" + query + " sort="+ sort+ " numHits="+ numHits);
    }
    final TopDocs topHits;
    if (sort == null) {
      topHits=searcher.search(query,numHits);
    }
 else {
      final TopFieldCollector c=TopFieldCollector.create(sort,numHits,true,true,true,random().nextBoolean());
      searcher.search(query,c);
      topHits=c.topDocs(0,numHits);
    }
    if (VERBOSE) {
      System.out.println("  top search: " + topHits.totalHits + " totalHits; hits="+ (topHits.scoreDocs == null ? "null" : topHits.scoreDocs.length));
      if (topHits.scoreDocs != null) {
        for (int hitIDX=0; hitIDX < topHits.scoreDocs.length; hitIDX++) {
          final ScoreDoc sd=topHits.scoreDocs[hitIDX];
          System.out.println("    doc=" + sd.doc + " score="+ sd.score);
        }
      }
    }
    final Weight w=searcher.createNormalizedWeight(query);
    final TopDocs[] shardHits=new TopDocs[subSearchers.length];
    for (int shardIDX=0; shardIDX < subSearchers.length; shardIDX++) {
      final TopDocs subHits;
      final ShardSearcher subSearcher=subSearchers[shardIDX];
      if (sort == null) {
        subHits=subSearcher.search(w,numHits);
      }
 else {
        final TopFieldCollector c=TopFieldCollector.create(sort,numHits,true,true,true,random().nextBoolean());
        subSearcher.search(w,c);
        subHits=c.topDocs(0,numHits);
      }
      shardHits[shardIDX]=subHits;
      if (VERBOSE) {
        System.out.println("  shard=" + shardIDX + " "+ subHits.totalHits+ " totalHits hits="+ (subHits.scoreDocs == null ? "null" : subHits.scoreDocs.length));
        if (subHits.scoreDocs != null) {
          for (          ScoreDoc sd : subHits.scoreDocs) {
            System.out.println("    doc=" + sd.doc + " score="+ sd.score);
          }
        }
      }
    }
    final TopDocs mergedHits=TopDocs.merge(sort,numHits,shardHits);
    if (mergedHits.scoreDocs != null) {
      for (int hitIDX=0; hitIDX < mergedHits.scoreDocs.length; hitIDX++) {
        final ScoreDoc sd=mergedHits.scoreDocs[hitIDX];
        assertEquals("doc=" + sd.doc + " wrong shard",ReaderUtil.subIndex(sd.doc,docStarts),sd.shardIndex);
      }
    }
    TestUtil.assertEquals(topHits,mergedHits);
  }
  reader.close();
  dir.close();
}
