{
  if (q.weight(s).scoresDocsOutOfOrder())   return;
  final int skip_op=0;
  final int next_op=1;
  final int orders[][]={{next_op},{skip_op},{skip_op,next_op},{next_op,skip_op},{skip_op,skip_op,next_op,next_op},{next_op,next_op,skip_op,skip_op},{skip_op,skip_op,skip_op,next_op,next_op}};
  for (int k=0; k < orders.length; k++) {
    final int order[]=orders[k];
    final int opidx[]={0};
    final int lastDoc[]={-1};
    final float maxDiff=1e-5f;
    final IndexReader lastReader[]={null};
    s.search(q,new Collector(){
      private Scorer sc;
      private IndexReader reader;
      private Scorer scorer;
      @Override public void setScorer(      Scorer scorer) throws IOException {
        this.sc=scorer;
      }
      @Override public void collect(      int doc) throws IOException {
        float score=sc.score();
        lastDoc[0]=doc;
        try {
          if (scorer == null) {
            Weight w=q.weight(s);
            scorer=w.scorer(reader,true,false);
          }
          int op=order[(opidx[0]++) % order.length];
          boolean more=op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;
          int scorerDoc=scorer.docID();
          float scorerScore=scorer.score();
          float scorerScore2=scorer.score();
          float scoreDiff=Math.abs(score - scorerScore);
          float scorerDiff=Math.abs(scorerScore2 - scorerScore);
          if (!more || doc != scorerDoc || scoreDiff > maxDiff || scorerDiff > maxDiff) {
            StringBuilder sbord=new StringBuilder();
            for (int i=0; i < order.length; i++)             sbord.append(order[i] == skip_op ? " skip()" : " next()");
            throw new RuntimeException("ERROR matching docs:" + "\n\t" + (doc != scorerDoc ? "--> " : "") + "doc="+ doc+ ", scorerDoc="+ scorerDoc+ "\n\t"+ (!more ? "--> " : "")+ "tscorer.more="+ more+ "\n\t"+ (scoreDiff > maxDiff ? "--> " : "")+ "scorerScore="+ scorerScore+ " scoreDiff="+ scoreDiff+ " maxDiff="+ maxDiff+ "\n\t"+ (scorerDiff > maxDiff ? "--> " : "")+ "scorerScore2="+ scorerScore2+ " scorerDiff="+ scorerDiff+ "\n\thitCollector.doc="+ doc+ " score="+ score+ "\n\t Scorer="+ scorer+ "\n\t Query="+ q+ "  "+ q.getClass().getName()+ "\n\t Searcher="+ s+ "\n\t Order="+ sbord+ "\n\t Op="+ (op == skip_op ? " skip()" : " next()"));
          }
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      @Override public void setNextReader(      IndexReader reader,      int docBase) throws IOException {
        if (lastReader[0] != null) {
          final IndexReader previousReader=lastReader[0];
          Weight w=q.weight(new IndexSearcher(previousReader));
          Scorer scorer=w.scorer(previousReader,true,false);
          if (scorer != null) {
            boolean more=scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
            Assert.assertFalse("query's last doc was " + lastDoc[0] + " but skipTo("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
          }
        }
        this.reader=lastReader[0]=reader;
        this.scorer=null;
        lastDoc[0]=-1;
      }
      @Override public boolean acceptsDocsOutOfOrder(){
        return true;
      }
    }
);
    if (lastReader[0] != null) {
      final IndexReader previousReader=lastReader[0];
      Weight w=q.weight(new IndexSearcher(previousReader));
      Scorer scorer=w.scorer(previousReader,true,false);
      if (scorer != null) {
        boolean more=scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
        Assert.assertFalse("query's last doc was " + lastDoc[0] + " but skipTo("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
      }
    }
  }
}
