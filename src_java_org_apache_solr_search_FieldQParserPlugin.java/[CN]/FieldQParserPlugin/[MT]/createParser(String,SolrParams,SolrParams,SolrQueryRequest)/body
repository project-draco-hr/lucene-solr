{
  return new QParser(qstr,localParams,params,req){
    public Query parse() throws ParseException {
      String field=localParams.get(QueryParsing.F);
      String queryText=localParams.get(QueryParsing.V);
      FieldType ft=req.getSchema().getFieldType(field);
      if (!(ft instanceof TextField)) {
        String internal=ft.toInternal(queryText);
        return new TermQuery(new Term(field,internal));
      }
      int phraseSlop=0;
      Analyzer analyzer=req.getSchema().getQueryAnalyzer();
      TokenStream source=null;
      try {
        source=analyzer.reusableTokenStream(field,new StringReader(queryText));
        source.reset();
      }
 catch (      IOException e) {
        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,e);
      }
      ArrayList<Token> lst=new ArrayList<Token>();
      Token t;
      int positionCount=0;
      boolean severalTokensAtSamePosition=false;
      while (true) {
        try {
          t=source.next();
        }
 catch (        IOException e) {
          t=null;
        }
        if (t == null)         break;
        lst.add(t);
        if (t.getPositionIncrement() != 0)         positionCount+=t.getPositionIncrement();
 else         severalTokensAtSamePosition=true;
      }
      try {
        source.close();
      }
 catch (      IOException e) {
      }
      if (lst.size() == 0)       return null;
 else       if (lst.size() == 1) {
        t=lst.get(0);
        return new TermQuery(new Term(field,new String(t.termBuffer(),0,t.termLength())));
      }
 else {
        if (severalTokensAtSamePosition) {
          if (positionCount == 1) {
            BooleanQuery q=new BooleanQuery(true);
            for (int i=0; i < lst.size(); i++) {
              t=(org.apache.lucene.analysis.Token)lst.get(i);
              TermQuery currentQuery=new TermQuery(new Term(field,new String(t.termBuffer(),0,t.termLength())));
              q.add(currentQuery,BooleanClause.Occur.SHOULD);
            }
            return q;
          }
 else {
            MultiPhraseQuery mpq=new MultiPhraseQuery();
            mpq.setSlop(phraseSlop);
            ArrayList multiTerms=new ArrayList();
            for (int i=0; i < lst.size(); i++) {
              t=(org.apache.lucene.analysis.Token)lst.get(i);
              if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {
                mpq.add((Term[])multiTerms.toArray(new Term[0]));
                multiTerms.clear();
              }
              multiTerms.add(new Term(field,new String(t.termBuffer(),0,t.termLength())));
            }
            mpq.add((Term[])multiTerms.toArray(new Term[0]));
            return mpq;
          }
        }
 else {
          PhraseQuery q=new PhraseQuery();
          q.setSlop(phraseSlop);
          for (int i=0; i < lst.size(); i++) {
            Token token=lst.get(i);
            q.add(new Term(field,new String(token.termBuffer(),0,token.termLength())));
          }
          return q;
        }
      }
    }
  }
;
}
