{
  LeafReader reader=readerContext.reader();
  final NumericDocValues minX=DocValues.getNumeric(reader,strategy.field_minX);
  final NumericDocValues minY=DocValues.getNumeric(reader,strategy.field_minY);
  final NumericDocValues maxX=DocValues.getNumeric(reader,strategy.field_maxX);
  final NumericDocValues maxY=DocValues.getNumeric(reader,strategy.field_maxY);
  final Rectangle rect=strategy.getSpatialContext().makeRectangle(0,0,0,0);
  return new FunctionValues(){
    private int lastDocID=-1;
    private double getDocValue(    NumericDocValues values,    int doc) throws IOException {
      int curDocID=values.docID();
      if (doc > curDocID) {
        curDocID=values.advance(doc);
      }
      if (doc == curDocID) {
        return Double.longBitsToDouble(values.longValue());
      }
 else {
        return 0.0;
      }
    }
    @Override public Object objectVal(    int doc) throws IOException {
      if (doc < lastDocID) {
        throw new AssertionError("docs were sent out-of-order: lastDocID=" + lastDocID + " vs doc="+ doc);
      }
      lastDocID=doc;
      double minXValue=getDocValue(minX,doc);
      if (minX.docID() != doc) {
        return null;
      }
 else {
        double minYValue=getDocValue(minY,doc);
        double maxXValue=getDocValue(maxX,doc);
        double maxYValue=getDocValue(maxY,doc);
        rect.reset(minXValue,maxXValue,minYValue,maxYValue);
        return rect;
      }
    }
    @Override public String strVal(    int doc) throws IOException {
      Object v=objectVal(doc);
      return v == null ? null : v.toString();
    }
    @Override public boolean exists(    int doc) throws IOException {
      getDocValue(minX,doc);
      return minX.docID() == doc;
    }
    @Override public Explanation explain(    int doc) throws IOException {
      return Explanation.match(Float.NaN,toString(doc));
    }
    @Override public String toString(    int doc) throws IOException {
      return description() + '=' + strVal(doc);
    }
  }
;
}
