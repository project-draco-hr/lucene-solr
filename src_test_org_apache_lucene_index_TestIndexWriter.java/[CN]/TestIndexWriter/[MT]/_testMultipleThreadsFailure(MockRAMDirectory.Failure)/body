{
  int NUM_THREADS=3;
  for (int iter=0; iter < 5; iter++) {
    MockRAMDirectory dir=new MockRAMDirectory();
    IndexWriter writer=new IndexWriter(dir,new WhitespaceAnalyzer(),IndexWriter.MaxFieldLength.LIMITED);
    ConcurrentMergeScheduler cms=new ConcurrentMergeScheduler();
    cms.setSuppressExceptions();
    writer.setMergeScheduler(cms);
    writer.setMaxBufferedDocs(2);
    writer.setMergeFactor(4);
    IndexerThread[] threads=new IndexerThread[NUM_THREADS];
    boolean diskFull=false;
    for (int i=0; i < NUM_THREADS; i++)     threads[i]=new IndexerThread(writer,true);
    for (int i=0; i < NUM_THREADS; i++)     threads[i].start();
    try {
      Thread.sleep(10);
    }
 catch (    InterruptedException ie) {
      Thread.currentThread().interrupt();
    }
    dir.failOn(failure);
    failure.setDoFail();
    for (int i=0; i < NUM_THREADS; i++) {
      while (true) {
        try {
          threads[i].join();
          break;
        }
 catch (        InterruptedException ie) {
          Thread.currentThread().interrupt();
        }
      }
      if (threads[i].isAlive())       fail("thread seems to be hung");
 else       assertTrue("hit unexpected Throwable",threads[i].error == null);
    }
    boolean success=false;
    try {
      writer.close(false);
      success=true;
    }
 catch (    IOException ioe) {
    }
    if (success) {
      IndexReader reader=IndexReader.open(dir);
      for (int j=0; j < reader.maxDoc(); j++) {
        if (!reader.isDeleted(j)) {
          reader.document(j);
          reader.getTermFreqVectors(j);
        }
      }
      reader.close();
    }
    dir.close();
  }
}
