{
  final String origThreadName=Thread.currentThread().getName();
  try {
    Thread.currentThread().setName(origThreadName + "-w" + workerId);
    final int maxDocMultiplier=expected.length - 1;
    for (int docIter=0; docIter < numDocsToUpdate; docIter++) {
      final int docId=DOC_ID_INCR * TestUtil.nextInt(rand,0,maxDocMultiplier);
      Thread.currentThread().setName(origThreadName + "-w" + workerId+ "-d"+ docId);
      final int itersPerDoc=atLeast(rand,2);
      for (int updateIter=0; updateIter < itersPerDoc; updateIter++) {
        if (0 == abortLatch.getCount()) {
          return;
        }
        doRandomAtomicUpdate(docId);
      }
      if (rand.nextBoolean()) {
        Thread.yield();
      }
    }
  }
 catch (  Error err) {
    log.error(Thread.currentThread().getName(),err);
    abortLatch.countDown();
    throw err;
  }
catch (  Exception ex) {
    log.error(Thread.currentThread().getName(),ex);
    abortLatch.countDown();
    throw new RuntimeException(ex.getMessage(),ex);
  }
 finally {
    Thread.currentThread().setName(origThreadName);
  }
  ok=true;
}
