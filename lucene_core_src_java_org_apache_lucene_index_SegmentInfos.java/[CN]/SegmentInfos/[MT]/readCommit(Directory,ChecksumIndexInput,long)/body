{
  int magic=input.readInt();
  if (magic != CodecUtil.CODEC_MAGIC) {
    throw new IndexFormatTooOldException(input,magic,CodecUtil.CODEC_MAGIC,CodecUtil.CODEC_MAGIC);
  }
  int format=CodecUtil.checkHeaderNoMagic(input,"segments",VERSION_53,VERSION_CURRENT);
  byte id[]=new byte[StringHelper.ID_LENGTH];
  input.readBytes(id,0,id.length);
  CodecUtil.checkIndexHeaderSuffix(input,Long.toString(generation,Character.MAX_RADIX));
  SegmentInfos infos=new SegmentInfos();
  infos.id=id;
  infos.generation=generation;
  infos.lastGeneration=generation;
  if (format >= VERSION_53) {
    infos.luceneVersion=Version.fromBits(input.readVInt(),input.readVInt(),input.readVInt());
    if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {
      throw new IndexFormatTooOldException(input,"this index is too old (version: " + infos.luceneVersion + ")");
    }
  }
 else {
    throw new IndexFormatTooOldException(input,"this index segments file is too old (segment infos format: " + format + ")");
  }
  infos.version=input.readLong();
  infos.counter=input.readInt();
  int numSegments=input.readInt();
  if (numSegments < 0) {
    throw new CorruptIndexException("invalid segment count: " + numSegments,input);
  }
  if (numSegments > 0) {
    infos.minSegmentLuceneVersion=Version.fromBits(input.readVInt(),input.readVInt(),input.readVInt());
  }
 else {
  }
  long totalDocs=0;
  for (int seg=0; seg < numSegments; seg++) {
    String segName=input.readString();
    final byte segmentID[];
    byte hasID=input.readByte();
    if (hasID == 1) {
      segmentID=new byte[StringHelper.ID_LENGTH];
      input.readBytes(segmentID,0,segmentID.length);
    }
 else     if (hasID == 0) {
      throw new IndexFormatTooOldException(input,"Segment is from Lucene 4.x");
    }
 else {
      throw new CorruptIndexException("invalid hasID byte, got: " + hasID,input);
    }
    Codec codec=readCodec(input,format < VERSION_53);
    SegmentInfo info=codec.segmentInfoFormat().read(directory,segName,segmentID,IOContext.READ);
    info.setCodec(codec);
    totalDocs+=info.maxDoc();
    long delGen=input.readLong();
    int delCount=input.readInt();
    if (delCount < 0 || delCount > info.maxDoc()) {
      throw new CorruptIndexException("invalid deletion count: " + delCount + " vs maxDoc="+ info.maxDoc(),input);
    }
    long fieldInfosGen=input.readLong();
    long dvGen=input.readLong();
    SegmentCommitInfo siPerCommit=new SegmentCommitInfo(info,delCount,delGen,fieldInfosGen,dvGen);
    siPerCommit.setFieldInfosFiles(input.readSetOfStrings());
    final Map<Integer,Set<String>> dvUpdateFiles;
    final int numDVFields=input.readInt();
    if (numDVFields == 0) {
      dvUpdateFiles=Collections.emptyMap();
    }
 else {
      Map<Integer,Set<String>> map=new HashMap<>(numDVFields);
      for (int i=0; i < numDVFields; i++) {
        map.put(input.readInt(),input.readSetOfStrings());
      }
      dvUpdateFiles=Collections.unmodifiableMap(map);
    }
    siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);
    infos.add(siPerCommit);
    Version segmentVersion=info.getVersion();
    if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {
      throw new CorruptIndexException("segments file recorded minSegmentLuceneVersion=" + infos.minSegmentLuceneVersion + " but segment="+ info+ " has older version="+ segmentVersion,input);
    }
  }
  infos.userData=input.readMapOfStrings();
  CodecUtil.checkFooter(input);
  if (totalDocs > IndexWriter.getActualMaxDocs()) {
    throw new CorruptIndexException("Too many documents: an index cannot exceed " + IndexWriter.getActualMaxDocs() + " but readers have total maxDoc="+ totalDocs,input);
  }
  return infos;
}
