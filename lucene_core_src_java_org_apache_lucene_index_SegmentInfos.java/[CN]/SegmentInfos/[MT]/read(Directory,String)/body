{
  boolean success=false;
  this.clear();
  generation=generationFromSegmentsFileName(segmentFileName);
  lastGeneration=generation;
  ChecksumIndexInput input=directory.openChecksumInput(segmentFileName,IOContext.READ);
  try {
    int magic=input.readInt();
    if (magic != CodecUtil.CODEC_MAGIC) {
      throw new IndexFormatTooOldException(input,magic,CodecUtil.CODEC_MAGIC,CodecUtil.CODEC_MAGIC);
    }
    int format=CodecUtil.checkHeaderNoMagic(input,"segments",VERSION_40,VERSION_50);
    version=input.readLong();
    counter=input.readInt();
    int numSegments=input.readInt();
    if (numSegments < 0) {
      throw new CorruptIndexException("invalid segment count: " + numSegments,input);
    }
    for (int seg=0; seg < numSegments; seg++) {
      String segName=input.readString();
      Codec codec=Codec.forName(input.readString());
      SegmentInfo info=codec.segmentInfoFormat().getSegmentInfoReader().read(directory,segName,IOContext.READ);
      info.setCodec(codec);
      long delGen=input.readLong();
      int delCount=input.readInt();
      if (delCount < 0 || delCount > info.getDocCount()) {
        throw new CorruptIndexException("invalid deletion count: " + delCount + " vs docCount="+ info.getDocCount(),input);
      }
      long fieldInfosGen=-1;
      if (format >= VERSION_46) {
        fieldInfosGen=input.readLong();
      }
      long dvGen=-1;
      if (format >= VERSION_49) {
        dvGen=input.readLong();
      }
 else {
        dvGen=fieldInfosGen;
      }
      SegmentCommitInfo siPerCommit=new SegmentCommitInfo(info,delCount,delGen,fieldInfosGen,dvGen);
      if (format >= VERSION_46) {
        if (format < VERSION_49) {
          final int numGensUpdatesFiles=input.readInt();
          final Map<Long,Set<String>> genUpdatesFiles;
          if (numGensUpdatesFiles == 0) {
            genUpdatesFiles=Collections.emptyMap();
          }
 else {
            genUpdatesFiles=new HashMap<>(numGensUpdatesFiles);
            for (int i=0; i < numGensUpdatesFiles; i++) {
              genUpdatesFiles.put(input.readLong(),input.readStringSet());
            }
          }
          siPerCommit.setGenUpdatesFiles(genUpdatesFiles);
        }
 else {
          siPerCommit.setFieldInfosFiles(input.readStringSet());
          final Map<Integer,Set<String>> dvUpdateFiles;
          final int numDVFields=input.readInt();
          if (numDVFields == 0) {
            dvUpdateFiles=Collections.emptyMap();
          }
 else {
            dvUpdateFiles=new HashMap<>(numDVFields);
            for (int i=0; i < numDVFields; i++) {
              dvUpdateFiles.put(input.readInt(),input.readStringSet());
            }
          }
          siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);
        }
      }
      add(siPerCommit);
    }
    userData=input.readStringStringMap();
    if (format >= VERSION_50) {
      id=new byte[StringHelper.ID_LENGTH];
      input.readBytes(id,0,id.length);
    }
    if (format >= VERSION_48) {
      CodecUtil.checkFooter(input);
    }
 else {
      final long checksumNow=input.getChecksum();
      final long checksumThen=input.readLong();
      if (checksumNow != checksumThen) {
        throw new CorruptIndexException("checksum failed (hardware problem?) : expected=" + Long.toHexString(checksumThen) + " actual="+ Long.toHexString(checksumNow),input);
      }
      CodecUtil.checkEOF(input);
    }
    success=true;
  }
  finally {
    if (!success) {
      this.clear();
      IOUtils.closeWhileHandlingException(input);
    }
 else {
      input.close();
    }
  }
}
