{
  boolean success=false;
  this.clear();
  generation=generationFromSegmentsFileName(segmentFileName);
  lastGeneration=generation;
  ChecksumIndexInput input=new ChecksumIndexInput(directory.openInput(segmentFileName,IOContext.READ));
  try {
    int magic=input.readInt();
    if (magic != CodecUtil.CODEC_MAGIC) {
      throw new IndexFormatTooOldException(input,magic,CodecUtil.CODEC_MAGIC,CodecUtil.CODEC_MAGIC);
    }
    CodecUtil.checkHeaderNoMagic(input,"segments",VERSION_40,VERSION_40);
    version=input.readLong();
    counter=input.readInt();
    int numSegments=input.readInt();
    if (numSegments < 0) {
      throw new CorruptIndexException("invalid segment count: " + numSegments + " (resource: "+ input+ ")");
    }
    for (int seg=0; seg < numSegments; seg++) {
      String segName=input.readString();
      Codec codec=Codec.forName(input.readString());
      SegmentInfo info=codec.segmentInfoFormat().getSegmentInfoReader().read(directory,segName,IOContext.READ);
      info.setCodec(codec);
      long delGen=input.readLong();
      int delCount=input.readInt();
      if (delCount < 0 || delCount > info.getDocCount()) {
        throw new CorruptIndexException("invalid deletion count: " + delCount + " (resource: "+ input+ ")");
      }
      add(new SegmentInfoPerCommit(info,delCount,delGen));
    }
    userData=input.readStringStringMap();
    final long checksumNow=input.getChecksum();
    final long checksumThen=input.readLong();
    if (checksumNow != checksumThen) {
      throw new CorruptIndexException("checksum mismatch in segments file (resource: " + input + ")");
    }
    success=true;
  }
  finally {
    if (!success) {
      this.clear();
      IOUtils.closeWhileHandlingException(input);
    }
 else {
      input.close();
    }
  }
}
