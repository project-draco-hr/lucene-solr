{
  long generation=generationFromSegmentsFileName(segmentFileName);
  try (ChecksumIndexInput input=directory.openChecksumInput(segmentFileName,IOContext.READ)){
    int magic=input.readInt();
    if (magic != CodecUtil.CODEC_MAGIC) {
      throw new IndexFormatTooOldException(input,magic,CodecUtil.CODEC_MAGIC,CodecUtil.CODEC_MAGIC);
    }
    int format=CodecUtil.checkHeaderNoMagic(input,"segments",VERSION_50,VERSION_CURRENT);
    byte id[]=new byte[StringHelper.ID_LENGTH];
    input.readBytes(id,0,id.length);
    CodecUtil.checkIndexHeaderSuffix(input,Long.toString(generation,Character.MAX_RADIX));
    SegmentInfos infos=new SegmentInfos();
    infos.id=id;
    infos.generation=generation;
    infos.lastGeneration=generation;
    infos.version=input.readLong();
    infos.counter=input.readInt();
    int numSegments=input.readInt();
    if (numSegments < 0) {
      throw new CorruptIndexException("invalid segment count: " + numSegments,input);
    }
    long totalDocs=0;
    for (int seg=0; seg < numSegments; seg++) {
      String segName=input.readString();
      final byte segmentID[];
      byte hasID=input.readByte();
      if (hasID == 1) {
        segmentID=new byte[StringHelper.ID_LENGTH];
        input.readBytes(segmentID,0,segmentID.length);
      }
 else       if (hasID == 0) {
        throw new IndexFormatTooOldException(input,"Segment is from Lucene 4.x");
      }
 else {
        throw new CorruptIndexException("invalid hasID byte, got: " + hasID,input);
      }
      Codec codec=readCodec(input);
      SegmentInfo info=codec.segmentInfoFormat().read(directory,segName,segmentID,IOContext.READ);
      info.setCodec(codec);
      totalDocs+=info.maxDoc();
      long delGen=input.readLong();
      int delCount=input.readInt();
      if (delCount < 0 || delCount > info.maxDoc()) {
        throw new CorruptIndexException("invalid deletion count: " + delCount + " vs maxDoc="+ info.maxDoc(),input);
      }
      long fieldInfosGen=input.readLong();
      long dvGen=input.readLong();
      SegmentCommitInfo siPerCommit=new SegmentCommitInfo(info,delCount,delGen,fieldInfosGen,dvGen);
      if (format >= VERSION_51) {
        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());
      }
 else {
        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));
      }
      final Map<Integer,Set<String>> dvUpdateFiles;
      final int numDVFields=input.readInt();
      if (numDVFields == 0) {
        dvUpdateFiles=Collections.emptyMap();
      }
 else {
        Map<Integer,Set<String>> map=new HashMap<>(numDVFields);
        for (int i=0; i < numDVFields; i++) {
          if (format >= VERSION_51) {
            map.put(input.readInt(),input.readSetOfStrings());
          }
 else {
            map.put(input.readInt(),Collections.unmodifiableSet(input.readStringSet()));
          }
        }
        dvUpdateFiles=Collections.unmodifiableMap(map);
      }
      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);
      infos.add(siPerCommit);
    }
    if (format >= VERSION_51) {
      infos.userData=input.readMapOfStrings();
    }
 else {
      infos.userData=Collections.unmodifiableMap(input.readStringStringMap());
    }
    CodecUtil.checkFooter(input);
    if (totalDocs > IndexWriter.getActualMaxDocs()) {
      throw new CorruptIndexException("Too many documents: an index cannot exceed " + IndexWriter.getActualMaxDocs() + " but readers have total maxDoc="+ totalDocs,input);
    }
    return infos;
  }
 }
