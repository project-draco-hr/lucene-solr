{
  try {
    DirectUpdateHandler2.commitOnClose=false;
    final Semaphore logReplay=new Semaphore(0);
    final Semaphore logReplayFinish=new Semaphore(0);
    UpdateLog.testing_logReplayHook=new Runnable(){
      @Override public void run(){
        try {
          assertTrue(logReplay.tryAcquire(timeout,TimeUnit.SECONDS));
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    UpdateLog.testing_logReplayFinishHook=new Runnable(){
      @Override public void run(){
        logReplayFinish.release();
      }
    }
;
    clearIndex();
    assertU(commit());
    UpdateLog ulog=h.getCore().getUpdateHandler().getUpdateLog();
    File logDir=new File(h.getCore().getUpdateHandler().getUpdateLog().getLogDir());
    h.close();
    String[] files=ulog.getLogList(logDir);
    for (    String file : files) {
      Files.delete(new File(logDir,file).toPath());
    }
    assertEquals(0,ulog.getLogList(logDir).length);
    createCore();
    int numIndexed=0;
    int maxReq=200;
    LinkedList<Long> versions=new LinkedList<>();
    int docsPerBatch=3;
    int expectedToRetain=ulog.getMaxNumLogsToKeep() * docsPerBatch;
    int versExpected;
    for (int i=1; i <= ulog.getMaxNumLogsToKeep() + 2; i++) {
      addDocs(docsPerBatch,numIndexed,versions);
      numIndexed+=docsPerBatch;
      versExpected=Math.min(numIndexed,expectedToRetain + docsPerBatch);
      assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,versExpected)));
      assertU(commit());
      versExpected=Math.min(numIndexed,expectedToRetain);
      assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,versExpected)));
      assertEquals(Math.min(i,ulog.getMaxNumLogsToKeep()),ulog.getLogList(logDir).length);
    }
    docsPerBatch=ulog.getNumRecordsToKeep() + 20;
    expectedToRetain=ulog.getNumRecordsToKeep();
    addDocs(docsPerBatch,numIndexed,versions);
    numIndexed+=docsPerBatch;
    versExpected=Math.min(numIndexed,expectedToRetain);
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,versExpected)));
    assertU(commit());
    expectedToRetain=expectedToRetain - 1;
    versExpected=Math.min(numIndexed,expectedToRetain);
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,versExpected)));
    assertEquals(1,ulog.getLogList(logDir).length);
    addDocs(1,numIndexed,versions);
    numIndexed+=1;
    h.close();
    createCore();
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,expectedToRetain)));
    logReplay.release(1000);
    assertTrue(logReplayFinish.tryAcquire(timeout,TimeUnit.SECONDS));
    expectedToRetain=expectedToRetain - 1;
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,expectedToRetain)));
    docsPerBatch=ulog.getNumRecordsToKeep() + 20;
    expectedToRetain=ulog.getNumRecordsToKeep();
    addDocs(docsPerBatch,numIndexed,versions);
    numIndexed+=docsPerBatch;
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,expectedToRetain)));
    assertU(commit());
    expectedToRetain=expectedToRetain - 1;
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,expectedToRetain)));
    assertEquals(1,ulog.getLogList(logDir).length);
    addDocs(1,numIndexed,new LinkedList<Long>());
    h.close();
    files=ulog.getLogList(logDir);
    Arrays.sort(files);
    RandomAccessFile raf=new RandomAccessFile(new File(logDir,files[files.length - 1]),"rw");
    raf.writeChars("This is a trashed log file that really shouldn't work at all, but we'll see...");
    raf.close();
    ignoreException("Failure to open existing");
    createCore();
    assertJQ(req("qt","/get","getVersions","" + maxReq),"/versions==" + versions.subList(0,Math.min(maxReq,expectedToRetain)));
    resetExceptionIgnores();
  }
  finally {
    DirectUpdateHandler2.commitOnClose=true;
    UpdateLog.testing_logReplayHook=null;
    UpdateLog.testing_logReplayFinishHook=null;
  }
}
