{
  final Charset ASCII=Charset.forName("ASCII");
  final int INDEX_KEY=0;
  final int INDEX_IV=1;
  final int ITERATIONS=1;
  final int SALT_OFFSET=8;
  final int SALT_SIZE=8;
  final int CIPHERTEXT_OFFSET=SALT_OFFSET + SALT_SIZE;
  try {
    byte[] headerSaltAndCipherText=Base64.base64ToByteArray(base64CipherTxt);
    byte[] salt=Arrays.copyOfRange(headerSaltAndCipherText,SALT_OFFSET,SALT_OFFSET + SALT_SIZE);
    byte[] encrypted=Arrays.copyOfRange(headerSaltAndCipherText,CIPHERTEXT_OFFSET,headerSaltAndCipherText.length);
    Cipher aesCBC=Cipher.getInstance("AES/CBC/PKCS5Padding");
    MessageDigest md5=MessageDigest.getInstance("MD5");
    final byte[][] keyAndIV=evpBytesTokey(keySizeBits / Byte.SIZE,aesCBC.getBlockSize(),md5,salt,pwd.getBytes(ASCII),ITERATIONS);
    SecretKeySpec key=new SecretKeySpec(keyAndIV[INDEX_KEY],"AES");
    IvParameterSpec iv=new IvParameterSpec(keyAndIV[INDEX_IV]);
    aesCBC.init(Cipher.DECRYPT_MODE,key,iv);
    byte[] decrypted=aesCBC.doFinal(encrypted);
    return new String(decrypted,ASCII);
  }
 catch (  BadPaddingException e) {
    throw new IllegalStateException("Bad password, algorithm, mode or padding;" + " no salt, wrong number of iterations or corrupted ciphertext.",e);
  }
catch (  IllegalBlockSizeException e) {
    throw new IllegalStateException("Bad algorithm, mode or corrupted (resized) ciphertext.",e);
  }
catch (  GeneralSecurityException e) {
    throw new IllegalStateException(e);
  }
}
