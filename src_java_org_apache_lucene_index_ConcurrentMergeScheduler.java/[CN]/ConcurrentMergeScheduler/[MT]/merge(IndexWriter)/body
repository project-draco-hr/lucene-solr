{
  this.writer=writer;
  initMergeThreadPriority();
  dir=writer.getDirectory();
  message("now merge");
  message("  index: " + writer.segString());
  while (true) {
    MergePolicy.OneMerge merge=writer.getNextMerge();
    if (merge == null) {
      message("  no more merges pending; now return");
      return;
    }
    writer.mergeInit(merge);
    message("  consider merge " + merge.segString(dir));
    if (merge.isExternal) {
      message("    merge involves segments from an external directory; now run in foreground");
    }
 else {
synchronized (this) {
        if (mergeThreadCount() < maxThreadCount) {
          final MergeThread merger=getMergeThread(writer,merge);
          mergeThreads.add(merger);
          message("    launch new thread [" + merger.getName() + "]");
          merger.start();
          continue;
        }
 else         message("    too many merge threads running; run merge in foreground");
      }
    }
    doMerge(merge);
  }
}
