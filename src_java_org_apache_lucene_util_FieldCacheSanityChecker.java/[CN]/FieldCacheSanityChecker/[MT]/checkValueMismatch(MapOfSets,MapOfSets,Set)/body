{
  final List insanity=new ArrayList(valMismatchKeys.size() * 3);
  if (!valMismatchKeys.isEmpty()) {
    final Map rfMap=readerFieldToValIds.getMap();
    final Map valMap=valIdToItems.getMap();
    final Iterator mismatchIter=valMismatchKeys.iterator();
    while (mismatchIter.hasNext()) {
      final ReaderField rf=(ReaderField)mismatchIter.next();
      final List badEntries=new ArrayList(valMismatchKeys.size() * 2);
      final Iterator valIter=((Set)rfMap.get(rf)).iterator();
      while (valIter.hasNext()) {
        Iterator entriesIter=((Set)valMap.get(valIter.next())).iterator();
        while (entriesIter.hasNext()) {
          badEntries.add(entriesIter.next());
        }
      }
      CacheEntry[] badness=new CacheEntry[badEntries.size()];
      badness=(CacheEntry[])badEntries.toArray(badness);
      insanity.add(new Insanity(InsanityType.VALUEMISMATCH,"Multiple distinct value objects for " + rf.toString(),badness));
    }
  }
  return insanity;
}
