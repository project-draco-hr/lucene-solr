{
  int minDfFilterCache=params.getFieldInt(field,FacetParams.FACET_ENUM_CACHE_MINDF,0);
  DocSet fastForRandomSet=docs;
  if (minDfFilterCache > 0 && docs instanceof SortedIntDocSet) {
    SortedIntDocSet sset=(SortedIntDocSet)docs;
    fastForRandomSet=new HashDocSet(sset.getDocs(),0,sset.size());
  }
  IndexSchema schema=searcher.getSchema();
  AtomicReader r=searcher.getAtomicReader();
  FieldType ft=schema.getFieldType(field);
  boolean sortByCount=sort.equals("count") || sort.equals("true");
  final int maxsize=limit >= 0 ? offset + limit : Integer.MAX_VALUE - 1;
  final BoundedTreeSet<CountPair<BytesRef,Integer>> queue=sortByCount ? new BoundedTreeSet<CountPair<BytesRef,Integer>>(maxsize) : null;
  final NamedList<Integer> res=new NamedList<Integer>();
  int min=mincount - 1;
  int off=offset;
  int lim=limit >= 0 ? limit : Integer.MAX_VALUE;
  BytesRef startTermBytes=null;
  if (prefix != null) {
    String indexedPrefix=ft.toInternal(prefix);
    startTermBytes=new BytesRef(indexedPrefix);
  }
  Fields fields=r.fields();
  Terms terms=fields == null ? null : fields.terms(field);
  TermsEnum termsEnum=null;
  SolrIndexSearcher.DocsEnumState deState=null;
  BytesRef term=null;
  if (terms != null) {
    termsEnum=terms.iterator(null);
    if (startTermBytes != null) {
      if (termsEnum.seekCeil(startTermBytes) == TermsEnum.SeekStatus.END) {
        termsEnum=null;
      }
 else {
        term=termsEnum.term();
      }
    }
 else {
      term=termsEnum.next();
    }
  }
  DocsEnum docsEnum=null;
  CharsRef charsRef=new CharsRef(10);
  if (docs.size() >= mincount) {
    while (term != null) {
      if (startTermBytes != null && !StringHelper.startsWith(term,startTermBytes))       break;
      int df=termsEnum.docFreq();
      if (df > 0 && df > min) {
        int c;
        if (df >= minDfFilterCache) {
          if (deState == null) {
            deState=new SolrIndexSearcher.DocsEnumState();
            deState.fieldName=field;
            deState.liveDocs=r.getLiveDocs();
            deState.termsEnum=termsEnum;
            deState.docsEnum=docsEnum;
          }
          c=searcher.numDocs(docs,deState);
          docsEnum=deState.docsEnum;
        }
 else {
          docsEnum=termsEnum.docs(null,docsEnum,DocsEnum.FLAG_NONE);
          c=0;
          if (docsEnum instanceof MultiDocsEnum) {
            MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
            int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
            for (int subindex=0; subindex < numSubs; subindex++) {
              MultiDocsEnum.EnumWithSlice sub=subs[subindex];
              if (sub.docsEnum == null)               continue;
              int base=sub.slice.start;
              int docid;
              while ((docid=sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
                if (fastForRandomSet.exists(docid + base))                 c++;
              }
            }
          }
 else {
            int docid;
            while ((docid=docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
              if (fastForRandomSet.exists(docid))               c++;
            }
          }
        }
        if (sortByCount) {
          if (c > min) {
            BytesRef termCopy=BytesRef.deepCopyOf(term);
            queue.add(new CountPair<BytesRef,Integer>(termCopy,c));
            if (queue.size() >= maxsize)             min=queue.last().val;
          }
        }
 else {
          if (c >= mincount && --off < 0) {
            if (--lim < 0)             break;
            ft.indexedToReadable(term,charsRef);
            res.add(charsRef.toString(),c);
          }
        }
      }
      term=termsEnum.next();
    }
  }
  if (sortByCount) {
    for (    CountPair<BytesRef,Integer> p : queue) {
      if (--off >= 0)       continue;
      if (--lim < 0)       break;
      ft.indexedToReadable(p.key,charsRef);
      res.add(charsRef.toString(),p.val);
    }
  }
  if (missing) {
    res.add(null,getFieldMissingCount(searcher,docs,field));
  }
  return res;
}
