{
  long output=arc.output;
  int upto=0;
  while (true) {
    if (arc.isFinal()) {
      final long finalOutput=output + arc.nextFinalOutput;
      if (finalOutput == targetOutput) {
        result.setLength(upto);
        return result.get();
      }
 else       if (finalOutput > targetOutput) {
        return null;
      }
    }
    if (FST.targetHasArcs(arc)) {
      result.grow(1 + upto);
      fst.readFirstRealTargetArc(arc.target,arc,in);
      if (arc.bytesPerArc != 0) {
        int low=0;
        int high=arc.numArcs - 1;
        int mid=0;
        boolean exact=false;
        while (low <= high) {
          mid=(low + high) >>> 1;
          in.setPosition(arc.posArcsStart);
          in.skipBytes(arc.bytesPerArc * mid);
          final byte flags=in.readByte();
          fst.readLabel(in);
          final long minArcOutput;
          if ((flags & FST.BIT_ARC_HAS_OUTPUT) != 0) {
            final long arcOutput=fst.outputs.read(in);
            minArcOutput=output + arcOutput;
          }
 else {
            minArcOutput=output;
          }
          if (minArcOutput == targetOutput) {
            exact=true;
            break;
          }
 else           if (minArcOutput < targetOutput) {
            low=mid + 1;
          }
 else {
            high=mid - 1;
          }
        }
        if (high == -1) {
          return null;
        }
 else         if (exact) {
          arc.arcIdx=mid - 1;
        }
 else {
          arc.arcIdx=low - 2;
        }
        fst.readNextRealArc(arc,in);
        result.setIntAt(upto++,arc.label);
        output+=arc.output;
      }
 else {
        FST.Arc<Long> prevArc=null;
        while (true) {
          final long minArcOutput=output + arc.output;
          if (minArcOutput == targetOutput) {
            output=minArcOutput;
            result.setIntAt(upto++,arc.label);
            break;
          }
 else           if (minArcOutput > targetOutput) {
            if (prevArc == null) {
              return null;
            }
 else {
              arc.copyFrom(prevArc);
              result.setIntAt(upto++,arc.label);
              output+=arc.output;
              break;
            }
          }
 else           if (arc.isLast()) {
            output=minArcOutput;
            result.setIntAt(upto++,arc.label);
            break;
          }
 else {
            prevArc=scratchArc;
            prevArc.copyFrom(arc);
            fst.readNextRealArc(arc,in);
          }
        }
      }
    }
 else {
      return null;
    }
  }
}
