{
  Counter bytesUsed=Counter.newCounter();
  ByteBlockPool pool=new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));
  pool.nextBuffer();
  boolean reuseFirst=random().nextBoolean();
  for (int j=0; j < 2; j++) {
    List<BytesRef> list=new ArrayList<>();
    int maxLength=atLeast(500);
    final int numValues=atLeast(100);
    BytesRefBuilder ref=new BytesRefBuilder();
    for (int i=0; i < numValues; i++) {
      final String value=TestUtil.randomRealisticUnicodeString(random(),maxLength);
      list.add(new BytesRef(value));
      ref.copyChars(value);
      pool.append(ref.get());
    }
    long position=0;
    for (    BytesRef expected : list) {
      ref.grow(expected.length);
      ref.setLength(expected.length);
switch (random().nextInt(3)) {
case 0:
        pool.readBytes(position,ref.bytes(),0,ref.length());
      break;
case 1:
    for (int i=0; i < ref.length(); ++i) {
      ref.setByteAt(i,pool.readByte(position + i));
    }
  break;
case 2:
BytesRef scratch=new BytesRef();
scratch.length=ref.length();
pool.setRawBytesRef(scratch,position);
System.arraycopy(scratch.bytes,scratch.offset,ref.bytes(),0,ref.length());
break;
default :
fail();
}
assertEquals(expected,ref.get());
position+=ref.length();
}
pool.reset(random().nextBoolean(),reuseFirst);
if (reuseFirst) {
assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE,bytesUsed.get());
}
 else {
assertEquals(0,bytesUsed.get());
pool.nextBuffer();
}
}
}
