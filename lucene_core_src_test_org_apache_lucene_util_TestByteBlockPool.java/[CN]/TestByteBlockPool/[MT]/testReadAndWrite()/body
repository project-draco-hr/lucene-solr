{
  Counter bytesUsed=Counter.newCounter();
  ByteBlockPool pool=new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(bytesUsed));
  pool.nextBuffer();
  boolean reuseFirst=random().nextBoolean();
  for (int j=0; j < 2; j++) {
    List<BytesRef> list=new ArrayList<>();
    int maxLength=atLeast(500);
    final int numValues=atLeast(100);
    BytesRefBuilder ref=new BytesRefBuilder();
    for (int i=0; i < numValues; i++) {
      final String value=TestUtil.randomRealisticUnicodeString(random(),maxLength);
      list.add(new BytesRef(value));
      ref.copyChars(value);
      pool.append(ref.get());
    }
    long position=0;
    for (    BytesRef expected : list) {
      ref.grow(expected.length);
      ref.setLength(expected.length);
      pool.readBytes(position,ref.bytes(),0,ref.length());
      assertEquals(expected,ref.get());
      position+=ref.length();
    }
    pool.reset(random().nextBoolean(),reuseFirst);
    if (reuseFirst) {
      assertEquals(ByteBlockPool.BYTE_BLOCK_SIZE,bytesUsed.get());
    }
 else {
      assertEquals(0,bytesUsed.get());
      pool.nextBuffer();
    }
  }
}
