{
  final Parser parser=(Parser)key.custom;
  final HoldsOneThing<GrowableWriterAndMinValue> valuesRef=new HoldsOneThing<>();
  Uninvert u=new Uninvert(){
    private long minValue;
    private long currentValue;
    private GrowableWriter values;
    @Override public void visitTerm(    BytesRef term){
      currentValue=parser.parseValue(term);
      if (values == null) {
        int startBitsPerValue;
        if (currentValue < 0) {
          minValue=currentValue;
          startBitsPerValue=minValue == Long.MIN_VALUE ? 64 : PackedInts.bitsRequired(-minValue);
        }
 else {
          minValue=0;
          startBitsPerValue=PackedInts.bitsRequired(currentValue);
        }
        values=new GrowableWriter(startBitsPerValue,reader.maxDoc(),PackedInts.FAST);
        if (minValue != 0) {
          values.fill(0,values.size(),-minValue);
        }
        valuesRef.set(new GrowableWriterAndMinValue(values,minValue));
      }
    }
    @Override public void visitDoc(    int docID){
      values.set(docID,currentValue - minValue);
    }
    @Override protected TermsEnum termsEnum(    Terms terms) throws IOException {
      return parser.termsEnum(terms);
    }
  }
;
  u.uninvert(reader,key.field,setDocsWithField);
  if (setDocsWithField) {
    wrapper.setDocsWithField(reader,key.field,u.docsWithField);
  }
  GrowableWriterAndMinValue values=valuesRef.get();
  if (values == null) {
    return new LongsFromArray(new PackedInts.NullReader(reader.maxDoc()),0L);
  }
  return new LongsFromArray(values.writer.getMutable(),values.minValue);
}
