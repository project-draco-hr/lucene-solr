{
  addNumericField(fieldInfo,new Iterable<Number>(){
    @Override public Iterator<Number> iterator(){
      return new Iterator<Number>(){
        int readerUpto=-1;
        int docIDUpto;
        long nextValue;
        boolean nextHasValue;
        int currentMaxDoc;
        NumericDocValues currentValues;
        Bits currentLiveDocs;
        Bits currentDocsWithField;
        boolean nextIsSet;
        @Override public boolean hasNext(){
          return nextIsSet || setNext();
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
        @Override public Number next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          assert nextIsSet;
          nextIsSet=false;
          return nextHasValue ? nextValue : null;
        }
        private boolean setNext(){
          while (true) {
            if (readerUpto == toMerge.size()) {
              return false;
            }
            if (docIDUpto == currentMaxDoc) {
              readerUpto++;
              if (readerUpto < toMerge.size()) {
                currentValues=toMerge.get(readerUpto);
                currentDocsWithField=docsWithField.get(readerUpto);
                currentLiveDocs=mergeState.liveDocs[readerUpto];
                currentMaxDoc=mergeState.maxDocs[readerUpto];
              }
              docIDUpto=0;
              continue;
            }
            if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {
              nextIsSet=true;
              nextValue=currentValues.get(docIDUpto);
              if (nextValue == 0 && currentDocsWithField.get(docIDUpto) == false) {
                nextHasValue=false;
              }
 else {
                nextHasValue=true;
              }
              docIDUpto++;
              return true;
            }
            docIDUpto++;
          }
        }
      }
;
    }
  }
);
}
