{
  final SortedBytesMerger merger=new SortedBytesMerger();
  merger.merge(mergeState,toMerge);
  addSortedField(fieldInfo,new Iterable<BytesRef>(){
    @Override public Iterator<BytesRef> iterator(){
      final AppendingLongBuffer.Iterator readerIDs=merger.ordToReaderId.iterator();
      final AppendingLongBuffer.Iterator ordDeltas[]=new AppendingLongBuffer.Iterator[merger.segStates.size()];
      final int lastOrds[]=new int[ordDeltas.length];
      for (int i=0; i < ordDeltas.length; i++) {
        ordDeltas[i]=merger.segStates.get(i).ordDeltas.iterator();
      }
      final BytesRef scratch=new BytesRef();
      return new Iterator<BytesRef>(){
        int ordUpto;
        @Override public boolean hasNext(){
          return ordUpto < merger.numMergedTerms;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
        @Override public BytesRef next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          int readerID=(int)readerIDs.next();
          int ord=lastOrds[readerID] + (int)ordDeltas[readerID].next();
          merger.segStates.get(readerID).values.lookupOrd(ord,scratch);
          lastOrds[readerID]=ord;
          ordUpto++;
          return scratch;
        }
      }
;
    }
  }
,new Iterable<Number>(){
    @Override public Iterator<Number> iterator(){
      return new Iterator<Number>(){
        int readerUpto=-1;
        int docIDUpto;
        int nextValue;
        SortedBytesMerger.SegmentState currentReader;
        Bits currentLiveDocs;
        boolean nextIsSet;
        @Override public boolean hasNext(){
          return nextIsSet || setNext();
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
        @Override public Number next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          assert nextIsSet;
          nextIsSet=false;
          return nextValue;
        }
        private boolean setNext(){
          while (true) {
            if (readerUpto == merger.segStates.size()) {
              return false;
            }
            if (currentReader == null || docIDUpto == currentReader.reader.maxDoc()) {
              readerUpto++;
              if (readerUpto < merger.segStates.size()) {
                currentReader=merger.segStates.get(readerUpto);
                currentLiveDocs=currentReader.reader.getLiveDocs();
              }
              docIDUpto=0;
              continue;
            }
            if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {
              nextIsSet=true;
              int segOrd=currentReader.values.getOrd(docIDUpto);
              nextValue=currentReader.segOrdToMergedOrd[segOrd];
              docIDUpto++;
              return true;
            }
            docIDUpto++;
          }
        }
      }
;
    }
  }
);
}
