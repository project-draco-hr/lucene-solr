{
  final AtomicReader readers[]=mergeState.readers.toArray(new AtomicReader[toMerge.size()]);
  final SortedDocValues dvs[]=toMerge.toArray(new SortedDocValues[toMerge.size()]);
  TermsEnum liveTerms[]=new TermsEnum[dvs.length];
  for (int sub=0; sub < liveTerms.length; sub++) {
    AtomicReader reader=readers[sub];
    SortedDocValues dv=dvs[sub];
    Bits liveDocs=reader.getLiveDocs();
    if (liveDocs == null) {
      liveTerms[sub]=dv.termsEnum();
    }
 else {
      LongBitSet bitset=new LongBitSet(dv.getValueCount());
      for (int i=0; i < reader.maxDoc(); i++) {
        if (liveDocs.get(i)) {
          int ord=dv.getOrd(i);
          if (ord >= 0) {
            bitset.set(ord);
          }
        }
      }
      liveTerms[sub]=new BitsFilteredTermsEnum(dv.termsEnum(),bitset);
    }
  }
  final OrdinalMap map=new OrdinalMap(this,liveTerms);
  addSortedField(fieldInfo,new Iterable<BytesRef>(){
    @Override public Iterator<BytesRef> iterator(){
      return new Iterator<BytesRef>(){
        int currentOrd;
        @Override public boolean hasNext(){
          return currentOrd < map.getValueCount();
        }
        @Override public BytesRef next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          int segmentNumber=map.getFirstSegmentNumber(currentOrd);
          int segmentOrd=(int)map.getFirstSegmentOrd(currentOrd);
          final BytesRef term=dvs[segmentNumber].lookupOrd(segmentOrd);
          currentOrd++;
          return term;
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
,new Iterable<Number>(){
    @Override public Iterator<Number> iterator(){
      return new Iterator<Number>(){
        int readerUpto=-1;
        int docIDUpto;
        int nextValue;
        AtomicReader currentReader;
        Bits currentLiveDocs;
        LongValues currentMap;
        boolean nextIsSet;
        @Override public boolean hasNext(){
          return nextIsSet || setNext();
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
        @Override public Number next(){
          if (!hasNext()) {
            throw new NoSuchElementException();
          }
          assert nextIsSet;
          nextIsSet=false;
          return nextValue;
        }
        private boolean setNext(){
          while (true) {
            if (readerUpto == readers.length) {
              return false;
            }
            if (currentReader == null || docIDUpto == currentReader.maxDoc()) {
              readerUpto++;
              if (readerUpto < readers.length) {
                currentReader=readers[readerUpto];
                currentLiveDocs=currentReader.getLiveDocs();
                currentMap=map.getGlobalOrds(readerUpto);
              }
              docIDUpto=0;
              continue;
            }
            if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {
              nextIsSet=true;
              int segOrd=dvs[readerUpto].getOrd(docIDUpto);
              nextValue=segOrd == -1 ? -1 : (int)currentMap.get(segOrd);
              docIDUpto++;
              return true;
            }
            docIDUpto++;
          }
        }
      }
;
    }
  }
);
}
