{
  final int iters=atLeast(5);
  for (int iter=0; iter < iters; ++iter) {
    final int numDocs=TestUtil.nextInt(random(),0,100);
    final int[] docIds=new int[numDocs];
    final long[] values=new long[numDocs];
    final int maxDoc;
    if (numDocs == 0) {
      maxDoc=1 + random().nextInt(10);
    }
 else {
      docIds[0]=random().nextInt(10);
      for (int i=1; i < docIds.length; ++i) {
        docIds[i]=docIds[i - 1] + 1 + random().nextInt(100);
      }
      maxDoc=docIds[numDocs - 1] + 1 + random().nextInt(10);
    }
    for (int i=0; i < values.length; ++i) {
      values[i]=random().nextLong();
    }
    final long missingValue=random().nextLong();
    final LongValues docIdsValues=new LongValues(){
      @Override public long get(      long index){
        return docIds[Math.toIntExact(index)];
      }
    }
;
    final LongValues valuesValues=new LongValues(){
      @Override public long get(      long index){
        return values[Math.toIntExact(index)];
      }
    }
;
    final SparseNumericDocValues sparseValues=new SparseNumericDocValues(numDocs,docIdsValues,valuesValues);
    assertEquals(-1,sparseValues.docID());
    for (int i=0; i < docIds.length; ++i) {
      assertEquals(docIds[i],sparseValues.nextDoc());
    }
    assertEquals(DocIdSetIterator.NO_MORE_DOCS,sparseValues.nextDoc());
    for (int i=0; i < 2000; ++i) {
      final int target=TestUtil.nextInt(random(),0,maxDoc);
      int index=Arrays.binarySearch(docIds,target);
      if (index < 0) {
        index=-1 - index;
      }
      sparseValues.reset();
      if (index > 0) {
        assertEquals(docIds[index - 1],sparseValues.advance(Math.toIntExact(docIds[index - 1])));
      }
      if (index == docIds.length) {
        assertEquals(DocIdSetIterator.NO_MORE_DOCS,sparseValues.advance(target));
      }
 else {
        assertEquals(docIds[index],sparseValues.advance(target));
      }
    }
    for (int i=0; i < 2000; ++i) {
      sparseValues.reset();
      if (random().nextBoolean() && docIds.length > 0) {
        sparseValues.advance(docIds[TestUtil.nextInt(random(),0,docIds.length - 1)]);
      }
      final int target=TestUtil.nextInt(random(),Math.max(0,sparseValues.docID()),maxDoc - 1);
      final boolean exists=sparseValues.advanceExact(target);
      final int index=Arrays.binarySearch(docIds,target);
      assertEquals(index >= 0,exists);
      assertEquals(target,sparseValues.docID());
      final boolean exists2=sparseValues.advanceExact(target);
      assertEquals(index >= 0,exists2);
      assertEquals(target,sparseValues.docID());
      final int nextIndex=index >= 0 ? index + 1 : -1 - index;
      if (nextIndex >= docIds.length) {
        assertEquals(DocIdSetIterator.NO_MORE_DOCS,sparseValues.nextDoc());
      }
 else {
        assertEquals(docIds[nextIndex],sparseValues.nextDoc());
      }
    }
    final SparseNumericDocValuesRandomAccessWrapper raWrapper=new SparseNumericDocValuesRandomAccessWrapper(sparseValues,missingValue);
    for (int i=0; i < 2000; ++i) {
      final int docId=TestUtil.nextInt(random(),0,maxDoc - 1);
      final int idx=Arrays.binarySearch(docIds,docId);
      final long value=raWrapper.get(docId);
      if (idx >= 0) {
        assertEquals(values[idx],value);
      }
 else {
        assertEquals(missingValue,value);
      }
    }
    for (int docId=0; docId < maxDoc; docId+=random().nextInt(3)) {
      final int idx=Arrays.binarySearch(docIds,docId);
      final long value=raWrapper.get(docId);
      if (idx >= 0) {
        assertEquals(values[idx],value);
      }
 else {
        assertEquals(missingValue,value);
      }
    }
  }
}
