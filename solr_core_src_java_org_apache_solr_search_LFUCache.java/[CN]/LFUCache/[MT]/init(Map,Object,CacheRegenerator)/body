{
  state=State.CREATED;
  this.regenerator=regenerator;
  name=(String)args.get(NAME);
  String str=(String)args.get("size");
  int limit=str == null ? 1024 : Integer.parseInt(str);
  int minLimit;
  str=(String)args.get("minSize");
  if (str == null) {
    minLimit=(int)(limit * 0.9);
  }
 else {
    minLimit=Integer.parseInt(str);
  }
  if (minLimit == 0)   minLimit=1;
  if (limit <= minLimit)   limit=minLimit + 1;
  int acceptableSize;
  str=(String)args.get("acceptableSize");
  if (str == null) {
    acceptableSize=(int)(limit * 0.95);
  }
 else {
    acceptableSize=Integer.parseInt(str);
  }
  acceptableSize=Math.max(minLimit,acceptableSize);
  str=(String)args.get("initialSize");
  final int initialSize=str == null ? limit : Integer.parseInt(str);
  str=(String)args.get("autowarmCount");
  autowarmCount=str == null ? 0 : Integer.parseInt(str);
  str=(String)args.get("cleanupThread");
  boolean newThread=str == null ? false : Boolean.parseBoolean(str);
  str=(String)args.get("showItems");
  showItems=str == null ? 0 : Integer.parseInt(str);
  str=(String)args.get("timeDecay");
  timeDecay=(str == null) ? true : Boolean.parseBoolean(str);
  description="Concurrent LFU Cache(maxSize=" + limit + ", initialSize="+ initialSize+ ", minSize="+ minLimit+ ", acceptableSize="+ acceptableSize+ ", cleanupThread="+ newThread+ ", timeDecay="+ Boolean.toString(timeDecay);
  if (autowarmCount > 0) {
    description+=", autowarmCount=" + autowarmCount + ", regenerator="+ regenerator;
  }
  description+=')';
  cache=new ConcurrentLFUCache<>(limit,minLimit,acceptableSize,initialSize,newThread,false,null,timeDecay);
  cache.setAlive(false);
  statsList=(List<ConcurrentLFUCache.Stats>)persistence;
  if (statsList == null) {
    statsList=new CopyOnWriteArrayList<>();
    statsList.add(new ConcurrentLFUCache.Stats());
  }
  statsList.add(cache.getStats());
  return statsList;
}
