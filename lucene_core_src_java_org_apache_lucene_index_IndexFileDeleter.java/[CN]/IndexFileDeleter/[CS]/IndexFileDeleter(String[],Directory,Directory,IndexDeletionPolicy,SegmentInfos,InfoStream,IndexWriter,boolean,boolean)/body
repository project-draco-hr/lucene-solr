{
  Objects.requireNonNull(writer);
  this.infoStream=infoStream;
  this.writer=writer;
  final String currentSegmentsFile=segmentInfos.getSegmentsFileName();
  if (infoStream.isEnabled("IFD")) {
    infoStream.message("IFD","init: current segments file is \"" + currentSegmentsFile + "\"; deletionPolicy="+ policy);
  }
  this.policy=policy;
  this.directoryOrig=directoryOrig;
  this.directory=directory;
  CommitPoint currentCommitPoint=null;
  if (currentSegmentsFile != null) {
    Matcher m=IndexFileNames.CODEC_FILE_PATTERN.matcher("");
    for (    String fileName : files) {
      m.reset(fileName);
      if (!fileName.endsWith("write.lock") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {
        getRefCount(fileName);
        if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {
          if (infoStream.isEnabled("IFD")) {
            infoStream.message("IFD","init: load commit \"" + fileName + "\"");
          }
          SegmentInfos sis=SegmentInfos.readCommit(directoryOrig,fileName);
          final CommitPoint commitPoint=new CommitPoint(commitsToDelete,directoryOrig,sis);
          if (sis.getGeneration() == segmentInfos.getGeneration()) {
            currentCommitPoint=commitPoint;
          }
          commits.add(commitPoint);
          incRef(sis,true);
          if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {
            lastSegmentInfos=sis;
          }
        }
      }
    }
  }
  if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {
    SegmentInfos sis=null;
    try {
      sis=SegmentInfos.readCommit(directoryOrig,currentSegmentsFile);
    }
 catch (    IOException e) {
      throw new CorruptIndexException("unable to read current segments_N file",currentSegmentsFile,e);
    }
    if (infoStream.isEnabled("IFD")) {
      infoStream.message("IFD","forced open of current segments file " + segmentInfos.getSegmentsFileName());
    }
    currentCommitPoint=new CommitPoint(commitsToDelete,directoryOrig,sis);
    commits.add(currentCommitPoint);
    incRef(sis,true);
  }
  if (isReaderInit) {
    checkpoint(segmentInfos,false);
  }
  CollectionUtil.timSort(commits);
  inflateGens(segmentInfos,refCounts.keySet(),infoStream);
  Set<String> toDelete=new HashSet<>();
  for (  Map.Entry<String,RefCount> entry : refCounts.entrySet()) {
    RefCount rc=entry.getValue();
    final String fileName=entry.getKey();
    if (0 == rc.count) {
      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {
        throw new IllegalStateException("file \"" + fileName + "\" has refCount=0, which should never happen on init");
      }
      if (infoStream.isEnabled("IFD")) {
        infoStream.message("IFD","init: removing unreferenced file \"" + fileName + "\"");
      }
      toDelete.add(fileName);
    }
  }
  deleteFiles(toDelete);
  policy.onInit(commits);
  checkpoint(segmentInfos,false);
  if (currentCommitPoint == null) {
    startingCommitDeleted=false;
  }
 else {
    startingCommitDeleted=currentCommitPoint.isDeleted();
  }
  deleteCommits();
}
