{
  this.infoStream=infoStream;
  this.writer=writer;
  final String currentSegmentsFile=segmentInfos.getSegmentsFileName();
  if (infoStream.isEnabled("IFD")) {
    infoStream.message("IFD","init: current segments file is \"" + currentSegmentsFile + "\"; deletionPolicy="+ policy);
  }
  this.policy=policy;
  this.directory=directory;
  long currentGen=segmentInfos.getGeneration();
  CommitPoint currentCommitPoint=null;
  String[] files=null;
  try {
    files=directory.listAll();
  }
 catch (  NoSuchDirectoryException e) {
    files=new String[0];
  }
  if (currentSegmentsFile != null) {
    Matcher m=IndexFileNames.CODEC_FILE_PATTERN.matcher("");
    for (    String fileName : files) {
      m.reset(fileName);
      if (!fileName.endsWith("write.lock") && !fileName.equals(IndexFileNames.SEGMENTS_GEN) && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {
        getRefCount(fileName);
        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {
          if (infoStream.isEnabled("IFD")) {
            infoStream.message("IFD","init: load commit \"" + fileName + "\"");
          }
          SegmentInfos sis=new SegmentInfos();
          try {
            sis.read(directory,fileName);
          }
 catch (          FileNotFoundException|NoSuchFileException e) {
            if (infoStream.isEnabled("IFD")) {
              infoStream.message("IFD","init: hit FileNotFoundException when loading commit \"" + fileName + "\"; skipping this commit point");
            }
            sis=null;
          }
catch (          IOException e) {
            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {
              throw e;
            }
 else {
              sis=null;
            }
          }
          if (sis != null) {
            final CommitPoint commitPoint=new CommitPoint(commitsToDelete,directory,sis);
            if (sis.getGeneration() == segmentInfos.getGeneration()) {
              currentCommitPoint=commitPoint;
            }
            commits.add(commitPoint);
            incRef(sis,true);
            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {
              lastSegmentInfos=sis;
            }
          }
        }
      }
    }
  }
  if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {
    SegmentInfos sis=new SegmentInfos();
    try {
      sis.read(directory,currentSegmentsFile);
    }
 catch (    IOException e) {
      throw new CorruptIndexException("failed to locate current segments_N file \"" + currentSegmentsFile + "\"");
    }
    if (infoStream.isEnabled("IFD")) {
      infoStream.message("IFD","forced open of current segments file " + segmentInfos.getSegmentsFileName());
    }
    currentCommitPoint=new CommitPoint(commitsToDelete,directory,sis);
    commits.add(currentCommitPoint);
    incRef(sis,true);
  }
  CollectionUtil.timSort(commits);
  inflateGens(segmentInfos,refCounts.keySet(),infoStream);
  for (  Map.Entry<String,RefCount> entry : refCounts.entrySet()) {
    RefCount rc=entry.getValue();
    final String fileName=entry.getKey();
    if (0 == rc.count) {
      if (infoStream.isEnabled("IFD")) {
        infoStream.message("IFD","init: removing unreferenced file \"" + fileName + "\"");
      }
      deleteFile(fileName);
    }
  }
  policy.onInit(commits);
  checkpoint(segmentInfos,false);
  startingCommitDeleted=currentCommitPoint == null ? false : currentCommitPoint.isDeleted();
  deleteCommits();
}
