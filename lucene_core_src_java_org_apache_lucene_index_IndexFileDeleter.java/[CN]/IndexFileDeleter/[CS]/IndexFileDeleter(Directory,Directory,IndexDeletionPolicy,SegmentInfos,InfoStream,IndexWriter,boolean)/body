{
  Objects.requireNonNull(writer);
  this.infoStream=infoStream;
  this.writer=writer;
  final String currentSegmentsFile=segmentInfos.getSegmentsFileName();
  if (infoStream.isEnabled("IFD")) {
    infoStream.message("IFD","init: current segments file is \"" + currentSegmentsFile + "\"; deletionPolicy="+ policy);
  }
  this.policy=policy;
  this.directoryOrig=directoryOrig;
  this.directory=directory;
  CommitPoint currentCommitPoint=null;
  String[] files=directory.listAll();
  if (currentSegmentsFile != null) {
    Matcher m=IndexFileNames.CODEC_FILE_PATTERN.matcher("");
    for (    String fileName : files) {
      m.reset(fileName);
      if (!fileName.endsWith("write.lock") && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS) || fileName.startsWith(IndexFileNames.PENDING_SEGMENTS))) {
        getRefCount(fileName);
        if (fileName.startsWith(IndexFileNames.SEGMENTS) && !fileName.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {
          if (infoStream.isEnabled("IFD")) {
            infoStream.message("IFD","init: load commit \"" + fileName + "\"");
          }
          SegmentInfos sis=null;
          try {
            sis=SegmentInfos.readCommit(directoryOrig,fileName);
          }
 catch (          FileNotFoundException|NoSuchFileException e) {
            if (infoStream.isEnabled("IFD")) {
              infoStream.message("IFD","init: hit FileNotFoundException when loading commit \"" + fileName + "\"; skipping this commit point");
            }
          }
          if (sis != null) {
            final CommitPoint commitPoint=new CommitPoint(commitsToDelete,directoryOrig,sis);
            if (sis.getGeneration() == segmentInfos.getGeneration()) {
              currentCommitPoint=commitPoint;
            }
            commits.add(commitPoint);
            incRef(sis,true);
            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {
              lastSegmentInfos=sis;
            }
          }
        }
      }
    }
  }
  if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {
    SegmentInfos sis=null;
    try {
      sis=SegmentInfos.readCommit(directoryOrig,currentSegmentsFile);
    }
 catch (    IOException e) {
      throw new CorruptIndexException("unable to read current segments_N file",currentSegmentsFile,e);
    }
    if (infoStream.isEnabled("IFD")) {
      infoStream.message("IFD","forced open of current segments file " + segmentInfos.getSegmentsFileName());
    }
    currentCommitPoint=new CommitPoint(commitsToDelete,directoryOrig,sis);
    commits.add(currentCommitPoint);
    incRef(sis,true);
  }
  CollectionUtil.timSort(commits);
  inflateGens(segmentInfos,refCounts.keySet(),infoStream);
  for (  Map.Entry<String,RefCount> entry : refCounts.entrySet()) {
    RefCount rc=entry.getValue();
    final String fileName=entry.getKey();
    if (0 == rc.count) {
      if (infoStream.isEnabled("IFD")) {
        infoStream.message("IFD","init: removing unreferenced file \"" + fileName + "\"");
      }
      deleteFile(fileName);
    }
  }
  policy.onInit(commits);
  checkpoint(segmentInfos,false);
  startingCommitDeleted=currentCommitPoint == null ? false : currentCommitPoint.isDeleted();
  deleteCommits();
}
