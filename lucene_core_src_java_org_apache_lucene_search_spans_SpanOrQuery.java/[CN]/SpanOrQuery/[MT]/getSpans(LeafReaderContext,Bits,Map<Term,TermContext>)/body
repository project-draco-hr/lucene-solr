{
  ArrayList<Spans> subSpans=new ArrayList<>(clauses.size());
  for (  SpanQuery seq : clauses) {
    Spans subSpan=seq.getSpans(context,acceptDocs,termContexts);
    if (subSpan != null) {
      subSpans.add(subSpan);
    }
  }
  if (subSpans.size() == 0) {
    return null;
  }
 else   if (subSpans.size() == 1) {
    return subSpans.get(0);
  }
  SpanQueue queue=new SpanQueue(clauses.size());
  for (  Spans spans : subSpans) {
    queue.add(spans);
  }
  return new Spans(){
    @Override public int nextDoc() throws IOException {
      if (queue.size() == 0) {
        return NO_MORE_DOCS;
      }
      int currentDoc=top().docID();
      if (currentDoc == -1) {
        return advance(0);
      }
      do {
        if (top().nextDoc() != NO_MORE_DOCS) {
          queue.updateTop();
        }
 else {
          queue.pop();
          if (queue.size() == 0) {
            return NO_MORE_DOCS;
          }
        }
        int doc=top().docID();
        if (doc > currentDoc) {
          return doc;
        }
      }
 while (true);
    }
    private Spans top(){
      return queue.top();
    }
    @Override public int advance(    int target) throws IOException {
      while ((queue.size() > 0) && (top().docID() < target)) {
        if (top().advance(target) != NO_MORE_DOCS) {
          queue.updateTop();
        }
 else {
          queue.pop();
        }
      }
      return (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;
    }
    @Override public int docID(){
      return (queue == null) ? -1 : (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;
    }
    @Override public int nextStartPosition() throws IOException {
      top().nextStartPosition();
      queue.updateTop();
      int startPos=top().startPosition();
      while (startPos == -1) {
        top().nextStartPosition();
        queue.updateTop();
        startPos=top().startPosition();
      }
      return startPos;
    }
    @Override public int startPosition(){
      return top().startPosition();
    }
    @Override public int endPosition(){
      return top().endPosition();
    }
    @Override public Collection<byte[]> getPayload() throws IOException {
      ArrayList<byte[]> result=null;
      Spans theTop=top();
      if (theTop != null && theTop.isPayloadAvailable()) {
        result=new ArrayList<>(theTop.getPayload());
      }
      return result;
    }
    @Override public boolean isPayloadAvailable() throws IOException {
      Spans top=top();
      return top != null && top.isPayloadAvailable();
    }
    @Override public String toString(){
      return "spans(" + SpanOrQuery.this + ")@"+ ((queue == null) ? "START" : (queue.size() > 0 ? (docID() + ": " + top().startPosition()+ " - "+ top().endPosition()) : "END"));
    }
    private long cost=-1;
    @Override public long cost(){
      if (cost == -1) {
        cost=0;
        for (        Spans spans : subSpans) {
          cost+=spans.cost();
        }
      }
      return cost;
    }
  }
;
}
