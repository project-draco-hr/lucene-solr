{
  termAttribute=addAttribute(CharTermAttribute.class);
  positionIncrementAttribute=addAttribute(PositionIncrementAttribute.class);
  offsetAttribute=addAttribute(OffsetAttribute.class);
  final TermsEnum termsEnum=vector.iterator(null);
  BytesRef text;
  DocsAndPositionsEnum dpEnum=null;
  while ((text=termsEnum.next()) != null) {
    dpEnum=termsEnum.docsAndPositions(null,dpEnum,true);
    final boolean hasOffsets;
    if (dpEnum == null) {
      hasOffsets=false;
      dpEnum=termsEnum.docsAndPositions(null,dpEnum,false);
    }
 else {
      hasOffsets=true;
    }
    dpEnum.nextDoc();
    final int freq=dpEnum.freq();
    for (int j=0; j < freq; j++) {
      int pos=dpEnum.nextPosition();
      Token token;
      if (hasOffsets) {
        token=new Token(text.utf8ToString(),dpEnum.startOffset(),dpEnum.endOffset());
      }
 else {
        token=new Token();
        token.setEmpty().append(text.utf8ToString());
      }
      token.setPositionIncrement(pos);
      this.positionedTokens.add(token);
    }
  }
  CollectionUtil.mergeSort(this.positionedTokens,tokenComparator);
  int lastPosition=-1;
  for (  final Token token : this.positionedTokens) {
    int thisPosition=token.getPositionIncrement();
    token.setPositionIncrement(thisPosition - lastPosition);
    lastPosition=thisPosition;
  }
  this.tokensAtCurrentPosition=this.positionedTokens.iterator();
}
