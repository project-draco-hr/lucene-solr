{
  termAttribute=addAttribute(CharTermAttribute.class);
  positionIncrementAttribute=addAttribute(PositionIncrementAttribute.class);
  offsetAttribute=addAttribute(OffsetAttribute.class);
  final TermsEnum termsEnum=vector.iterator(null);
  BytesRef text;
  DocsAndPositionsEnum dpEnum=null;
  while ((text=termsEnum.next()) != null) {
    dpEnum=termsEnum.docsAndPositions(null,dpEnum);
    dpEnum.nextDoc();
    final int freq=dpEnum.freq();
    final OffsetAttribute offsetAtt;
    if (dpEnum.attributes().hasAttribute(OffsetAttribute.class)) {
      offsetAtt=dpEnum.attributes().getAttribute(OffsetAttribute.class);
    }
 else {
      offsetAtt=null;
    }
    for (int j=0; j < freq; j++) {
      int pos=dpEnum.nextPosition();
      Token token;
      if (offsetAtt != null) {
        token=new Token(text.utf8ToString(),offsetAtt.startOffset(),offsetAtt.endOffset());
      }
 else {
        token=new Token();
        token.setEmpty().append(text.utf8ToString());
      }
      token.setPositionIncrement(pos);
      this.positionedTokens.add(token);
    }
  }
  CollectionUtil.mergeSort(this.positionedTokens,tokenComparator);
  int lastPosition=-1;
  for (  final Token token : this.positionedTokens) {
    int thisPosition=token.getPositionIncrement();
    token.setPositionIncrement(thisPosition - lastPosition);
    lastPosition=thisPosition;
  }
  this.tokensAtCurrentPosition=this.positionedTokens.iterator();
}
