{
  final Map<String,Set<String>> collectorStats=new TreeMap<>();
  final Map<String,Set<Integer>> collectorPercs=new TreeMap<>();
  final Map<String,ValueSource> collectorSources=new TreeMap<>();
  for (  ExpressionRequest expRequest : exRequests) {
    String statExpression=expRequest.getExpressionString();
    Set<String> statistics=getStatistics(statExpression);
    if (statistics == null) {
      continue;
    }
    for (    String statExp : statistics) {
      String stat;
      String operands;
      try {
        stat=statExp.substring(0,statExp.indexOf('(')).trim();
        operands=statExp.substring(statExp.indexOf('(') + 1,statExp.lastIndexOf(')')).trim();
      }
 catch (      Exception e) {
        throw new SolrException(ErrorCode.BAD_REQUEST,"Unable to parse statistic: [" + statExpression + "]",e);
      }
      String[] arguments=ExpressionFactory.getArguments(operands);
      String source=arguments[0];
      if (stat.equals(AnalyticsParams.STAT_PERCENTILE)) {
        if (arguments.length < 2) {
          throw new SolrException(ErrorCode.BAD_REQUEST,"Too few arguments given for " + stat + "() in ["+ statExp+ "].");
        }
 else         if (arguments.length > 2) {
          throw new SolrException(ErrorCode.BAD_REQUEST,"Too many arguments given for " + stat + "() in ["+ statExp+ "].");
        }
        source=arguments[1];
        Set<Integer> percs=collectorPercs.get(source);
        if (percs == null) {
          percs=new HashSet<>();
          collectorPercs.put(source,percs);
        }
        try {
          int perc=Integer.parseInt(arguments[0]);
          if (perc > 0 && perc < 100) {
            percs.add(perc);
          }
 else {
            throw new SolrException(ErrorCode.BAD_REQUEST,"The percentile in [" + statExp + "] is not between 0 and 100, exculsive.");
          }
        }
 catch (        NumberFormatException e) {
          throw new SolrException(ErrorCode.BAD_REQUEST,"\"" + arguments[0] + "\" cannot be converted into a percentile.",e);
        }
      }
 else       if (arguments.length > 1) {
        throw new SolrException(ErrorCode.BAD_REQUEST,"Too many arguments given for " + stat + "() in ["+ statExp+ "].");
      }
 else       if (arguments.length == 0) {
        throw new SolrException(ErrorCode.BAD_REQUEST,"No arguments given for " + stat + "() in ["+ statExp+ "].");
      }
      Set<String> stats=collectorStats.get(source);
      if (stats == null) {
        stats=new HashSet<>();
        collectorStats.put(source,stats);
      }
      if (AnalyticsParams.STAT_PERCENTILE.equals(stat)) {
        stats.add(stat + "_" + arguments[0]);
      }
 else {
        stats.add(stat);
      }
    }
  }
  String[] keys=collectorStats.keySet().toArray(new String[0]);
  for (  String sourceStr : keys) {
    ValueSource source=buildSourceTree(schema,sourceStr);
    if (source == null) {
      throw new SolrException(ErrorCode.BAD_REQUEST,"The statistic [" + sourceStr + "] could not be parsed.");
    }
    String builtString=source.toString();
    collectorSources.put(builtString,source);
    if (!builtString.equals(sourceStr)) {
      Set<String> stats=collectorStats.remove(sourceStr);
      if (stats != null) {
        collectorStats.put(builtString,stats);
      }
      Set<Integer> percs=collectorPercs.remove(sourceStr);
      if (percs != null) {
        collectorPercs.put(builtString,percs);
      }
      for (      ExpressionRequest er : exRequests) {
        er.setExpressionString(er.getExpressionString().replace(sourceStr,builtString));
      }
    }
  }
  if (collectorSources.size() == 0) {
    return new Supplier<StatsCollector[]>(){
      @Override public StatsCollector[] get(){
        return new StatsCollector[0];
      }
    }
;
  }
  log.info("Stats objects: " + collectorStats.size() + " sr="+ collectorSources.size()+ " pr="+ collectorPercs.size());
  final Set<String>[] statsArr=collectorStats.values().toArray(new Set[0]);
  final ValueSource[] sourceArr=collectorSources.values().toArray(new ValueSource[0]);
  final boolean[] uniqueBools=new boolean[statsArr.length];
  final boolean[] medianBools=new boolean[statsArr.length];
  final boolean[] numericBools=new boolean[statsArr.length];
  final boolean[] dateBools=new boolean[statsArr.length];
  final double[][] percsArr=new double[statsArr.length][];
  final String[][] percsNames=new String[statsArr.length][];
  for (int count=0; count < sourceArr.length; count++) {
    uniqueBools[count]=statsArr[count].contains(AnalyticsParams.STAT_UNIQUE);
    medianBools[count]=statsArr[count].contains(AnalyticsParams.STAT_MEDIAN);
    numericBools[count]=statsArr[count].contains(AnalyticsParams.STAT_SUM) || statsArr[count].contains(AnalyticsParams.STAT_SUM_OF_SQUARES) || statsArr[count].contains(AnalyticsParams.STAT_MEAN)|| statsArr[count].contains(AnalyticsParams.STAT_STANDARD_DEVIATION);
    dateBools[count]=(sourceArr[count] instanceof DateFieldSource) | (sourceArr[count] instanceof MultiDateFunction) | (sourceArr[count] instanceof ConstDateSource);
    Set<Integer> ps=collectorPercs.get(sourceArr[count].toString());
    if (ps != null) {
      percsArr[count]=new double[ps.size()];
      percsNames[count]=new String[ps.size()];
      int percCount=0;
      for (      int p : ps) {
        percsArr[count][percCount]=p / 100.0;
        percsNames[count][percCount++]=AnalyticsParams.STAT_PERCENTILE + "_" + p;
      }
    }
  }
  return new Supplier<StatsCollector[]>(){
    public StatsCollector[] get(){
      StatsCollector[] collectors=new StatsCollector[statsArr.length];
      for (int count=0; count < statsArr.length; count++) {
        if (numericBools[count]) {
          StatsCollector sc=new NumericStatsCollector(sourceArr[count],statsArr[count]);
          if (uniqueBools[count])           sc=new UniqueStatsCollector(sc);
          if (medianBools[count])           sc=new MedianStatsCollector(sc);
          if (percsArr[count] != null)           sc=new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);
          collectors[count]=sc;
        }
 else         if (dateBools[count]) {
          StatsCollector sc=new MinMaxStatsCollector(sourceArr[count],statsArr[count]);
          if (uniqueBools[count])           sc=new UniqueStatsCollector(sc);
          if (medianBools[count])           sc=new DateMedianStatsCollector(sc);
          if (percsArr[count] != null)           sc=new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);
          collectors[count]=sc;
        }
 else {
          StatsCollector sc=new MinMaxStatsCollector(sourceArr[count],statsArr[count]);
          if (uniqueBools[count])           sc=new UniqueStatsCollector(sc);
          if (medianBools[count])           sc=new MedianStatsCollector(sc);
          if (percsArr[count] != null)           sc=new PercentileStatsCollector(sc,percsArr[count],percsNames[count]);
          collectors[count]=sc;
        }
      }
      return collectors;
    }
  }
;
}
