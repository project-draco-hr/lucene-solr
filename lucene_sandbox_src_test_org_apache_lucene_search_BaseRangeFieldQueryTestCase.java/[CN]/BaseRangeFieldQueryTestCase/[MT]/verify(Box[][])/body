{
  IndexWriterConfig iwc=newIndexWriterConfig();
  iwc.setMergeScheduler(new SerialMergeScheduler());
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < boxes.length / 100) {
    iwc.setMaxBufferedDocs(boxes.length / 100);
  }
  Directory dir;
  if (boxes.length > 50000) {
    dir=newFSDirectory(createTempDir(getClass().getSimpleName()));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < boxes.length; ++id) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (Double.isNaN(boxes[id][0].min[0]) == false) {
      for (int n=0; n < boxes[id].length; ++n) {
        doc.add(newRangeField(boxes[id][n].min,boxes[id][n].max));
      }
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 1) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w);
  w.close();
  IndexSearcher s=newSearcher(r);
  int dimensions=boxes[0][0].min.length;
  int iters=atLeast(25);
  NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
  Bits liveDocs=MultiFields.getLiveDocs(s.getIndexReader());
  int maxDoc=s.getIndexReader().maxDoc();
  for (int iter=0; iter < iters; ++iter) {
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " s="+ s);
    }
    Box queryBox=nextBox(dimensions);
    int rv=random().nextInt(3);
    Query query;
    Box.QueryType queryType;
    if (rv == 0) {
      queryType=Box.QueryType.INTERSECTS;
      query=newIntersectsQuery(queryBox.min,queryBox.max);
    }
 else     if (rv == 1) {
      queryType=Box.QueryType.CONTAINS;
      query=newContainsQuery(queryBox.min,queryBox.max);
    }
 else {
      queryType=Box.QueryType.WITHIN;
      query=newWithinQuery(queryBox.min,queryBox.max);
    }
    if (VERBOSE) {
      System.out.println("  query=" + query);
    }
    final FixedBitSet hits=new FixedBitSet(maxDoc);
    s.search(query,new SimpleCollector(){
      private int docBase;
      @Override public void collect(      int doc){
        hits.set(docBase + doc);
      }
      @Override protected void doSetNextReader(      LeafReaderContext context) throws IOException {
        docBase=context.docBase;
      }
      @Override public boolean needsScores(){
        return false;
      }
    }
);
    for (int docID=0; docID < maxDoc; ++docID) {
      int id=(int)docIDToID.get(docID);
      boolean expected;
      if (liveDocs != null && liveDocs.get(docID) == false) {
        expected=false;
      }
 else       if (Double.isNaN(boxes[id][0].min[0])) {
        expected=false;
      }
 else {
        expected=expectedResult(queryBox,boxes[id],queryType);
      }
      if (hits.get(docID) != expected) {
        StringBuilder b=new StringBuilder();
        b.append("FAIL (iter " + iter + "): ");
        if (expected == true) {
          b.append("id=" + id + (boxes[id].length > 1 ? " (MultiValue) " : " ")+ "should match but did not\n");
        }
 else {
          b.append("id=" + id + " should not match but did\n");
        }
        b.append(" queryBox=" + queryBox + "\n");
        b.append(" box" + ((boxes[id].length > 1) ? "es=" : "=") + boxes[id][0]);
        for (int n=1; n < boxes[id].length; ++n) {
          b.append(", ");
          b.append(boxes[id][n]);
        }
        b.append("\n queryType=" + queryType + "\n");
        b.append(" deleted?=" + (liveDocs != null && liveDocs.get(docID) == false));
        fail("wrong hit (first of possibly more):\n\n" + b);
      }
    }
  }
  IOUtils.close(r,dir);
}
