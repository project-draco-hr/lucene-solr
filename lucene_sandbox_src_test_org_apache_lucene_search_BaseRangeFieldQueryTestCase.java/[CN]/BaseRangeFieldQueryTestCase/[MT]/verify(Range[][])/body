{
  IndexWriterConfig iwc=newIndexWriterConfig();
  iwc.setMergeScheduler(new SerialMergeScheduler());
  int mbd=iwc.getMaxBufferedDocs();
  if (mbd != -1 && mbd < ranges.length / 100) {
    iwc.setMaxBufferedDocs(ranges.length / 100);
  }
  Directory dir;
  if (ranges.length > 50000) {
    dir=newFSDirectory(createTempDir(getClass().getSimpleName()));
  }
 else {
    dir=newDirectory();
  }
  Set<Integer> deleted=new HashSet<>();
  IndexWriter w=new IndexWriter(dir,iwc);
  for (int id=0; id < ranges.length; ++id) {
    Document doc=new Document();
    doc.add(newStringField("id","" + id,Field.Store.NO));
    doc.add(new NumericDocValuesField("id",id));
    if (ranges[id][0].isMissing == false) {
      for (int n=0; n < ranges[id].length; ++n) {
        doc.add(newRangeField(ranges[id][n]));
      }
    }
    w.addDocument(doc);
    if (id > 0 && random().nextInt(100) == 1) {
      int idToDelete=random().nextInt(id);
      w.deleteDocuments(new Term("id","" + idToDelete));
      deleted.add(idToDelete);
      if (VERBOSE) {
        System.out.println("  delete id=" + idToDelete);
      }
    }
  }
  if (random().nextBoolean()) {
    w.forceMerge(1);
  }
  final IndexReader r=DirectoryReader.open(w);
  w.close();
  IndexSearcher s=newSearcher(r);
  int dimensions=ranges[0][0].numDimensions();
  int iters=atLeast(25);
  Bits liveDocs=MultiFields.getLiveDocs(s.getIndexReader());
  int maxDoc=s.getIndexReader().maxDoc();
  for (int iter=0; iter < iters; ++iter) {
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " s="+ s);
    }
    Range queryRange=nextRange(dimensions);
    int rv=random().nextInt(3);
    Query query;
    Range.QueryType queryType;
    if (rv == 0) {
      queryType=Range.QueryType.INTERSECTS;
      query=newIntersectsQuery(queryRange);
    }
 else     if (rv == 1) {
      queryType=Range.QueryType.CONTAINS;
      query=newContainsQuery(queryRange);
    }
 else {
      queryType=Range.QueryType.WITHIN;
      query=newWithinQuery(queryRange);
    }
    if (VERBOSE) {
      System.out.println("  query=" + query);
    }
    final FixedBitSet hits=new FixedBitSet(maxDoc);
    s.search(query,new SimpleCollector(){
      private int docBase;
      @Override public void collect(      int doc){
        hits.set(docBase + doc);
      }
      @Override protected void doSetNextReader(      LeafReaderContext context) throws IOException {
        docBase=context.docBase;
      }
      @Override public boolean needsScores(){
        return false;
      }
    }
);
    NumericDocValues docIDToID=MultiDocValues.getNumericValues(r,"id");
    for (int docID=0; docID < maxDoc; ++docID) {
      assertEquals(docID,docIDToID.nextDoc());
      int id=(int)docIDToID.longValue();
      boolean expected;
      if (liveDocs != null && liveDocs.get(docID) == false) {
        expected=false;
      }
 else       if (ranges[id][0].isMissing) {
        expected=false;
      }
 else {
        expected=expectedResult(queryRange,ranges[id],queryType);
      }
      if (hits.get(docID) != expected) {
        StringBuilder b=new StringBuilder();
        b.append("FAIL (iter " + iter + "): ");
        if (expected == true) {
          b.append("id=" + id + (ranges[id].length > 1 ? " (MultiValue) " : " ")+ "should match but did not\n");
        }
 else {
          b.append("id=" + id + " should not match but did\n");
        }
        b.append(" queryRange=" + queryRange + "\n");
        b.append(" box" + ((ranges[id].length > 1) ? "es=" : "=") + ranges[id][0]);
        for (int n=1; n < ranges[id].length; ++n) {
          b.append(", ");
          b.append(ranges[id][n]);
        }
        b.append("\n queryType=" + queryType + "\n");
        b.append(" deleted?=" + (liveDocs != null && liveDocs.get(docID) == false));
        fail("wrong hit (first of possibly more):\n\n" + b);
      }
    }
  }
  IOUtils.close(r,dir);
}
