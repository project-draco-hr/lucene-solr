{
  final int limit=Math.max(1,reader.maxDoc());
  if (after != null && after.doc >= limit) {
    throw new IllegalArgumentException("after.doc exceeds the number of documents in the reader: after.doc=" + after.doc + " limit="+ limit);
  }
  numHits=Math.min(numHits,limit);
  if (executor == null) {
    final TopScoreDocCollector collector=TopScoreDocCollector.create(numHits,after);
    search(query,collector);
    return collector.topDocs();
  }
 else {
    final TopScoreDocCollector[] collectors=new TopScoreDocCollector[leafSlices.length];
    boolean needsScores=false;
    for (int i=0; i < leafSlices.length; ++i) {
      collectors[i]=TopScoreDocCollector.create(numHits,after);
      needsScores|=collectors[i].needsScores();
    }
    final Weight weight=createNormalizedWeight(query,needsScores);
    final List<Future<TopDocs>> topDocsFutures=new ArrayList<>(leafSlices.length);
    for (int i=0; i < leafSlices.length; ++i) {
      final LeafReaderContext[] leaves=leafSlices[i].leaves;
      final TopScoreDocCollector collector=collectors[i];
      topDocsFutures.add(executor.submit(new Callable<TopDocs>(){
        @Override public TopDocs call() throws Exception {
          search(Arrays.asList(leaves),weight,collector);
          return collector.topDocs();
        }
      }
));
    }
    final TopDocs[] topDocs=new TopDocs[leafSlices.length];
    for (int i=0; i < topDocs.length; ++i) {
      try {
        topDocs[i]=topDocsFutures.get(i).get();
      }
 catch (      InterruptedException e) {
        throw new ThreadInterruptedException(e);
      }
catch (      ExecutionException e) {
        throw new RuntimeException(e);
      }
    }
    return TopDocs.merge(numHits,topDocs);
  }
}
