{
  if (sort == null)   throw new NullPointerException("Sort must not be null");
  int limit=reader.maxDoc();
  if (limit == 0) {
    limit=1;
  }
  nDocs=Math.min(nDocs,limit);
  if (executor == null) {
    return search(leafContexts,weight,after,nDocs,sort,fillFields,doDocScores,doMaxScore);
  }
 else {
    final List<Future<TopFieldDocs>> topDocsFutures=new ArrayList<>(leafSlices.length);
    for (int i=0; i < leafSlices.length; i++) {
      topDocsFutures.add(executor.submit(new SearcherCallableWithSort(this,leafSlices[i],weight,after,nDocs,sort,doDocScores,doMaxScore)));
    }
    final TopFieldDocs[] topDocs=new TopFieldDocs[leafSlices.length];
    for (int i=0; i < leafSlices.length; i++) {
      try {
        topDocs[i]=topDocsFutures.get(i).get();
      }
 catch (      InterruptedException e) {
        throw new ThreadInterruptedException(e);
      }
catch (      ExecutionException e) {
        throw new RuntimeException(e);
      }
    }
    return (TopFieldDocs)TopDocs.merge(sort,nDocs,topDocs);
  }
}
