{
  String collectionName="testOverseerCol";
  createCollection(collectionName,client);
  waitForRecoveriesToFinish(collectionName,false);
  Set<String> nodes=client.getZkStateReader().getClusterState().getLiveNodes();
  ArrayList<String> l=new ArrayList<>(nodes);
  log.info("All nodes {}",l);
  String currentLeader=OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());
  log.info("Current leader {} ",currentLeader);
  l.remove(currentLeader);
  Collections.shuffle(l);
  String overseerDesignate=l.get(0);
  log.info("overseerDesignate {}",overseerDesignate);
  setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);
  long timeout=System.currentTimeMillis() + 10000;
  boolean leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    if (overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))) {
      log.info("overseer designate is the new overseer");
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("could not set the new overseer",leaderchanged);
  l.remove(overseerDesignate);
  Collections.shuffle(l);
  String anotherOverseer=l.get(0);
  log.info("Adding another overseer designate {}",anotherOverseer);
  setOverseerRole(CollectionAction.ADDROLE,anotherOverseer);
  timeout=System.currentTimeMillis() + 10000;
  leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    List<String> sortedNodeNames=OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient());
    if (sortedNodeNames.get(1).equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)) {
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("New overseer not the frontrunner : " + OverseerCollectionProcessor.getSortedNodeNames(client.getZkStateReader().getZkClient()) + " expected : "+ anotherOverseer,leaderchanged);
  client.shutdown();
}
