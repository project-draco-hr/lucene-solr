{
  String collectionName="testOverseerCol";
  createCollection(collectionName,client);
  waitForRecoveriesToFinish(collectionName,false);
  Set<String> nodes=client.getZkStateReader().getClusterState().getLiveNodes();
  ArrayList<String> l=new ArrayList<>(nodes);
  log.info("All nodes {}",l);
  String currentLeader=getLeaderNode(client);
  log.info("Current leader {} ",currentLeader);
  l.remove(currentLeader);
  Collections.shuffle(l);
  String overseerDesignate=l.get(0);
  log.info("overseerDesignate {}",overseerDesignate);
  setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);
  long timeout=System.currentTimeMillis() + 10000;
  boolean leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    if (getLeaderNode(client).equals(overseerDesignate)) {
      log.info("overseer designate is the new overseer");
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("could not set the new overseer",leaderchanged);
  l.remove(overseerDesignate);
  Collections.shuffle(l);
  String anotherOverseer=l.get(0);
  log.info("Adding another overseer designate {}",anotherOverseer);
  setOverseerRole(CollectionAction.ADDROLE,anotherOverseer);
  timeout=System.currentTimeMillis() + 10000;
  leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    log.info(" count {}",System.currentTimeMillis());
    List<String> seqs=client.getZkStateReader().getZkClient().getChildren("/overseer_elect/election",null,true);
    LeaderElector.sortSeqs(seqs);
    log.info("seqs : {} ",seqs);
    if (LeaderElector.getNodeName(seqs.get(1)).equals(anotherOverseer)) {
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("New overseer not the frontrunner",leaderchanged);
  client.shutdown();
}
