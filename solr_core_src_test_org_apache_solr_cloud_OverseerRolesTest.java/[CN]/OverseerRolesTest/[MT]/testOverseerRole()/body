{
  String collectionName="testOverseerCol";
  createCollection(collectionName,client);
  waitForRecoveriesToFinish(collectionName,false);
  List<String> l=OverseerCollectionProcessor.getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());
  log.info("All nodes {}",l);
  String currentLeader=OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient());
  log.info("Current leader {} ",currentLeader);
  l.remove(currentLeader);
  Collections.shuffle(l);
  String overseerDesignate=l.get(0);
  log.info("overseerDesignate {}",overseerDesignate);
  setOverseerRole(CollectionAction.ADDROLE,overseerDesignate);
  long timeout=System.currentTimeMillis() + 15000;
  boolean leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    if (overseerDesignate.equals(OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()))) {
      log.info("overseer designate is the new overseer");
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("could not set the new overseer . expected " + overseerDesignate + " current order : "+ getSortedOverseerNodeNames(client.getZkStateReader().getZkClient())+ " ldr :"+ OverseerCollectionProcessor.getLeaderNode(client.getZkStateReader().getZkClient()),leaderchanged);
  l.remove(overseerDesignate);
  Collections.shuffle(l);
  String anotherOverseer=l.get(0);
  log.info("Adding another overseer designate {}",anotherOverseer);
  setOverseerRole(CollectionAction.ADDROLE,anotherOverseer);
  timeout=System.currentTimeMillis() + 10000;
  leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    List<String> sortedNodeNames=getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());
    if (sortedNodeNames.get(1).equals(anotherOverseer) || sortedNodeNames.get(0).equals(anotherOverseer)) {
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("New overseer not the frontrunner : " + getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + " expected : "+ anotherOverseer,leaderchanged);
  String currentOverseer=getLeaderNode(client.getZkStateReader().getZkClient());
  String killedOverseer=currentOverseer;
  log.info("Current Overseer {}",currentOverseer);
  Pattern pattern=Pattern.compile("(.*):(\\d*)(.*)");
  Matcher m=pattern.matcher(currentOverseer);
  JettySolrRunner stoppedJetty=null;
  if (m.matches()) {
    String hostPort=m.group(1) + ":" + m.group(2);
    log.info("hostPort : {}",hostPort);
    for (    JettySolrRunner jetty : jettys) {
      String s=jetty.getBaseUrl().toString();
      if (s.contains(hostPort)) {
        log.info("leader node {}",s);
        ChaosMonkey.stop(jetty);
        stoppedJetty=jetty;
        timeout=System.currentTimeMillis() + 10000;
        leaderchanged=false;
        for (; System.currentTimeMillis() < timeout; ) {
          currentOverseer=getLeaderNode(client.getZkStateReader().getZkClient());
          if (anotherOverseer.equals(currentOverseer)) {
            leaderchanged=true;
            break;
          }
          Thread.sleep(100);
        }
        assertTrue("New overseer designate has not become the overseer, expected : " + anotherOverseer + "actual : "+ currentOverseer,leaderchanged);
      }
    }
  }
  ChaosMonkey.start(stoppedJetty);
  timeout=System.currentTimeMillis() + 10000;
  leaderchanged=false;
  for (; System.currentTimeMillis() < timeout; ) {
    List<String> sortedNodeNames=getSortedOverseerNodeNames(client.getZkStateReader().getZkClient());
    if (sortedNodeNames.get(1).equals(killedOverseer) || sortedNodeNames.get(0).equals(killedOverseer)) {
      leaderchanged=true;
      break;
    }
    Thread.sleep(100);
  }
  assertTrue("New overseer not the frontrunner : " + getSortedOverseerNodeNames(client.getZkStateReader().getZkClient()) + " expected : "+ killedOverseer,leaderchanged);
}
