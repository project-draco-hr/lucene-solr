{
  final LRUFilterCache filterCache=new LRUFilterCache(1000000,10000000);
  final RamUsageTester.Accumulator acc=new RamUsageTester.Accumulator(){
    @Override public long accumulateObject(    Object o,    long shallowSize,    Map<Field,Object> fieldValues,    Collection<Object> queue){
      if (o instanceof DocIdSet) {
        return ((DocIdSet)o).ramBytesUsed();
      }
      if (o instanceof Filter) {
        return filterCache.ramBytesUsed((Filter)o);
      }
      if (o.getClass().getSimpleName().equals("SegmentCoreReaders")) {
        return 0;
      }
      return super.accumulateObject(o,shallowSize,fieldValues,queue);
    }
  }
;
  Directory dir=newDirectory();
  final RandomIndexWriter w=new RandomIndexWriter(random(),dir);
  Document doc=new Document();
  final int numDocs=atLeast(100);
  for (int i=0; i < numDocs; ++i) {
    w.addDocument(doc);
  }
  final DirectoryReader reader=w.getReader();
  final IndexSearcher searcher=new IndexSearcher(reader);
  final int numFilters=atLeast(1000);
  for (int i=0; i < numFilters; ++i) {
    final Filter filter=new DummyFilter();
    final Filter cached=filterCache.doCache(filter,FilterCachingPolicy.ALWAYS_CACHE);
    searcher.search(new ConstantScoreQuery(cached),1);
  }
  final long actualRamBytesUsed=RamUsageTester.sizeOf(filterCache,acc);
  final long expectedRamBytesUsed=filterCache.ramBytesUsed();
  assertEquals(actualRamBytesUsed,expectedRamBytesUsed,30 * actualRamBytesUsed / 100);
  reader.close();
  w.close();
  dir.close();
}
