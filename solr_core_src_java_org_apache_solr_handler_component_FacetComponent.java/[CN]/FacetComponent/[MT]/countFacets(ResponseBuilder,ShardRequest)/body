{
  FacetInfo fi=rb._facetInfo;
  for (  ShardResponse srsp : sreq.responses) {
    int shardNum=rb.getShardNum(srsp.getShard());
    NamedList facet_counts=null;
    try {
      facet_counts=(NamedList)srsp.getSolrResponse().getResponse().get("facet_counts");
    }
 catch (    Exception ex) {
      if (rb.req.getParams().getBool(ShardParams.SHARDS_TOLERANT,false)) {
        continue;
      }
      throw new SolrException(ErrorCode.SERVER_ERROR,"Unable to read facet info for shard: " + srsp.getShard(),ex);
    }
    NamedList facet_queries=(NamedList)facet_counts.get("facet_queries");
    if (facet_queries != null) {
      for (int i=0; i < facet_queries.size(); i++) {
        String returnedKey=facet_queries.getName(i);
        long count=((Number)facet_queries.getVal(i)).longValue();
        QueryFacet qf=fi.queryFacets.get(returnedKey);
        qf.count+=count;
      }
    }
    NamedList facet_fields=(NamedList)facet_counts.get("facet_fields");
    if (facet_fields != null) {
      for (      DistribFieldFacet dff : fi.facets.values()) {
        dff.add(shardNum,(NamedList)facet_fields.get(dff.getKey()),dff.initialLimit);
      }
    }
    doDistribDates(fi,facet_counts);
    @SuppressWarnings("unchecked") SimpleOrderedMap<SimpleOrderedMap<Object>> rangesFromShard=(SimpleOrderedMap<SimpleOrderedMap<Object>>)facet_counts.get("facet_ranges");
    if (rangesFromShard != null) {
      RangeFacetRequest.DistribRangeFacet.mergeFacetRangesFromShardResponse(fi.rangeFacets,rangesFromShard);
    }
    doDistribIntervals(fi,facet_counts);
    doDistribPivots(rb,shardNum,facet_counts);
    SpatialHeatmapFacets.distribHandleResponse(fi.heatmapFacets,facet_counts);
  }
  for (  Entry<String,PivotFacet> pivotFacet : fi.pivotFacets) {
    pivotFacet.getValue().queuePivotRefinementRequests();
  }
  for (  DistribFieldFacet dff : fi.facets.values()) {
    if (dff.initialLimit <= 0 && dff.initialMincount <= 1)     continue;
    if (dff.minCount <= 1 && dff.sort.equals(FacetParams.FACET_SORT_INDEX))     continue;
    @SuppressWarnings("unchecked") List<String>[] tmp=(List<String>[])new List[rb.shards.length];
    dff._toRefine=tmp;
    ShardFacetCount[] counts=dff.getCountSorted();
    int ntop=Math.min(counts.length,dff.limit >= 0 ? dff.offset + dff.limit : Integer.MAX_VALUE);
    long smallestCount=counts.length == 0 ? 0 : counts[ntop - 1].count;
    for (int i=0; i < counts.length; i++) {
      ShardFacetCount sfc=counts[i];
      boolean needRefinement=false;
      if (i < ntop) {
        needRefinement=true;
      }
 else {
        long maxCount=sfc.count;
        for (int shardNum=0; shardNum < rb.shards.length; shardNum++) {
          FixedBitSet fbs=dff.counted[shardNum];
          if (fbs != null && (sfc.termNum >= fbs.length() || !fbs.get(sfc.termNum))) {
            maxCount+=dff.maxPossible(shardNum);
          }
        }
        if (maxCount >= smallestCount) {
          needRefinement=true;
        }
      }
      if (needRefinement) {
        for (int shardNum=0; shardNum < rb.shards.length; shardNum++) {
          FixedBitSet fbs=dff.counted[shardNum];
          if (fbs != null && (sfc.termNum >= fbs.length() || !fbs.get(sfc.termNum)) && dff.maxPossible(shardNum) > 0) {
            dff.needRefinements=true;
            List<String> lst=dff._toRefine[shardNum];
            if (lst == null) {
              lst=dff._toRefine[shardNum]=new ArrayList<>();
            }
            lst.add(sfc.name);
          }
        }
      }
    }
  }
  removeFieldFacetsUnderLimits(rb);
  removeRangeFacetsUnderLimits(rb);
  removeQueryFacetsUnderLimits(rb);
}
