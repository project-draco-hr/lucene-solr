{
  final int parentSlots[]=new int[numHits];
  final int childSlots[]=new int[numHits];
  SortField parentFields[]=parentSort.getSort();
  final int parentReverseMul[]=new int[parentFields.length];
  final FieldComparator<?> parentComparators[]=new FieldComparator[parentFields.length];
  for (int i=0; i < parentFields.length; i++) {
    parentReverseMul[i]=parentFields[i].getReverse() ? -1 : 1;
    parentComparators[i]=parentFields[i].getComparator(2,i);
  }
  SortField childFields[]=childSort.getSort();
  final int childReverseMul[]=new int[childFields.length];
  final FieldComparator<?> childComparators[]=new FieldComparator[childFields.length];
  for (int i=0; i < childFields.length; i++) {
    childReverseMul[i]=childFields[i].getReverse() ? -1 : 1;
    childComparators[i]=childFields[i].getComparator(2,i);
  }
  return new FieldComparator<Integer>(){
    int bottomParent;
    int bottomChild;
    FixedBitSet parentBits;
    @Override public int compare(    int slot1,    int slot2){
      try {
        return compare(childSlots[slot1],parentSlots[slot1],childSlots[slot2],parentSlots[slot2]);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void setBottom(    int slot){
      bottomParent=parentSlots[slot];
      bottomChild=childSlots[slot];
    }
    @Override public void setTopValue(    Integer value){
      throw new UnsupportedOperationException("this comparator cannot be used with deep paging");
    }
    @Override public int compareBottom(    int doc) throws IOException {
      return compare(bottomChild,bottomParent,doc,parent(doc));
    }
    @Override public int compareTop(    int doc) throws IOException {
      throw new UnsupportedOperationException("this comparator cannot be used with deep paging");
    }
    @Override public void copy(    int slot,    int doc) throws IOException {
      childSlots[slot]=doc;
      parentSlots[slot]=parent(doc);
    }
    @Override public FieldComparator<Integer> setNextReader(    AtomicReaderContext context) throws IOException {
      final DocIdSet parents=parentsFilter.getDocIdSet(context,null);
      if (parents == null) {
        throw new IllegalStateException("AtomicReader " + context.reader() + " contains no parents!");
      }
      if (!(parents instanceof FixedBitSet)) {
        throw new IllegalStateException("parentFilter must return FixedBitSet; got " + parents);
      }
      parentBits=(FixedBitSet)parents;
      for (int i=0; i < parentComparators.length; i++) {
        parentComparators[i]=parentComparators[i].setNextReader(context);
      }
      for (int i=0; i < childComparators.length; i++) {
        childComparators[i]=childComparators[i].setNextReader(context);
      }
      return this;
    }
    @Override public Integer value(    int slot){
      throw new UnsupportedOperationException();
    }
    @Override public void setScorer(    Scorer scorer){
      super.setScorer(scorer);
      for (      FieldComparator<?> comp : parentComparators) {
        comp.setScorer(scorer);
      }
      for (      FieldComparator<?> comp : childComparators) {
        comp.setScorer(scorer);
      }
    }
    int parent(    int doc){
      return parentBits.nextSetBit(doc);
    }
    int compare(    int docID1,    int parent1,    int docID2,    int parent2) throws IOException {
      if (parent1 == parent2) {
        if (docID1 == parent1 || docID2 == parent2) {
          return docID1 - docID2;
        }
 else {
          return compare(docID1,docID2,childComparators,childReverseMul);
        }
      }
 else {
        int cmp=compare(parent1,parent2,parentComparators,parentReverseMul);
        if (cmp == 0) {
          return parent1 - parent2;
        }
 else {
          return cmp;
        }
      }
    }
    int compare(    int docID1,    int docID2,    FieldComparator<?> comparators[],    int reverseMul[]) throws IOException {
      for (int i=0; i < comparators.length; i++) {
        comparators[i].copy(0,docID1);
        comparators[i].copy(1,docID2);
        int comp=reverseMul[i] * comparators[i].compare(0,1);
        if (comp != 0) {
          return comp;
        }
      }
      return 0;
    }
  }
;
}
