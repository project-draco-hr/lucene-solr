{
  final int downTo=Math.max(1,prefixLenPlus1);
  for (int idx=lastInput.length; idx >= downTo; idx--) {
    boolean doPrune=false;
    boolean doCompile=false;
    final UnCompiledNode<T> node=frontier[idx];
    final UnCompiledNode<T> parent=frontier[idx - 1];
    if (node.inputCount < minSuffixCount1) {
      doPrune=true;
      doCompile=true;
    }
 else     if (idx > prefixLenPlus1) {
      if (parent.inputCount < minSuffixCount2 || (minSuffixCount2 == 1 && parent.inputCount == 1 && idx > 1)) {
        doPrune=true;
      }
 else {
        doPrune=false;
      }
      doCompile=true;
    }
 else {
      doCompile=minSuffixCount2 == 0;
    }
    if (node.inputCount < minSuffixCount2 || (minSuffixCount2 == 1 && node.inputCount == 1 && idx > 1)) {
      for (int arcIdx=0; arcIdx < node.numArcs; arcIdx++) {
        @SuppressWarnings({"rawtypes","unchecked"}) final UnCompiledNode<T> target=(UnCompiledNode<T>)node.arcs[arcIdx].target;
        target.clear();
      }
      node.numArcs=0;
    }
    if (doPrune) {
      node.clear();
      parent.deleteLast(lastInput.ints[lastInput.offset + idx - 1],node);
    }
 else {
      if (minSuffixCount2 != 0) {
        compileAllTargets(node,lastInput.length - idx);
      }
      final T nextFinalOutput=node.output;
      final boolean isFinal=node.isFinal || node.numArcs == 0;
      if (doCompile) {
        parent.replaceLast(lastInput.ints[lastInput.offset + idx - 1],compileNode(node,1 + lastInput.length - idx),nextFinalOutput,isFinal);
      }
 else {
        parent.replaceLast(lastInput.ints[lastInput.offset + idx - 1],node,nextFinalOutput,isFinal);
        frontier[idx]=new UnCompiledNode<>(this,idx);
      }
    }
  }
}
