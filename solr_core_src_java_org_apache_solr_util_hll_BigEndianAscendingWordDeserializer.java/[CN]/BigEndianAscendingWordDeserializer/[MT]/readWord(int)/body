{
  if (position < 0) {
    throw new ArrayIndexOutOfBoundsException(position);
  }
  final long firstBitIndex=((long)position) * ((long)wordLength);
  final int firstByteIndex=(bytePadding + (int)(firstBitIndex / BITS_PER_BYTE));
  final int firstByteSkipBits=(int)(firstBitIndex % BITS_PER_BYTE);
  final long lastBitIndex=(firstBitIndex + wordLength - 1);
  final int lastByteIndex=(bytePadding + (int)(lastBitIndex / BITS_PER_BYTE));
  final int lastByteBitsToConsume;
  final int bitsAfterByteBoundary=(int)((lastBitIndex + 1) % BITS_PER_BYTE);
  if (bitsAfterByteBoundary == 0) {
    lastByteBitsToConsume=BITS_PER_BYTE;
  }
 else {
    lastByteBitsToConsume=bitsAfterByteBoundary;
  }
  if (lastByteIndex >= bytes.length) {
    throw new ArrayIndexOutOfBoundsException("Word out of bounds of backing array.");
  }
  long value=0;
  final int bitsRemainingInFirstByte=(BITS_PER_BYTE - firstByteSkipBits);
  final int bitsToConsumeInFirstByte=Math.min(bitsRemainingInFirstByte,wordLength);
  long firstByte=(long)bytes[firstByteIndex];
  final long firstByteMask=((1L << bitsRemainingInFirstByte) - 1L);
  firstByte&=firstByteMask;
  firstByte>>>=(bitsRemainingInFirstByte - bitsToConsumeInFirstByte);
  value|=firstByte;
  if (firstByteIndex == lastByteIndex) {
    return value;
  }
  final int middleByteCount=(lastByteIndex - firstByteIndex - 1);
  for (int i=0; i < middleByteCount; i++) {
    final long middleByte=(bytes[firstByteIndex + i + 1] & BYTE_MASK);
    value<<=BITS_PER_BYTE;
    value|=middleByte;
  }
  long lastByte=(bytes[lastByteIndex] & BYTE_MASK);
  lastByte>>=(BITS_PER_BYTE - lastByteBitsToConsume);
  value<<=lastByteBitsToConsume;
  value|=lastByte;
  return value;
}
