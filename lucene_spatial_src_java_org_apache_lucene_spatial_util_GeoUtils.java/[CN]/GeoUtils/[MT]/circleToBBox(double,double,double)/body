{
  final double radLat=TO_RADIANS * centerLat;
  final double radLon=TO_RADIANS * centerLon;
  double radDistance=radiusMeters / SEMIMAJOR_AXIS;
  double minLat=radLat - radDistance;
  double maxLat=radLat + radDistance;
  double minLon;
  double maxLon;
  if (minLat > MIN_LAT_RADIANS && maxLat < MAX_LAT_RADIANS) {
    double deltaLon=asin(sloppySin(radDistance) / cos(radLat));
    minLon=radLon - deltaLon;
    if (minLon < MIN_LON_RADIANS) {
      minLon+=2d * PI;
    }
    maxLon=radLon + deltaLon;
    if (maxLon > MAX_LON_RADIANS) {
      maxLon-=2d * PI;
    }
  }
 else {
    minLat=max(minLat,MIN_LAT_RADIANS);
    maxLat=min(maxLat,MAX_LAT_RADIANS);
    minLon=MIN_LON_RADIANS;
    maxLon=MAX_LON_RADIANS;
  }
  return new GeoRect(TO_DEGREES * minLon,TO_DEGREES * maxLon,TO_DEGREES * minLat,TO_DEGREES * maxLat);
}
