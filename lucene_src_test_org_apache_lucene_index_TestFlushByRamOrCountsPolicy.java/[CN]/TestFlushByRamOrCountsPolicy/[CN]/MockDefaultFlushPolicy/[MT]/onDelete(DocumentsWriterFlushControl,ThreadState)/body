{
  final ArrayList<ThreadState> pending=new ArrayList<DocumentsWriterPerThreadPool.ThreadState>();
  final ArrayList<ThreadState> notPending=new ArrayList<DocumentsWriterPerThreadPool.ThreadState>();
  findPending(control,pending,notPending);
  final boolean flushCurrent=state.flushPending;
  final ThreadState toFlush;
  if (state.flushPending) {
    toFlush=state;
  }
 else   if (flushOnDeleteTerms() && state.perThread.pendingDeletes.numTermDeletes.get() >= indexWriterConfig.getMaxBufferedDeleteTerms()) {
    toFlush=state;
  }
 else {
    toFlush=null;
  }
  super.onDelete(control,state);
  if (toFlush != null) {
    if (flushCurrent) {
      assertTrue(pending.remove(toFlush));
    }
 else {
      assertTrue(notPending.remove(toFlush));
    }
    assertTrue(toFlush.flushPending);
    hasMarkedPending=true;
  }
  for (  ThreadState threadState : notPending) {
    assertFalse(threadState.flushPending);
  }
}
