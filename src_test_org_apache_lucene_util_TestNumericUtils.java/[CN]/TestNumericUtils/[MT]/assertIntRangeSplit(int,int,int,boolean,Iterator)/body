{
  final OpenBitSet bits=useBitSet ? new OpenBitSet(upper - lower + 1) : null;
  NumericUtils.splitIntRange(new NumericUtils.IntRangeBuilder(){
    public void addRange(    int min,    int max,    int shift){
      assertTrue("min, max should be inside bounds",min >= lower && min <= upper && max >= lower && max <= upper);
      if (useBitSet)       for (int i=min; i <= max; i++) {
        assertFalse("ranges should not overlap",bits.getAndSet(i - lower));
      }
      min^=0x80000000;
      max^=0x80000000;
      assertEquals("inner min bound",((Integer)neededBounds.next()).intValue(),min >>> shift);
      assertEquals("inner max bound",((Integer)neededBounds.next()).intValue(),max >>> shift);
    }
  }
,precisionStep,lower,upper);
  if (useBitSet) {
    bits.flip(0,upper - lower + 1);
    assertTrue("The sub-range concenated should match the whole range",bits.isEmpty());
  }
}
