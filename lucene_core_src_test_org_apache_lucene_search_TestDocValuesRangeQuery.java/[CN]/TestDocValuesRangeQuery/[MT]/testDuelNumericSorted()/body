{
  Directory dir=newDirectory();
  RandomIndexWriter iw=new RandomIndexWriter(random(),dir);
  final int numDocs=atLeast(100);
  for (int i=0; i < numDocs; ++i) {
    Document doc=new Document();
    final int numValues=random().nextInt(3);
    for (int j=0; j < numValues; ++j) {
      final long value=TestUtil.nextLong(random(),-100,10000);
      doc.add(new SortedNumericDocValuesField("dv1",value));
      doc.add(new SortedSetDocValuesField("dv2",toSortableBytes(value)));
    }
    iw.addDocument(doc);
  }
  if (random().nextBoolean()) {
    iw.deleteDocuments(DocValuesRangeQuery.newLongRange("dv1",0L,10L,true,true));
  }
  iw.commit();
  final IndexReader reader=iw.getReader();
  final IndexSearcher searcher=newSearcher(reader);
  iw.close();
  for (int i=0; i < 100; ++i) {
    final Long min=random().nextBoolean() ? null : TestUtil.nextLong(random(),-100,1000);
    final Long max=random().nextBoolean() ? null : TestUtil.nextLong(random(),-100,1000);
    final boolean minInclusive=random().nextBoolean();
    final boolean maxInclusive=random().nextBoolean();
    final Query q1=DocValuesRangeQuery.newLongRange("dv1",min,max,minInclusive,maxInclusive);
    final Query q2=DocValuesRangeQuery.newBytesRefRange("dv2",toSortableBytes(min),toSortableBytes(max),minInclusive,maxInclusive);
    assertSameMatches(searcher,q1,q2,true);
  }
  reader.close();
  dir.close();
}
