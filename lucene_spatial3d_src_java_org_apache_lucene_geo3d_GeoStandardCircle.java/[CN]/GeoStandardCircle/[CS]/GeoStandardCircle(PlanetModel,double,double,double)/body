{
  super(planetModel);
  if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)   throw new IllegalArgumentException("Latitude out of bounds");
  if (lon < -Math.PI || lon > Math.PI)   throw new IllegalArgumentException("Longitude out of bounds");
  if (cutoffAngle < 0.0 || cutoffAngle > Math.PI)   throw new IllegalArgumentException("Cutoff angle out of bounds");
  if (cutoffAngle < Vector.MINIMUM_RESOLUTION)   throw new IllegalArgumentException("Cutoff angle cannot be effectively zero");
  this.center=new GeoPoint(planetModel,lat,lon);
  this.cutoffAngle=cutoffAngle;
  double upperLat=lat + cutoffAngle;
  double upperLon=lon;
  if (upperLat > Math.PI * 0.5) {
    upperLon+=Math.PI;
    if (upperLon > Math.PI)     upperLon-=2.0 * Math.PI;
    upperLat=Math.PI - upperLat;
  }
  double lowerLat=lat - cutoffAngle;
  double lowerLon=lon;
  if (lowerLat < -Math.PI * 0.5) {
    lowerLon+=Math.PI;
    if (lowerLon > Math.PI)     lowerLon-=2.0 * Math.PI;
    lowerLat=-Math.PI - lowerLat;
  }
  final GeoPoint upperPoint=new GeoPoint(planetModel,upperLat,upperLon);
  final GeoPoint lowerPoint=new GeoPoint(planetModel,lowerLat,lowerLon);
  if (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION) {
    this.circlePlane=null;
    this.edgePoints=new GeoPoint[0];
  }
 else {
    final Plane normalPlane=Plane.constructNormalizedZPlane(upperPoint,lowerPoint,center);
    this.circlePlane=SidedPlane.constructNormalizedPerpendicularSidedPlane(center,normalPlane,upperPoint,lowerPoint);
    if (circlePlane == null)     throw new IllegalArgumentException("Couldn't construct circle plane, probably too small?  Cutoff angle = " + cutoffAngle + "; upperPoint = "+ upperPoint+ "; lowerPoint = "+ lowerPoint);
    final GeoPoint recomputedIntersectionPoint=circlePlane.getSampleIntersectionPoint(planetModel,normalPlane);
    if (recomputedIntersectionPoint == null)     throw new IllegalArgumentException("Couldn't construct intersection point, probably circle too small?  Plane = " + circlePlane);
    this.edgePoints=new GeoPoint[]{recomputedIntersectionPoint};
  }
}
