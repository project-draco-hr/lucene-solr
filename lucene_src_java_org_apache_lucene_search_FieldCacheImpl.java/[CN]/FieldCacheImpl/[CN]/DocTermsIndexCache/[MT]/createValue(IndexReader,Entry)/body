{
  String field=StringHelper.intern(entryKey.field);
  Terms terms=MultiFields.getTerms(reader,field);
  final boolean fasterButMoreRAM=((Boolean)entryKey.custom).booleanValue();
  final PagedBytes bytes=new PagedBytes(15);
  int startBytesBPV;
  int startTermsBPV;
  int startNumUniqueTerms;
  if (terms != null) {
    long numUniqueTerms=0;
    try {
      numUniqueTerms=terms.getUniqueTermCount();
    }
 catch (    UnsupportedOperationException uoe) {
      numUniqueTerms=-1;
    }
    if (numUniqueTerms != -1) {
      startBytesBPV=PackedInts.bitsRequired(numUniqueTerms * 4);
      startTermsBPV=PackedInts.bitsRequired(numUniqueTerms);
      if (numUniqueTerms > Integer.MAX_VALUE - 1) {
        throw new IllegalStateException("this field has too many (" + numUniqueTerms + ") unique terms");
      }
      startNumUniqueTerms=(int)numUniqueTerms;
    }
 else {
      startBytesBPV=1;
      startTermsBPV=1;
      startNumUniqueTerms=1;
    }
  }
 else {
    startBytesBPV=1;
    startTermsBPV=1;
    startNumUniqueTerms=1;
  }
  GrowableWriter termOrdToBytesOffset=new GrowableWriter(startBytesBPV,1 + startNumUniqueTerms,fasterButMoreRAM);
  final GrowableWriter docToTermOrd=new GrowableWriter(startTermsBPV,reader.maxDoc(),fasterButMoreRAM);
  bytes.copyUsingLengthPrefix(new BytesRef());
  int termOrd=1;
  if (terms != null) {
    final TermsEnum termsEnum=terms.iterator();
    final Bits delDocs=MultiFields.getDeletedDocs(reader);
    DocsEnum docs=null;
    while (true) {
      final BytesRef term=termsEnum.next();
      if (term == null) {
        break;
      }
      if (termOrd == termOrdToBytesOffset.size()) {
        termOrdToBytesOffset=termOrdToBytesOffset.resize(ArrayUtil.oversize(1 + termOrd,1));
      }
      termOrdToBytesOffset.set(termOrd,bytes.copyUsingLengthPrefix(term));
      docs=termsEnum.docs(delDocs,docs);
      while (true) {
        final int docID=docs.nextDoc();
        if (docID == DocsEnum.NO_MORE_DOCS) {
          break;
        }
        docToTermOrd.set(docID,termOrd);
      }
      termOrd++;
    }
    if (termOrdToBytesOffset.size() > termOrd) {
      termOrdToBytesOffset=termOrdToBytesOffset.resize(termOrd);
    }
  }
  return new DocTermsIndexImpl(bytes.freeze(true),termOrdToBytesOffset.getMutable(),docToTermOrd.getMutable(),termOrd);
}
