{
  meta.writeLong(data.getFilePointer());
  long minValue=Long.MAX_VALUE;
  long maxValue=Long.MIN_VALUE;
  boolean missing=false;
  long count=0;
  for (  Number nv : values) {
    if (nv != null) {
      long v=nv.longValue();
      minValue=Math.min(minValue,v);
      maxValue=Math.max(maxValue,v);
    }
 else {
      missing=true;
    }
    count++;
    if (count >= DirectDocValuesFormat.MAX_SORTED_SET_ORDS) {
      throw new IllegalArgumentException("DocValuesField \"" + field.name + "\" is too large, must be <= "+ DirectDocValuesFormat.MAX_SORTED_SET_ORDS+ " values/total ords");
    }
  }
  meta.writeInt((int)count);
  if (missing) {
    long start=data.getFilePointer();
    writeMissingBitset(values);
    meta.writeLong(start);
    meta.writeLong(data.getFilePointer() - start);
  }
 else {
    meta.writeLong(-1L);
  }
  byte byteWidth;
  if (minValue >= Byte.MIN_VALUE && maxValue <= Byte.MAX_VALUE) {
    byteWidth=1;
  }
 else   if (minValue >= Short.MIN_VALUE && maxValue <= Short.MAX_VALUE) {
    byteWidth=2;
  }
 else   if (minValue >= Integer.MIN_VALUE && maxValue <= Integer.MAX_VALUE) {
    byteWidth=4;
  }
 else {
    byteWidth=8;
  }
  meta.writeByte(byteWidth);
  for (  Number nv : values) {
    long v;
    if (nv != null) {
      v=nv.longValue();
    }
 else {
      v=0;
    }
switch (byteWidth) {
case 1:
      data.writeByte((byte)v);
    break;
case 2:
  data.writeShort((short)v);
break;
case 4:
data.writeInt((int)v);
break;
case 8:
data.writeLong(v);
break;
}
}
}
