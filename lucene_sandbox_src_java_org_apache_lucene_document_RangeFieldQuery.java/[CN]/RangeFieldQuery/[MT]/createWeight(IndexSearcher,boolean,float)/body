{
  return new ConstantScoreWeight(this,boost){
    final RangeFieldComparator comparator=new RangeFieldComparator();
    private DocIdSet buildMatchingDocIdSet(    LeafReader reader,    PointValues values) throws IOException {
      DocIdSetBuilder result=new DocIdSetBuilder(reader.maxDoc(),values,field);
      values.intersect(field,new IntersectVisitor(){
        DocIdSetBuilder.BulkAdder adder;
        @Override public void grow(        int count){
          adder=result.grow(count);
        }
        @Override public void visit(        int docID) throws IOException {
          adder.add(docID);
        }
        @Override public void visit(        int docID,        byte[] leaf) throws IOException {
          if ((comparator.isWithin(leaf) && queryType != QueryType.WITHIN) || (comparator.contains(leaf) && queryType != QueryType.CONTAINS) || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {
            adder.add(docID);
          }
        }
        @Override public Relation compare(        byte[] minPackedValue,        byte[] maxPackedValue){
          byte[] node=getInternalRange(minPackedValue,maxPackedValue);
          if (comparator.isDisjoint(node)) {
            return Relation.CELL_OUTSIDE_QUERY;
          }
 else           if (comparator.contains(node)) {
            return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;
          }
 else           if (comparator.isWithin(node)) {
            return Relation.CELL_CROSSES_QUERY;
          }
          return Relation.CELL_CROSSES_QUERY;
        }
      }
);
      return result.build();
    }
    @Override public Scorer scorer(    LeafReaderContext context) throws IOException {
      LeafReader reader=context.reader();
      PointValues values=reader.getPointValues();
      if (values == null) {
        return null;
      }
      FieldInfo fieldInfo=reader.getFieldInfos().fieldInfo(field);
      if (fieldInfo == null) {
      }
      checkFieldInfo(fieldInfo);
      boolean allDocsMatch=true;
      if (values.getDocCount(field) == reader.maxDoc()) {
        byte[] range=getInternalRange(values.getMinPackedValue(field),values.getMaxPackedValue(field));
        if (((comparator.contains(range) && queryType == QueryType.CONTAINS)) == false) {
          allDocsMatch=false;
        }
      }
 else {
        allDocsMatch=false;
      }
      DocIdSetIterator iterator=allDocsMatch == true ? DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader,values).iterator();
      return new ConstantScoreScorer(this,score(),iterator);
    }
    /** 
 * get an encoded byte representation of the internal node; this is
 * the lower half of the min array and the upper half of the max array 
 */
    private byte[] getInternalRange(    byte[] min,    byte[] max){
      byte[] range=new byte[min.length];
      final int dimSize=numDims * bytesPerDim;
      System.arraycopy(min,0,range,0,dimSize);
      System.arraycopy(max,dimSize,range,dimSize,dimSize);
      return range;
    }
  }
;
}
