{
  Bits liveDocs=reader.getLiveDocs();
  List<Integer> values=new ArrayList<Integer>();
  for (int i=0; i < reader.maxDoc(); i++) {
    if (liveDocs == null || liveDocs.get(i)) {
      values.add(Integer.valueOf(reader.document(i).get(ID_FIELD)));
    }
  }
  Sorter sorter=SORTERS[random().nextInt(SORTERS.length)];
  if (sorter == Sorter.REVERSE_DOCS) {
    Collections.reverse(values);
  }
 else {
    Collections.sort(values);
    if (sorter instanceof SortSorter && random().nextBoolean()) {
      sorter=new SortSorter(new Sort(new SortField(NUMERIC_DV_FIELD,SortField.Type.LONG,true)));
      Collections.reverse(values);
    }
  }
  sortedValues=values.toArray(new Integer[values.size()]);
  if (VERBOSE) {
    System.out.println("sortedValues: " + sortedValues);
    System.out.println("Sorter: " + sorter);
  }
  Directory target=newDirectory();
  IndexWriter writer=new IndexWriter(target,newIndexWriterConfig(TEST_VERSION_CURRENT,null));
  reader=SortingAtomicReader.wrap(reader,sorter);
  writer.addIndexes(reader);
  writer.close();
  reader.close();
  dir.close();
  dir=target;
  TestUtil.checkIndex(dir);
  reader=SlowCompositeReaderWrapper.wrap(DirectoryReader.open(dir));
  assertFalse("index should not have deletions",reader.hasDeletions());
}
