{
  String collectionName=message.getStr(COLLECTION_PROP);
  String backupName=message.getStr(NAME);
  ShardHandler shardHandler=ocmh.shardHandlerFactory.getShardHandler();
  String asyncId=message.getStr(ASYNC);
  String repo=message.getStr(CoreAdminParams.BACKUP_REPOSITORY);
  String commitName=message.getStr(CoreAdminParams.COMMIT_NAME);
  Optional<CollectionSnapshotMetaData> snapshotMeta=Optional.empty();
  if (commitName != null) {
    SolrZkClient zkClient=ocmh.overseer.getZkController().getZkClient();
    snapshotMeta=SolrSnapshotManager.getCollectionLevelSnapshot(zkClient,collectionName,commitName);
    if (!snapshotMeta.isPresent()) {
      throw new SolrException(ErrorCode.BAD_REQUEST,"Snapshot with name " + commitName + " does not exist for collection "+ collectionName);
    }
    if (snapshotMeta.get().getStatus() != SnapshotStatus.Successful) {
      throw new SolrException(ErrorCode.BAD_REQUEST,"Snapshot with name " + commitName + " for collection "+ collectionName+ " has not completed successfully. The status is "+ snapshotMeta.get().getStatus());
    }
  }
  Map<String,String> requestMap=new HashMap<>();
  Instant startTime=Instant.now();
  CoreContainer cc=ocmh.overseer.getZkController().getCoreContainer();
  BackupRepository repository=cc.newBackupRepository(Optional.ofNullable(repo));
  BackupManager backupMgr=new BackupManager(repository,ocmh.zkStateReader,collectionName);
  URI location=repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));
  URI backupPath=repository.resolve(location,backupName);
  if (repository.exists(backupPath)) {
    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"The backup directory already exists: " + backupPath);
  }
  repository.createDirectory(backupPath);
  log.info("Starting backup of collection={} with backupName={} at location={}",collectionName,backupName,backupPath);
  Collection<String> shardsToConsider=Collections.emptySet();
  if (snapshotMeta.isPresent()) {
    shardsToConsider=snapshotMeta.get().getShards();
  }
  for (  Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getActiveSlices()) {
    Replica replica=null;
    if (snapshotMeta.isPresent()) {
      if (!shardsToConsider.contains(slice.getName())) {
        log.warn("Skipping the backup for shard {} since it wasn't part of the collection {} when snapshot {} was created.",slice.getName(),collectionName,snapshotMeta.get().getName());
        continue;
      }
      replica=selectReplicaWithSnapshot(snapshotMeta.get(),slice);
    }
 else {
      replica=slice.getLeader();
      if (replica == null) {
        throw new SolrException(ErrorCode.SERVER_ERROR,"No 'leader' replica available for shard " + slice.getName() + " of collection "+ collectionName);
      }
    }
    String coreName=replica.getStr(CORE_NAME_PROP);
    ModifiableSolrParams params=new ModifiableSolrParams();
    params.set(CoreAdminParams.ACTION,CoreAdminParams.CoreAdminAction.BACKUPCORE.toString());
    params.set(NAME,slice.getName());
    params.set(CoreAdminParams.BACKUP_REPOSITORY,repo);
    params.set(CoreAdminParams.BACKUP_LOCATION,backupPath.toASCIIString());
    params.set(CORE_NAME_PROP,coreName);
    if (snapshotMeta.isPresent()) {
      params.set(CoreAdminParams.COMMIT_NAME,snapshotMeta.get().getName());
    }
    ocmh.sendShardRequest(replica.getNodeName(),params,shardHandler,asyncId,requestMap);
    log.debug("Sent backup request to core={} for backupName={}",coreName,backupName);
  }
  log.debug("Sent backup requests to all shard leaders for backupName={}",backupName);
  ocmh.processResponses(results,shardHandler,true,"Could not backup all replicas",asyncId,requestMap);
  log.info("Starting to backup ZK data for backupName={}",backupName);
  String configName=ocmh.zkStateReader.readConfigName(collectionName);
  backupMgr.downloadConfigDir(location,backupName,configName);
  DocCollection collectionState=ocmh.zkStateReader.getClusterState().getCollection(collectionName);
  backupMgr.writeCollectionState(location,backupName,collectionName,collectionState);
  Properties properties=new Properties();
  properties.put(BackupManager.BACKUP_NAME_PROP,backupName);
  properties.put(BackupManager.COLLECTION_NAME_PROP,collectionName);
  properties.put(COLL_CONF,configName);
  properties.put(BackupManager.START_TIME_PROP,startTime.toString());
  backupMgr.writeBackupProperties(location,backupName,properties);
  log.info("Completed backing up ZK data for backupName={}",backupName);
}
