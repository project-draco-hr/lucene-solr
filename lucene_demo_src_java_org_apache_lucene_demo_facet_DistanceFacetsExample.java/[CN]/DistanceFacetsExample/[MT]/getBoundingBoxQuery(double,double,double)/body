{
  double originLatRadians=SloppyMath.toRadians(originLat);
  double originLngRadians=SloppyMath.toRadians(originLng);
  double angle=maxDistanceKM / EARTH_RADIUS_KM;
  double minLat=originLatRadians - angle;
  double maxLat=originLatRadians + angle;
  double minLng;
  double maxLng;
  if (minLat > SloppyMath.toRadians(-90) && maxLat < SloppyMath.toRadians(90)) {
    double delta=Math.asin(Math.sin(angle) / Math.cos(originLatRadians));
    minLng=originLngRadians - delta;
    if (minLng < SloppyMath.toRadians(-180)) {
      minLng+=2 * Math.PI;
    }
    maxLng=originLngRadians + delta;
    if (maxLng > SloppyMath.toRadians(180)) {
      maxLng-=2 * Math.PI;
    }
  }
 else {
    minLat=Math.max(minLat,SloppyMath.toRadians(-90));
    maxLat=Math.min(maxLat,SloppyMath.toRadians(90));
    minLng=SloppyMath.toRadians(-180);
    maxLng=SloppyMath.toRadians(180);
  }
  BooleanQuery.Builder f=new BooleanQuery.Builder();
  f.add(DoublePoint.newRangeQuery("latitude",SloppyMath.toDegrees(minLat),SloppyMath.toDegrees(maxLat)),BooleanClause.Occur.FILTER);
  if (minLng > maxLng) {
    BooleanQuery.Builder lonF=new BooleanQuery.Builder();
    lonF.add(DoublePoint.newRangeQuery("longitude",SloppyMath.toDegrees(minLng),Double.POSITIVE_INFINITY),BooleanClause.Occur.SHOULD);
    lonF.add(DoublePoint.newRangeQuery("longitude",Double.NEGATIVE_INFINITY,SloppyMath.toDegrees(maxLng)),BooleanClause.Occur.SHOULD);
    f.add(lonF.build(),BooleanClause.Occur.MUST);
  }
 else {
    f.add(DoublePoint.newRangeQuery("longitude",SloppyMath.toDegrees(minLng),SloppyMath.toDegrees(maxLng)),BooleanClause.Occur.FILTER);
  }
  return f.build();
}
