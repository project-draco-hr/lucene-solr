{
  double originLatRadians=Math.toRadians(originLat);
  double originLngRadians=Math.toRadians(originLng);
  double angle=maxDistanceKM / (SloppyMath.earthDiameter(originLat) / 2.0);
  double minLat=originLatRadians - angle;
  double maxLat=originLatRadians + angle;
  double minLng;
  double maxLng;
  if (minLat > Math.toRadians(-90) && maxLat < Math.toRadians(90)) {
    double delta=Math.asin(Math.sin(angle) / Math.cos(originLatRadians));
    minLng=originLngRadians - delta;
    if (minLng < Math.toRadians(-180)) {
      minLng+=2 * Math.PI;
    }
    maxLng=originLngRadians + delta;
    if (maxLng > Math.toRadians(180)) {
      maxLng-=2 * Math.PI;
    }
  }
 else {
    minLat=Math.max(minLat,Math.toRadians(-90));
    maxLat=Math.min(maxLat,Math.toRadians(90));
    minLng=Math.toRadians(-180);
    maxLng=Math.toRadians(180);
  }
  BooleanQuery.Builder f=new BooleanQuery.Builder();
  f.add(NumericRangeQuery.newDoubleRange("latitude",Math.toDegrees(minLat),Math.toDegrees(maxLat),true,true),BooleanClause.Occur.FILTER);
  if (minLng > maxLng) {
    BooleanQuery.Builder lonF=new BooleanQuery.Builder();
    lonF.add(NumericRangeQuery.newDoubleRange("longitude",Math.toDegrees(minLng),null,true,true),BooleanClause.Occur.SHOULD);
    lonF.add(NumericRangeQuery.newDoubleRange("longitude",null,Math.toDegrees(maxLng),true,true),BooleanClause.Occur.SHOULD);
    f.add(lonF.build(),BooleanClause.Occur.MUST);
  }
 else {
    f.add(NumericRangeQuery.newDoubleRange("longitude",Math.toDegrees(minLng),Math.toDegrees(maxLng),true,true),BooleanClause.Occur.FILTER);
  }
  return new QueryWrapperFilter(f.build());
}
