{
  Directory dir=newDirectory();
  IndexWriter writer=new IndexWriter(dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)).setMergeScheduler(new ConcurrentMergeScheduler()));
  writer.addDocument(new Document());
  writer.commit();
  final CountDownLatch awaitEnterWarm=new CountDownLatch(1);
  final CountDownLatch awaitClose=new CountDownLatch(1);
  final ExecutorService es=random.nextBoolean() ? null : Executors.newCachedThreadPool(new NamedThreadFactory("testIntermediateClose"));
  final SearcherWarmer warmer=new SearcherWarmer(){
    @Override public void warm(    IndexSearcher s) throws IOException {
      try {
        awaitEnterWarm.countDown();
        awaitClose.await();
      }
 catch (      InterruptedException e) {
      }
    }
  }
;
  final SearcherManager searcherManager=random.nextBoolean() ? new SearcherManager(dir,warmer,es) : new SearcherManager(writer,random.nextBoolean(),warmer,es);
  IndexSearcher searcher=searcherManager.acquire();
  try {
    assertEquals(1,searcher.getIndexReader().numDocs());
  }
  finally {
    searcherManager.release(searcher);
  }
  writer.addDocument(new Document());
  writer.commit();
  final AtomicBoolean success=new AtomicBoolean(false);
  final AtomicBoolean triedReopen=new AtomicBoolean(false);
  final Throwable[] exc=new Throwable[1];
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      try {
        triedReopen.set(true);
        searcherManager.maybeReopen();
        success.set(true);
      }
 catch (      AlreadyClosedException e) {
      }
catch (      Throwable e) {
        exc[0]=e;
        success.set(false);
      }
    }
  }
);
  thread.start();
  awaitEnterWarm.await();
  for (int i=0; i < 2; i++) {
    searcherManager.close();
  }
  awaitClose.countDown();
  thread.join();
  try {
    searcherManager.acquire();
    fail("already closed");
  }
 catch (  AlreadyClosedException ex) {
  }
  assertFalse(success.get());
  assertTrue(triedReopen.get());
  assertNull("" + exc[0],exc[0]);
  writer.close();
  dir.close();
  if (es != null) {
    es.shutdown();
    es.awaitTermination(1,TimeUnit.SECONDS);
  }
}
