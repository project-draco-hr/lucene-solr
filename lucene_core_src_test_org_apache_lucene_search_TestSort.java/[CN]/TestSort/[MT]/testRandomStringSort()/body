{
  Random random=new Random(random().nextLong());
  final int NUM_DOCS=atLeast(100);
  final Directory dir=newDirectory();
  final RandomIndexWriter writer=new RandomIndexWriter(random,dir);
  final boolean allowDups=random.nextBoolean();
  final Set<String> seen=new HashSet<String>();
  final int maxLength=_TestUtil.nextInt(random,5,100);
  if (VERBOSE) {
    System.out.println("TEST: NUM_DOCS=" + NUM_DOCS + " maxLength="+ maxLength+ " allowDups="+ allowDups);
  }
  int numDocs=0;
  final List<BytesRef> docValues=new ArrayList<BytesRef>();
  while (numDocs < NUM_DOCS) {
    final String s;
    if (random.nextBoolean()) {
      s=_TestUtil.randomSimpleString(random,maxLength);
    }
 else {
      s=_TestUtil.randomUnicodeString(random,maxLength);
    }
    final BytesRef br=new BytesRef(s);
    if (!allowDups) {
      if (seen.contains(s)) {
        continue;
      }
      seen.add(s);
    }
    if (VERBOSE) {
      System.out.println("  " + numDocs + ": s="+ s);
    }
    final Document doc=new Document();
    doc.add(new SortedBytesDocValuesField("stringdv",br));
    doc.add(newStringField("string",s,Field.Store.NO));
    doc.add(new PackedLongDocValuesField("id",numDocs));
    docValues.add(br);
    writer.addDocument(doc);
    numDocs++;
    if (random.nextInt(40) == 17) {
      writer.getReader().close();
    }
  }
  final IndexReader r=writer.getReader();
  writer.close();
  if (VERBOSE) {
    System.out.println("  reader=" + r);
  }
  final IndexSearcher s=newSearcher(r,false);
  final int ITERS=atLeast(100);
  for (int iter=0; iter < ITERS; iter++) {
    final boolean reverse=random.nextBoolean();
    final TopFieldDocs hits;
    final SortField sf;
    if (random.nextBoolean()) {
      sf=new SortField("stringdv",SortField.Type.STRING,reverse);
      sf.setUseIndexValues(true);
    }
 else {
      sf=new SortField("string",SortField.Type.STRING,reverse);
    }
    final Sort sort=new Sort(sf);
    final int hitCount=_TestUtil.nextInt(random,1,r.maxDoc() + 20);
    final RandomFilter f=new RandomFilter(random,random.nextFloat(),docValues);
    if (random.nextBoolean()) {
      hits=s.search(new ConstantScoreQuery(f),hitCount,sort);
    }
 else {
      hits=s.search(new MatchAllDocsQuery(),f,hitCount,sort);
    }
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " "+ hits.totalHits+ " hits; topN="+ hitCount+ "; reverse="+ reverse);
    }
    Collections.sort(f.matchValues);
    if (reverse) {
      Collections.reverse(f.matchValues);
    }
    final List<BytesRef> expected=f.matchValues;
    if (VERBOSE) {
      System.out.println("  expected:");
      for (int idx=0; idx < expected.size(); idx++) {
        System.out.println("    " + idx + ": "+ expected.get(idx).utf8ToString());
        if (idx == hitCount - 1) {
          break;
        }
      }
    }
    if (VERBOSE) {
      System.out.println("  actual:");
      for (int hitIDX=0; hitIDX < hits.scoreDocs.length; hitIDX++) {
        final FieldDoc fd=(FieldDoc)hits.scoreDocs[hitIDX];
        System.out.println("    " + hitIDX + ": "+ ((BytesRef)fd.fields[0]).utf8ToString());
      }
    }
    for (int hitIDX=0; hitIDX < hits.scoreDocs.length; hitIDX++) {
      final FieldDoc fd=(FieldDoc)hits.scoreDocs[hitIDX];
      assertEquals(expected.get(hitIDX),(BytesRef)fd.fields[0]);
    }
  }
  r.close();
  dir.close();
}
