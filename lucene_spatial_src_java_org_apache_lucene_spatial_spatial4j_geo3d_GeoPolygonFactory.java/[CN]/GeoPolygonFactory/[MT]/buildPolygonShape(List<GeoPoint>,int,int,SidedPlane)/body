{
  GeoCompositeMembershipShape rval=new GeoCompositeMembershipShape();
  List<GeoPoint> recursionList=new ArrayList<GeoPoint>();
  List<GeoPoint> currentList=new ArrayList<GeoPoint>();
  List<SidedPlane> currentPlanes=new ArrayList<SidedPlane>();
  currentList.add(pointsList.get(startPointIndex));
  currentList.add(pointsList.get(endPointIndex));
  currentPlanes.add(startingEdge);
  for (int i=0; i < pointsList.size() - 2; i++) {
    GeoPoint newPoint=pointsList.get(getLegalIndex(i + endPointIndex + 1,pointsList.size()));
    if (isWithin(newPoint,currentPlanes)) {
      SidedPlane newBoundary=new SidedPlane(currentList.get(currentList.size() - 2),newPoint,currentList.get(currentList.size() - 1));
      SidedPlane returnBoundary=new SidedPlane(currentList.get(currentList.size() - 1),currentList.get(0),newPoint);
      boolean pointInside=false;
      for (int j=i + 1; j < pointsList.size() - 2; j++) {
        GeoPoint checkPoint=pointsList.get(getLegalIndex(j + endPointIndex + 1,pointsList.size()));
        boolean isInside=true;
        if (isInside && !newBoundary.isWithin(checkPoint))         isInside=false;
        if (isInside && !returnBoundary.isWithin(checkPoint))         isInside=false;
        if (isInside) {
          for (          SidedPlane plane : currentPlanes) {
            if (!plane.isWithin(checkPoint)) {
              isInside=false;
              break;
            }
          }
        }
        if (isInside) {
          pointInside=true;
          break;
        }
      }
      if (!pointInside) {
        if (recursionList.size() > 0) {
          recursionList.add(newPoint);
          recursionList.add(currentList.get(currentList.size() - 1));
          SidedPlane otherSideNewBoundary=new SidedPlane(newBoundary);
          rval.addShape(buildPolygonShape(recursionList,recursionList.size() - 2,recursionList.size() - 1,otherSideNewBoundary));
          recursionList.clear();
        }
        currentList.add(newPoint);
        currentPlanes.add(newBoundary);
      }
 else {
        recursionList.add(newPoint);
      }
    }
 else {
      recursionList.add(newPoint);
    }
  }
  if (recursionList.size() > 0) {
    recursionList.add(currentList.get(0));
    recursionList.add(currentList.get(currentList.size() - 1));
    SidedPlane newBoundary=new SidedPlane(currentList.get(currentList.size() - 2),currentList.get(0),currentList.get(currentList.size() - 1));
    SidedPlane otherSideNewBoundary=new SidedPlane(newBoundary);
    rval.addShape(buildPolygonShape(recursionList,recursionList.size() - 2,recursionList.size() - 1,otherSideNewBoundary));
    recursionList.clear();
  }
  rval.addShape(new GeoConvexPolygon(currentList));
  return rval;
}
