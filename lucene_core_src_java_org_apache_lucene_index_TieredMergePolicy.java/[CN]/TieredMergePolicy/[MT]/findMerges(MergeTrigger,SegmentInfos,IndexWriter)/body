{
  if (verbose(writer)) {
    message("findMerges: " + infos.size() + " segments",writer);
  }
  if (infos.size() == 0) {
    return null;
  }
  final Collection<SegmentCommitInfo> merging=writer.getMergingSegments();
  final Collection<SegmentCommitInfo> toBeMerged=new HashSet<>();
  final List<SegmentCommitInfo> infosSorted=new ArrayList<>(infos.asList());
  Collections.sort(infosSorted,new SegmentByteSizeDescending(writer));
  long totIndexBytes=0;
  long minSegmentBytes=Long.MAX_VALUE;
  for (  SegmentCommitInfo info : infosSorted) {
    final long segBytes=size(info,writer);
    if (verbose(writer)) {
      String extra=merging.contains(info) ? " [merging]" : "";
      if (segBytes >= maxMergedSegmentBytes / 2.0) {
        extra+=" [skip: too large]";
      }
 else       if (segBytes < floorSegmentBytes) {
        extra+=" [floored]";
      }
      message("  seg=" + writer.segString(info) + " size="+ String.format(Locale.ROOT,"%.3f",segBytes / 1024 / 1024.)+ " MB"+ extra,writer);
    }
    minSegmentBytes=Math.min(segBytes,minSegmentBytes);
    totIndexBytes+=segBytes;
  }
  int tooBigCount=0;
  while (tooBigCount < infosSorted.size() && size(infosSorted.get(tooBigCount),writer) >= maxMergedSegmentBytes / 2.0) {
    totIndexBytes-=size(infosSorted.get(tooBigCount),writer);
    tooBigCount++;
  }
  minSegmentBytes=floorSize(minSegmentBytes);
  long levelSize=minSegmentBytes;
  long bytesLeft=totIndexBytes;
  double allowedSegCount=0;
  while (true) {
    final double segCountLevel=bytesLeft / (double)levelSize;
    if (segCountLevel < segsPerTier) {
      allowedSegCount+=Math.ceil(segCountLevel);
      break;
    }
    allowedSegCount+=segsPerTier;
    bytesLeft-=segsPerTier * levelSize;
    levelSize*=maxMergeAtOnce;
  }
  int allowedSegCountInt=(int)allowedSegCount;
  MergeSpecification spec=null;
  while (true) {
    long mergingBytes=0;
    final List<SegmentCommitInfo> eligible=new ArrayList<>();
    for (int idx=tooBigCount; idx < infosSorted.size(); idx++) {
      final SegmentCommitInfo info=infosSorted.get(idx);
      if (merging.contains(info)) {
        mergingBytes+=info.sizeInBytes();
      }
 else       if (!toBeMerged.contains(info)) {
        eligible.add(info);
      }
    }
    final boolean maxMergeIsRunning=mergingBytes >= maxMergedSegmentBytes;
    if (verbose(writer)) {
      message("  allowedSegmentCount=" + allowedSegCountInt + " vs count="+ infosSorted.size()+ " (eligible count="+ eligible.size()+ ") tooBigCount="+ tooBigCount,writer);
    }
    if (eligible.size() == 0) {
      return spec;
    }
    if (eligible.size() > allowedSegCountInt) {
      MergeScore bestScore=null;
      List<SegmentCommitInfo> best=null;
      boolean bestTooLarge=false;
      long bestMergeBytes=0;
      for (int startIdx=0; startIdx <= eligible.size() - maxMergeAtOnce; startIdx++) {
        long totAfterMergeBytes=0;
        final List<SegmentCommitInfo> candidate=new ArrayList<>();
        boolean hitTooLarge=false;
        for (int idx=startIdx; idx < eligible.size() && candidate.size() < maxMergeAtOnce; idx++) {
          final SegmentCommitInfo info=eligible.get(idx);
          final long segBytes=size(info,writer);
          if (totAfterMergeBytes + segBytes > maxMergedSegmentBytes) {
            hitTooLarge=true;
            continue;
          }
          candidate.add(info);
          totAfterMergeBytes+=segBytes;
        }
        final MergeScore score=score(candidate,hitTooLarge,mergingBytes,writer);
        if (verbose(writer)) {
          message("  maybe=" + writer.segString(candidate) + " score="+ score.getScore()+ " "+ score.getExplanation()+ " tooLarge="+ hitTooLarge+ " size="+ String.format(Locale.ROOT,"%.3f MB",totAfterMergeBytes / 1024. / 1024.),writer);
        }
        if ((bestScore == null || score.getScore() < bestScore.getScore()) && (!hitTooLarge || !maxMergeIsRunning)) {
          best=candidate;
          bestScore=score;
          bestTooLarge=hitTooLarge;
          bestMergeBytes=totAfterMergeBytes;
        }
      }
      if (best != null) {
        if (spec == null) {
          spec=new MergeSpecification();
        }
        final OneMerge merge=new OneMerge(best);
        spec.add(merge);
        for (        SegmentCommitInfo info : merge.segments) {
          toBeMerged.add(info);
        }
        if (verbose(writer)) {
          message("  add merge=" + writer.segString(merge.segments) + " size="+ String.format(Locale.ROOT,"%.3f MB",bestMergeBytes / 1024. / 1024.)+ " score="+ String.format(Locale.ROOT,"%.3f",bestScore.getScore())+ " "+ bestScore.getExplanation()+ (bestTooLarge ? " [max merge]" : ""),writer);
        }
      }
 else {
        return spec;
      }
    }
 else {
      return spec;
    }
  }
}
