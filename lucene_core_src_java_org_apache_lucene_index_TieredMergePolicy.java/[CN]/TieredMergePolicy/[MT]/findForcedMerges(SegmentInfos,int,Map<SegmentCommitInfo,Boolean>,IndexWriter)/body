{
  if (verbose(writer)) {
    message("findForcedMerges maxSegmentCount=" + maxSegmentCount + " infos="+ writer.segString(infos)+ " segmentsToMerge="+ segmentsToMerge,writer);
  }
  List<SegmentCommitInfo> eligible=new ArrayList<>();
  boolean forceMergeRunning=false;
  final Collection<SegmentCommitInfo> merging=writer.getMergingSegments();
  boolean segmentIsOriginal=false;
  for (  SegmentCommitInfo info : infos) {
    final Boolean isOriginal=segmentsToMerge.get(info);
    if (isOriginal != null) {
      segmentIsOriginal=isOriginal;
      if (!merging.contains(info)) {
        eligible.add(info);
      }
 else {
        forceMergeRunning=true;
      }
    }
  }
  if (eligible.size() == 0) {
    return null;
  }
  if ((maxSegmentCount > 1 && eligible.size() <= maxSegmentCount) || (maxSegmentCount == 1 && eligible.size() == 1 && (!segmentIsOriginal || isMerged(infos,eligible.get(0),writer)))) {
    if (verbose(writer)) {
      message("already merged",writer);
    }
    return null;
  }
  Collections.sort(eligible,new SegmentByteSizeDescending(writer));
  if (verbose(writer)) {
    message("eligible=" + eligible,writer);
    message("forceMergeRunning=" + forceMergeRunning,writer);
  }
  int end=eligible.size();
  MergeSpecification spec=null;
  while (end >= maxMergeAtOnceExplicit + maxSegmentCount - 1) {
    if (spec == null) {
      spec=new MergeSpecification();
    }
    final OneMerge merge=new OneMerge(eligible.subList(end - maxMergeAtOnceExplicit,end));
    if (verbose(writer)) {
      message("add merge=" + writer.segString(merge.segments),writer);
    }
    spec.add(merge);
    end-=maxMergeAtOnceExplicit;
  }
  if (spec == null && !forceMergeRunning) {
    final int numToMerge=end - maxSegmentCount + 1;
    final OneMerge merge=new OneMerge(eligible.subList(end - numToMerge,end));
    if (verbose(writer)) {
      message("add final merge=" + merge.segString(),writer);
    }
    spec=new MergeSpecification();
    spec.add(merge);
  }
  return spec;
}
