{
  TaxonomyWriter taxonomy=null;
  taxonomy=new LuceneTaxonomyWriter(new RAMDirectory());
  CategoryPath[] topLevelPaths=new CategoryPath[10];
  String[] topLevelStrings=new String[10];
  for (int i=0; i < 10; i++) {
    topLevelStrings[i]=Integer.valueOf(random.nextInt(30)).toString();
    topLevelPaths[i]=new CategoryPath(topLevelStrings[i]);
    taxonomy.addCategory(topLevelPaths[i]);
  }
  CategoryPath[] nonTopLevelPaths=new CategoryPath[300];
  for (int i=0; i < 300; i++) {
    int nComponents=2 + random.nextInt(10);
    String[] components=new String[nComponents];
    components[0]=topLevelStrings[i % 10];
    for (int j=1; j < components.length; j++) {
      components[j]=(Integer.valueOf(random.nextInt(30))).toString();
    }
    nonTopLevelPaths[i]=new CategoryPath(components);
    taxonomy.addCategory(nonTopLevelPaths[i]);
  }
  PathPolicy pathPolicy=new NonTopLevelPathPolicy();
  assertFalse("top level path policy should not match root",pathPolicy.shouldAdd(new CategoryPath()));
  for (int i=0; i < 10; i++) {
    assertFalse("top level path policy should not match " + topLevelPaths[i],pathPolicy.shouldAdd(topLevelPaths[i]));
  }
  for (int i=0; i < 300; i++) {
    assertTrue("top level path policy should match " + nonTopLevelPaths[i],pathPolicy.shouldAdd(nonTopLevelPaths[i]));
  }
}
