{
  meta.writeVInt(field.number);
  meta.writeByte(BYTES);
  int minLength=Integer.MAX_VALUE;
  int maxLength=Integer.MIN_VALUE;
  final long startFP=data.getFilePointer();
  boolean missing=false;
  int upto=0;
  for (  BytesRef v : values) {
    final int length;
    if (v == null) {
      length=0;
      missing=true;
    }
 else {
      length=v.length;
    }
    if (length > MemoryDocValuesFormat.MAX_BINARY_FIELD_LENGTH) {
      throw new IllegalArgumentException("DocValuesField \"" + field.name + "\" is too large, must be <= "+ MemoryDocValuesFormat.MAX_BINARY_FIELD_LENGTH+ " but got length="+ length+ " v="+ v+ "; upto="+ upto+ " values="+ values);
    }
    upto++;
    minLength=Math.min(minLength,length);
    maxLength=Math.max(maxLength,length);
    if (v != null) {
      data.writeBytes(v.bytes,v.offset,v.length);
    }
  }
  meta.writeLong(startFP);
  meta.writeLong(data.getFilePointer() - startFP);
  if (missing) {
    long start=data.getFilePointer();
    writeMissingBitset(values);
    meta.writeLong(start);
    meta.writeLong(data.getFilePointer() - start);
  }
 else {
    meta.writeLong(-1L);
  }
  meta.writeVInt(minLength);
  meta.writeVInt(maxLength);
  if (minLength != maxLength) {
    meta.writeVInt(PackedInts.VERSION_CURRENT);
    meta.writeVInt(BLOCK_SIZE);
    final MonotonicBlockPackedWriter writer=new MonotonicBlockPackedWriter(data,BLOCK_SIZE);
    long addr=0;
    for (    BytesRef v : values) {
      if (v != null) {
        addr+=v.length;
      }
      writer.add(addr);
    }
    writer.finish();
  }
}
