{
  final double LONGITUDE_DECODE=360.0D / (0x1L << 32);
  Random random=random();
  for (int i=0; i < 10000; i++) {
    int encoded=random.nextInt();
    double min=MIN_LON_INCL + (encoded - (long)Integer.MIN_VALUE) * LONGITUDE_DECODE;
    double decoded=decodeLongitude(encoded);
    assertEquals(min,decoded,0.0D);
    assertEquals(encoded,encodeLongitude(decoded));
    assertEquals(encoded,encodeLongitudeCeil(decoded));
    if (i != Integer.MAX_VALUE) {
      double max=min + LONGITUDE_DECODE;
      assertEquals(max,decodeLongitude(encoded + 1),0.0D);
      assertEquals(encoded + 1,encodeLongitude(max));
      assertEquals(encoded + 1,encodeLongitudeCeil(max));
      double minEdge=Math.nextUp(min);
      double maxEdge=Math.nextDown(max);
      assertEquals(encoded,encodeLongitude(minEdge));
      assertEquals(encoded + 1,encodeLongitudeCeil(minEdge));
      assertEquals(encoded,encodeLongitude(maxEdge));
      assertEquals(encoded + 1,encodeLongitudeCeil(maxEdge));
      long minBits=NumericUtils.doubleToSortableLong(minEdge);
      long maxBits=NumericUtils.doubleToSortableLong(maxEdge);
      for (int j=0; j < 100; j++) {
        double value=NumericUtils.sortableLongToDouble(TestUtil.nextLong(random,minBits,maxBits));
        assertEquals(encoded,encodeLongitude(value));
        assertEquals(encoded + 1,encodeLongitudeCeil(value));
      }
    }
  }
}
