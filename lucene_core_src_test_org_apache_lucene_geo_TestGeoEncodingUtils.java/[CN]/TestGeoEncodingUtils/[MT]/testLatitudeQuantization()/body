{
  final double LATITUDE_DECODE=180.0D / (0x1L << 32);
  Random random=random();
  for (int i=0; i < 10000; i++) {
    int encoded=random.nextInt();
    double min=MIN_LAT_INCL + (encoded - (long)Integer.MIN_VALUE) * LATITUDE_DECODE;
    double decoded=decodeLatitude(encoded);
    assertEquals(min,decoded,0.0D);
    assertEquals(encoded,encodeLatitude(decoded));
    assertEquals(encoded,encodeLatitudeCeil(decoded));
    if (encoded != Integer.MAX_VALUE) {
      double max=min + LATITUDE_DECODE;
      assertEquals(max,decodeLatitude(encoded + 1),0.0D);
      assertEquals(encoded + 1,encodeLatitude(max));
      assertEquals(encoded + 1,encodeLatitudeCeil(max));
      double minEdge=Math.nextUp(min);
      double maxEdge=Math.nextDown(max);
      assertEquals(encoded,encodeLatitude(minEdge));
      assertEquals(encoded + 1,encodeLatitudeCeil(minEdge));
      assertEquals(encoded,encodeLatitude(maxEdge));
      assertEquals(encoded + 1,encodeLatitudeCeil(maxEdge));
      long minBits=NumericUtils.doubleToSortableLong(minEdge);
      long maxBits=NumericUtils.doubleToSortableLong(maxEdge);
      for (int j=0; j < 100; j++) {
        double value=NumericUtils.sortableLongToDouble(TestUtil.nextLong(random,minBits,maxBits));
        assertEquals(encoded,encodeLatitude(value));
        assertEquals(encoded + 1,encodeLatitudeCeil(value));
      }
    }
  }
}
