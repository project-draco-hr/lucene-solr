{
  final HitQueue hq=new HitQueue(nDocs,false);
  final Lock lock=new ReentrantLock();
  @SuppressWarnings("unchecked") final Future<TopDocs>[] searchThreads=new Future[searchables.length];
  for (int i=0; i < searchables.length; i++) {
    searchThreads[i]=executor.submit(new MultiSearcherCallableNoSort(lock,searchables[i],weight,filter,nDocs,hq,i,starts));
  }
  final CountTotalHits<TopDocs> func=new CountTotalHits<TopDocs>();
  foreach(func,Arrays.asList(searchThreads));
  final ScoreDoc[] scoreDocs=new ScoreDoc[hq.size()];
  for (int i=hq.size() - 1; i >= 0; i--)   scoreDocs[i]=hq.pop();
  return new TopDocs(func.totalHits,scoreDocs,func.maxScore);
}
