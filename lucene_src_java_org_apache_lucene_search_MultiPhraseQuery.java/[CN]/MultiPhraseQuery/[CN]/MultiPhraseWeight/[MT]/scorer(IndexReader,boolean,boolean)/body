{
  if (termArrays.size() == 0)   return null;
  final Bits delDocs=MultiFields.getDeletedDocs(reader);
  PhraseQuery.PostingsAndFreq[] postingsFreqs=new PhraseQuery.PostingsAndFreq[termArrays.size()];
  for (int pos=0; pos < postingsFreqs.length; pos++) {
    Term[] terms=termArrays.get(pos);
    final DocsAndPositionsEnum postingsEnum;
    int docFreq;
    if (terms.length > 1) {
      postingsEnum=new UnionDocsAndPositionsEnum(reader,terms);
      docFreq=0;
      for (int termIdx=0; termIdx < terms.length; termIdx++) {
        docFreq+=reader.docFreq(terms[termIdx]);
      }
    }
 else {
      final BytesRef text=new BytesRef(terms[0].text());
      postingsEnum=reader.termPositionsEnum(delDocs,terms[0].field(),text);
      if (postingsEnum == null) {
        if (MultiFields.getTermDocsEnum(reader,delDocs,terms[0].field(),text) != null) {
          throw new IllegalStateException("field \"" + terms[0].field() + "\" was indexed with Field.omitTermFreqAndPositions=true; cannot run PhraseQuery (term="+ terms[0].text()+ ")");
        }
 else {
          return null;
        }
      }
      docFreq=reader.docFreq(terms[0].field(),text);
    }
    postingsFreqs[pos]=new PhraseQuery.PostingsAndFreq(postingsEnum,docFreq,positions.get(pos).intValue());
  }
  if (slop == 0) {
    Arrays.sort(postingsFreqs);
  }
  if (slop == 0) {
    ExactPhraseScorer s=new ExactPhraseScorer(this,postingsFreqs,similarity,reader.norms(field));
    if (s.noDocs) {
      return null;
    }
 else {
      return s;
    }
  }
 else {
    return new SloppyPhraseScorer(this,postingsFreqs,similarity,slop,reader.norms(field));
  }
}
