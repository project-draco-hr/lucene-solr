{
  final double radLat=TO_RADIANS * centerLat;
  final double radLon=TO_RADIANS * centerLon;
  double radDistance=radiusMeters / GeoProjectionUtils.SEMIMAJOR_AXIS;
  double minLat=radLat - radDistance;
  double maxLat=radLat + radDistance;
  double minLon;
  double maxLon;
  if (minLat > GeoProjectionUtils.MIN_LAT_RADIANS && maxLat < GeoProjectionUtils.MAX_LAT_RADIANS) {
    double deltaLon=SloppyMath.asin(SloppyMath.sin(radDistance) / SloppyMath.cos(radLat));
    minLon=radLon - deltaLon;
    if (minLon < GeoProjectionUtils.MIN_LON_RADIANS) {
      minLon+=2d * StrictMath.PI;
    }
    maxLon=radLon + deltaLon;
    if (maxLon > GeoProjectionUtils.MAX_LON_RADIANS) {
      maxLon-=2d * StrictMath.PI;
    }
  }
 else {
    minLat=StrictMath.max(minLat,GeoProjectionUtils.MIN_LAT_RADIANS);
    maxLat=StrictMath.min(maxLat,GeoProjectionUtils.MAX_LAT_RADIANS);
    minLon=GeoProjectionUtils.MIN_LON_RADIANS;
    maxLon=GeoProjectionUtils.MAX_LON_RADIANS;
  }
  return new GeoRect(TO_DEGREES * minLon,TO_DEGREES * maxLon,TO_DEGREES * minLat,TO_DEGREES * maxLat);
}
