{
  final double radLat=StrictMath.toRadians(centerLat);
  final double radLon=StrictMath.toRadians(centerLon);
  double radDistance=radiusMeters / GeoProjectionUtils.SEMIMAJOR_AXIS;
  double minLat=radLat - radDistance;
  double maxLat=radLat + radDistance;
  double minLon;
  double maxLon;
  if (minLat > GeoProjectionUtils.MIN_LAT_RADIANS && maxLat < GeoProjectionUtils.MAX_LAT_RADIANS) {
    double deltaLon=StrictMath.asin(StrictMath.sin(radDistance) / StrictMath.cos(radLat));
    minLon=radLon - deltaLon;
    if (minLon < GeoProjectionUtils.MIN_LON_RADIANS) {
      minLon+=2d * StrictMath.PI;
    }
    maxLon=radLon + deltaLon;
    if (maxLon > GeoProjectionUtils.MAX_LON_RADIANS) {
      maxLon-=2d * StrictMath.PI;
    }
  }
 else {
    minLat=StrictMath.max(minLat,GeoProjectionUtils.MIN_LAT_RADIANS);
    maxLat=StrictMath.min(maxLat,GeoProjectionUtils.MAX_LAT_RADIANS);
    minLon=GeoProjectionUtils.MIN_LON_RADIANS;
    maxLon=GeoProjectionUtils.MAX_LON_RADIANS;
  }
  return new GeoRect(StrictMath.toDegrees(minLon),StrictMath.toDegrees(maxLon),StrictMath.toDegrees(minLat),StrictMath.toDegrees(maxLat));
}
