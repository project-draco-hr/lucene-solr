{
  lon=StrictMath.toRadians(lon);
  lat=StrictMath.toRadians(lat);
  final double sl=StrictMath.sin(lat);
  final double s2=sl * sl;
  final double cl=StrictMath.cos(lat);
  final double ge2=(SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / (SEMIMAJOR_AXIS2);
  if (ecf == null)   ecf=new double[3];
  if (lat < -PI_OVER_2 && lat > -1.001D * PI_OVER_2) {
    lat=-PI_OVER_2;
  }
 else   if (lat > PI_OVER_2 && lat < 1.001D * PI_OVER_2) {
    lat=PI_OVER_2;
  }
  assert((lat >= -PI_OVER_2) || (lat <= PI_OVER_2));
  if (lon > StrictMath.PI) {
    lon-=(2 * StrictMath.PI);
  }
  final double rn=SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - ge2 * s2);
  ecf[0]=(rn + alt) * cl * StrictMath.cos(lon);
  ecf[1]=(rn + alt) * cl * StrictMath.sin(lon);
  ecf[2]=((rn * (1.0 - ge2)) + alt) * sl;
  return ecf;
}
