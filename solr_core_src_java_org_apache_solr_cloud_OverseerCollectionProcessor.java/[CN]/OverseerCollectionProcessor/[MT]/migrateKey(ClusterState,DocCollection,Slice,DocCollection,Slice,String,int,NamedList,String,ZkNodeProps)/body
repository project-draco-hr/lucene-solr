{
  String tempSourceCollectionName="split_" + sourceSlice.getName() + "_temp_"+ targetSlice.getName();
  if (clusterState.hasCollection(tempSourceCollectionName)) {
    log.info("Deleting temporary collection: " + tempSourceCollectionName);
    Map<String,Object> props=ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION,DELETE.toLower(),NAME,tempSourceCollectionName);
    try {
      deleteCollection(new ZkNodeProps(props),results);
      clusterState=zkStateReader.getClusterState();
    }
 catch (    Exception e) {
      log.warn("Unable to clean up existing temporary collection: " + tempSourceCollectionName,e);
    }
  }
  CompositeIdRouter sourceRouter=(CompositeIdRouter)sourceCollection.getRouter();
  DocRouter.Range keyHashRange=sourceRouter.keyHashRange(splitKey);
  ShardHandler shardHandler=shardHandlerFactory.getShardHandler();
  log.info("Hash range for split.key: {} is: {}",splitKey,keyHashRange);
  DocRouter.Range splitRange=intersect(targetSlice.getRange(),intersect(sourceSlice.getRange(),keyHashRange));
  if (splitRange == null) {
    log.info("No common hashes between source shard: {} and target shard: {}",sourceSlice.getName(),targetSlice.getName());
    return;
  }
  log.info("Common hash range between source shard: {} and target shard: {} = " + splitRange,sourceSlice.getName(),targetSlice.getName());
  Replica targetLeader=zkStateReader.getLeaderRetry(targetCollection.getName(),targetSlice.getName(),10000);
  HashMap<String,String> requestMap=new HashMap<String,String>();
  log.info("Asking target leader node: " + targetLeader.getNodeName() + " core: "+ targetLeader.getStr("core")+ " to buffer updates");
  ModifiableSolrParams params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminAction.REQUESTBUFFERUPDATES.toString());
  params.set(CoreAdminParams.NAME,targetLeader.getStr("core"));
  String nodeName=targetLeader.getNodeName();
  sendShardRequest(targetLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  collectShardResponses(results,true,"MIGRATE failed to request node to buffer updates",shardHandler);
  completeAsyncRequest(asyncId,requestMap,results);
  ZkNodeProps m=new ZkNodeProps(Overseer.QUEUE_OPERATION,OverseerAction.ADDROUTINGRULE.toLower(),COLLECTION_PROP,sourceCollection.getName(),SHARD_ID_PROP,sourceSlice.getName(),"routeKey",SolrIndexSplitter.getRouteKey(splitKey) + "!","range",splitRange.toString(),"targetCollection",targetCollection.getName(),"expireAt",String.valueOf(System.currentTimeMillis() + timeout));
  log.info("Adding routing rule: " + m);
  Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));
  log.info("Waiting to see routing rule updated in clusterstate");
  long waitUntil=System.nanoTime() + TimeUnit.NANOSECONDS.convert(60,TimeUnit.SECONDS);
  boolean added=false;
  while (System.nanoTime() < waitUntil) {
    Thread.sleep(100);
    Map<String,RoutingRule> rules=zkStateReader.getClusterState().getSlice(sourceCollection.getName(),sourceSlice.getName()).getRoutingRules();
    if (rules != null) {
      RoutingRule rule=rules.get(SolrIndexSplitter.getRouteKey(splitKey) + "!");
      if (rule != null && rule.getRouteRanges().contains(splitRange)) {
        added=true;
        break;
      }
    }
  }
  if (!added) {
    throw new SolrException(ErrorCode.SERVER_ERROR,"Could not add routing rule: " + m);
  }
  log.info("Routing rule added successfully");
  Replica sourceLeader=zkStateReader.getLeaderRetry(sourceCollection.getName(),sourceSlice.getName(),10000);
  String configName=zkStateReader.readConfigName(sourceCollection.getName());
  Map<String,Object> props=ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION,CREATE.toLower(),NAME,tempSourceCollectionName,ZkStateReader.REPLICATION_FACTOR,1,NUM_SLICES,1,COLL_CONF,configName,CREATE_NODE_SET,sourceLeader.getNodeName());
  if (asyncId != null) {
    String internalAsyncId=asyncId + Math.abs(System.nanoTime());
    props.put(ASYNC,internalAsyncId);
  }
  log.info("Creating temporary collection: " + props);
  createCollection(clusterState,new ZkNodeProps(props),results);
  clusterState=zkStateReader.getClusterState();
  Slice tempSourceSlice=clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();
  Replica tempSourceLeader=zkStateReader.getLeaderRetry(tempSourceCollectionName,tempSourceSlice.getName(),120000);
  String tempCollectionReplica1=tempSourceCollectionName + "_" + tempSourceSlice.getName()+ "_replica1";
  String coreNodeName=waitForCoreNodeName(tempSourceCollectionName,sourceLeader.getNodeName(),tempCollectionReplica1);
  log.info("Asking source leader to wait for: " + tempCollectionReplica1 + " to be alive on: "+ sourceLeader.getNodeName());
  CoreAdminRequest.WaitForState cmd=new CoreAdminRequest.WaitForState();
  cmd.setCoreName(tempCollectionReplica1);
  cmd.setNodeName(sourceLeader.getNodeName());
  cmd.setCoreNodeName(coreNodeName);
  cmd.setState(ZkStateReader.ACTIVE);
  cmd.setCheckLive(true);
  cmd.setOnlyIfLeader(true);
  sendShardRequest(tempSourceLeader.getNodeName(),new ModifiableSolrParams(cmd.getParams()),shardHandler,null,null);
  collectShardResponses(results,true,"MIGRATE failed to create temp collection leader or timed out waiting for it to come up",shardHandler);
  log.info("Asking source leader to split index");
  params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminAction.SPLIT.toString());
  params.set(CoreAdminParams.CORE,sourceLeader.getStr("core"));
  params.add(CoreAdminParams.TARGET_CORE,tempSourceLeader.getStr("core"));
  params.set(CoreAdminParams.RANGES,splitRange.toString());
  params.set("split.key",splitKey);
  String tempNodeName=sourceLeader.getNodeName();
  sendShardRequest(tempNodeName,params,shardHandler,asyncId,requestMap);
  collectShardResponses(results,true,"MIGRATE failed to invoke SPLIT core admin command",shardHandler);
  completeAsyncRequest(asyncId,requestMap,results);
  log.info("Creating a replica of temporary collection: {} on the target leader node: {}",tempSourceCollectionName,targetLeader.getNodeName());
  String tempCollectionReplica2=tempSourceCollectionName + "_" + tempSourceSlice.getName()+ "_replica2";
  props=new HashMap<>();
  props.put(Overseer.QUEUE_OPERATION,ADDREPLICA.toLower());
  props.put(COLLECTION_PROP,tempSourceCollectionName);
  props.put(SHARD_ID_PROP,tempSourceSlice.getName());
  props.put("node",targetLeader.getNodeName());
  props.put(CoreAdminParams.NAME,tempCollectionReplica2);
  for (  String key : message.keySet()) {
    if (key.startsWith(COLL_PROP_PREFIX)) {
      props.put(key,message.getStr(key));
    }
  }
  if (asyncId != null) {
    props.put(ASYNC,asyncId);
  }
  addReplica(clusterState,new ZkNodeProps(props),results);
  collectShardResponses(results,true,"MIGRATE failed to create replica of temporary collection in target leader node.",shardHandler);
  completeAsyncRequest(asyncId,requestMap,results);
  coreNodeName=waitForCoreNodeName(tempSourceCollectionName,targetLeader.getNodeName(),tempCollectionReplica2);
  log.info("Asking temp source leader to wait for: " + tempCollectionReplica2 + " to be alive on: "+ targetLeader.getNodeName());
  cmd=new CoreAdminRequest.WaitForState();
  cmd.setCoreName(tempSourceLeader.getStr("core"));
  cmd.setNodeName(targetLeader.getNodeName());
  cmd.setCoreNodeName(coreNodeName);
  cmd.setState(ZkStateReader.ACTIVE);
  cmd.setCheckLive(true);
  cmd.setOnlyIfLeader(true);
  params=new ModifiableSolrParams(cmd.getParams());
  sendShardRequest(tempSourceLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  collectShardResponses(results,true,"MIGRATE failed to create temp collection replica or timed out waiting for them to come up",shardHandler);
  completeAsyncRequest(asyncId,requestMap,results);
  log.info("Successfully created replica of temp source collection on target leader node");
  log.info("Requesting merge of temp source collection replica to target leader");
  params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminAction.MERGEINDEXES.toString());
  params.set(CoreAdminParams.CORE,targetLeader.getStr("core"));
  params.set(CoreAdminParams.SRC_CORE,tempCollectionReplica2);
  sendShardRequest(targetLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  collectShardResponses(results,true,"MIGRATE failed to merge " + tempCollectionReplica2 + " to "+ targetLeader.getStr("core")+ " on node: "+ targetLeader.getNodeName(),shardHandler);
  completeAsyncRequest(asyncId,requestMap,results);
  log.info("Asking target leader to apply buffered updates");
  params=new ModifiableSolrParams();
  params.set(CoreAdminParams.ACTION,CoreAdminAction.REQUESTAPPLYUPDATES.toString());
  params.set(CoreAdminParams.NAME,targetLeader.getStr("core"));
  sendShardRequest(targetLeader.getNodeName(),params,shardHandler,asyncId,requestMap);
  collectShardResponses(results,true,"MIGRATE failed to request node to apply buffered updates",shardHandler);
  completeAsyncRequest(asyncId,requestMap,results);
  try {
    log.info("Deleting temporary collection: " + tempSourceCollectionName);
    props=ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION,DELETE.toLower(),NAME,tempSourceCollectionName);
    deleteCollection(new ZkNodeProps(props),results);
  }
 catch (  Exception e) {
    log.error("Unable to delete temporary collection: " + tempSourceCollectionName + ". Please remove it manually",e);
  }
}
