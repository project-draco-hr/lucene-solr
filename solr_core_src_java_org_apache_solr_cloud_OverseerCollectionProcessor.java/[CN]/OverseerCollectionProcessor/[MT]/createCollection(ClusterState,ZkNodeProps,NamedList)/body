{
  String collectionName=message.getStr("name");
  if (clusterState.hasCollection(collectionName)) {
    throw new SolrException(ErrorCode.BAD_REQUEST,"collection already exists: " + collectionName);
  }
  String configName=getConfigName(collectionName,message);
  if (configName == null) {
    throw new SolrException(ErrorCode.BAD_REQUEST,"No config set found to associate with the collection.");
  }
 else   if (!validateConfig(configName)) {
    throw new SolrException(ErrorCode.BAD_REQUEST,"Can not find the specified config set: " + configName);
  }
  try {
    int repFactor=message.getInt(ZkStateReader.REPLICATION_FACTOR,1);
    ShardHandler shardHandler=shardHandlerFactory.getShardHandler();
    String async=null;
    async=message.getStr("async");
    Integer numSlices=message.getInt(NUM_SLICES,null);
    String router=message.getStr("router.name",DocRouter.DEFAULT_NAME);
    List<String> shardNames=new ArrayList<>();
    if (ImplicitDocRouter.NAME.equals(router)) {
      ClusterStateMutator.getShardNames(shardNames,message.getStr("shards",null));
      numSlices=shardNames.size();
    }
 else {
      ClusterStateMutator.getShardNames(numSlices,shardNames);
    }
    if (numSlices == null) {
      throw new SolrException(ErrorCode.BAD_REQUEST,NUM_SLICES + " is a required param (when using CompositeId router).");
    }
    int maxShardsPerNode=message.getInt(ZkStateReader.MAX_SHARDS_PER_NODE,1);
    if (repFactor <= 0) {
      throw new SolrException(ErrorCode.BAD_REQUEST,ZkStateReader.REPLICATION_FACTOR + " must be greater than 0");
    }
    if (numSlices <= 0) {
      throw new SolrException(ErrorCode.BAD_REQUEST,NUM_SLICES + " must be > 0");
    }
    final List<String> nodeList=getLiveOrLiveAndCreateNodeSetList(clusterState.getLiveNodes(),message,RANDOM);
    if (repFactor > nodeList.size()) {
      log.warn("Specified " + ZkStateReader.REPLICATION_FACTOR + " of "+ repFactor+ " on collection "+ collectionName+ " is higher than or equal to the number of Solr instances currently live or live and part of your "+ CREATE_NODE_SET+ "("+ nodeList.size()+ "). It's unusual to run two replica of the same slice on the same Solr-instance.");
    }
    int maxShardsAllowedToCreate=maxShardsPerNode * nodeList.size();
    int requestedShardsToCreate=numSlices * repFactor;
    if (maxShardsAllowedToCreate < requestedShardsToCreate) {
      throw new SolrException(ErrorCode.BAD_REQUEST,"Cannot create collection " + collectionName + ". Value of "+ ZkStateReader.MAX_SHARDS_PER_NODE+ " is "+ maxShardsPerNode+ ", and the number of nodes currently live or live and part of your "+ CREATE_NODE_SET+ " is "+ nodeList.size()+ ". This allows a maximum of "+ maxShardsAllowedToCreate+ " to be created. Value of "+ NUM_SLICES+ " is "+ numSlices+ " and value of "+ ZkStateReader.REPLICATION_FACTOR+ " is "+ repFactor+ ". This requires "+ requestedShardsToCreate+ " shards to be created (higher than the allowed number)");
    }
    boolean isLegacyCloud=Overseer.isLegacy(zkStateReader.getClusterProps());
    createConfNode(configName,collectionName,isLegacyCloud);
    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));
    long waitUntil=System.nanoTime() + TimeUnit.NANOSECONDS.convert(30,TimeUnit.SECONDS);
    boolean created=false;
    while (System.nanoTime() < waitUntil) {
      Thread.sleep(100);
      created=zkStateReader.getClusterState().getCollections().contains(message.getStr("name"));
      if (created)       break;
    }
    if (!created)     throw new SolrException(ErrorCode.SERVER_ERROR,"Could not fully create collection: " + message.getStr("name"));
    HashMap<String,String> requestMap=new HashMap<String,String>();
    log.info("Creating SolrCores for new collection {}, shardNames {} , replicationFactor : {}",collectionName,shardNames,repFactor);
    Map<String,ShardRequest> coresToCreate=new LinkedHashMap<>();
    for (int i=1; i <= shardNames.size(); i++) {
      String sliceName=shardNames.get(i - 1);
      for (int j=1; j <= repFactor; j++) {
        String nodeName=nodeList.get((repFactor * (i - 1) + (j - 1)) % nodeList.size());
        String coreName=collectionName + "_" + sliceName+ "_replica"+ j;
        log.info("Creating shard " + coreName + " as part of slice "+ sliceName+ " of collection "+ collectionName+ " on "+ nodeName);
        String baseUrl=zkStateReader.getBaseUrlForNodeName(nodeName);
        if (!isLegacyCloud) {
          ZkNodeProps props=new ZkNodeProps(Overseer.QUEUE_OPERATION,ADDREPLICA.toString(),ZkStateReader.COLLECTION_PROP,collectionName,ZkStateReader.SHARD_ID_PROP,sliceName,ZkStateReader.CORE_NAME_PROP,coreName,ZkStateReader.STATE_PROP,ZkStateReader.DOWN,ZkStateReader.BASE_URL_PROP,baseUrl);
          Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(props));
        }
        ModifiableSolrParams params=new ModifiableSolrParams();
        params.set(CoreAdminParams.ACTION,CoreAdminAction.CREATE.toString());
        params.set(CoreAdminParams.NAME,coreName);
        params.set(COLL_CONF,configName);
        params.set(CoreAdminParams.COLLECTION,collectionName);
        params.set(CoreAdminParams.SHARD,sliceName);
        params.set(ZkStateReader.NUM_SHARDS_PROP,numSlices);
        setupAsyncRequest(async,requestMap,params,nodeName);
        addPropertyParams(message,params);
        ShardRequest sreq=new ShardRequest();
        params.set("qt",adminPath);
        sreq.purpose=1;
        sreq.shards=new String[]{baseUrl};
        sreq.actualShards=sreq.shards;
        sreq.params=params;
        if (isLegacyCloud) {
          shardHandler.submit(sreq,sreq.shards[0],sreq.params);
        }
 else {
          coresToCreate.put(coreName,sreq);
        }
      }
    }
    if (!isLegacyCloud) {
      Map<String,Replica> replicas=waitToSeeReplicasInState(collectionName,coresToCreate.keySet());
      for (      Map.Entry<String,ShardRequest> e : coresToCreate.entrySet()) {
        ShardRequest sreq=e.getValue();
        sreq.params.set(CoreAdminParams.CORE_NODE_NAME,replicas.get(e.getKey()).getName());
        shardHandler.submit(sreq,sreq.shards[0],sreq.params);
      }
    }
    processResponses(results,shardHandler);
    completeAsyncRequest(async,requestMap,results);
    log.info("Finished create command on all shards for collection: " + collectionName);
  }
 catch (  SolrException ex) {
    throw ex;
  }
catch (  Exception ex) {
    throw new SolrException(ErrorCode.SERVER_ERROR,null,ex);
  }
}
