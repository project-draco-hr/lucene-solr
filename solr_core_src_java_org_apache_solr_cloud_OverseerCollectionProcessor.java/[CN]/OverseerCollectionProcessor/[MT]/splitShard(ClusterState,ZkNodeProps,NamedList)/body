{
  log.info("Split shard invoked");
  String collectionName=message.getStr("collection");
  String slice=message.getStr(ZkStateReader.SHARD_ID_PROP);
  Slice parentSlice=clusterState.getSlice(collectionName,slice);
  if (parentSlice == null) {
    if (clusterState.getCollections().contains(collectionName)) {
      throw new SolrException(ErrorCode.BAD_REQUEST,"No shard with the specified name exists: " + slice);
    }
 else {
      throw new SolrException(ErrorCode.BAD_REQUEST,"No collection with the specified name exists: " + collectionName);
    }
  }
  Replica parentShardLeader=clusterState.getLeader(collectionName,slice);
  DocCollection collection=clusterState.getCollection(collectionName);
  DocRouter router=collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;
  DocRouter.Range range=parentSlice.getRange();
  if (range == null) {
    range=new PlainIdRouter().fullRange();
  }
  List<DocRouter.Range> subRanges=null;
  String rangesStr=message.getStr(CoreAdminParams.RANGES);
  if (rangesStr != null) {
    String[] ranges=rangesStr.split(",");
    if (ranges.length == 0 || ranges.length == 1) {
      throw new SolrException(ErrorCode.BAD_REQUEST,"There must be at least two ranges specified to split a shard");
    }
 else {
      subRanges=new ArrayList<DocRouter.Range>(ranges.length);
      for (int i=0; i < ranges.length; i++) {
        String r=ranges[i];
        try {
          subRanges.add(DocRouter.DEFAULT.fromString(r));
        }
 catch (        Exception e) {
          throw new SolrException(ErrorCode.BAD_REQUEST,"Exception in parsing hexadecimal hash range: " + r,e);
        }
        if (!subRanges.get(i).isSubsetOf(range)) {
          throw new SolrException(ErrorCode.BAD_REQUEST,"Specified hash range: " + r + " is not a subset of parent shard's range: "+ range.toString());
        }
      }
    }
  }
 else {
    subRanges=router.partitionRange(2,range);
  }
  try {
    List<String> subSlices=new ArrayList<String>(subRanges.size());
    List<String> subShardNames=new ArrayList<String>(subRanges.size());
    String nodeName=parentShardLeader.getNodeName();
    for (int i=0; i < subRanges.size(); i++) {
      String subSlice=slice + "_" + i;
      subSlices.add(subSlice);
      String subShardName=collectionName + "_" + subSlice+ "_replica1";
      subShardNames.add(subShardName);
      Slice oSlice=clusterState.getSlice(collectionName,subSlice);
      if (oSlice != null) {
        if (Slice.ACTIVE.equals(oSlice.getState())) {
          throw new SolrException(ErrorCode.BAD_REQUEST,"Sub-shard: " + subSlice + " exists in active state. Aborting split shard.");
        }
 else         if (Slice.CONSTRUCTION.equals(oSlice.getState())) {
          for (          Replica replica : oSlice.getReplicas()) {
            if (clusterState.liveNodesContain(replica.getNodeName())) {
              String core=replica.getStr("core");
              log.info("Unloading core: " + core + " from node: "+ replica.getNodeName());
              ModifiableSolrParams params=new ModifiableSolrParams();
              params.set(CoreAdminParams.ACTION,CoreAdminAction.UNLOAD.toString());
              params.set(CoreAdminParams.CORE,core);
              params.set(CoreAdminParams.DELETE_INDEX,"true");
              sendShardRequest(replica.getNodeName(),params);
            }
 else {
              log.warn("Replica {} exists in shard {} but is not live and cannot be unloaded",replica,oSlice);
            }
          }
        }
      }
    }
    collectShardResponses(results,false,null);
    for (int i=0; i < subRanges.size(); i++) {
      String subSlice=subSlices.get(i);
      String subShardName=subShardNames.get(i);
      DocRouter.Range subRange=subRanges.get(i);
      log.info("Creating shard " + subShardName + " as part of slice "+ subSlice+ " of collection "+ collectionName+ " on "+ nodeName);
      ModifiableSolrParams params=new ModifiableSolrParams();
      params.set(CoreAdminParams.ACTION,CoreAdminAction.CREATE.toString());
      params.set(CoreAdminParams.NAME,subShardName);
      params.set(CoreAdminParams.COLLECTION,collectionName);
      params.set(CoreAdminParams.SHARD,subSlice);
      params.set(CoreAdminParams.SHARD_RANGE,subRange.toString());
      params.set(CoreAdminParams.SHARD_STATE,Slice.CONSTRUCTION);
      sendShardRequest(nodeName,params);
    }
    collectShardResponses(results,true,"SPLTSHARD failed to create subshard leaders");
    for (    String subShardName : subShardNames) {
      log.info("Asking parent leader to wait for: " + subShardName + " to be alive on: "+ nodeName);
      String coreNodeName=waitForCoreNodeName(collection,zkStateReader.getZkClient().getBaseUrlForNodeName(nodeName),subShardName);
      CoreAdminRequest.WaitForState cmd=new CoreAdminRequest.WaitForState();
      cmd.setCoreName(subShardName);
      cmd.setNodeName(nodeName);
      cmd.setCoreNodeName(coreNodeName);
      cmd.setState(ZkStateReader.ACTIVE);
      cmd.setCheckLive(true);
      cmd.setOnlyIfLeader(true);
      sendShardRequest(nodeName,new ModifiableSolrParams(cmd.getParams()));
    }
    collectShardResponses(results,true,"SPLTSHARD timed out waiting for subshard leaders to come up");
    log.info("Successfully created all sub-shards for collection " + collectionName + " parent shard: "+ slice+ " on: "+ parentShardLeader);
    log.info("Splitting shard " + parentShardLeader.getName() + " as part of slice "+ slice+ " of collection "+ collectionName+ " on "+ parentShardLeader);
    ModifiableSolrParams params=new ModifiableSolrParams();
    params.set(CoreAdminParams.ACTION,CoreAdminAction.SPLIT.toString());
    params.set(CoreAdminParams.CORE,parentShardLeader.getStr("core"));
    for (int i=0; i < subShardNames.size(); i++) {
      String subShardName=subShardNames.get(i);
      params.add(CoreAdminParams.TARGET_CORE,subShardName);
    }
    params.set(CoreAdminParams.RANGES,rangesStr);
    sendShardRequest(parentShardLeader.getNodeName(),params);
    collectShardResponses(results,true,"SPLITSHARD failed to invoke SPLIT core admin command");
    log.info("Index on shard: " + nodeName + " split into two successfully");
    for (int i=0; i < subShardNames.size(); i++) {
      String subShardName=subShardNames.get(i);
      log.info("Applying buffered updates on : " + subShardName);
      params=new ModifiableSolrParams();
      params.set(CoreAdminParams.ACTION,CoreAdminAction.REQUESTAPPLYUPDATES.toString());
      params.set(CoreAdminParams.NAME,subShardName);
      sendShardRequest(nodeName,params);
    }
    collectShardResponses(results,true,"SPLITSHARD failed while asking sub shard leaders to apply buffered updates");
    log.info("Successfully applied buffered updates on : " + subShardNames);
    int repFactor=clusterState.getSlice(collectionName,slice).getReplicas().size();
    Set<String> nodes=clusterState.getLiveNodes();
    List<String> nodeList=new ArrayList<String>(nodes.size());
    nodeList.addAll(nodes);
    Collections.shuffle(nodeList);
    nodeList.remove(nodeName);
    for (int i=1; i <= subSlices.size(); i++) {
      Collections.shuffle(nodeList);
      String sliceName=subSlices.get(i - 1);
      for (int j=2; j <= repFactor; j++) {
        String subShardNodeName=nodeList.get((repFactor * (i - 1) + (j - 2)) % nodeList.size());
        String shardName=collectionName + "_" + sliceName+ "_replica"+ (j);
        log.info("Creating replica shard " + shardName + " as part of slice "+ sliceName+ " of collection "+ collectionName+ " on "+ subShardNodeName);
        params=new ModifiableSolrParams();
        params.set(CoreAdminParams.ACTION,CoreAdminAction.CREATE.toString());
        params.set(CoreAdminParams.NAME,shardName);
        params.set(CoreAdminParams.COLLECTION,collectionName);
        params.set(CoreAdminParams.SHARD,sliceName);
        sendShardRequest(subShardNodeName,params);
        String coreNodeName=waitForCoreNodeName(collection,zkStateReader.getZkClient().getBaseUrlForNodeName(subShardNodeName),shardName);
        log.info("Asking sub shard leader to wait for: " + shardName + " to be alive on: "+ subShardNodeName);
        CoreAdminRequest.WaitForState cmd=new CoreAdminRequest.WaitForState();
        cmd.setCoreName(subShardNames.get(i - 1));
        cmd.setNodeName(subShardNodeName);
        cmd.setCoreNodeName(coreNodeName);
        cmd.setState(ZkStateReader.ACTIVE);
        cmd.setCheckLive(true);
        cmd.setOnlyIfLeader(true);
        sendShardRequest(nodeName,new ModifiableSolrParams(cmd.getParams()));
      }
    }
    collectShardResponses(results,true,"SPLTSHARD failed to create subshard replicas or timed out waiting for them to come up");
    log.info("Calling soft commit to make sub shard updates visible");
    String coreUrl=new ZkCoreNodeProps(parentShardLeader).getCoreUrl();
    UpdateResponse updateResponse=null;
    try {
      updateResponse=softCommit(coreUrl);
      processResponse(results,null,coreUrl,updateResponse,slice);
    }
 catch (    Exception e) {
      processResponse(results,e,coreUrl,updateResponse,slice);
      throw new SolrException(ErrorCode.SERVER_ERROR,"Unable to call distrib softCommit on: " + coreUrl,e);
    }
    log.info("Successfully created all replica shards for all sub-slices " + subSlices);
    log.info("Requesting update shard state");
    DistributedQueue inQueue=Overseer.getInQueue(zkStateReader.getZkClient());
    Map<String,Object> propMap=new HashMap<String,Object>();
    propMap.put(Overseer.QUEUE_OPERATION,"updateshardstate");
    propMap.put(slice,Slice.INACTIVE);
    for (    String subSlice : subSlices) {
      propMap.put(subSlice,Slice.ACTIVE);
    }
    propMap.put(ZkStateReader.COLLECTION_PROP,collectionName);
    ZkNodeProps m=new ZkNodeProps(propMap);
    inQueue.offer(ZkStateReader.toJSON(m));
    return true;
  }
 catch (  SolrException e) {
    throw e;
  }
catch (  Exception e) {
    log.error("Error executing split operation for collection: " + collectionName + " parent shard: "+ slice,e);
    throw new SolrException(ErrorCode.SERVER_ERROR,null,e);
  }
}
