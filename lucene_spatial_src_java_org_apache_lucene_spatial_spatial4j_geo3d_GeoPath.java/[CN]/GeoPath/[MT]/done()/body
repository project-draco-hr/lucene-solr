{
  if (points.size() == 0)   throw new IllegalArgumentException("Path must have at least one point");
  final double cutoffOffset=this.sinAngle * planetModel.getMinimumMagnitude();
  GeoPoint lastPoint=null;
  for (  final GeoPoint end : points) {
    if (lastPoint != null) {
      final Plane normalizedConnectingPlane=new Plane(lastPoint,end).normalize();
      if (normalizedConnectingPlane == null) {
        continue;
      }
      segments.add(new PathSegment(planetModel,lastPoint,end,normalizedConnectingPlane,cutoffOffset));
    }
    lastPoint=end;
  }
  if (segments.size() == 0) {
    final SegmentEndpoint onlyEndpoint=new SegmentEndpoint(points.get(0),cutoffOffset);
    endPoints.add(onlyEndpoint);
    Plane verticalPlane=Plane.constructNormalizedVerticalPlane(onlyEndpoint.point.x,onlyEndpoint.point.y);
    if (verticalPlane == null) {
      verticalPlane=new Plane(1.0,0.0);
    }
    final GeoPoint edgePoint=onlyEndpoint.circlePlane.getSampleIntersectionPoint(planetModel,verticalPlane);
    if (edgePoint == null) {
      throw new RuntimeException("Could not find edge point for path endpoint=" + onlyEndpoint.point + " cutoffOffset="+ cutoffOffset+ " planetModel="+ planetModel);
    }
    this.edgePoints=new GeoPoint[]{edgePoint};
    return;
  }
  for (int i=0; i < segments.size(); i++) {
    final PathSegment currentSegment=segments.get(i);
    if (i == 0) {
      final SegmentEndpoint startEndpoint=new SegmentEndpoint(currentSegment.start,currentSegment.startCutoffPlane,currentSegment.ULHC,currentSegment.LLHC);
      endPoints.add(startEndpoint);
      this.edgePoints=new GeoPoint[]{currentSegment.ULHC};
      continue;
    }
    final PathSegment prevSegment=segments.get(i - 1);
    final SidedPlane candidate1=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,prevSegment.URHC,currentSegment.ULHC,currentSegment.LLHC);
    final SidedPlane candidate2=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,currentSegment.ULHC,currentSegment.LLHC,prevSegment.LRHC);
    final SidedPlane candidate3=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,currentSegment.LLHC,prevSegment.LRHC,prevSegment.URHC);
    final SidedPlane candidate4=SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start,prevSegment.LRHC,prevSegment.URHC,currentSegment.ULHC);
    if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {
      final SegmentEndpoint midEndpoint=new SegmentEndpoint(currentSegment.start,prevSegment.endCutoffPlane,currentSegment.startCutoffPlane,currentSegment.ULHC,currentSegment.LLHC);
      endPoints.add(midEndpoint);
    }
 else {
      endPoints.add(new SegmentEndpoint(currentSegment.start,prevSegment.endCutoffPlane,currentSegment.startCutoffPlane,prevSegment.URHC,prevSegment.LRHC,currentSegment.ULHC,currentSegment.LLHC,candidate1,candidate2,candidate3,candidate4));
    }
  }
  final PathSegment lastSegment=segments.get(segments.size() - 1);
  endPoints.add(new SegmentEndpoint(lastSegment.end,lastSegment.endCutoffPlane,lastSegment.URHC,lastSegment.LRHC));
}
