{
  data.seek(entry.offset + entry.missingBytes);
switch (entry.byteWidth) {
case 1:
{
      final byte[] values=new byte[entry.count];
      data.readBytes(values,0,entry.count);
      ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(values));
      return new NumericDocValues(){
        @Override public long get(        int idx){
          return values[idx];
        }
      }
;
    }
case 2:
{
    final short[] values=new short[entry.count];
    for (int i=0; i < entry.count; i++) {
      values[i]=data.readShort();
    }
    ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(values));
    return new NumericDocValues(){
      @Override public long get(      int idx){
        return values[idx];
      }
    }
;
  }
case 4:
{
  final int[] values=new int[entry.count];
  for (int i=0; i < entry.count; i++) {
    values[i]=data.readInt();
  }
  ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(values));
  return new NumericDocValues(){
    @Override public long get(    int idx){
      return values[idx];
    }
  }
;
}
case 8:
{
final long[] values=new long[entry.count];
for (int i=0; i < entry.count; i++) {
  values[i]=data.readLong();
}
ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(values));
return new NumericDocValues(){
  @Override public long get(  int idx){
    return values[idx];
  }
}
;
}
default :
throw new AssertionError();
}
}
