{
  NumericRawValues ret=new NumericRawValues();
  data.seek(entry.offset + entry.missingBytes);
switch (entry.byteWidth) {
case 1:
{
      final byte[] values=new byte[entry.count];
      data.readBytes(values,0,entry.count);
      ret.bytesUsed=RamUsageEstimator.sizeOf(values);
      ret.numerics=new NumericDocValues(){
        @Override public long get(        int idx){
          return values[idx];
        }
      }
;
      return ret;
    }
case 2:
{
    final short[] values=new short[entry.count];
    for (int i=0; i < entry.count; i++) {
      values[i]=data.readShort();
    }
    ret.bytesUsed=RamUsageEstimator.sizeOf(values);
    ret.numerics=new NumericDocValues(){
      @Override public long get(      int idx){
        return values[idx];
      }
    }
;
    return ret;
  }
case 4:
{
  final int[] values=new int[entry.count];
  for (int i=0; i < entry.count; i++) {
    values[i]=data.readInt();
  }
  ret.bytesUsed=RamUsageEstimator.sizeOf(values);
  ret.numerics=new NumericDocValues(){
    @Override public long get(    int idx){
      return values[idx];
    }
  }
;
  return ret;
}
case 8:
{
final long[] values=new long[entry.count];
for (int i=0; i < entry.count; i++) {
  values[i]=data.readLong();
}
ret.bytesUsed=RamUsageEstimator.sizeOf(values);
ret.numerics=new NumericDocValues(){
  @Override public long get(  int idx){
    return values[idx];
  }
}
;
return ret;
}
default :
throw new AssertionError();
}
}
