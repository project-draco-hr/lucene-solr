{
  int subCount=TestUtil.nextInt(random(),1,20);
  List<int[]> oldToNew=new ArrayList<>();
  List<Integer> uptos=new ArrayList<>();
  int totDocCount=0;
  for (int i=0; i < subCount; i++) {
    int maxDoc=TestUtil.nextInt(random(),1,1000);
    uptos.add(0);
    oldToNew.add(new int[maxDoc]);
    totDocCount+=maxDoc;
  }
  List<int[]> completedSubs=new ArrayList<>();
  for (int docID=0; docID < totDocCount; docID++) {
    int sub=random().nextInt(oldToNew.size());
    int upto=uptos.get(sub);
    int[] subDocs=oldToNew.get(sub);
    subDocs[upto]=docID;
    upto++;
    if (upto == subDocs.length) {
      completedSubs.add(subDocs);
      oldToNew.remove(sub);
      uptos.remove(sub);
    }
 else {
      uptos.set(sub,upto);
    }
  }
  assertEquals(0,oldToNew.size());
  List<TestSubSorted> subs=new ArrayList<>();
  for (int i=0; i < subCount; i++) {
    final int[] docMap=completedSubs.get(i);
    subs.add(new TestSubSorted(new MergeState.DocMap(){
      @Override public int get(      int docID){
        return docMap[docID];
      }
    }
,null,docMap.length,i));
  }
  DocIDMerger<TestSubSorted> merger=new DocIDMerger<>(subs,true);
  int count=0;
  while (true) {
    TestSubSorted sub=merger.next();
    if (sub == null) {
      break;
    }
    assertEquals(count,sub.mappedDocID);
    count++;
  }
  assertEquals(totDocCount,count);
}
