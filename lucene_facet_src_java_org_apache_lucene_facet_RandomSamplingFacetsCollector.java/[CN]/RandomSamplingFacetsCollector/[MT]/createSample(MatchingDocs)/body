{
  int maxdoc=docs.context.reader().maxDoc();
  FixedBitSet sampleDocs=new FixedBitSet(maxdoc);
  int binSize=(int)(1.0 / samplingRate);
  try {
    int counter=0;
    int limit, randomIndex;
    if (leftoverBin != NOT_CALCULATED) {
      limit=leftoverBin;
      randomIndex=leftoverIndex;
    }
 else {
      limit=binSize;
      randomIndex=random.nextInt(binSize);
    }
    final DocIdSetIterator it=docs.bits.iterator();
    for (int doc=it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=it.nextDoc()) {
      if (counter == randomIndex) {
        sampleDocs.set(doc);
      }
      counter++;
      if (counter >= limit) {
        counter=0;
        limit=binSize;
        randomIndex=random.nextInt(binSize);
      }
    }
    if (counter == 0) {
      leftoverBin=leftoverIndex=NOT_CALCULATED;
    }
 else {
      leftoverBin=limit - counter;
      if (randomIndex > counter) {
        leftoverIndex=randomIndex - counter;
      }
 else       if (randomIndex < counter) {
        leftoverIndex=NOT_CALCULATED;
      }
    }
    return new MatchingDocs(docs.context,new FixedBitDocIdSet(sampleDocs),docs.totalHits,null);
  }
 catch (  IOException e) {
    throw new RuntimeException();
  }
}
