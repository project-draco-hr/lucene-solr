{
  String collection=cli.getOptionValue("collection");
  if (collection == null)   throw new IllegalArgumentException("Must provide a collection to run a healthcheck against!");
  log.info("Running healthcheck for " + collection);
  ZkStateReader zkStateReader=cloudSolrServer.getZkStateReader();
  ClusterState clusterState=zkStateReader.getClusterState();
  Set<String> liveNodes=clusterState.getLiveNodes();
  Collection<Slice> slices=clusterState.getSlices(collection);
  if (slices == null)   throw new IllegalArgumentException("Collection " + collection + " not found!");
  SolrQuery q=new SolrQuery("*:*");
  q.setRows(0);
  QueryResponse qr=cloudSolrServer.query(q);
  String collErr=null;
  long docCount=-1;
  try {
    docCount=qr.getResults().getNumFound();
  }
 catch (  Exception exc) {
    collErr=String.valueOf(exc);
  }
  List<Object> shardList=new ArrayList<>();
  boolean collectionIsHealthy=(docCount != -1);
  for (  Slice slice : slices) {
    String shardName=slice.getName();
    String leaderUrl=null;
    try {
      leaderUrl=zkStateReader.getLeaderUrl(collection,shardName,1000);
    }
 catch (    Exception exc) {
      log.warn("Failed to get leader for shard " + shardName + " due to: "+ exc);
    }
    List<ReplicaHealth> replicaList=new ArrayList<ReplicaHealth>();
    for (    Replica r : slice.getReplicas()) {
      String uptime=null;
      String memory=null;
      String replicaStatus=null;
      long numDocs=-1L;
      ZkCoreNodeProps replicaCoreProps=new ZkCoreNodeProps(r);
      String coreUrl=replicaCoreProps.getCoreUrl();
      boolean isLeader=coreUrl.equals(leaderUrl);
      String nodeName=replicaCoreProps.getNodeName();
      if (nodeName == null || !liveNodes.contains(nodeName)) {
        replicaStatus=ZkStateReader.DOWN;
      }
 else {
        HttpSolrServer solr=new HttpSolrServer(coreUrl);
        String solrUrl=solr.getBaseURL();
        q=new SolrQuery("*:*");
        q.setRows(0);
        q.set("distrib","false");
        try {
          qr=solr.query(q);
          numDocs=qr.getResults().getNumFound();
          int lastSlash=solrUrl.lastIndexOf('/');
          String systemInfoUrl=solrUrl.substring(0,lastSlash) + "/admin/info/system";
          Map<String,Object> info=getJson(solr.getHttpClient(),systemInfoUrl,2);
          uptime=uptime(asLong("/jvm/jmx/upTimeMS",info));
          String usedMemory=asString("/jvm/memory/used",info);
          String totalMemory=asString("/jvm/memory/total",info);
          memory=usedMemory + " of " + totalMemory;
          replicaStatus=replicaCoreProps.getState();
        }
 catch (        Exception exc) {
          log.error("ERROR: " + exc + " when trying to reach: "+ solrUrl);
          if (checkCommunicationError(exc)) {
            replicaStatus="down";
          }
 else {
            replicaStatus="error: " + exc;
          }
        }
 finally {
          solr.shutdown();
        }
      }
      replicaList.add(new ReplicaHealth(shardName,r.getName(),coreUrl,replicaStatus,numDocs,isLeader,uptime,memory));
    }
    ShardHealth shardHealth=new ShardHealth(shardName,replicaList);
    if (ShardState.healthy != shardHealth.getShardState())     collectionIsHealthy=false;
    shardList.add(shardHealth.asMap());
  }
  Map<String,Object> report=new LinkedHashMap<String,Object>();
  report.put("collection",collection);
  report.put("status",collectionIsHealthy ? "healthy" : "degraded");
  if (collErr != null) {
    report.put("error",collErr);
  }
  report.put("numDocs",docCount);
  report.put("numShards",slices.size());
  report.put("shards",shardList);
  CharArr arr=new CharArr();
  new JSONWriter(arr,2).write(report);
  System.out.println(arr.toString());
  return 0;
}
