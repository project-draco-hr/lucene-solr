{
  final String fileName=IndexFileNames.segmentFileName(segmentName,"",Lucene40FieldInfosWriter.FIELD_INFOS_EXTENSION);
  IndexInput input=directory.openInput(fileName,iocontext);
  boolean hasVectors=false;
  boolean hasFreq=false;
  boolean hasProx=false;
  try {
    final int format=input.readVInt();
    if (format > FORMAT_MINIMUM) {
      throw new IndexFormatTooOldException(input,format,FORMAT_MINIMUM,Lucene40FieldInfosWriter.FORMAT_CURRENT);
    }
    if (format < Lucene40FieldInfosWriter.FORMAT_CURRENT) {
      throw new IndexFormatTooNewException(input,format,FORMAT_MINIMUM,Lucene40FieldInfosWriter.FORMAT_CURRENT);
    }
    final int size=input.readVInt();
    FieldInfo infos[]=new FieldInfo[size];
    for (int i=0; i < size; i++) {
      String name=input.readString();
      final int fieldNumber=format <= Lucene40FieldInfosWriter.FORMAT_FLEX ? input.readInt() : i;
      byte bits=input.readByte();
      boolean isIndexed=(bits & Lucene40FieldInfosWriter.IS_INDEXED) != 0;
      boolean storeTermVector=(bits & Lucene40FieldInfosWriter.STORE_TERMVECTOR) != 0;
      boolean omitNorms=(bits & Lucene40FieldInfosWriter.OMIT_NORMS) != 0;
      boolean storePayloads=(bits & Lucene40FieldInfosWriter.STORE_PAYLOADS) != 0;
      final IndexOptions indexOptions;
      if ((bits & Lucene40FieldInfosWriter.OMIT_TERM_FREQ_AND_POSITIONS) != 0) {
        indexOptions=IndexOptions.DOCS_ONLY;
      }
 else       if ((bits & Lucene40FieldInfosWriter.OMIT_POSITIONS) != 0) {
        if (format <= Lucene40FieldInfosWriter.FORMAT_OMIT_POSITIONS) {
          indexOptions=IndexOptions.DOCS_AND_FREQS;
        }
 else {
          throw new CorruptIndexException("Corrupt fieldinfos, OMIT_POSITIONS set but format=" + format + " (resource: "+ input+ ")");
        }
      }
 else       if (format <= Lucene40FieldInfosWriter.FORMAT_FLEX && (bits & Lucene40FieldInfosWriter.STORE_OFFSETS_IN_POSTINGS) != 0) {
        indexOptions=IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS;
      }
 else {
        indexOptions=IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
      }
      if (indexOptions != IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
        storePayloads=false;
      }
      hasVectors|=storeTermVector;
      hasProx|=isIndexed && indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
      hasFreq|=isIndexed && indexOptions != IndexOptions.DOCS_ONLY;
      DocValues.Type docValuesType=null;
      if (format <= Lucene40FieldInfosWriter.FORMAT_FLEX) {
        final byte b=input.readByte();
switch (b) {
case 0:
          docValuesType=null;
        break;
case 1:
      docValuesType=DocValues.Type.VAR_INTS;
    break;
case 2:
  docValuesType=DocValues.Type.FLOAT_32;
break;
case 3:
docValuesType=DocValues.Type.FLOAT_64;
break;
case 4:
docValuesType=DocValues.Type.BYTES_FIXED_STRAIGHT;
break;
case 5:
docValuesType=DocValues.Type.BYTES_FIXED_DEREF;
break;
case 6:
docValuesType=DocValues.Type.BYTES_VAR_STRAIGHT;
break;
case 7:
docValuesType=DocValues.Type.BYTES_VAR_DEREF;
break;
case 8:
docValuesType=DocValues.Type.FIXED_INTS_16;
break;
case 9:
docValuesType=DocValues.Type.FIXED_INTS_32;
break;
case 10:
docValuesType=DocValues.Type.FIXED_INTS_64;
break;
case 11:
docValuesType=DocValues.Type.FIXED_INTS_8;
break;
case 12:
docValuesType=DocValues.Type.BYTES_FIXED_SORTED;
break;
case 13:
docValuesType=DocValues.Type.BYTES_VAR_SORTED;
break;
default :
throw new IllegalStateException("unhandled indexValues type " + b);
}
}
infos[i]=new FieldInfo(name,isIndexed,fieldNumber,storeTermVector,omitNorms,storePayloads,indexOptions,docValuesType);
}
if (input.getFilePointer() != input.length()) {
throw new CorruptIndexException("did not read all bytes from file \"" + fileName + "\": read "+ input.getFilePointer()+ " vs size "+ input.length()+ " (resource: "+ input+ ")");
}
return new FieldInfos(infos,hasFreq,hasProx,hasVectors);
}
  finally {
input.close();
}
}
