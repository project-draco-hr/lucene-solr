{
  boolean any=false;
  while (true) {
    SegmentInfo info=null;
    MergePolicy.OneMerge merge=null;
synchronized (this) {
      final int numSegments=segmentInfos.size();
      for (int i=0; i < numSegments; i++) {
        info=segmentInfos.info(i);
        if (info.dir != directory) {
          merge=new MergePolicy.OneMerge(segmentInfos.range(i,1 + i),info.getUseCompoundFile());
          break;
        }
      }
    }
    if (merge != null) {
      if (registerMerge(merge)) {
        pendingMerges.remove(merge);
        runningMerges.add(merge);
        any=true;
        merge(merge);
      }
 else       throw new MergePolicy.MergeException("segment \"" + info.name + " exists in external directory yet the MergeScheduler executed the merge in a separate thread",directory);
    }
 else     break;
  }
  if (any)   mergeScheduler.merge(this);
}
