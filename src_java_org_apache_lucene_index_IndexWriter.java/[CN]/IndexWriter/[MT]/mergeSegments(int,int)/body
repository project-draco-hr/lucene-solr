{
  final String mergedName=newSegmentName();
  SegmentMerger merger=null;
  SegmentInfo newSegment=null;
  int mergedDocCount=0;
  try {
    if (infoStream != null)     infoStream.print("merging segments");
    Directory lastDir=directory;
    String lastDocStoreSegment=null;
    boolean mergeDocStores=false;
    boolean doFlushDocStore=false;
    int next=-1;
    for (int i=minSegment; i < end; i++) {
      SegmentInfo si=segmentInfos.info(i);
      if (si.hasDeletions())       mergeDocStores=true;
      if (-1 == si.getDocStoreOffset())       mergeDocStores=true;
      String docStoreSegment=si.getDocStoreSegment();
      if (docStoreSegment == null)       mergeDocStores=true;
 else       if (lastDocStoreSegment == null)       lastDocStoreSegment=docStoreSegment;
 else       if (!lastDocStoreSegment.equals(docStoreSegment))       mergeDocStores=true;
      if (-1 == next)       next=si.getDocStoreOffset() + si.docCount;
 else       if (next != si.getDocStoreOffset())       mergeDocStores=true;
 else       next=si.getDocStoreOffset() + si.docCount;
      if (lastDir != si.dir)       mergeDocStores=true;
      if (si.getDocStoreOffset() != -1 && si.getDocStoreSegment().equals(docWriter.getDocStoreSegment()))       doFlushDocStore=true;
    }
    final int docStoreOffset;
    final String docStoreSegment;
    final boolean docStoreIsCompoundFile;
    if (mergeDocStores) {
      docStoreOffset=-1;
      docStoreSegment=null;
      docStoreIsCompoundFile=false;
    }
 else {
      SegmentInfo si=segmentInfos.info(minSegment);
      docStoreOffset=si.getDocStoreOffset();
      docStoreSegment=si.getDocStoreSegment();
      docStoreIsCompoundFile=si.getDocStoreIsCompoundFile();
    }
    if (mergeDocStores && doFlushDocStore)     flushDocStores();
    merger=new SegmentMerger(this,mergedName);
    for (int i=minSegment; i < end; i++) {
      SegmentInfo si=segmentInfos.info(i);
      if (infoStream != null)       infoStream.print(" " + si.name + " ("+ si.docCount+ " docs)");
      IndexReader reader=SegmentReader.get(si,MERGE_READ_BUFFER_SIZE,mergeDocStores);
      merger.add(reader);
    }
    SegmentInfos rollback=null;
    boolean success=false;
    try {
      mergedDocCount=merger.merge(mergeDocStores);
      if (infoStream != null) {
        infoStream.println(" into " + mergedName + " ("+ mergedDocCount+ " docs)");
      }
      newSegment=new SegmentInfo(mergedName,mergedDocCount,directory,false,true,docStoreOffset,docStoreSegment,docStoreIsCompoundFile);
      rollback=(SegmentInfos)segmentInfos.clone();
      for (int i=end - 1; i > minSegment; i--)       segmentInfos.remove(i);
      segmentInfos.set(minSegment,newSegment);
      checkpoint();
      success=true;
    }
  finally {
      if (!success) {
        if (rollback != null) {
          segmentInfos.clear();
          segmentInfos.addAll(rollback);
        }
        deleter.refresh();
      }
    }
  }
  finally {
    if (merger != null) {
      merger.closeReaders();
    }
  }
  deleter.checkpoint(segmentInfos,autoCommit);
  if (useCompoundFile) {
    boolean success=false;
    try {
      merger.createCompoundFile(mergedName + ".cfs");
      newSegment.setUseCompoundFile(true);
      checkpoint();
      success=true;
    }
  finally {
      if (!success) {
        newSegment.setUseCompoundFile(false);
        deleter.refresh();
      }
    }
    deleter.checkpoint(segmentInfos,autoCommit);
  }
  return mergedDocCount;
}
