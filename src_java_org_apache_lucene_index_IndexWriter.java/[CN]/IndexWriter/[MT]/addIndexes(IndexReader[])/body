{
  optimize();
  final String mergedName=newSegmentName();
  SegmentMerger merger=new SegmentMerger(directory,mergedName);
  final Vector segmentsToDelete=new Vector();
  IndexReader sReader=null;
  if (segmentInfos.size() == 1) {
    sReader=new SegmentReader(segmentInfos.info(0));
    merger.add(sReader);
    segmentsToDelete.addElement(sReader);
  }
  for (int i=0; i < readers.length; i++)   merger.add(readers[i]);
  int docCount=merger.merge();
  segmentInfos.setSize(0);
  segmentInfos.addElement(new SegmentInfo(mergedName,docCount,directory));
  if (sReader != null)   sReader.close();
synchronized (directory) {
    new Lock.With(directory.makeLock(COMMIT_LOCK_NAME),COMMIT_LOCK_TIMEOUT){
      public Object doBody() throws IOException {
        segmentInfos.write(directory);
        deleteSegments(segmentsToDelete);
        return null;
      }
    }
.run();
  }
  if (useCompoundFile) {
    final Vector filesToDelete=merger.createCompoundFile(mergedName + ".tmp");
synchronized (directory) {
      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME),COMMIT_LOCK_TIMEOUT){
        public Object doBody() throws IOException {
          directory.renameFile(mergedName + ".tmp",mergedName + ".cfs");
          deleteFiles(filesToDelete);
          return null;
        }
      }
.run();
    }
  }
}
