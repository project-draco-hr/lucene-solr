{
  boolean doMerge=end > 0;
  final String mergedName=newSegmentName();
  SegmentMerger merger=null;
  final List ramSegmentsToDelete=new ArrayList();
  SegmentInfo newSegment=null;
  int mergedDocCount=0;
  boolean anyDeletes=(bufferedDeleteTerms.size() != 0);
  try {
    if (doMerge) {
      if (infoStream != null)       infoStream.print("merging segments");
      merger=new SegmentMerger(this,mergedName);
      for (int i=minSegment; i < end; i++) {
        SegmentInfo si=sourceSegments.info(i);
        if (infoStream != null)         infoStream.print(" " + si.name + " ("+ si.docCount+ " docs)");
        IndexReader reader=SegmentReader.get(si);
        merger.add(reader);
        if (reader.directory() == this.ramDirectory) {
          ramSegmentsToDelete.add(si);
        }
      }
    }
    SegmentInfos rollback=null;
    boolean success=false;
    try {
      if (doMerge) {
        mergedDocCount=merger.merge();
        if (infoStream != null) {
          infoStream.println(" into " + mergedName + " ("+ mergedDocCount+ " docs)");
        }
        newSegment=new SegmentInfo(mergedName,mergedDocCount,directory,false,true);
      }
      if (sourceSegments != ramSegmentInfos || anyDeletes) {
        rollback=(SegmentInfos)segmentInfos.clone();
      }
      if (doMerge) {
        if (sourceSegments == ramSegmentInfos) {
          segmentInfos.addElement(newSegment);
        }
 else {
          for (int i=end - 1; i > minSegment; i--)           sourceSegments.remove(i);
          segmentInfos.set(minSegment,newSegment);
        }
      }
      if (sourceSegments == ramSegmentInfos) {
        maybeApplyDeletes(doMerge);
        doAfterFlush();
      }
      checkpoint();
      success=true;
    }
  finally {
      if (success) {
        if (sourceSegments == ramSegmentInfos) {
          ramSegmentInfos.removeAllElements();
        }
      }
 else {
        if (sourceSegments == ramSegmentInfos && !anyDeletes) {
          if (newSegment != null && segmentInfos.size() > 0 && segmentInfos.info(segmentInfos.size() - 1) == newSegment) {
            segmentInfos.remove(segmentInfos.size() - 1);
          }
        }
 else         if (rollback != null) {
          segmentInfos.clear();
          segmentInfos.addAll(rollback);
        }
        deleter.refresh();
      }
    }
  }
  finally {
    if (doMerge)     merger.closeReaders();
  }
  deleter.deleteDirect(ramDirectory,ramSegmentsToDelete);
  deleter.checkpoint(segmentInfos,autoCommit);
  if (useCompoundFile && doMerge) {
    boolean success=false;
    try {
      merger.createCompoundFile(mergedName + ".cfs");
      newSegment.setUseCompoundFile(true);
      checkpoint();
      success=true;
    }
  finally {
      if (!success) {
        newSegment.setUseCompoundFile(false);
        deleter.refresh();
      }
    }
    deleter.checkpoint(segmentInfos,autoCommit);
  }
  return mergedDocCount;
}
