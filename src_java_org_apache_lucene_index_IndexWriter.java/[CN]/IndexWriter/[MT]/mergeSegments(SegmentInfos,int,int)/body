{
  boolean doMerge=end > 0;
  final String mergedName=newSegmentName();
  SegmentMerger merger=null;
  final Vector segmentsToDelete=new Vector();
  String segmentsInfosFileName=segmentInfos.getCurrentSegmentFileName();
  String nextSegmentsFileName=segmentInfos.getNextSegmentFileName();
  SegmentInfo newSegment=null;
  int mergedDocCount=0;
  try {
    if (doMerge) {
      if (infoStream != null)       infoStream.print("merging segments");
      merger=new SegmentMerger(this,mergedName);
      for (int i=minSegment; i < end; i++) {
        SegmentInfo si=sourceSegments.info(i);
        if (infoStream != null)         infoStream.print(" " + si.name + " ("+ si.docCount+ " docs)");
        IndexReader reader=SegmentReader.get(si);
        merger.add(reader);
        if ((reader.directory() == this.directory) || (reader.directory() == this.ramDirectory))         segmentsToDelete.addElement(reader);
      }
    }
    SegmentInfos rollback=null;
    boolean success=false;
    try {
      if (doMerge) {
        mergedDocCount=merger.merge();
        if (infoStream != null) {
          infoStream.println(" into " + mergedName + " ("+ mergedDocCount+ " docs)");
        }
        newSegment=new SegmentInfo(mergedName,mergedDocCount,directory,false,true);
      }
      if (!inTransaction && (sourceSegments != ramSegmentInfos || bufferedDeleteTerms.size() > 0)) {
        rollback=(SegmentInfos)segmentInfos.clone();
      }
      if (doMerge) {
        if (sourceSegments == ramSegmentInfos) {
          segmentInfos.addElement(newSegment);
        }
 else {
          for (int i=end - 1; i > minSegment; i--)           sourceSegments.remove(i);
          segmentInfos.set(minSegment,newSegment);
        }
      }
      if (sourceSegments == ramSegmentInfos) {
        deleter.clearPendingFiles();
        maybeApplyDeletes(doMerge);
        doAfterFlush();
      }
      if (!inTransaction) {
        segmentInfos.write(directory);
      }
 else {
        commitPending=true;
      }
      success=true;
    }
  finally {
      if (success) {
        if (sourceSegments == ramSegmentInfos) {
          ramSegmentInfos.removeAllElements();
        }
      }
 else       if (!inTransaction) {
        if (sourceSegments == ramSegmentInfos && 0 == bufferedDeleteTerms.size()) {
          if (newSegment != null && segmentInfos.size() > 0 && segmentInfos.info(segmentInfos.size() - 1) == newSegment) {
            segmentInfos.remove(segmentInfos.size() - 1);
          }
        }
 else         if (rollback != null) {
          segmentInfos.clear();
          segmentInfos.addAll(rollback);
        }
        deleter.clearPendingFiles();
        deleter.deleteFile(nextSegmentsFileName);
        deleter.findDeletableFiles();
        deleter.deleteFiles();
      }
    }
  }
  finally {
    if (doMerge)     merger.closeReaders();
  }
  if (!inTransaction) {
    deleter.deleteFile(segmentsInfosFileName);
    deleter.deleteSegments(segmentsToDelete);
    deleter.commitPendingFiles();
  }
 else {
    deleter.addPendingFile(segmentsInfosFileName);
    deleter.deleteSegments(segmentsToDelete,protectedSegments);
  }
  if (useCompoundFile && doMerge) {
    segmentsInfosFileName=nextSegmentsFileName;
    nextSegmentsFileName=segmentInfos.getNextSegmentFileName();
    Vector filesToDelete;
    boolean success=false;
    try {
      filesToDelete=merger.createCompoundFile(mergedName + ".cfs");
      newSegment.setUseCompoundFile(true);
      if (!inTransaction) {
        segmentInfos.write(directory);
      }
      success=true;
    }
  finally {
      if (!success && !inTransaction) {
        newSegment.setUseCompoundFile(false);
        deleter.deleteFile(mergedName + ".cfs");
        deleter.deleteFile(nextSegmentsFileName);
      }
    }
    if (!inTransaction) {
      deleter.deleteFile(segmentsInfosFileName);
    }
    deleter.deleteFiles(filesToDelete);
  }
  return mergedDocCount;
}
