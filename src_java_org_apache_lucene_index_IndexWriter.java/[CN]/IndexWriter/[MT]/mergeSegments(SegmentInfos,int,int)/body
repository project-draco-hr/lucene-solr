{
  final String mergedName=newSegmentName();
  if (infoStream != null)   infoStream.print("merging segments");
  SegmentMerger merger=new SegmentMerger(this,mergedName);
  boolean fromRAM=false;
  final Vector segmentsToDelete=new Vector();
  for (int i=minSegment; i < end; i++) {
    SegmentInfo si=sourceSegments.info(i);
    if (infoStream != null)     infoStream.print(" " + si.name + " ("+ si.docCount+ " docs)");
    IndexReader reader=SegmentReader.get(si);
    merger.add(reader);
    if ((reader.directory() == this.directory) || (reader.directory() == this.ramDirectory))     segmentsToDelete.addElement(reader);
    if (!fromRAM && (reader.directory() == this.ramDirectory)) {
      fromRAM=true;
    }
  }
  int mergedDocCount=merger.merge();
  if (infoStream != null) {
    infoStream.println(" into " + mergedName + " ("+ mergedDocCount+ " docs)");
  }
  SegmentInfo newSegment=new SegmentInfo(mergedName,mergedDocCount,directory);
  if (fromRAM) {
    sourceSegments.removeAllElements();
    if (mergedDocCount > 0)     segmentInfos.addElement(newSegment);
  }
 else {
    for (int i=end - 1; i > minSegment; i--)     sourceSegments.remove(i);
    if (mergedDocCount > 0)     segmentInfos.set(minSegment,newSegment);
 else     sourceSegments.remove(minSegment);
  }
  merger.closeReaders();
synchronized (directory) {
    new Lock.With(directory.makeLock(COMMIT_LOCK_NAME),commitLockTimeout){
      public Object doBody() throws IOException {
        segmentInfos.write(directory);
        return null;
      }
    }
.run();
  }
  deleteSegments(segmentsToDelete);
  if (useCompoundFile) {
    final Vector filesToDelete=merger.createCompoundFile(mergedName + ".tmp");
synchronized (directory) {
      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME),commitLockTimeout){
        public Object doBody() throws IOException {
          directory.renameFile(mergedName + ".tmp",mergedName + ".cfs");
          return null;
        }
      }
.run();
    }
    deleteFiles(filesToDelete);
  }
  return mergedDocCount;
}
