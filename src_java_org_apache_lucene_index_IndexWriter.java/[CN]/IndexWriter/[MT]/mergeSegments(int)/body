{
  String mergedName=newSegmentName();
  int mergedDocCount=0;
  if (infoStream != null)   infoStream.print("merging segments");
  SegmentMerger merger=new SegmentMerger(directory,mergedName,useCompoundFile);
  final Vector segmentsToDelete=new Vector();
  for (int i=minSegment; i < segmentInfos.size(); i++) {
    SegmentInfo si=segmentInfos.info(i);
    if (infoStream != null)     infoStream.print(" " + si.name + " ("+ si.docCount+ " docs)");
    SegmentReader reader=new SegmentReader(si);
    merger.add(reader);
    if ((reader.directory == this.directory) || (reader.directory == this.ramDirectory))     segmentsToDelete.addElement(reader);
    mergedDocCount+=reader.numDocs();
  }
  if (infoStream != null) {
    infoStream.println();
    infoStream.println(" into " + mergedName + " ("+ mergedDocCount+ " docs)");
  }
  merger.merge();
  segmentInfos.setSize(minSegment);
  segmentInfos.addElement(new SegmentInfo(mergedName,mergedDocCount,directory));
synchronized (directory) {
    new Lock.With(directory.makeLock("commit.lock"),COMMIT_LOCK_TIMEOUT){
      public Object doBody() throws IOException {
        segmentInfos.write(directory);
        deleteSegments(segmentsToDelete);
        return null;
      }
    }
.run();
  }
}
