{
  SortedSetEntry ss=sortedNumerics.get(field.name);
  if (ss.format == SORTED_SINGLE_VALUED) {
    NumericEntry numericEntry=numerics.get(field.name);
    final LongValues values=getNumeric(numericEntry);
    final Bits docsWithField;
    if (numericEntry.format == SPARSE_COMPRESSED) {
      docsWithField=((SparseLongValues)values).docsWithField;
    }
 else {
      docsWithField=getLiveBits(numericEntry.missingOffset,maxDoc);
    }
    return new SortedNumericDocValues(){
      int docID=-1;
      @Override public int docID(){
        return docID;
      }
      @Override public int nextDoc(){
        while (true) {
          docID++;
          if (docID == maxDoc) {
            docID=NO_MORE_DOCS;
            break;
          }
          if (docsWithField.get(docID)) {
            break;
          }
        }
        return docID;
      }
      @Override public int advance(      int target){
        if (target >= maxDoc) {
          docID=NO_MORE_DOCS;
          return docID;
        }
 else {
          docID=target - 1;
          return nextDoc();
        }
      }
      @Override public long cost(){
        return 0;
      }
      @Override public int docValueCount(){
        return 1;
      }
      @Override public long nextValue(){
        return values.get(docID);
      }
    }
;
  }
 else   if (ss.format == SORTED_WITH_ADDRESSES) {
    NumericEntry numericEntry=numerics.get(field.name);
    final LongValues values=getNumeric(numericEntry);
    final LongValues ordIndex=getOrdIndexInstance(field,ordIndexes.get(field.name));
    return new SortedNumericDocValues(){
      long startOffset;
      long endOffset;
      int docID=-1;
      long upto;
      @Override public int docID(){
        return docID;
      }
      @Override public int nextDoc(){
        while (true) {
          docID++;
          if (docID == maxDoc) {
            docID=NO_MORE_DOCS;
            return docID;
          }
          startOffset=ordIndex.get(docID);
          endOffset=ordIndex.get(docID + 1L);
          if (endOffset > startOffset) {
            break;
          }
        }
        upto=startOffset;
        return docID;
      }
      @Override public int advance(      int target){
        if (target >= maxDoc) {
          docID=NO_MORE_DOCS;
          return docID;
        }
 else {
          docID=target - 1;
          return nextDoc();
        }
      }
      @Override public long cost(){
        return 0;
      }
      @Override public int docValueCount(){
        return (int)(endOffset - startOffset);
      }
      @Override public long nextValue(){
        return values.get(upto++);
      }
    }
;
  }
 else   if (ss.format == SORTED_SET_TABLE) {
    NumericEntry entry=ords.get(field.name);
    final LongValues ordinals=getNumeric(entry);
    final long[] table=ss.table;
    final int[] offsets=ss.tableOffsets;
    return new SortedNumericDocValues(){
      int startOffset;
      int endOffset;
      int docID=-1;
      int upto;
      @Override public int docID(){
        return docID;
      }
      @Override public int nextDoc(){
        while (true) {
          docID++;
          if (docID == maxDoc) {
            docID=NO_MORE_DOCS;
            return docID;
          }
          int ord=(int)ordinals.get(docID);
          startOffset=offsets[ord];
          endOffset=offsets[ord + 1];
          if (endOffset > startOffset) {
            break;
          }
        }
        upto=startOffset;
        return docID;
      }
      @Override public int advance(      int target){
        if (target >= maxDoc) {
          docID=NO_MORE_DOCS;
          return docID;
        }
 else {
          docID=target - 1;
          return nextDoc();
        }
      }
      @Override public long cost(){
        return 0;
      }
      @Override public int docValueCount(){
        return endOffset - startOffset;
      }
      @Override public long nextValue(){
        return table[upto++];
      }
    }
;
  }
 else {
    throw new AssertionError();
  }
}
