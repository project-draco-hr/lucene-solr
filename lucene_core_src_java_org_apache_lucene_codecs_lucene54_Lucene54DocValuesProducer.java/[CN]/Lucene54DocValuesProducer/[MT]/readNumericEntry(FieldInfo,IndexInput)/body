{
  NumericEntry entry=new NumericEntry();
  entry.format=meta.readVInt();
  entry.missingOffset=meta.readLong();
  if (entry.format == SPARSE_COMPRESSED) {
    entry.numDocsWithValue=meta.readVLong();
    final int blockShift=meta.readVInt();
    entry.monotonicMeta=DirectMonotonicReader.loadMeta(meta,entry.numDocsWithValue,blockShift);
    ramBytesUsed.addAndGet(entry.monotonicMeta.ramBytesUsed());
    directAddressesMeta.put(info.name,entry.monotonicMeta);
  }
  entry.offset=meta.readLong();
  entry.count=meta.readVLong();
switch (entry.format) {
case CONST_COMPRESSED:
    entry.minValue=meta.readLong();
  if (entry.count > Integer.MAX_VALUE) {
    throw new CorruptIndexException("illegal CONST_COMPRESSED count: " + entry.count,meta);
  }
break;
case GCD_COMPRESSED:
entry.minValue=meta.readLong();
entry.gcd=meta.readLong();
entry.bitsPerValue=meta.readVInt();
break;
case TABLE_COMPRESSED:
final int uniqueValues=meta.readVInt();
if (uniqueValues > 256) {
throw new CorruptIndexException("TABLE_COMPRESSED cannot have more than 256 distinct values, got=" + uniqueValues,meta);
}
entry.table=new long[uniqueValues];
for (int i=0; i < uniqueValues; ++i) {
entry.table[i]=meta.readLong();
}
ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(entry.table));
entry.bitsPerValue=meta.readVInt();
break;
case DELTA_COMPRESSED:
entry.minValue=meta.readLong();
entry.bitsPerValue=meta.readVInt();
break;
case MONOTONIC_COMPRESSED:
final int blockShift=meta.readVInt();
entry.monotonicMeta=DirectMonotonicReader.loadMeta(meta,maxDoc,blockShift);
ramBytesUsed.addAndGet(entry.monotonicMeta.ramBytesUsed());
directAddressesMeta.put(info.name,entry.monotonicMeta);
break;
case SPARSE_COMPRESSED:
final byte numberType=meta.readByte();
switch (numberType) {
case 0:
entry.numberType=NumberType.VALUE;
break;
case 1:
entry.numberType=NumberType.ORDINAL;
break;
default :
throw new CorruptIndexException("Number type can only be 0 or 1, got=" + numberType,meta);
}
final int fieldNumber=meta.readVInt();
if (fieldNumber != info.number) {
throw new CorruptIndexException("Field numbers mistmatch: " + fieldNumber + " != "+ info.number,meta);
}
final int dvFormat=meta.readByte();
if (dvFormat != NUMERIC) {
throw new CorruptIndexException("Formats mistmatch: " + dvFormat + " != "+ NUMERIC,meta);
}
entry.nonMissingValues=readNumericEntry(info,meta);
break;
default :
throw new CorruptIndexException("Unknown format: " + entry.format + ", input=",meta);
}
entry.endOffset=meta.readLong();
return entry;
}
