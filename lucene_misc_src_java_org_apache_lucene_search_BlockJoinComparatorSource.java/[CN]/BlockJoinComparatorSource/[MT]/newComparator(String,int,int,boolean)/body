{
  final int parentSlots[]=new int[numHits];
  final int childSlots[]=new int[numHits];
  SortField parentFields[]=parentSort.getSort();
  final int parentReverseMul[]=new int[parentFields.length];
  final FieldComparator<?> parentComparators[]=new FieldComparator[parentFields.length];
  for (int i=0; i < parentFields.length; i++) {
    parentReverseMul[i]=parentFields[i].getReverse() ? -1 : 1;
    parentComparators[i]=parentFields[i].getComparator(1,i);
  }
  SortField childFields[]=childSort.getSort();
  final int childReverseMul[]=new int[childFields.length];
  final FieldComparator<?> childComparators[]=new FieldComparator[childFields.length];
  for (int i=0; i < childFields.length; i++) {
    childReverseMul[i]=childFields[i].getReverse() ? -1 : 1;
    childComparators[i]=childFields[i].getComparator(1,i);
  }
  return new FieldComparator<Integer>(){
    int bottomParent;
    int bottomChild;
    BitSet parentBits;
    LeafFieldComparator[] parentLeafComparators;
    LeafFieldComparator[] childLeafComparators;
    @Override public int compare(    int slot1,    int slot2){
      try {
        return compare(childSlots[slot1],parentSlots[slot1],childSlots[slot2],parentSlots[slot2]);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void setTopValue(    Integer value){
      throw new UnsupportedOperationException("this comparator cannot be used with deep paging");
    }
    @Override public LeafFieldComparator getLeafComparator(    LeafReaderContext context) throws IOException {
      if (parentBits != null) {
        throw new IllegalStateException("This comparator can only be used on a single segment");
      }
      IndexSearcher searcher=new IndexSearcher(ReaderUtil.getTopLevelContext(context));
      searcher.setQueryCache(null);
      final Weight weight=searcher.createNormalizedWeight(parentsFilter,false);
      final Scorer parents=weight.scorer(context);
      if (parents == null) {
        throw new IllegalStateException("LeafReader " + context.reader() + " contains no parents!");
      }
      parentBits=BitSet.of(parents.iterator(),context.reader().maxDoc());
      parentLeafComparators=new LeafFieldComparator[parentComparators.length];
      for (int i=0; i < parentComparators.length; i++) {
        parentLeafComparators[i]=parentComparators[i].getLeafComparator(context);
      }
      childLeafComparators=new LeafFieldComparator[childComparators.length];
      for (int i=0; i < childComparators.length; i++) {
        childLeafComparators[i]=childComparators[i].getLeafComparator(context);
      }
      return new LeafFieldComparator(){
        @Override public int compareBottom(        int doc) throws IOException {
          return compare(bottomChild,bottomParent,doc,parent(doc));
        }
        @Override public int compareTop(        int doc) throws IOException {
          throw new UnsupportedOperationException("this comparator cannot be used with deep paging");
        }
        @Override public void copy(        int slot,        int doc) throws IOException {
          childSlots[slot]=doc;
          parentSlots[slot]=parent(doc);
        }
        @Override public void setBottom(        int slot){
          bottomParent=parentSlots[slot];
          bottomChild=childSlots[slot];
        }
        @Override public void setScorer(        Scorer scorer){
          for (          LeafFieldComparator comp : parentLeafComparators) {
            comp.setScorer(scorer);
          }
          for (          LeafFieldComparator comp : childLeafComparators) {
            comp.setScorer(scorer);
          }
        }
      }
;
    }
    @Override public Integer value(    int slot){
      throw new UnsupportedOperationException("filling sort field values is not yet supported");
    }
    int parent(    int doc){
      return parentBits.nextSetBit(doc);
    }
    int compare(    int docID1,    int parent1,    int docID2,    int parent2) throws IOException {
      if (parent1 == parent2) {
        if (docID1 == parent1 || docID2 == parent2) {
          return docID1 - docID2;
        }
 else {
          return compare(docID1,docID2,childLeafComparators,childReverseMul);
        }
      }
 else {
        int cmp=compare(parent1,parent2,parentLeafComparators,parentReverseMul);
        if (cmp == 0) {
          return parent1 - parent2;
        }
 else {
          return cmp;
        }
      }
    }
    int compare(    int docID1,    int docID2,    LeafFieldComparator comparators[],    int reverseMul[]) throws IOException {
      for (int i=0; i < comparators.length; i++) {
        comparators[i].copy(0,docID1);
        comparators[i].setBottom(0);
        int comp=reverseMul[i] * comparators[i].compareBottom(docID2);
        if (comp != 0) {
          return comp;
        }
      }
      return 0;
    }
  }
;
}
