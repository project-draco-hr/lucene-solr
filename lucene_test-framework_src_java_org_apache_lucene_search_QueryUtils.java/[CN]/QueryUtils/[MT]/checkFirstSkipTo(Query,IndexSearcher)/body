{
  final float maxDiff=1e-3f;
  final int lastDoc[]={-1};
  final LeafReader lastReader[]={null};
  final List<LeafReaderContext> context=s.getTopReaderContext().leaves();
  s.search(q,new SimpleCollector(){
    private Scorer scorer;
    private int leafPtr;
    @Override public void setScorer(    Scorer scorer){
      this.scorer=scorer;
    }
    @Override public void collect(    int doc) throws IOException {
      float score=scorer.score();
      try {
        long startMS=System.currentTimeMillis();
        for (int i=lastDoc[0] + 1; i <= doc; i++) {
          Weight w=s.createNormalizedWeight(q,true);
          Scorer scorer=w.scorer(context.get(leafPtr));
          Assert.assertTrue("query collected " + doc + " but advance("+ i+ ") says no more docs!",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);
          Assert.assertEquals("query collected " + doc + " but advance("+ i+ ") got to "+ scorer.docID(),doc,scorer.docID());
          float advanceScore=scorer.score();
          Assert.assertEquals("unstable advance(" + i + ") score!",advanceScore,scorer.score(),maxDiff);
          Assert.assertEquals("query assigned doc " + doc + " a score of <"+ score+ "> but advance("+ i+ ") has <"+ advanceScore+ ">!",score,advanceScore,maxDiff);
          if (i < doc && System.currentTimeMillis() - startMS > 5) {
            i=doc - 1;
          }
        }
        lastDoc[0]=doc;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public boolean needsScores(){
      return true;
    }
    @Override protected void doSetNextReader(    LeafReaderContext context) throws IOException {
      if (lastReader[0] != null) {
        final LeafReader previousReader=lastReader[0];
        IndexSearcher indexSearcher=LuceneTestCase.newSearcher(previousReader);
        indexSearcher.setSimilarity(s.getSimilarity(true));
        Weight w=indexSearcher.createNormalizedWeight(q,true);
        Scorer scorer=w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());
        if (scorer != null) {
          DocIdSetIterator iterator=scorer.iterator();
          boolean more=false;
          final Bits liveDocs=context.reader().getLiveDocs();
          for (int d=iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d=iterator.nextDoc()) {
            if (liveDocs == null || liveDocs.get(d)) {
              more=true;
              break;
            }
          }
          Assert.assertFalse("query's last doc was " + lastDoc[0] + " but advance("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
        }
        leafPtr++;
      }
      lastReader[0]=context.reader();
      lastDoc[0]=-1;
    }
  }
);
  if (lastReader[0] != null) {
    final LeafReader previousReader=lastReader[0];
    IndexSearcher indexSearcher=LuceneTestCase.newSearcher(previousReader);
    indexSearcher.setSimilarity(s.getSimilarity(true));
    Weight w=indexSearcher.createNormalizedWeight(q,true);
    Scorer scorer=w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());
    if (scorer != null) {
      DocIdSetIterator iterator=scorer.iterator();
      boolean more=false;
      final Bits liveDocs=lastReader[0].getLiveDocs();
      for (int d=iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d=iterator.nextDoc()) {
        if (liveDocs == null || liveDocs.get(d)) {
          more=true;
          break;
        }
      }
      Assert.assertFalse("query's last doc was " + lastDoc[0] + " but advance("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
    }
  }
}
