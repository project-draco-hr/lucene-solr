{
  final float maxDiff=1e-3f;
  final int lastDoc[]={-1};
  final AtomicReader lastReader[]={null};
  final List<AtomicReaderContext> context=s.getTopReaderContext().leaves();
  s.search(q,new Collector(){
    private Scorer scorer;
    private int leafPtr;
    private Bits liveDocs;
    @Override public void setScorer(    Scorer scorer) throws IOException {
      this.scorer=scorer;
    }
    @Override public void collect(    int doc) throws IOException {
      float score=scorer.score();
      try {
        long startMS=System.currentTimeMillis();
        for (int i=lastDoc[0] + 1; i <= doc; i++) {
          Weight w=s.createNormalizedWeight(q);
          Scorer scorer=w.scorer(context.get(leafPtr),true,false,liveDocs);
          Assert.assertTrue("query collected " + doc + " but skipTo("+ i+ ") says no more docs!",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);
          Assert.assertEquals("query collected " + doc + " but skipTo("+ i+ ") got to "+ scorer.docID(),doc,scorer.docID());
          float skipToScore=scorer.score();
          Assert.assertEquals("unstable skipTo(" + i + ") score!",skipToScore,scorer.score(),maxDiff);
          Assert.assertEquals("query assigned doc " + doc + " a score of <"+ score+ "> but skipTo("+ i+ ") has <"+ skipToScore+ ">!",score,skipToScore,maxDiff);
          if (i < doc && System.currentTimeMillis() - startMS > 5) {
            i=doc - 1;
          }
        }
        lastDoc[0]=doc;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void setNextReader(    AtomicReaderContext context) throws IOException {
      if (lastReader[0] != null) {
        final AtomicReader previousReader=lastReader[0];
        IndexSearcher indexSearcher=LuceneTestCase.newSearcher(previousReader);
        indexSearcher.setSimilarity(s.getSimilarity());
        Weight w=indexSearcher.createNormalizedWeight(q);
        Scorer scorer=w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(),true,false,previousReader.getLiveDocs());
        if (scorer != null) {
          boolean more=scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
          Assert.assertFalse("query's last doc was " + lastDoc[0] + " but skipTo("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
        }
        leafPtr++;
      }
      lastReader[0]=context.reader();
      lastDoc[0]=-1;
      liveDocs=context.reader().getLiveDocs();
    }
    @Override public boolean acceptsDocsOutOfOrder(){
      return false;
    }
  }
);
  if (lastReader[0] != null) {
    final AtomicReader previousReader=lastReader[0];
    IndexSearcher indexSearcher=LuceneTestCase.newSearcher(previousReader);
    indexSearcher.setSimilarity(s.getSimilarity());
    Weight w=indexSearcher.createNormalizedWeight(q);
    Scorer scorer=w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(),true,false,previousReader.getLiveDocs());
    if (scorer != null) {
      boolean more=scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
      Assert.assertFalse("query's last doc was " + lastDoc[0] + " but skipTo("+ (lastDoc[0] + 1)+ ") got to "+ scorer.docID(),more);
    }
  }
}
