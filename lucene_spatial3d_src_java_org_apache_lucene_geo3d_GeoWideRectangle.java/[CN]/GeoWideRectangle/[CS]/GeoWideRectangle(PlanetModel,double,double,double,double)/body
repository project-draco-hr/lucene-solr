{
  super(planetModel);
  if (topLat > Math.PI * 0.5 || topLat < -Math.PI * 0.5)   throw new IllegalArgumentException("Top latitude out of range");
  if (bottomLat > Math.PI * 0.5 || bottomLat < -Math.PI * 0.5)   throw new IllegalArgumentException("Bottom latitude out of range");
  if (topLat < bottomLat)   throw new IllegalArgumentException("Top latitude less than bottom latitude");
  if (leftLon < -Math.PI || leftLon > Math.PI)   throw new IllegalArgumentException("Left longitude out of range");
  if (rightLon < -Math.PI || rightLon > Math.PI)   throw new IllegalArgumentException("Right longitude out of range");
  double extent=rightLon - leftLon;
  if (extent < 0.0) {
    extent+=2.0 * Math.PI;
  }
  if (extent < Math.PI)   throw new IllegalArgumentException("Width of rectangle too small");
  this.topLat=topLat;
  this.bottomLat=bottomLat;
  this.leftLon=leftLon;
  this.rightLon=rightLon;
  final double sinTopLat=Math.sin(topLat);
  final double cosTopLat=Math.cos(topLat);
  final double sinBottomLat=Math.sin(bottomLat);
  final double cosBottomLat=Math.cos(bottomLat);
  final double sinLeftLon=Math.sin(leftLon);
  final double cosLeftLon=Math.cos(leftLon);
  final double sinRightLon=Math.sin(rightLon);
  final double cosRightLon=Math.cos(rightLon);
  this.ULHC=new GeoPoint(planetModel,sinTopLat,sinLeftLon,cosTopLat,cosLeftLon);
  this.URHC=new GeoPoint(planetModel,sinTopLat,sinRightLon,cosTopLat,cosRightLon);
  this.LRHC=new GeoPoint(planetModel,sinBottomLat,sinRightLon,cosBottomLat,cosRightLon);
  this.LLHC=new GeoPoint(planetModel,sinBottomLat,sinLeftLon,cosBottomLat,cosLeftLon);
  final double middleLat=(topLat + bottomLat) * 0.5;
  final double sinMiddleLat=Math.sin(middleLat);
  this.cosMiddleLat=Math.cos(middleLat);
  while (leftLon > rightLon) {
    rightLon+=Math.PI * 2.0;
  }
  final double middleLon=(leftLon + rightLon) * 0.5;
  final double sinMiddleLon=Math.sin(middleLon);
  final double cosMiddleLon=Math.cos(middleLon);
  this.centerPoint=new GeoPoint(planetModel,sinMiddleLat,sinMiddleLon,cosMiddleLat,cosMiddleLon);
  this.topPlane=new SidedPlane(centerPoint,planetModel,sinTopLat);
  this.bottomPlane=new SidedPlane(centerPoint,planetModel,sinBottomLat);
  this.leftPlane=new SidedPlane(centerPoint,cosLeftLon,sinLeftLon);
  this.rightPlane=new SidedPlane(centerPoint,cosRightLon,sinRightLon);
  this.topPlanePoints=new GeoPoint[]{ULHC,URHC};
  this.bottomPlanePoints=new GeoPoint[]{LLHC,LRHC};
  this.leftPlanePoints=new GeoPoint[]{ULHC,LLHC};
  this.rightPlanePoints=new GeoPoint[]{URHC,LRHC};
  this.eitherBound=new EitherBound();
  this.edgePoints=new GeoPoint[]{ULHC};
}
