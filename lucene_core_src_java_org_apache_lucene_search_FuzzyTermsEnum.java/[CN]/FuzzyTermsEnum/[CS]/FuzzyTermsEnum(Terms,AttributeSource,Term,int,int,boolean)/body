{
  if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {
    throw new IllegalArgumentException("max edits must be 0.." + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE + ", inclusive; got: "+ maxEdits);
  }
  if (prefixLength < 0) {
    throw new IllegalArgumentException("prefixLength cannot be less than 0");
  }
  this.maxEdits=maxEdits;
  this.terms=terms;
  this.term=term;
  final String utf16=term.text();
  this.termText=new int[utf16.codePointCount(0,utf16.length())];
  for (int cp, i=0, j=0; i < utf16.length(); i+=Character.charCount(cp)) {
    termText[j++]=cp=utf16.codePointAt(i);
  }
  this.termLength=termText.length;
  this.dfaAtt=atts.addAttribute(LevenshteinAutomataAttribute.class);
  this.maxBoostAtt=atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);
  this.boostAtt=attributes().addAttribute(BoostAttribute.class);
  this.realPrefixLength=prefixLength > termLength ? termLength : prefixLength;
  this.transpositions=transpositions;
  CompiledAutomaton[] prevAutomata=dfaAtt.automata();
  if (prevAutomata == null) {
    prevAutomata=new CompiledAutomaton[maxEdits + 1];
    LevenshteinAutomata builder=new LevenshteinAutomata(UnicodeUtil.newString(termText,realPrefixLength,termText.length - realPrefixLength),transpositions);
    String prefix=UnicodeUtil.newString(termText,0,realPrefixLength);
    for (int i=0; i <= maxEdits; i++) {
      Automaton a=builder.toAutomaton(i,prefix);
      prevAutomata[i]=new CompiledAutomaton(a,true,false);
    }
    dfaAtt.setAutomata(prevAutomata);
  }
  this.automata=prevAutomata;
  bottom=maxBoostAtt.getMaxNonCompetitiveBoost();
  bottomTerm=maxBoostAtt.getCompetitiveTerm();
  bottomChanged(null);
}
