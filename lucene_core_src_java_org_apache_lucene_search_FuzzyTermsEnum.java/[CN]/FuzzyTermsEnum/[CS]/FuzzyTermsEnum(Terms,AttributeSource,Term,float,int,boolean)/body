{
  if (minSimilarity >= 1.0f && minSimilarity != (int)minSimilarity)   throw new IllegalArgumentException("fractional edit distances are not allowed");
  if (minSimilarity < 0.0f)   throw new IllegalArgumentException("minimumSimilarity cannot be less than 0");
  if (prefixLength < 0)   throw new IllegalArgumentException("prefixLength cannot be less than 0");
  this.terms=terms;
  this.term=term;
  final String utf16=term.text();
  this.termText=new int[utf16.codePointCount(0,utf16.length())];
  for (int cp, i=0, j=0; i < utf16.length(); i+=Character.charCount(cp))   termText[j++]=cp=utf16.codePointAt(i);
  this.termLength=termText.length;
  this.dfaAtt=atts.addAttribute(LevenshteinAutomataAttribute.class);
  this.realPrefixLength=prefixLength > termLength ? termLength : prefixLength;
  if (minSimilarity >= 1f) {
    this.minSimilarity=1 - (minSimilarity + 1) / this.termLength;
    maxEdits=(int)minSimilarity;
    raw=true;
  }
 else {
    this.minSimilarity=minSimilarity;
    maxEdits=initialMaxDistance(this.minSimilarity,termLength);
    raw=false;
  }
  if (transpositions && maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {
    throw new UnsupportedOperationException("with transpositions enabled, distances > " + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE + " are not supported ");
  }
  this.transpositions=transpositions;
  this.scale_factor=1.0f / (1.0f - this.minSimilarity);
  this.maxBoostAtt=atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);
  bottom=maxBoostAtt.getMaxNonCompetitiveBoost();
  bottomTerm=maxBoostAtt.getCompetitiveTerm();
  bottomChanged(null,true);
}
