{
  super(planetModel);
  if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)   throw new IllegalArgumentException("Latitude out of bounds");
  if (lon < -Math.PI || lon > Math.PI)   throw new IllegalArgumentException("Longitude out of bounds");
  if (cutoffAngle <= 0.0 || cutoffAngle > Math.PI)   throw new IllegalArgumentException("Cutoff angle out of bounds");
  final double cosAngle=Math.cos(cutoffAngle);
  this.center=new GeoPoint(planetModel,lat,lon);
  this.cutoffAngle=cutoffAngle;
  double upperLat=lat + cutoffAngle;
  double upperLon=lon;
  if (upperLat > Math.PI * 0.5) {
    upperLon+=Math.PI;
    if (upperLon > Math.PI)     upperLon-=2.0 * Math.PI;
    upperLat=Math.PI - upperLat;
  }
  double lowerLat=lat - cutoffAngle;
  double lowerLon=lon;
  if (lowerLat < -Math.PI * 0.5) {
    lowerLon+=Math.PI;
    if (lowerLon > Math.PI)     lowerLon-=2.0 * Math.PI;
    lowerLat=-Math.PI - lowerLat;
  }
  final GeoPoint upperPoint=new GeoPoint(planetModel,upperLat,upperLon);
  final GeoPoint lowerPoint=new GeoPoint(planetModel,lowerLat,lowerLon);
  final Plane normalPlane=new Plane(upperPoint,center);
  this.circlePlane=SidedPlane.constructNormalizedPerpendicularSidedPlane(center,normalPlane,upperPoint,lowerPoint);
  if (circlePlane == null)   throw new RuntimeException("Couldn't construct circle plane.  Cutoff angle = " + cutoffAngle + "; upperPoint = "+ upperPoint+ "; lowerPoint = "+ lowerPoint);
  if (cutoffAngle == Math.PI)   this.edgePoints=new GeoPoint[0];
 else {
    this.edgePoints=new GeoPoint[]{upperPoint};
  }
}
