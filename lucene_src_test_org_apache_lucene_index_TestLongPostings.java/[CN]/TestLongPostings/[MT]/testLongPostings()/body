{
  assumeFalse("Too slow with SimpleText codec",CodecProvider.getDefault().getFieldCodec("field").equals("SimpleText"));
  Directory dir=newFSDirectory(new File(LuceneTestCase.TEMP_DIR,"longpostings" + "." + random.nextLong()));
  final int NUM_DOCS=(int)((TEST_NIGHTLY ? 4e6 : (RANDOM_MULTIPLIER * 2e4)) * (1 + random.nextDouble()));
  if (VERBOSE) {
    System.out.println("TEST: NUM_DOCS=" + NUM_DOCS);
  }
  final String s1=getRandomTerm(null);
  final String s2=getRandomTerm(s1);
  if (VERBOSE) {
    System.out.println("\nTEST: s1=" + s1 + " s2="+ s2);
  }
  final OpenBitSet isS1=new OpenBitSet(NUM_DOCS);
  for (int idx=0; idx < NUM_DOCS; idx++) {
    if (random.nextBoolean()) {
      isS1.set(idx);
    }
  }
  final IndexReader r;
  if (true) {
    final IndexWriterConfig iwc=newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE).setMergePolicy(newLogMergePolicy());
    iwc.setRAMBufferSizeMB(16.0 + 16.0 * random.nextDouble());
    iwc.setMaxBufferedDocs(-1);
    final RandomIndexWriter riw=new RandomIndexWriter(random,dir,iwc);
    for (int idx=0; idx < NUM_DOCS; idx++) {
      final Document doc=new Document();
      String s=isS1.get(idx) ? s1 : s2;
      final Field f=newField("field",s,Field.Index.ANALYZED);
      final int count=_TestUtil.nextInt(random,1,4);
      for (int ct=0; ct < count; ct++) {
        doc.add(f);
      }
      riw.addDocument(doc);
    }
    r=riw.getReader();
    riw.close();
  }
 else {
    r=IndexReader.open(dir);
  }
  assertEquals(NUM_DOCS,r.numDocs());
  assertTrue(r.docFreq(new Term("field",s1)) > 0);
  assertTrue(r.docFreq(new Term("field",s2)) > 0);
  for (int iter=0; iter < 1000 * RANDOM_MULTIPLIER; iter++) {
    final String term;
    final boolean doS1;
    if (random.nextBoolean()) {
      term=s1;
      doS1=true;
    }
 else {
      term=s2;
      doS1=false;
    }
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " doS1="+ doS1);
    }
    final DocsAndPositionsEnum postings=MultiFields.getTermPositionsEnum(r,null,"field",new BytesRef(term));
    int docID=-1;
    while (docID < DocsEnum.NO_MORE_DOCS) {
      final int what=random.nextInt(3);
      if (what == 0) {
        if (VERBOSE) {
          System.out.println("TEST: docID=" + docID + "; do next()");
        }
        int expected=docID + 1;
        while (true) {
          if (expected == NUM_DOCS) {
            expected=Integer.MAX_VALUE;
            break;
          }
 else           if (isS1.get(expected) == doS1) {
            break;
          }
 else {
            expected++;
          }
        }
        docID=postings.nextDoc();
        if (VERBOSE) {
          System.out.println("  got docID=" + docID);
        }
        assertEquals(expected,docID);
        if (docID == DocsEnum.NO_MORE_DOCS) {
          break;
        }
        if (random.nextInt(6) == 3) {
          final int freq=postings.freq();
          assertTrue(freq >= 1 && freq <= 4);
          for (int pos=0; pos < freq; pos++) {
            assertEquals(pos,postings.nextPosition());
            if (random.nextBoolean() && postings.hasPayload()) {
              postings.getPayload();
            }
          }
        }
      }
 else {
        final int targetDocID;
        if (docID == -1) {
          targetDocID=random.nextInt(NUM_DOCS + 1);
        }
 else {
          targetDocID=docID + _TestUtil.nextInt(random,1,NUM_DOCS - docID);
        }
        if (VERBOSE) {
          System.out.println("TEST: docID=" + docID + "; do advance("+ targetDocID+ ")");
        }
        int expected=targetDocID;
        while (true) {
          if (expected == NUM_DOCS) {
            expected=Integer.MAX_VALUE;
            break;
          }
 else           if (isS1.get(expected) == doS1) {
            break;
          }
 else {
            expected++;
          }
        }
        docID=postings.advance(targetDocID);
        if (VERBOSE) {
          System.out.println("  got docID=" + docID);
        }
        assertEquals(expected,docID);
        if (docID == DocsEnum.NO_MORE_DOCS) {
          break;
        }
        if (random.nextInt(6) == 3) {
          final int freq=postings.freq();
          assertTrue(freq >= 1 && freq <= 4);
          for (int pos=0; pos < freq; pos++) {
            assertEquals(pos,postings.nextPosition());
            if (random.nextBoolean() && postings.hasPayload()) {
              postings.getPayload();
            }
          }
        }
      }
    }
  }
  r.close();
  dir.close();
}
