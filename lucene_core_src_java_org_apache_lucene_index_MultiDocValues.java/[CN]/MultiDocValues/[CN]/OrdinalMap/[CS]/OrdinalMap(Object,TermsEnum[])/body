{
  this.owner=owner;
  globalOrdDeltas=new MonotonicAppendingLongBuffer(PackedInts.COMPACT);
  firstSegments=new AppendingPackedLongBuffer(PackedInts.COMPACT);
  ordDeltas=new MonotonicAppendingLongBuffer[subs.length];
  for (int i=0; i < ordDeltas.length; i++) {
    ordDeltas[i]=new MonotonicAppendingLongBuffer();
  }
  long segmentOrds[]=new long[subs.length];
  ReaderSlice slices[]=new ReaderSlice[subs.length];
  TermsEnumIndex indexes[]=new TermsEnumIndex[slices.length];
  for (int i=0; i < slices.length; i++) {
    slices[i]=new ReaderSlice(0,0,i);
    indexes[i]=new TermsEnumIndex(subs[i],i);
  }
  MultiTermsEnum mte=new MultiTermsEnum(slices);
  mte.reset(indexes);
  long globalOrd=0;
  while (mte.next() != null) {
    TermsEnumWithSlice matches[]=mte.getMatchArray();
    for (int i=0; i < mte.getMatchCount(); i++) {
      int segmentIndex=matches[i].index;
      long segmentOrd=matches[i].terms.ord();
      long delta=globalOrd - segmentOrd;
      if (i == 0) {
        firstSegments.add(segmentIndex);
        globalOrdDeltas.add(delta);
      }
      while (segmentOrds[segmentIndex] <= segmentOrd) {
        ordDeltas[segmentIndex].add(delta);
        segmentOrds[segmentIndex]++;
      }
    }
    globalOrd++;
  }
  firstSegments.freeze();
  globalOrdDeltas.freeze();
  for (int i=0; i < ordDeltas.length; ++i) {
    ordDeltas[i].freeze();
  }
}
