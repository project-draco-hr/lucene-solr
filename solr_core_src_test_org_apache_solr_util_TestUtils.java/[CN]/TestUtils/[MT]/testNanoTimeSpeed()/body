{
  final int maxNumThreads=100;
  final int numIters=1000;
  if (VERBOSE)   log.info("testNanoTime: maxNumThreads = {}, numIters = {}",maxNumThreads,numIters);
  final ExecutorService workers=Executors.newCachedThreadPool(new DefaultSolrThreadFactory("nanoTimeTestThread"));
  for (int numThreads=1; numThreads <= maxNumThreads; numThreads++) {
    List<Callable<Long>> tasks=new ArrayList<>();
    for (int i=0; i < numThreads; i++) {
      tasks.add(new Callable<Long>(){
        @Override public Long call(){
          final long startTime=System.nanoTime();
          for (int i=0; i < numIters; i++) {
            System.nanoTime();
          }
          return System.nanoTime() - startTime;
        }
      }
);
    }
    try {
      List<Future<Long>> results=workers.invokeAll(tasks);
      long totalTime=0;
      for (      Future<Long> res : results) {
        totalTime+=res.get();
      }
      long timePerIter=totalTime / (numIters * numThreads);
      assertTrue("Time taken for System.nanoTime is too high",timePerIter < 10000);
      if (VERBOSE)       log.info("numThreads = {}, time_per_call = {}ns",numThreads,timePerIter);
    }
 catch (    InterruptedException|ExecutionException ignored) {
    }
  }
  ExecutorUtil.shutdownAndAwaitTermination(workers);
}
