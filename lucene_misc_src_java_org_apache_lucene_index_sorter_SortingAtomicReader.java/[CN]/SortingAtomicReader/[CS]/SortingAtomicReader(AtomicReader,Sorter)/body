{
  super(in);
  old2new=sorter.oldToNew(in);
  if (old2new.length != in.maxDoc()) {
    throw new IllegalArgumentException("sorter should provide mapping for every document in the index, including deleted ones");
  }
  new2old=new int[old2new.length];
  for (int i=0; i < new2old.length; i++) {
    new2old[old2new[i]]=i;
  }
  if (!in.hasDeletions()) {
    mappedLiveDocs=null;
  }
 else {
    mappedLiveDocs=new FixedBitSet(in.maxDoc());
    mappedLiveDocs.set(0,in.maxDoc());
    Bits liveDocs=in.getLiveDocs();
    int len=liveDocs.length();
    for (int i=0; i < len; i++) {
      if (!liveDocs.get(i)) {
        mappedLiveDocs.clear(old2new[i]);
      }
    }
  }
}
