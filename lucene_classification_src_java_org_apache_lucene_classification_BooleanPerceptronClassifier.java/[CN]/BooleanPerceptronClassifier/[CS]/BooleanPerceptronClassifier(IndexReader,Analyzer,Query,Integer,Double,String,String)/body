{
  this.textTerms=MultiFields.getTerms(indexReader,textFieldName);
  if (textTerms == null) {
    throw new IOException("term vectors need to be available for field " + textFieldName);
  }
  this.analyzer=analyzer;
  this.textFieldName=textFieldName;
  if (threshold == null || threshold == 0d) {
    long sumDocFreq=indexReader.getSumDocFreq(textFieldName);
    if (sumDocFreq != -1) {
      this.threshold=(double)sumDocFreq / 2d;
    }
 else {
      throw new IOException("threshold cannot be assigned since term vectors for field " + textFieldName + " do not exist");
    }
  }
 else {
    this.threshold=threshold;
  }
  SortedMap<String,Double> weights=new ConcurrentSkipListMap<>();
  TermsEnum termsEnum=textTerms.iterator();
  BytesRef textTerm;
  while ((textTerm=termsEnum.next()) != null) {
    weights.put(textTerm.utf8ToString(),(double)termsEnum.totalTermFreq());
  }
  updateFST(weights);
  IndexSearcher indexSearcher=new IndexSearcher(indexReader);
  int batchCount=0;
  BooleanQuery.Builder q=new BooleanQuery.Builder();
  q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName,"*")),BooleanClause.Occur.MUST));
  if (query != null) {
    q.add(new BooleanClause(query,BooleanClause.Occur.MUST));
  }
  for (  ScoreDoc scoreDoc : indexSearcher.search(q.build(),Integer.MAX_VALUE).scoreDocs) {
    Document doc=indexSearcher.doc(scoreDoc.doc);
    IndexableField textField=doc.getField(textFieldName);
    IndexableField classField=doc.getField(classFieldName);
    if (textField != null && classField != null) {
      ClassificationResult<Boolean> classificationResult=assignClass(textField.stringValue());
      Boolean assignedClass=classificationResult.getAssignedClass();
      Boolean correctClass=Boolean.valueOf(classField.stringValue());
      long modifier=correctClass.compareTo(assignedClass);
      if (modifier != 0) {
        updateWeights(indexReader,scoreDoc.doc,assignedClass,weights,modifier,batchCount % batchSize == 0);
      }
      batchCount++;
    }
  }
  weights.clear();
}
