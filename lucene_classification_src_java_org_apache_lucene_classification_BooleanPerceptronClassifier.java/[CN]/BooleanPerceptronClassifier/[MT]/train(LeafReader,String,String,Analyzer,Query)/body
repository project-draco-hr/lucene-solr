{
  this.textTerms=MultiFields.getTerms(leafReader,textFieldName);
  if (textTerms == null) {
    throw new IOException("term vectors need to be available for field " + textFieldName);
  }
  this.analyzer=analyzer;
  this.textFieldName=textFieldName;
  if (threshold == null || threshold == 0d) {
    long sumDocFreq=leafReader.getSumDocFreq(textFieldName);
    if (sumDocFreq != -1) {
      this.threshold=(double)sumDocFreq / 2d;
    }
 else {
      throw new IOException("threshold cannot be assigned since term vectors for field " + textFieldName + " do not exist");
    }
  }
  SortedMap<String,Double> weights=new ConcurrentSkipListMap<>();
  TermsEnum termsEnum=textTerms.iterator();
  BytesRef textTerm;
  while ((textTerm=termsEnum.next()) != null) {
    weights.put(textTerm.utf8ToString(),(double)termsEnum.totalTermFreq());
  }
  updateFST(weights);
  IndexSearcher indexSearcher=new IndexSearcher(leafReader);
  int batchCount=0;
  BooleanQuery q=new BooleanQuery();
  q.add(new BooleanClause(new WildcardQuery(new Term(classFieldName,"*")),BooleanClause.Occur.MUST));
  if (query != null) {
    q.add(new BooleanClause(query,BooleanClause.Occur.MUST));
  }
  for (  ScoreDoc scoreDoc : indexSearcher.search(q,Integer.MAX_VALUE).scoreDocs) {
    StoredDocument doc=indexSearcher.doc(scoreDoc.doc);
    ClassificationResult<Boolean> classificationResult=assignClass(doc.getField(textFieldName).stringValue());
    Boolean assignedClass=classificationResult.getAssignedClass();
    StorableField field=doc.getField(classFieldName);
    Boolean correctClass=Boolean.valueOf(field.stringValue());
    long modifier=correctClass.compareTo(assignedClass);
    if (modifier != 0) {
      updateWeights(leafReader,scoreDoc.doc,assignedClass,weights,modifier,batchCount % batchSize == 0);
    }
    batchCount++;
  }
  weights.clear();
}
