{
  Random random=new Random(random().nextLong());
  final BaseDirectoryWrapper dir=newDirectory();
  final LineFileDocs docs=new LineFileDocs(random,true);
  if (random().nextBoolean()) {
    Codec.setDefault(TestUtil.alwaysPostingsFormat(new MemoryPostingsFormat(random().nextBoolean(),random.nextFloat())));
  }
  MockAnalyzer analyzer=new MockAnalyzer(random());
  analyzer.setMaxTokenLength(TestUtil.nextInt(random(),1,IndexWriter.MAX_TERM_LENGTH));
  final IndexWriter w=new IndexWriter(dir,newIndexWriterConfig(analyzer));
  final int SIZE=atLeast(20);
  int id=0;
  IndexReader r=null;
  IndexSearcher s=null;
  final int numUpdates=(int)(SIZE * (2 + (TEST_NIGHTLY ? 200 * random().nextDouble() : 5 * random().nextDouble())));
  if (VERBOSE) {
    System.out.println("TEST: numUpdates=" + numUpdates);
  }
  int updateCount=0;
  for (int docIter=0; docIter < numUpdates; docIter++) {
    final Document doc=docs.nextDoc();
    final String myID=Integer.toString(id);
    if (id == SIZE - 1) {
      id=0;
    }
 else {
      id++;
    }
    if (VERBOSE) {
      System.out.println("  docIter=" + docIter + " id="+ id);
    }
    doc.getField("docid").setStringValue(myID);
    Term idTerm=new Term("docid",myID);
    final boolean doUpdate;
    if (s != null && updateCount < SIZE) {
      TopDocs hits=s.search(new TermQuery(idTerm),1);
      assertEquals(1,hits.totalHits);
      doUpdate=!w.tryDeleteDocument(r,hits.scoreDocs[0].doc);
      if (VERBOSE) {
        if (doUpdate) {
          System.out.println("  tryDeleteDocument failed");
        }
 else {
          System.out.println("  tryDeleteDocument succeeded");
        }
      }
    }
 else {
      doUpdate=true;
      if (VERBOSE) {
        System.out.println("  no searcher: doUpdate=true");
      }
    }
    updateCount++;
    if (doUpdate) {
      w.updateDocument(idTerm,doc);
    }
 else {
      w.addDocument(doc);
    }
    if (docIter >= SIZE && random().nextInt(50) == 17) {
      if (r != null) {
        r.close();
      }
      final boolean applyDeletions=random().nextBoolean();
      if (VERBOSE) {
        System.out.println("TEST: reopen applyDeletions=" + applyDeletions);
      }
      r=w.getReader(applyDeletions);
      if (applyDeletions) {
        s=newSearcher(r);
      }
 else {
        s=null;
      }
      assertTrue("applyDeletions=" + applyDeletions + " r.numDocs()="+ r.numDocs()+ " vs SIZE="+ SIZE,!applyDeletions || r.numDocs() == SIZE);
      updateCount=0;
    }
  }
  if (r != null) {
    r.close();
  }
  w.commit();
  assertEquals(SIZE,w.numDocs());
  w.shutdown();
  TestIndexWriter.assertNoUnreferencedFiles(dir,"leftover files after rolling updates");
  docs.close();
  SegmentInfos infos=new SegmentInfos();
  infos.read(dir);
  long totalBytes=0;
  for (  SegmentCommitInfo sipc : infos) {
    totalBytes+=sipc.sizeInBytes();
  }
  long totalBytes2=0;
  for (  String fileName : dir.listAll()) {
    if (!fileName.startsWith(IndexFileNames.SEGMENTS)) {
      totalBytes2+=dir.fileLength(fileName);
    }
  }
  assertEquals(totalBytes2,totalBytes);
  dir.close();
}
