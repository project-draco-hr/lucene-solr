{
  TokenStream source=analyzer.tokenStream(field,new StringReader(queryText));
  Vector v=new Vector();
  final org.apache.lucene.analysis.Token reusableToken=new org.apache.lucene.analysis.Token();
  org.apache.lucene.analysis.Token nextToken;
  int positionCount=0;
  boolean severalTokensAtSamePosition=false;
  while (true) {
    try {
      nextToken=source.next(reusableToken);
    }
 catch (    IOException e) {
      nextToken=null;
    }
    if (nextToken == null)     break;
    v.addElement(nextToken.clone());
    if (nextToken.getPositionIncrement() != 0)     positionCount+=nextToken.getPositionIncrement();
 else     severalTokensAtSamePosition=true;
  }
  try {
    source.close();
  }
 catch (  IOException e) {
  }
  if (v.size() == 0)   return null;
 else   if (v.size() == 1) {
    nextToken=(org.apache.lucene.analysis.Token)v.elementAt(0);
    return new TermQuery(new Term(field,nextToken.term()));
  }
 else {
    if (severalTokensAtSamePosition) {
      if (positionCount == 1) {
        BooleanQuery q=new BooleanQuery(true);
        for (int i=0; i < v.size(); i++) {
          nextToken=(org.apache.lucene.analysis.Token)v.elementAt(i);
          TermQuery currentQuery=new TermQuery(new Term(field,nextToken.term()));
          q.add(currentQuery,BooleanClause.Occur.SHOULD);
        }
        return q;
      }
 else {
        MultiPhraseQuery mpq=new MultiPhraseQuery();
        mpq.setSlop(phraseSlop);
        List multiTerms=new ArrayList();
        int position=-1;
        for (int i=0; i < v.size(); i++) {
          nextToken=(org.apache.lucene.analysis.Token)v.elementAt(i);
          if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {
            if (enablePositionIncrements) {
              mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
            }
 else {
              mpq.add((Term[])multiTerms.toArray(new Term[0]));
            }
            multiTerms.clear();
          }
          position+=nextToken.getPositionIncrement();
          multiTerms.add(new Term(field,nextToken.term()));
        }
        if (enablePositionIncrements) {
          mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
        }
 else {
          mpq.add((Term[])multiTerms.toArray(new Term[0]));
        }
        return mpq;
      }
    }
 else {
      PhraseQuery pq=new PhraseQuery();
      pq.setSlop(phraseSlop);
      int position=-1;
      for (int i=0; i < v.size(); i++) {
        nextToken=(org.apache.lucene.analysis.Token)v.elementAt(i);
        if (enablePositionIncrements) {
          position+=nextToken.getPositionIncrement();
          pq.add(new Term(field,nextToken.term()),position);
        }
 else {
          pq.add(new Term(field,nextToken.term()));
        }
      }
      return pq;
    }
  }
}
