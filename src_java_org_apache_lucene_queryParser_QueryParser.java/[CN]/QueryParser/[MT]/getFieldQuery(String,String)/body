{
  TokenStream source=analyzer.tokenStream(field,new StringReader(queryText));
  Vector v=new Vector();
  org.apache.lucene.analysis.Token t;
  int positionCount=0;
  boolean severalTokensAtSamePosition=false;
  while (true) {
    try {
      t=source.next();
    }
 catch (    IOException e) {
      t=null;
    }
    if (t == null)     break;
    v.addElement(t);
    if (t.getPositionIncrement() == 1)     positionCount++;
 else     severalTokensAtSamePosition=true;
  }
  try {
    source.close();
  }
 catch (  IOException e) {
  }
  if (v.size() == 0)   return null;
 else   if (v.size() == 1) {
    t=(org.apache.lucene.analysis.Token)v.elementAt(0);
    return new TermQuery(new Term(field,t.termText()));
  }
 else {
    if (severalTokensAtSamePosition) {
      if (positionCount == 1) {
        BooleanQuery q=new BooleanQuery();
        for (int i=0; i < v.size(); i++) {
          t=(org.apache.lucene.analysis.Token)v.elementAt(i);
          TermQuery currentQuery=new TermQuery(new Term(field,t.termText()));
          q.add(currentQuery,BooleanClause.Occur.SHOULD);
        }
        return q;
      }
 else {
        MultiPhraseQuery mpq=new MultiPhraseQuery();
        List multiTerms=new ArrayList();
        for (int i=0; i < v.size(); i++) {
          t=(org.apache.lucene.analysis.Token)v.elementAt(i);
          if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {
            mpq.add((Term[])multiTerms.toArray(new Term[0]));
            multiTerms.clear();
          }
          multiTerms.add(new Term(field,t.termText()));
        }
        mpq.add((Term[])multiTerms.toArray(new Term[0]));
        return mpq;
      }
    }
 else {
      PhraseQuery q=new PhraseQuery();
      q.setSlop(phraseSlop);
      for (int i=0; i < v.size(); i++) {
        q.add(new Term(field,((org.apache.lucene.analysis.Token)v.elementAt(i)).termText()));
      }
      return q;
    }
  }
}
