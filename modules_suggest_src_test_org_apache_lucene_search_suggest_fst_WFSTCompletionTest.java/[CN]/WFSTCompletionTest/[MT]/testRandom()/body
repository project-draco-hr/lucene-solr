{
  int numWords=atLeast(1000);
  final TreeMap<String,Long> slowCompletor=new TreeMap<String,Long>();
  final TreeSet<String> allPrefixes=new TreeSet<String>();
  TermFreq[] keys=new TermFreq[numWords];
  for (int i=0; i < numWords; i++) {
    String s;
    while (true) {
      s=_TestUtil.randomSimpleString(random);
      if (!slowCompletor.containsKey(s)) {
        break;
      }
    }
    for (int j=1; j < s.length(); j++) {
      allPrefixes.add(s.substring(0,j));
    }
    int weight=random.nextInt(1 << 24);
    slowCompletor.put(s,(long)weight);
    keys[i]=new TermFreq(s,weight);
  }
  WFSTCompletionLookup suggester=new WFSTCompletionLookup(false);
  suggester.build(new TermFreqArrayIterator(keys));
  for (  String prefix : allPrefixes) {
    final int topN=_TestUtil.nextInt(random,1,10);
    List<LookupResult> r=suggester.lookup(_TestUtil.stringToCharSequence(prefix,random),false,topN);
    final List<LookupResult> matches=new ArrayList<LookupResult>();
    for (    Map.Entry<String,Long> e : slowCompletor.entrySet()) {
      if (e.getKey().startsWith(prefix)) {
        matches.add(new LookupResult(e.getKey(),e.getValue().longValue()));
      }
    }
    assertTrue(matches.size() > 0);
    Collections.sort(matches,new Comparator<LookupResult>(){
      public int compare(      LookupResult left,      LookupResult right){
        int cmp=Float.compare(right.value,left.value);
        if (cmp == 0) {
          return left.compareTo(right);
        }
 else {
          return cmp;
        }
      }
    }
);
    if (matches.size() > topN) {
      matches.subList(topN,matches.size()).clear();
    }
    assertEquals(matches.size(),r.size());
    for (int hit=0; hit < r.size(); hit++) {
      assertEquals(matches.get(hit).key.toString(),r.get(hit).key.toString());
      assertEquals(matches.get(hit).value,r.get(hit).value,0f);
    }
  }
}
