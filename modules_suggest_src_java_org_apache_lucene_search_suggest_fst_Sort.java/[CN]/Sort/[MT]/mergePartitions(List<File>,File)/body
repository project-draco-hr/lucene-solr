{
  long start=System.currentTimeMillis();
  ByteSequencesWriter out=new ByteSequencesWriter(outputFile);
  PriorityQueue<FileAndTop> queue=new PriorityQueue<FileAndTop>(merges.size()){
    protected boolean lessThan(    FileAndTop a,    FileAndTop b){
      return a.current.compareTo(b.current) < 0;
    }
  }
;
  ByteSequencesReader[] streams=new ByteSequencesReader[merges.size()];
  try {
    for (int i=0; i < merges.size(); i++) {
      streams[i]=new ByteSequencesReader(merges.get(i));
      byte line[]=streams[i].read();
      if (line != null) {
        queue.insertWithOverflow(new FileAndTop(i,line));
      }
    }
    FileAndTop top;
    while ((top=queue.top()) != null) {
      out.write(top.current);
      if (!streams[top.fd].read(top.current)) {
        queue.pop();
      }
 else {
        queue.updateTop();
      }
    }
    sortInfo.mergeTime+=System.currentTimeMillis() - start;
    sortInfo.mergeRounds++;
  }
  finally {
    try {
      IOUtils.close(streams);
    }
  finally {
      IOUtils.close(out);
    }
  }
}
