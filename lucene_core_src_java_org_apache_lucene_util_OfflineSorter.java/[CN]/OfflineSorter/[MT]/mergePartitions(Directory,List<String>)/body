{
  long start=System.currentTimeMillis();
  List<String> segmentsToMerge;
  if (segments.size() > maxTempFiles) {
    segmentsToMerge=segments.subList(segments.size() - maxTempFiles,segments.size());
  }
 else {
    segmentsToMerge=segments;
  }
  PriorityQueue<FileAndTop> queue=new PriorityQueue<FileAndTop>(segmentsToMerge.size()){
    @Override protected boolean lessThan(    FileAndTop a,    FileAndTop b){
      return comparator.compare(a.current.get(),b.current.get()) < 0;
    }
  }
;
  ByteSequencesReader[] streams=new ByteSequencesReader[segmentsToMerge.size()];
  String newSegmentName=null;
  try (IndexOutput out=trackingDir.createTempOutput(tempFileNamePrefix,"sort",IOContext.DEFAULT);ByteSequencesWriter writer=getWriter(out)){
    newSegmentName=out.getName();
    for (int i=0; i < segmentsToMerge.size(); i++) {
      streams[i]=getReader(dir.openInput(segmentsToMerge.get(i),IOContext.READONCE));
      BytesRefBuilder bytes=new BytesRefBuilder();
      boolean result=streams[i].read(bytes);
      assert result;
      queue.insertWithOverflow(new FileAndTop(i,bytes));
    }
    FileAndTop top;
    while ((top=queue.top()) != null) {
      writer.write(top.current.bytes(),0,top.current.length());
      if (!streams[top.fd].read(top.current)) {
        queue.pop();
      }
 else {
        queue.updateTop();
      }
    }
    sortInfo.mergeTime+=System.currentTimeMillis() - start;
    sortInfo.mergeRounds++;
  }
  finally {
    IOUtils.close(streams);
  }
  IOUtils.deleteFiles(trackingDir,segmentsToMerge);
  segmentsToMerge.clear();
  segments.add(newSegmentName);
  sortInfo.tempMergeFiles++;
}
