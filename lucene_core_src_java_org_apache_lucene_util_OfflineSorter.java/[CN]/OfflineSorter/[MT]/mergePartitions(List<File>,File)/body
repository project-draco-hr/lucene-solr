{
  long start=System.currentTimeMillis();
  ByteSequencesWriter out=new ByteSequencesWriter(outputFile);
  PriorityQueue<FileAndTop> queue=new PriorityQueue<FileAndTop>(merges.size()){
    @Override protected boolean lessThan(    FileAndTop a,    FileAndTop b){
      return comparator.compare(a.current.get(),b.current.get()) < 0;
    }
  }
;
  ByteSequencesReader[] streams=new ByteSequencesReader[merges.size()];
  try {
    for (int i=0; i < merges.size(); i++) {
      streams[i]=new ByteSequencesReader(merges.get(i));
      byte line[]=streams[i].read();
      if (line != null) {
        queue.insertWithOverflow(new FileAndTop(i,line));
      }
    }
    FileAndTop top;
    while ((top=queue.top()) != null) {
      out.write(top.current.bytes(),0,top.current.length());
      if (!streams[top.fd].read(top.current)) {
        queue.pop();
      }
 else {
        queue.updateTop();
      }
    }
    sortInfo.mergeTime+=System.currentTimeMillis() - start;
    sortInfo.mergeRounds++;
  }
  finally {
    try {
      IOUtils.close(streams);
    }
  finally {
      IOUtils.close(out);
    }
  }
}
