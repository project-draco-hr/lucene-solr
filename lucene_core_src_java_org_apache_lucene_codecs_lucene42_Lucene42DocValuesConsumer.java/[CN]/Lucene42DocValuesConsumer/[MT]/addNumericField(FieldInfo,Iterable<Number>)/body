{
  meta.writeVInt(field.number);
  meta.writeByte(NUMBER);
  meta.writeLong(data.getFilePointer());
  long minValue=Long.MAX_VALUE;
  long maxValue=Long.MIN_VALUE;
  HashSet<Long> uniqueValues=new HashSet<Long>();
  for (  Number nv : values) {
    long v=nv.longValue();
    minValue=Math.min(minValue,v);
    maxValue=Math.max(maxValue,v);
    if (uniqueValues != null) {
      if (uniqueValues.add(v)) {
        if (uniqueValues.size() > 256) {
          uniqueValues=null;
        }
      }
    }
  }
  final long delta=maxValue - minValue;
  if (uniqueValues != null && (delta < 0 || PackedInts.bitsRequired(uniqueValues.size() - 1) < PackedInts.bitsRequired(delta))) {
    final int bitsPerValue=PackedInts.bitsRequired(uniqueValues.size() - 1);
    meta.writeByte((byte)1);
    Long[] decode=uniqueValues.toArray(new Long[uniqueValues.size()]);
    final HashMap<Long,Integer> encode=new HashMap<Long,Integer>();
    data.writeVInt(decode.length);
    for (int i=0; i < decode.length; i++) {
      data.writeLong(decode[i]);
      encode.put(decode[i],i);
    }
    meta.writeVInt(PackedInts.VERSION_CURRENT);
    data.writeVInt(bitsPerValue);
    final PackedInts.Writer writer=PackedInts.getWriterNoHeader(data,PackedInts.Format.PACKED,maxDoc,bitsPerValue,PackedInts.DEFAULT_BUFFER_SIZE);
    for (    Number nv : values) {
      writer.add(encode.get(nv));
    }
    writer.finish();
  }
 else {
    meta.writeByte((byte)0);
    meta.writeVInt(PackedInts.VERSION_CURRENT);
    data.writeVInt(BLOCK_SIZE);
    final BlockPackedWriter writer=new BlockPackedWriter(data,BLOCK_SIZE);
    for (    Number nv : values) {
      writer.add(nv.longValue());
    }
    writer.finish();
  }
}
