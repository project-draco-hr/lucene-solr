{
  int numberOfRuns=_TestUtil.nextInt(random(),3,6);
  for (int iter=0; iter < numberOfRuns; iter++) {
    if (VERBOSE) {
      System.out.println("TEST: iter=" + iter);
    }
    final int numDocs=_TestUtil.nextInt(random(),100,1000) * RANDOM_MULTIPLIER;
    final int numGroups=_TestUtil.nextInt(random(),1,numDocs);
    if (VERBOSE) {
      System.out.println("TEST: numDocs=" + numDocs + " numGroups="+ numGroups);
    }
    final List<BytesRef> groups=new ArrayList<BytesRef>();
    for (int i=0; i < numGroups; i++) {
      String randomValue;
      do {
        randomValue=_TestUtil.randomRealisticUnicodeString(random());
      }
 while ("".equals(randomValue));
      groups.add(new BytesRef(randomValue));
    }
    final String[] contentStrings=new String[_TestUtil.nextInt(random(),2,20)];
    if (VERBOSE) {
      System.out.println("TEST: create fake content");
    }
    for (int contentIDX=0; contentIDX < contentStrings.length; contentIDX++) {
      final StringBuilder sb=new StringBuilder();
      sb.append("real").append(random().nextInt(3)).append(' ');
      final int fakeCount=random().nextInt(10);
      for (int fakeIDX=0; fakeIDX < fakeCount; fakeIDX++) {
        sb.append("fake ");
      }
      contentStrings[contentIDX]=sb.toString();
      if (VERBOSE) {
        System.out.println("  content=" + sb.toString());
      }
    }
    Directory dir=newDirectory();
    RandomIndexWriter w=new RandomIndexWriter(random(),dir,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random())));
    boolean canUseIDV=true;
    Document doc=new Document();
    Document docNoGroup=new Document();
    Field idvGroupField=new SortedDocValuesField("group_dv",new BytesRef());
    if (canUseIDV) {
      doc.add(idvGroupField);
      docNoGroup.add(idvGroupField);
    }
    Field group=newStringField("group","",Field.Store.NO);
    doc.add(group);
    Field sort1=newStringField("sort1","",Field.Store.NO);
    doc.add(sort1);
    docNoGroup.add(sort1);
    Field sort2=newStringField("sort2","",Field.Store.NO);
    doc.add(sort2);
    docNoGroup.add(sort2);
    Field content=newTextField("content","",Field.Store.NO);
    doc.add(content);
    docNoGroup.add(content);
    IntField id=new IntField("id",0,Field.Store.NO);
    doc.add(id);
    docNoGroup.add(id);
    final GroupDoc[] groupDocs=new GroupDoc[numDocs];
    for (int i=0; i < numDocs; i++) {
      final BytesRef groupValue;
      if (random().nextInt(24) == 17) {
        groupValue=null;
      }
 else {
        groupValue=groups.get(random().nextInt(groups.size()));
      }
      final GroupDoc groupDoc=new GroupDoc(i,groupValue,groups.get(random().nextInt(groups.size())),groups.get(random().nextInt(groups.size())),contentStrings[random().nextInt(contentStrings.length)]);
      if (VERBOSE) {
        System.out.println("  doc content=" + groupDoc.content + " id="+ i+ " group="+ (groupDoc.group == null ? "null" : groupDoc.group.utf8ToString())+ " sort1="+ groupDoc.sort1.utf8ToString()+ " sort2="+ groupDoc.sort2.utf8ToString());
      }
      groupDocs[i]=groupDoc;
      if (groupDoc.group != null) {
        group.setStringValue(groupDoc.group.utf8ToString());
        if (canUseIDV) {
          idvGroupField.setBytesValue(BytesRef.deepCopyOf(groupDoc.group));
        }
      }
 else       if (canUseIDV) {
        idvGroupField.setBytesValue(new BytesRef());
      }
      sort1.setStringValue(groupDoc.sort1.utf8ToString());
      sort2.setStringValue(groupDoc.sort2.utf8ToString());
      content.setStringValue(groupDoc.content);
      id.setIntValue(groupDoc.id);
      if (groupDoc.group == null) {
        w.addDocument(docNoGroup);
      }
 else {
        w.addDocument(doc);
      }
    }
    final GroupDoc[] groupDocsByID=new GroupDoc[groupDocs.length];
    System.arraycopy(groupDocs,0,groupDocsByID,0,groupDocs.length);
    final DirectoryReader r=w.getReader();
    w.close();
    final FieldCache.Ints docIDToID=FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(r),"id",false);
    DirectoryReader rBlocks=null;
    Directory dirBlocks=null;
    try {
      final IndexSearcher s=newSearcher(r);
      if (VERBOSE) {
        System.out.println("\nTEST: searcher=" + s);
      }
      if (SlowCompositeReaderWrapper.class.isAssignableFrom(s.getIndexReader().getClass())) {
        canUseIDV=false;
      }
 else {
        canUseIDV=true;
      }
      final ShardState shards=new ShardState(s);
      for (int contentID=0; contentID < 3; contentID++) {
        final ScoreDoc[] hits=s.search(new TermQuery(new Term("content","real" + contentID)),numDocs).scoreDocs;
        for (        ScoreDoc hit : hits) {
          final GroupDoc gd=groupDocs[docIDToID.get(hit.doc)];
          assertTrue(gd.score == 0.0);
          gd.score=hit.score;
          assertEquals(gd.id,docIDToID.get(hit.doc));
        }
      }
      for (      GroupDoc gd : groupDocs) {
        assertTrue(gd.score != 0.0);
      }
      dirBlocks=newDirectory();
      rBlocks=getDocBlockReader(dirBlocks,groupDocs);
      final Filter lastDocInBlock=new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("groupend","x"))));
      final FieldCache.Ints docIDToIDBlocks=FieldCache.DEFAULT.getInts(new SlowCompositeReaderWrapper(rBlocks),"id",false);
      final IndexSearcher sBlocks=newSearcher(rBlocks);
      final ShardState shardsBlocks=new ShardState(sBlocks);
      final Map<String,Map<Float,Float>> scoreMap=new HashMap<String,Map<Float,Float>>();
      for (int contentID=0; contentID < 3; contentID++) {
        final Map<Float,Float> termScoreMap=new HashMap<Float,Float>();
        scoreMap.put("real" + contentID,termScoreMap);
        final ScoreDoc[] hits=sBlocks.search(new TermQuery(new Term("content","real" + contentID)),numDocs).scoreDocs;
        for (        ScoreDoc hit : hits) {
          final GroupDoc gd=groupDocsByID[docIDToIDBlocks.get(hit.doc)];
          assertTrue(gd.score2 == 0.0);
          gd.score2=hit.score;
          assertEquals(gd.id,docIDToIDBlocks.get(hit.doc));
          termScoreMap.put(gd.score,gd.score2);
        }
      }
      for (int searchIter=0; searchIter < 100; searchIter++) {
        if (VERBOSE) {
          System.out.println("\nTEST: searchIter=" + searchIter);
        }
        final String searchTerm="real" + random().nextInt(3);
        final boolean fillFields=random().nextBoolean();
        boolean getScores=random().nextBoolean();
        final boolean getMaxScores=random().nextBoolean();
        final Sort groupSort=getRandomSort();
        final Sort docSort=getRandomSort();
        for (        SortField sf : docSort.getSort()) {
          if (sf.getType() == SortField.Type.SCORE) {
            getScores=true;
          }
        }
        for (        SortField sf : groupSort.getSort()) {
          if (sf.getType() == SortField.Type.SCORE) {
            getScores=true;
          }
        }
        final int topNGroups=_TestUtil.nextInt(random(),1,30);
        final int docsPerGroup=_TestUtil.nextInt(random(),1,50);
        final int groupOffset=_TestUtil.nextInt(random(),0,(topNGroups - 1) / 2);
        final int docOffset=_TestUtil.nextInt(random(),0,docsPerGroup - 1);
        final boolean doCache=random().nextBoolean();
        final boolean doAllGroups=random().nextBoolean();
        if (VERBOSE) {
          System.out.println("TEST: groupSort=" + groupSort + " docSort="+ docSort+ " searchTerm="+ searchTerm+ " dF="+ r.docFreq(new Term("content",searchTerm))+ " dFBlock="+ rBlocks.docFreq(new Term("content",searchTerm))+ " topNGroups="+ topNGroups+ " groupOffset="+ groupOffset+ " docOffset="+ docOffset+ " doCache="+ doCache+ " docsPerGroup="+ docsPerGroup+ " doAllGroups="+ doAllGroups+ " getScores="+ getScores+ " getMaxScores="+ getMaxScores);
        }
        String groupField="group";
        if (canUseIDV && random().nextBoolean()) {
          groupField+="_dv";
        }
        if (VERBOSE) {
          System.out.println("  groupField=" + groupField);
        }
        final AbstractFirstPassGroupingCollector<?> c1=createRandomFirstPassCollector(groupField,groupSort,groupOffset + topNGroups);
        final CachingCollector cCache;
        final Collector c;
        final AbstractAllGroupsCollector<?> allGroupsCollector;
        if (doAllGroups) {
          allGroupsCollector=createAllGroupsCollector(c1,groupField);
        }
 else {
          allGroupsCollector=null;
        }
        final boolean useWrappingCollector=random().nextBoolean();
        if (doCache) {
          final double maxCacheMB=random().nextDouble();
          if (VERBOSE) {
            System.out.println("TEST: maxCacheMB=" + maxCacheMB);
          }
          if (useWrappingCollector) {
            if (doAllGroups) {
              cCache=CachingCollector.create(c1,true,maxCacheMB);
              c=MultiCollector.wrap(cCache,allGroupsCollector);
            }
 else {
              c=cCache=CachingCollector.create(c1,true,maxCacheMB);
            }
          }
 else {
            c=cCache=CachingCollector.create(false,true,maxCacheMB);
          }
        }
 else {
          cCache=null;
          if (doAllGroups) {
            c=MultiCollector.wrap(c1,allGroupsCollector);
          }
 else {
            c=c1;
          }
        }
        final Query query=new TermQuery(new Term("content",searchTerm));
        s.search(query,c);
        if (doCache && !useWrappingCollector) {
          if (cCache.isCached()) {
            cCache.replay(c1);
            if (doAllGroups) {
              cCache.replay(allGroupsCollector);
            }
          }
 else {
            s.search(query,c1);
            if (doAllGroups) {
              s.search(query,allGroupsCollector);
            }
          }
        }
        final Collection<SearchGroup<BytesRef>> topGroups=getSearchGroups(c1,groupOffset,fillFields);
        final TopGroups<BytesRef> groupsResult;
        if (VERBOSE) {
          System.out.println("TEST: first pass topGroups");
          if (topGroups == null) {
            System.out.println("  null");
          }
 else {
            for (            SearchGroup<BytesRef> searchGroup : topGroups) {
              System.out.println("  " + (searchGroup.groupValue == null ? "null" : searchGroup.groupValue) + ": "+ Arrays.deepToString(searchGroup.sortValues));
            }
          }
        }
        ValueHolder<Boolean> idvBasedImplsUsedSharded=new ValueHolder<Boolean>(false);
        final TopGroups<BytesRef> topGroupsShards=searchShards(s,shards.subSearchers,query,groupSort,docSort,groupOffset,topNGroups,docOffset,docsPerGroup,getScores,getMaxScores,canUseIDV,false,idvBasedImplsUsedSharded);
        final AbstractSecondPassGroupingCollector<?> c2;
        if (topGroups != null) {
          if (VERBOSE) {
            System.out.println("TEST: topGroups");
            for (            SearchGroup<BytesRef> searchGroup : topGroups) {
              System.out.println("  " + (searchGroup.groupValue == null ? "null" : searchGroup.groupValue.utf8ToString()) + ": "+ Arrays.deepToString(searchGroup.sortValues));
            }
          }
          c2=createSecondPassCollector(c1,groupField,groupSort,docSort,groupOffset,docOffset + docsPerGroup,getScores,getMaxScores,fillFields);
          if (doCache) {
            if (cCache.isCached()) {
              if (VERBOSE) {
                System.out.println("TEST: cache is intact");
              }
              cCache.replay(c2);
            }
 else {
              if (VERBOSE) {
                System.out.println("TEST: cache was too large");
              }
              s.search(query,c2);
            }
          }
 else {
            s.search(query,c2);
          }
          if (doAllGroups) {
            TopGroups<BytesRef> tempTopGroups=getTopGroups(c2,docOffset);
            groupsResult=new TopGroups<BytesRef>(tempTopGroups,allGroupsCollector.getGroupCount());
          }
 else {
            groupsResult=getTopGroups(c2,docOffset);
          }
        }
 else {
          c2=null;
          groupsResult=null;
          if (VERBOSE) {
            System.out.println("TEST:   no results");
          }
        }
        final TopGroups<BytesRef> expectedGroups=slowGrouping(groupDocs,searchTerm,fillFields,getScores,getMaxScores,doAllGroups,groupSort,docSort,topNGroups,docsPerGroup,groupOffset,docOffset);
        if (VERBOSE) {
          if (expectedGroups == null) {
            System.out.println("TEST: no expected groups");
          }
 else {
            System.out.println("TEST: expected groups totalGroupedHitCount=" + expectedGroups.totalGroupedHitCount);
            for (            GroupDocs<BytesRef> gd : expectedGroups.groups) {
              System.out.println("  group=" + (gd.groupValue == null ? "null" : gd.groupValue) + " totalHits="+ gd.totalHits+ " scoreDocs.len="+ gd.scoreDocs.length);
              for (              ScoreDoc sd : gd.scoreDocs) {
                System.out.println("    id=" + sd.doc + " score="+ sd.score);
              }
            }
          }
          if (groupsResult == null) {
            System.out.println("TEST: no matched groups");
          }
 else {
            System.out.println("TEST: matched groups totalGroupedHitCount=" + groupsResult.totalGroupedHitCount);
            for (            GroupDocs<BytesRef> gd : groupsResult.groups) {
              System.out.println("  group=" + (gd.groupValue == null ? "null" : gd.groupValue) + " totalHits="+ gd.totalHits);
              for (              ScoreDoc sd : gd.scoreDocs) {
                System.out.println("    id=" + docIDToID.get(sd.doc) + " score="+ sd.score);
              }
            }
            if (searchIter == 14) {
              for (int docIDX=0; docIDX < s.getIndexReader().maxDoc(); docIDX++) {
                System.out.println("ID=" + docIDToID.get(docIDX) + " explain="+ s.explain(query,docIDX));
              }
            }
          }
          if (topGroupsShards == null) {
            System.out.println("TEST: no matched-merged groups");
          }
 else {
            System.out.println("TEST: matched-merged groups totalGroupedHitCount=" + topGroupsShards.totalGroupedHitCount);
            for (            GroupDocs<BytesRef> gd : topGroupsShards.groups) {
              System.out.println("  group=" + (gd.groupValue == null ? "null" : gd.groupValue) + " totalHits="+ gd.totalHits);
              for (              ScoreDoc sd : gd.scoreDocs) {
                System.out.println("    id=" + docIDToID.get(sd.doc) + " score="+ sd.score);
              }
            }
          }
        }
        assertEquals(docIDToID,expectedGroups,groupsResult,true,true,true,getScores,groupField.endsWith("_dv"));
        assertEquals(docIDToID,expectedGroups,topGroupsShards,true,false,fillFields,getScores,idvBasedImplsUsedSharded.value);
        if (topGroupsShards != null) {
          verifyShards(shards.docStarts,topGroupsShards);
        }
        final boolean needsScores=getScores || getMaxScores || docSort == null;
        final BlockGroupingCollector c3=new BlockGroupingCollector(groupSort,groupOffset + topNGroups,needsScores,lastDocInBlock);
        final TermAllGroupsCollector allGroupsCollector2;
        final Collector c4;
        if (doAllGroups) {
          allGroupsCollector2=new TermAllGroupsCollector("group");
          c4=MultiCollector.wrap(c3,allGroupsCollector2);
        }
 else {
          allGroupsCollector2=null;
          c4=c3;
        }
        sBlocks.search(query,c4);
        @SuppressWarnings({"unchecked","rawtypes"}) final TopGroups<BytesRef> tempTopGroupsBlocks=(TopGroups<BytesRef>)c3.getTopGroups(docSort,groupOffset,docOffset,docOffset + docsPerGroup,fillFields);
        final TopGroups<BytesRef> groupsResultBlocks;
        if (doAllGroups && tempTopGroupsBlocks != null) {
          assertEquals((int)tempTopGroupsBlocks.totalGroupCount,allGroupsCollector2.getGroupCount());
          groupsResultBlocks=new TopGroups<BytesRef>(tempTopGroupsBlocks,allGroupsCollector2.getGroupCount());
        }
 else {
          groupsResultBlocks=tempTopGroupsBlocks;
        }
        if (VERBOSE) {
          if (groupsResultBlocks == null) {
            System.out.println("TEST: no block groups");
          }
 else {
            System.out.println("TEST: block groups totalGroupedHitCount=" + groupsResultBlocks.totalGroupedHitCount);
            boolean first=true;
            for (            GroupDocs<BytesRef> gd : groupsResultBlocks.groups) {
              System.out.println("  group=" + (gd.groupValue == null ? "null" : gd.groupValue.utf8ToString()) + " totalHits="+ gd.totalHits);
              for (              ScoreDoc sd : gd.scoreDocs) {
                System.out.println("    id=" + docIDToIDBlocks.get(sd.doc) + " score="+ sd.score);
                if (first) {
                  System.out.println("explain: " + sBlocks.explain(query,sd.doc));
                  first=false;
                }
              }
            }
          }
        }
        final TopGroups<BytesRef> topGroupsBlockShards=searchShards(sBlocks,shardsBlocks.subSearchers,query,groupSort,docSort,groupOffset,topNGroups,docOffset,docsPerGroup,getScores,getMaxScores,false,false,new ValueHolder<Boolean>(false));
        if (expectedGroups != null) {
          for (          GroupDocs<?> groupDocsHits : expectedGroups.groups) {
            for (            ScoreDoc hit : groupDocsHits.scoreDocs) {
              final GroupDoc gd=groupDocsByID[hit.doc];
              assertEquals(gd.id,hit.doc);
              hit.score=gd.score2;
            }
          }
          final SortField[] sortFields=groupSort.getSort();
          final Map<Float,Float> termScoreMap=scoreMap.get(searchTerm);
          for (int groupSortIDX=0; groupSortIDX < sortFields.length; groupSortIDX++) {
            if (sortFields[groupSortIDX].getType() == SortField.Type.SCORE) {
              for (              GroupDocs<?> groupDocsHits : expectedGroups.groups) {
                if (groupDocsHits.groupSortValues != null) {
                  groupDocsHits.groupSortValues[groupSortIDX]=termScoreMap.get(groupDocsHits.groupSortValues[groupSortIDX]);
                  assertNotNull(groupDocsHits.groupSortValues[groupSortIDX]);
                }
              }
            }
          }
          final SortField[] docSortFields=docSort.getSort();
          for (int docSortIDX=0; docSortIDX < docSortFields.length; docSortIDX++) {
            if (docSortFields[docSortIDX].getType() == SortField.Type.SCORE) {
              for (              GroupDocs<?> groupDocsHits : expectedGroups.groups) {
                for (                ScoreDoc _hit : groupDocsHits.scoreDocs) {
                  FieldDoc hit=(FieldDoc)_hit;
                  if (hit.fields != null) {
                    hit.fields[docSortIDX]=termScoreMap.get(hit.fields[docSortIDX]);
                    assertNotNull(hit.fields[docSortIDX]);
                  }
                }
              }
            }
          }
        }
        assertEquals(docIDToIDBlocks,expectedGroups,groupsResultBlocks,false,true,true,getScores,false);
        assertEquals(docIDToIDBlocks,expectedGroups,topGroupsBlockShards,false,false,fillFields,getScores,false);
      }
    }
  finally {
      QueryUtils.purgeFieldCache(r);
      if (rBlocks != null) {
        QueryUtils.purgeFieldCache(rBlocks);
      }
    }
    r.close();
    dir.close();
    rBlocks.close();
    dirBlocks.close();
  }
}
