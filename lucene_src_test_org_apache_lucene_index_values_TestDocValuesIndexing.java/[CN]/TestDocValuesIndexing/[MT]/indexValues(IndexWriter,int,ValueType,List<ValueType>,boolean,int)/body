{
  final boolean isNumeric=NUMERICS.contains(value);
  OpenBitSet deleted=new OpenBitSet(numValues);
  Document doc=new Document();
  Index idx=IDX_VALUES[random.nextInt(IDX_VALUES.length)];
  AbstractField field=random.nextBoolean() ? new IndexDocValuesField(value.name()) : newField(value.name(),_TestUtil.randomRealisticUnicodeString(random,10),idx == Index.NO ? Store.YES : Store.NO,idx);
  doc.add(field);
  IndexDocValuesField valField=new IndexDocValuesField("prototype");
  final BytesRef bytesRef=new BytesRef();
  final String idBase=value.name() + "_";
  final byte[] b=new byte[multOfSeven];
  if (bytesRef != null) {
    bytesRef.bytes=b;
    bytesRef.length=b.length;
    bytesRef.offset=0;
  }
  byte upto=0;
  for (int i=0; i < numValues; i++) {
    if (isNumeric) {
switch (value) {
case INTS:
        valField.setInt(i);
      break;
case FLOAT_32:
    valField.setFloat(2.0f * i);
  break;
case FLOAT_64:
valField.setFloat(2.0d * i);
break;
default :
fail("unexpected value " + value);
}
}
 else {
for (int j=0; j < b.length; j++) {
b[j]=upto++;
}
if (bytesRef != null) {
valField.setBytes(bytesRef,value);
}
}
doc.removeFields("id");
doc.add(new Field("id",idBase + i,Store.YES,Index.NOT_ANALYZED_NO_NORMS));
valField.set(field);
w.addDocument(doc);
if (i % 7 == 0) {
if (withDeletions && random.nextBoolean()) {
ValueType val=valueVarList.get(random.nextInt(1 + valueVarList.indexOf(value)));
final int randInt=val == value ? random.nextInt(1 + i) : random.nextInt(numValues);
w.deleteDocuments(new Term("id",val.name() + "_" + randInt));
if (val == value) {
deleted.set(randInt);
}
}
if (random.nextInt(10) == 0) {
w.commit();
}
}
}
w.commit();
if (withDeletions || random.nextBoolean()) w.optimize(true);
return deleted;
}
