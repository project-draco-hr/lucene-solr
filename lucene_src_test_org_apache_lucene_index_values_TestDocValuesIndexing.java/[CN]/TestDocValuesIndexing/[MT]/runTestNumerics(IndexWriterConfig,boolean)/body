{
  Directory d=newDirectory();
  IndexWriter w=new IndexWriter(d,cfg);
  final int numValues=50 + atLeast(10);
  final List<ValueType> numVariantList=new ArrayList<ValueType>(NUMERICS);
  Collections.shuffle(numVariantList,random);
  for (  ValueType val : numVariantList) {
    FixedBitSet deleted=indexValues(w,numValues,val,numVariantList,withDeletions,7);
    List<Closeable> closeables=new ArrayList<Closeable>();
    IndexReader r=IndexReader.open(w,true);
    final int numRemainingValues=numValues - deleted.cardinality();
    final int base=r.numDocs() - numRemainingValues;
    int mod=numValues;
switch (val) {
case FIXED_INTS_8:
      mod=128;
case FIXED_INTS_16:
case FIXED_INTS_32:
case FIXED_INTS_64:
case VAR_INTS:
{
      IndexDocValues intsReader=getDocValues(r,val.name());
      assertNotNull(intsReader);
      Source ints=getSource(intsReader);
      for (int i=0; i < base; i++) {
        long value=ints.getInt(i);
        assertEquals("index " + i,0,value);
      }
      int expected=0;
      for (int i=base; i < r.numDocs(); i++, expected++) {
        while (deleted.get(expected)) {
          expected++;
        }
        assertEquals(val + " mod: " + mod+ " index: "+ i,expected % mod,ints.getInt(i));
      }
    }
  break;
case FLOAT_32:
case FLOAT_64:
{
  IndexDocValues floatReader=getDocValues(r,val.name());
  assertNotNull(floatReader);
  Source floats=getSource(floatReader);
  for (int i=0; i < base; i++) {
    double value=floats.getFloat(i);
    assertEquals(val + " failed for doc: " + i+ " base: "+ base,0.0d,value,0.0d);
  }
  int expected=0;
  for (int i=base; i < r.numDocs(); i++, expected++) {
    while (deleted.get(expected)) {
      expected++;
    }
    assertEquals("index " + i,2.0 * expected,floats.getFloat(i),0.00001);
  }
}
break;
default :
fail("unexpected value " + val);
}
closeables.add(r);
for (Closeable toClose : closeables) {
toClose.close();
}
}
w.close();
d.close();
}
