{
  final Directory d=newDirectory();
  IndexWriter w=new IndexWriter(d,cfg);
  final List<ValueType> byteVariantList=new ArrayList<ValueType>(BYTES);
  Collections.shuffle(byteVariantList,random);
  final int numValues=179 + random.nextInt(151);
  for (  ValueType byteIndexValue : byteVariantList) {
    List<Closeable> closeables=new ArrayList<Closeable>();
    int bytesSize=7 + random.nextInt(128);
    OpenBitSet deleted=indexValues(w,numValues,byteIndexValue,byteVariantList,withDeletions,bytesSize);
    final IndexReader r=IndexReader.open(w,withDeletions);
    assertEquals(0,r.numDeletedDocs());
    final int numRemainingValues=(int)(numValues - deleted.cardinality());
    final int base=r.numDocs() - numRemainingValues;
    IndexDocValues bytesReader=getDocValues(r,byteIndexValue.name());
    assertNotNull("field " + byteIndexValue.name() + " returned null reader - maybe merged failed",bytesReader);
    Source bytes=getSource(bytesReader);
    byte upto=0;
    for (int i=0; i < base; i++) {
      BytesRef br=bytes.getBytes(i,new BytesRef());
      String msg=" field: " + byteIndexValue.name() + " at index: "+ i+ " base: "+ base+ " numDocs:"+ r.numDocs();
switch (byteIndexValue) {
case BYTES_VAR_STRAIGHT:
case BYTES_FIXED_STRAIGHT:
        assertNotNull("expected none null - " + msg,br);
      if (br.length != 0) {
        assertEquals("expected zero bytes of length " + bytesSize + " - "+ msg,bytesSize,br.length);
        for (int j=0; j < br.length; j++) {
          assertEquals("Byte at index " + j + " doesn't match - "+ msg,0,br.bytes[br.offset + j]);
        }
      }
    break;
case BYTES_VAR_SORTED:
case BYTES_FIXED_SORTED:
case BYTES_VAR_DEREF:
case BYTES_FIXED_DEREF:
default :
  assertNotNull("expected none null - " + msg,br);
assertEquals(0,br.length);
ValuesEnum bytesEnum=getValuesEnum(bytesReader);
try {
final int advancedTo=bytesEnum.advance(0);
assertTrue(byteIndexValue.name() + " advanced failed base:" + base+ " advancedTo: "+ advancedTo,base <= advancedTo);
}
 catch (Throwable e) {
final int advancedTo=bytesEnum.advance(0);
assertTrue(byteIndexValue.name() + " advanced failed base:" + base+ " advancedTo: "+ advancedTo,base <= advancedTo);
}
}
}
ValuesEnum bytesEnum=getValuesEnum(bytesReader);
final BytesRef enumRef=bytesEnum.bytes();
assertEquals(base + numRemainingValues,r.numDocs());
int v=0;
for (int i=base; i < r.numDocs(); i++) {
String msg=" field: " + byteIndexValue.name() + " at index: "+ i+ " base: "+ base+ " numDocs:"+ r.numDocs()+ " bytesSize: "+ bytesSize+ " src: "+ bytes;
while (withDeletions && deleted.get(v++)) {
upto+=bytesSize;
}
BytesRef br=bytes.getBytes(i,new BytesRef());
if (bytesEnum.docID() != i) {
assertEquals("seek failed for index " + i + " "+ msg,i,bytesEnum.advance(i));
}
for (int j=0; j < br.length; j++, upto++) {
assertTrue(" enumRef not initialized " + msg,enumRef.bytes.length > 0);
assertEquals("EnumRef Byte at index " + j + " doesn't match - "+ msg,upto,enumRef.bytes[enumRef.offset + j]);
if (!(br.bytes.length > br.offset + j)) br=bytes.getBytes(i,new BytesRef());
assertTrue("BytesRef index exceeded [" + msg + "] offset: "+ br.offset+ " length: "+ br.length+ " index: "+ (br.offset + j),br.bytes.length > br.offset + j);
assertEquals("SourceRef Byte at index " + j + " doesn't match - "+ msg,upto,br.bytes[br.offset + j]);
}
}
closeables.add(r);
for (Closeable toClose : closeables) {
toClose.close();
}
}
w.close();
d.close();
}
