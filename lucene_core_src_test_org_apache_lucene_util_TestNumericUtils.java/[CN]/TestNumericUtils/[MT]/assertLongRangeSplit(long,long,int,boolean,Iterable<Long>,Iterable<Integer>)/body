{
  final OpenBitSet bits=useBitSet ? new OpenBitSet(upper - lower + 1) : null;
  final Iterator<Long> neededBounds=(expectedBounds == null) ? null : expectedBounds.iterator();
  final Iterator<Integer> neededShifts=(expectedShifts == null) ? null : expectedShifts.iterator();
  NumericUtils.splitLongRange(new NumericUtils.LongRangeBuilder(){
    @Override public void addRange(    long min,    long max,    int shift){
      assertTrue("min, max should be inside bounds",min >= lower && min <= upper && max >= lower && max <= upper);
      if (useBitSet)       for (long l=min; l <= max; l++) {
        assertFalse("ranges should not overlap",bits.getAndSet(l - lower));
        if (l == max)         break;
      }
      if (neededBounds == null || neededShifts == null)       return;
      min^=0x8000000000000000L;
      max^=0x8000000000000000L;
      assertEquals("shift",neededShifts.next().intValue(),shift);
      assertEquals("inner min bound",neededBounds.next().longValue(),min >>> shift);
      assertEquals("inner max bound",neededBounds.next().longValue(),max >>> shift);
    }
  }
,precisionStep,lower,upper);
  if (useBitSet) {
    bits.flip(0,upper - lower + 1);
    assertEquals("The sub-range concenated should match the whole range",0,bits.cardinality());
  }
}
