{
  ThreadState state=(ThreadState)threadBindings.get(Thread.currentThread());
  if (state == null) {
    ThreadState minThreadState=null;
    for (int i=0; i < threadStates.length; i++) {
      ThreadState ts=threadStates[i];
      if (minThreadState == null || ts.numThreads < minThreadState.numThreads)       minThreadState=ts;
    }
    if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {
      state=minThreadState;
      state.numThreads++;
    }
 else {
      ThreadState[] newArray=new ThreadState[1 + threadStates.length];
      if (threadStates.length > 0)       System.arraycopy(threadStates,0,newArray,0,threadStates.length);
      state=newArray[threadStates.length]=new ThreadState();
      threadStates=newArray;
    }
    threadBindings.put(Thread.currentThread(),state);
  }
  while (!state.isIdle || pauseThreads != 0 || flushPending)   try {
    wait();
  }
 catch (  InterruptedException e) {
  }
  if (segment == null)   segment=writer.newSegmentName();
  numDocsInRAM++;
  if (!flushPending && ramBufferSize == 0 && numDocsInRAM >= maxBufferedDocs) {
    flushPending=true;
    state.doFlushAfter=true;
  }
 else   state.doFlushAfter=false;
  state.isIdle=false;
  boolean success=false;
  try {
    state.init(doc,nextDocID++);
    success=true;
  }
  finally {
    if (!success) {
      state.isIdle=true;
      if (state.doFlushAfter) {
        state.doFlushAfter=false;
        flushPending=false;
      }
      abort();
    }
  }
  return state;
}
