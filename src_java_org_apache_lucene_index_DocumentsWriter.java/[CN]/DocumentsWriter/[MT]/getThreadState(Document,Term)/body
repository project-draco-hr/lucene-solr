{
  DocumentsWriterThreadState state=(DocumentsWriterThreadState)threadBindings.get(Thread.currentThread());
  if (state == null) {
    DocumentsWriterThreadState minThreadState=null;
    for (int i=0; i < threadStates.length; i++) {
      DocumentsWriterThreadState ts=threadStates[i];
      if (minThreadState == null || ts.numThreads < minThreadState.numThreads)       minThreadState=ts;
    }
    if (minThreadState != null && (minThreadState.numThreads == 0 || threadStates.length == MAX_THREAD_STATE)) {
      state=minThreadState;
      state.numThreads++;
    }
 else {
      DocumentsWriterThreadState[] newArray=new DocumentsWriterThreadState[1 + threadStates.length];
      if (threadStates.length > 0)       System.arraycopy(threadStates,0,newArray,0,threadStates.length);
      state=newArray[threadStates.length]=new DocumentsWriterThreadState(this);
      threadStates=newArray;
    }
    threadBindings.put(Thread.currentThread(),state);
  }
  waitReady(state);
  if (segment == null)   segment=writer.newSegmentName();
  state.isIdle=false;
  try {
    boolean success=false;
    try {
      state.init(doc,nextDocID);
      if (delTerm != null) {
        addDeleteTerm(delTerm,state.docID);
        state.doFlushAfter=timeToFlushDeletes();
      }
      nextDocID++;
      numDocsInRAM++;
      if (!flushPending && maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH && numDocsInRAM >= maxBufferedDocs) {
        flushPending=true;
        state.doFlushAfter=true;
      }
      success=true;
    }
  finally {
      if (!success) {
        state.isIdle=true;
        notifyAll();
        if (state.doFlushAfter) {
          state.doFlushAfter=false;
          flushPending=false;
        }
      }
    }
  }
 catch (  AbortException ae) {
    abort(ae);
  }
  return state;
}
