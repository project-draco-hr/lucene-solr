{
  if (infoStream != null)   infoStream.println("docWriter: now abort");
  for (int i=0; i < numWaiting; i++)   waitingThreadStates[i].isIdle=true;
  numWaiting=0;
  pauseAllThreads();
  bufferedDeleteTerms.clear();
  bufferedDeleteDocIDs.clear();
  numBufferedDeleteTerms=0;
  try {
    abortedFiles=files();
    final int numField=fieldInfos.size();
    for (int i=0; i < numField; i++) {
      FieldInfo fi=fieldInfos.fieldInfo(i);
      if (fi.isIndexed && !fi.omitNorms) {
        BufferedNorms n=norms[i];
        if (n != null) {
          n.out.reset();
          n.reset();
        }
      }
    }
    if (tvx != null) {
      tvx.close();
      tvf.close();
      tvd.close();
      tvx=null;
    }
    if (fieldsWriter != null) {
      fieldsWriter.close();
      fieldsWriter=null;
    }
    resetPostingsData();
    for (int i=0; i < threadStates.length; i++) {
      ThreadState state=threadStates[i];
      if (state.localFieldsWriter != null) {
        state.localFieldsWriter.close();
        state.localFieldsWriter=null;
      }
      state.tvfLocal.reset();
      state.fdtLocal.reset();
    }
    docStoreSegment=null;
    files=null;
  }
  finally {
    resumeAllThreads();
  }
}
