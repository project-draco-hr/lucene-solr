{
  final int commitPercent=10;
  final int softCommitPercent=50;
  final int deletePercent=8;
  final int deleteByQueryPercent=4;
  final int ndocs=100;
  int nWriteThreads=10;
  final int maxConcurrentCommits=2;
  final boolean tombstones=false;
  final AtomicLong operations=new AtomicLong(10000000);
  int nReadThreads=10;
  initModel(ndocs);
  final AtomicInteger numCommitting=new AtomicInteger();
  List<Thread> threads=new ArrayList<Thread>();
  RAMDirectory dir=new RAMDirectory();
  final IndexWriter writer=new IndexWriter(dir,new IndexWriterConfig(Version.LUCENE_40,new WhitespaceAnalyzer(Version.LUCENE_40)));
  writer.commit();
  reader=IndexReader.open(dir);
  for (int i=0; i < nWriteThreads; i++) {
    Thread thread=new Thread("WRITER" + i){
      Random rand=new Random(random.nextInt());
      @Override public void run(){
        try {
          while (operations.get() > 0) {
            int oper=rand.nextInt(100);
            if (oper < commitPercent) {
              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {
                Map<Integer,Long> newCommittedModel;
                long version;
                IndexReader oldReader;
synchronized (TestRealTimeGet.this) {
                  newCommittedModel=new HashMap<Integer,Long>(model);
                  version=snapshotCount++;
                  oldReader=reader;
                  oldReader.incRef();
                }
                IndexReader newReader;
                if (rand.nextInt(100) < softCommitPercent) {
                  newReader=oldReader.reopen(writer,true);
                }
 else {
                  writer.commit();
                  newReader=oldReader.reopen();
                }
synchronized (TestRealTimeGet.this) {
                  if (newReader.getVersion() > reader.getVersion()) {
                    reader.decRef();
                    reader=newReader;
                    if (version >= committedModelClock) {
                      committedModel=newCommittedModel;
                      committedModelClock=version;
                    }
                  }
 else                   if (newReader != oldReader) {
                    newReader.decRef();
                  }
                  oldReader.decRef();
                }
              }
              numCommitting.decrementAndGet();
              continue;
            }
            int id=rand.nextInt(ndocs);
            Object sync=syncArr[id];
            boolean before=rand.nextBoolean();
            if (before) {
              lastId=id;
            }
synchronized (sync) {
              Long val=model.get(id);
              long nextVal=Math.abs(val) + 1;
              if (oper < commitPercent + deletePercent) {
                if (tombstones) {
                  Document d=new Document();
                  d.add(new Field("id","-" + Integer.toString(id),Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));
                  d.add(new Field(field,Long.toString(nextVal),Field.Store.YES,Field.Index.NO));
                  writer.updateDocument(new Term("id","-" + Integer.toString(id)),d);
                }
                writer.deleteDocuments(new Term("id",Integer.toString(id)));
                model.put(id,-nextVal);
              }
 else               if (oper < commitPercent + deletePercent + deleteByQueryPercent) {
                if (tombstones) {
                  Document d=new Document();
                  d.add(new Field("id","-" + Integer.toString(id),Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));
                  d.add(new Field(field,Long.toString(nextVal),Field.Store.YES,Field.Index.NO));
                  writer.updateDocument(new Term("id","-" + Integer.toString(id)),d);
                }
                writer.deleteDocuments(new TermQuery(new Term("id",Integer.toString(id))));
                model.put(id,-nextVal);
              }
 else {
                Document d=new Document();
                d.add(new Field("id",Integer.toString(id),Field.Store.YES,Field.Index.NOT_ANALYZED_NO_NORMS));
                d.add(new Field(field,Long.toString(nextVal),Field.Store.YES,Field.Index.NO));
                writer.updateDocument(new Term("id",Integer.toString(id)),d);
                if (tombstones) {
                  writer.deleteDocuments(new Term("id","-" + Integer.toString(id)));
                }
                model.put(id,nextVal);
              }
            }
            if (!before) {
              lastId=id;
            }
          }
        }
 catch (        Exception ex) {
          throw new RuntimeException(ex);
        }
      }
    }
;
    threads.add(thread);
  }
  for (int i=0; i < nReadThreads; i++) {
    Thread thread=new Thread("READER" + i){
      Random rand=new Random(random.nextInt());
      @Override public void run(){
        try {
          while (operations.decrementAndGet() >= 0) {
            int id=rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);
            long val;
synchronized (TestRealTimeGet.this) {
              val=committedModel.get(id);
            }
            IndexReader r;
synchronized (TestRealTimeGet.this) {
              r=reader;
              r.incRef();
            }
            IndexSearcher searcher=new IndexSearcher(r);
            Query q=new TermQuery(new Term("id",Integer.toString(id)));
            TopDocs results=searcher.search(q,1);
            if (results.totalHits == 0 && tombstones) {
              q=new TermQuery(new Term("id","-" + Integer.toString(id)));
              results=searcher.search(q,1);
              if (results.totalHits == 0) {
                if (val == -1L) {
                  continue;
                }
                fail("No documents or tombstones found for id " + id + ", expected at least "+ val);
              }
            }
            if (results.totalHits == 0 && !tombstones) {
            }
 else {
              assertEquals(1,results.totalHits);
              Document doc=searcher.doc(results.scoreDocs[0].doc);
              long foundVal=Long.parseLong(doc.get(field));
              if (foundVal < Math.abs(val)) {
                System.out.println("model_val=" + val + " foundVal="+ foundVal);
              }
              assertTrue(foundVal >= Math.abs(val));
            }
            r.decRef();
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          SolrException.log(log,e);
          fail(e.toString());
        }
      }
    }
;
    threads.add(thread);
  }
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
  writer.close();
  reader.close();
}
