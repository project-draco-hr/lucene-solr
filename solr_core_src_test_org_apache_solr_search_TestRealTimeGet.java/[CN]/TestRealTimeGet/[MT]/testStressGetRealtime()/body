{
  clearIndex();
  assertU(commit());
  final int commitPercent=5 + random.nextInt(20);
  final int softCommitPercent=30 + random.nextInt(60);
  final int deletePercent=4 + random.nextInt(25);
  final int deleteByQueryPercent=0;
  final int ndocs=5 + (random.nextBoolean() ? random.nextInt(25) : random.nextInt(200));
  int nWriteThreads=5 + random.nextInt(25);
  final int maxConcurrentCommits=nWriteThreads;
  final int percentRealtimeQuery=60;
  final AtomicLong operations=new AtomicLong(50000);
  int nReadThreads=5 + random.nextInt(25);
  initModel(ndocs);
  final AtomicInteger numCommitting=new AtomicInteger();
  List<Thread> threads=new ArrayList<Thread>();
  for (int i=0; i < nWriteThreads; i++) {
    Thread thread=new Thread("WRITER" + i){
      Random rand=new Random(random.nextInt());
      @Override public void run(){
        try {
          while (operations.get() > 0) {
            int oper=rand.nextInt(100);
            if (oper < commitPercent) {
              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {
                Map<Integer,Long> newCommittedModel;
                long version;
synchronized (TestRealTimeGet.this) {
                  newCommittedModel=new HashMap<Integer,Long>(model);
                  version=snapshotCount++;
                }
                if (rand.nextInt(100) < softCommitPercent) {
                  verbose("softCommit start");
                  assertU(h.commit("softCommit","true"));
                  verbose("softCommit end");
                }
 else {
                  verbose("commit start");
                  assertU(commit());
                  verbose("commit end");
                }
synchronized (TestRealTimeGet.this) {
                  if (version >= committedModelClock) {
                    if (VERBOSE) {
                      verbose("installing new committedModel version=" + committedModelClock);
                    }
                    committedModel=newCommittedModel;
                    committedModelClock=version;
                  }
                }
              }
              numCommitting.decrementAndGet();
              continue;
            }
            int id=rand.nextInt(ndocs);
            Object sync=syncArr[id];
            boolean before=rand.nextBoolean();
            if (before) {
              lastId=id;
            }
synchronized (sync) {
              Long val=model.get(id);
              long nextVal=Math.abs(val) + 1;
              if (oper < commitPercent + deletePercent) {
                if (VERBOSE) {
                  verbose("deleting id",id,"val=",nextVal);
                }
                assertU("<delete><id>" + id + "</id></delete>");
                model.put(id,-nextVal);
                if (VERBOSE) {
                  verbose("deleting id",id,"val=",nextVal,"DONE");
                }
              }
 else               if (oper < commitPercent + deletePercent + deleteByQueryPercent) {
                if (VERBOSE) {
                  verbose("deleteByQuery id ",id,"val=",nextVal);
                }
                assertU("<delete><query>id:" + id + "</query></delete>");
                model.put(id,-nextVal);
                if (VERBOSE) {
                  verbose("deleteByQuery id",id,"val=",nextVal,"DONE");
                }
              }
 else {
                if (VERBOSE) {
                  verbose("adding id",id,"val=",nextVal);
                }
                assertU(adoc("id",Integer.toString(id),field,Long.toString(nextVal)));
                model.put(id,nextVal);
                if (VERBOSE) {
                  verbose("adding id",id,"val=",nextVal,"DONE");
                }
              }
            }
            if (!before) {
              lastId=id;
            }
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          SolrException.log(log,e);
          fail(e.getMessage());
        }
      }
    }
;
    threads.add(thread);
  }
  for (int i=0; i < nReadThreads; i++) {
    Thread thread=new Thread("READER" + i){
      Random rand=new Random(random.nextInt());
      @Override public void run(){
        try {
          while (operations.decrementAndGet() >= 0) {
            int id=rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);
            boolean realTime=rand.nextInt(100) < percentRealtimeQuery;
            long val;
            if (realTime) {
              val=model.get(id);
            }
 else {
synchronized (TestRealTimeGet.this) {
                val=committedModel.get(id);
              }
            }
            if (VERBOSE) {
              verbose("querying id",id);
            }
            SolrQueryRequest sreq;
            if (realTime) {
              sreq=req("wt","json","qt","/get","ids",Integer.toString(id));
            }
 else {
              sreq=req("wt","json","q","id:" + Integer.toString(id),"omitHeader","true");
            }
            String response=h.query(sreq);
            Map rsp=(Map)ObjectBuilder.fromJSON(response);
            List doclist=(List)(((Map)rsp.get("response")).get("docs"));
            if (doclist.size() == 0) {
            }
 else {
              assertEquals(1,doclist.size());
              long foundVal=(Long)(((Map)doclist.get(0)).get(field));
              if (foundVal < Math.abs(val)) {
                verbose("ERROR, id=",id,"foundVal=",foundVal,"model val=",val);
                assertTrue(foundVal >= Math.abs(val));
              }
            }
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          SolrException.log(log,e);
          fail(e.getMessage());
        }
      }
    }
;
    threads.add(thread);
  }
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
}
