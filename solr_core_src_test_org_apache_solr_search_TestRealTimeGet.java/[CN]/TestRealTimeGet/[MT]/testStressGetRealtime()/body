{
  clearIndex();
  assertU(commit());
  final int commitPercent=5 + random().nextInt(20);
  final int softCommitPercent=30 + random().nextInt(75);
  final int deletePercent=4 + random().nextInt(25);
  final int deleteByQueryPercent=1 + random().nextInt(5);
  final int optimisticPercent=1 + random().nextInt(50);
  final int optimisticCorrectPercent=25 + random().nextInt(70);
  final int filteredGetPercent=random().nextInt(random().nextInt(20) + 1);
  final int ndocs=5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));
  int nWriteThreads=5 + random().nextInt(25);
  final int maxConcurrentCommits=nWriteThreads;
  final int percentRealtimeQuery=60;
  final AtomicLong operations=new AtomicLong(50000);
  int nReadThreads=5 + random().nextInt(25);
  verbose("commitPercent=",commitPercent);
  verbose("softCommitPercent=",softCommitPercent);
  verbose("deletePercent=",deletePercent);
  verbose("deleteByQueryPercent=",deleteByQueryPercent);
  verbose("ndocs=",ndocs);
  verbose("nWriteThreads=",nWriteThreads);
  verbose("nReadThreads=",nReadThreads);
  verbose("percentRealtimeQuery=",percentRealtimeQuery);
  verbose("maxConcurrentCommits=",maxConcurrentCommits);
  verbose("operations=",operations);
  initModel(ndocs);
  final AtomicInteger numCommitting=new AtomicInteger();
  List<Thread> threads=new ArrayList<>();
  for (int i=0; i < nWriteThreads; i++) {
    Thread thread=new Thread("WRITER" + i){
      Random rand=new Random(random().nextInt());
      @Override public void run(){
        try {
          while (operations.get() > 0) {
            int oper=rand.nextInt(100);
            if (oper < commitPercent) {
              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {
                Map<Integer,DocInfo> newCommittedModel;
                long version;
synchronized (TestRealTimeGet.this) {
                  newCommittedModel=new HashMap<>(model);
                  version=snapshotCount++;
                  verbose("took snapshot version=",version);
                }
                if (rand.nextInt(100) < softCommitPercent) {
                  verbose("softCommit start");
                  assertU(TestHarness.commit("softCommit","true"));
                  verbose("softCommit end");
                }
 else {
                  verbose("hardCommit start");
                  assertU(commit());
                  verbose("hardCommit end");
                }
synchronized (TestRealTimeGet.this) {
                  if (version >= committedModelClock) {
                    if (VERBOSE) {
                      verbose("installing new committedModel version=" + committedModelClock);
                    }
                    committedModel=newCommittedModel;
                    committedModelClock=version;
                  }
                }
              }
              numCommitting.decrementAndGet();
              continue;
            }
            int id=rand.nextInt(ndocs);
            Object sync=syncArr[id];
            boolean before=rand.nextBoolean();
            if (before) {
              lastId=id;
            }
synchronized (sync) {
              DocInfo info=model.get(id);
              long val=info.val;
              long nextVal=Math.abs(val) + 1;
              if (oper < commitPercent + deletePercent) {
                boolean opt=rand.nextInt() < optimisticPercent;
                boolean correct=opt ? rand.nextInt() < optimisticCorrectPercent : false;
                long badVersion=correct ? 0 : badVersion(rand,info.version);
                if (VERBOSE) {
                  if (!opt) {
                    verbose("deleting id",id,"val=",nextVal);
                  }
 else {
                    verbose("deleting id",id,"val=",nextVal,"existing_version=",info.version,(correct ? "" : (" bad_version=" + badVersion)));
                  }
                }
                Long version=null;
                if (opt) {
                  if (correct) {
                    version=deleteAndGetVersion(Integer.toString(id),params("_version_",Long.toString(info.version)));
                  }
 else {
                    try {
                      version=deleteAndGetVersion(Integer.toString(id),params("_version_",Long.toString(badVersion)));
                      fail();
                    }
 catch (                    SolrException se) {
                      assertEquals(409,se.code());
                    }
                  }
                }
 else {
                  version=deleteAndGetVersion(Integer.toString(id),null);
                }
                if (version != null) {
                  model.put(id,new DocInfo(version,-nextVal));
                }
                if (VERBOSE) {
                  verbose("deleting id",id,"val=",nextVal,"DONE");
                }
              }
 else               if (oper < commitPercent + deletePercent + deleteByQueryPercent) {
                if (VERBOSE) {
                  verbose("deleteByQuery id ",id,"val=",nextVal);
                }
                assertU("<delete><query>id:" + id + "</query></delete>");
                model.put(id,new DocInfo(-1L,-nextVal));
                if (VERBOSE) {
                  verbose("deleteByQuery id",id,"val=",nextVal,"DONE");
                }
              }
 else {
                boolean opt=rand.nextInt() < optimisticPercent;
                boolean correct=opt ? rand.nextInt() < optimisticCorrectPercent : false;
                long badVersion=correct ? 0 : badVersion(rand,info.version);
                if (VERBOSE) {
                  if (!opt) {
                    verbose("adding id",id,"val=",nextVal);
                  }
 else {
                    verbose("adding id",id,"val=",nextVal,"existing_version=",info.version,(correct ? "" : (" bad_version=" + badVersion)));
                  }
                }
                Long version=null;
                SolrInputDocument sd=sdoc("id",Integer.toString(id),field,Long.toString(nextVal));
                if (opt) {
                  if (correct) {
                    version=addAndGetVersion(sd,params("_version_",Long.toString(info.version)));
                  }
 else {
                    try {
                      version=addAndGetVersion(sd,params("_version_",Long.toString(badVersion)));
                      fail();
                    }
 catch (                    SolrException se) {
                      assertEquals(409,se.code());
                    }
                  }
                }
 else {
                  version=addAndGetVersion(sd,null);
                }
                if (version != null) {
                  model.put(id,new DocInfo(version,nextVal));
                }
                if (VERBOSE) {
                  verbose("adding id",id,"val=",nextVal,"DONE");
                }
              }
            }
            if (!before) {
              lastId=id;
            }
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          throw new RuntimeException(e);
        }
      }
    }
;
    threads.add(thread);
  }
  for (int i=0; i < nReadThreads; i++) {
    Thread thread=new Thread("READER" + i){
      Random rand=new Random(random().nextInt());
      @Override public void run(){
        try {
          while (operations.decrementAndGet() >= 0) {
            int id=rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);
            boolean realTime=rand.nextInt(100) < percentRealtimeQuery;
            DocInfo info;
            if (realTime) {
              info=model.get(id);
            }
 else {
synchronized (TestRealTimeGet.this) {
                info=committedModel.get(id);
              }
            }
            if (VERBOSE) {
              verbose("querying id",id);
            }
            boolean filteredOut=false;
            SolrQueryRequest sreq;
            if (realTime) {
              ModifiableSolrParams p=params("wt","json","qt","/get","ids",Integer.toString(id));
              if (rand.nextInt(100) < filteredGetPercent) {
                int idToFilter=rand.nextBoolean() ? id : rand.nextInt(ndocs);
                filteredOut=idToFilter != id;
                p.add("fq","id:" + idToFilter);
              }
              sreq=req(p);
            }
 else {
              sreq=req("wt","json","q","id:" + Integer.toString(id),"omitHeader","true");
            }
            String response=h.query(sreq);
            Map rsp=(Map)ObjectBuilder.fromJSON(response);
            List doclist=(List)(((Map)rsp.get("response")).get("docs"));
            if (doclist.size() == 0) {
            }
 else {
              assertEquals(1,doclist.size());
              long foundVal=(Long)(((Map)doclist.get(0)).get(field));
              long foundVer=(Long)(((Map)doclist.get(0)).get("_version_"));
              if (filteredOut || foundVal < Math.abs(info.val) || (foundVer == info.version && foundVal != info.val)) {
                verbose("ERROR, id=",id,"found=",response,"model",info);
                assertTrue(false);
              }
            }
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          throw new RuntimeException(e);
        }
      }
    }
;
    threads.add(thread);
  }
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
}
