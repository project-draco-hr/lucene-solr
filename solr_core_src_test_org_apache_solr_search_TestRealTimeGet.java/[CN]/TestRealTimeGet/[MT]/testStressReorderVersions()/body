{
  clearIndex();
  assertU(commit());
  final int commitPercent=5 + random().nextInt(20);
  final int softCommitPercent=30 + random().nextInt(75);
  final int deletePercent=4 + random().nextInt(25);
  final int deleteByQueryPercent=0;
  final int ndocs=5 + (random().nextBoolean() ? random().nextInt(25) : random().nextInt(200));
  int nWriteThreads=5 + random().nextInt(25);
  final int maxConcurrentCommits=nWriteThreads;
  final int percentRealtimeQuery=75;
  final AtomicLong operations=new AtomicLong(50000);
  int nReadThreads=5 + random().nextInt(25);
  initModel(ndocs);
  final AtomicInteger numCommitting=new AtomicInteger();
  List<Thread> threads=new ArrayList<Thread>();
  final AtomicLong testVersion=new AtomicLong(0);
  for (int i=0; i < nWriteThreads; i++) {
    Thread thread=new Thread("WRITER" + i){
      Random rand=new Random(random().nextInt());
      @Override public void run(){
        try {
          while (operations.get() > 0) {
            int oper=rand.nextInt(100);
            if (oper < commitPercent) {
              if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {
                Map<Integer,DocInfo> newCommittedModel;
                long version;
synchronized (TestRealTimeGet.this) {
                  newCommittedModel=new HashMap<Integer,DocInfo>(model);
                  version=snapshotCount++;
                }
                if (rand.nextInt(100) < softCommitPercent) {
                  verbose("softCommit start");
                  assertU(TestHarness.commit("softCommit","true"));
                  verbose("softCommit end");
                }
 else {
                  verbose("hardCommit start");
                  assertU(commit());
                  verbose("hardCommit end");
                }
synchronized (TestRealTimeGet.this) {
                  if (version >= committedModelClock) {
                    if (VERBOSE) {
                      verbose("installing new committedModel version=" + committedModelClock);
                    }
                    committedModel=newCommittedModel;
                    committedModelClock=version;
                  }
                }
              }
              numCommitting.decrementAndGet();
              continue;
            }
            int id;
            if (rand.nextBoolean()) {
              id=rand.nextInt(ndocs);
            }
 else {
              id=lastId;
            }
            boolean before=rand.nextBoolean();
            if (before) {
              lastId=id;
            }
            DocInfo info=model.get(id);
            long val=info.val;
            long nextVal=Math.abs(val) + 1;
            long version=testVersion.incrementAndGet();
            if (rand.nextBoolean())             Thread.yield();
            if (oper < commitPercent + deletePercent) {
              verbose("deleting id",id,"val=",nextVal,"version",version);
              Long returnedVersion=deleteAndGetVersion(Integer.toString(id),params("_version_",Long.toString(-version),SEEN_LEADER,SEEN_LEADER_VAL));
              if (returnedVersion != null) {
                assertEquals(-version,returnedVersion.longValue());
              }
synchronized (model) {
                DocInfo currInfo=model.get(id);
                if (Math.abs(version) > Math.abs(currInfo.version)) {
                  model.put(id,new DocInfo(version,-nextVal));
                }
              }
              verbose("deleting id",id,"val=",nextVal,"version",version,"DONE");
            }
 else             if (oper < commitPercent + deletePercent + deleteByQueryPercent) {
            }
 else {
              verbose("adding id",id,"val=",nextVal,"version",version);
              Long returnedVersion=addAndGetVersion(sdoc("id",Integer.toString(id),field,Long.toString(nextVal),"_version_",Long.toString(version)),params(SEEN_LEADER,SEEN_LEADER_VAL));
              if (returnedVersion != null) {
                assertEquals(version,returnedVersion.longValue());
              }
synchronized (model) {
                DocInfo currInfo=model.get(id);
                if (version > currInfo.version) {
                  model.put(id,new DocInfo(version,nextVal));
                }
              }
              if (VERBOSE) {
                verbose("adding id",id,"val=",nextVal,"version",version,"DONE");
              }
            }
            if (!before) {
              lastId=id;
            }
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          throw new RuntimeException(e);
        }
      }
    }
;
    threads.add(thread);
  }
  for (int i=0; i < nReadThreads; i++) {
    Thread thread=new Thread("READER" + i){
      Random rand=new Random(random().nextInt());
      @Override public void run(){
        try {
          while (operations.decrementAndGet() >= 0) {
            int id=rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);
            boolean realTime=rand.nextInt(100) < percentRealtimeQuery;
            DocInfo info;
            if (realTime) {
              info=model.get(id);
            }
 else {
synchronized (TestRealTimeGet.this) {
                info=committedModel.get(id);
              }
            }
            if (VERBOSE) {
              verbose("querying id",id);
            }
            SolrQueryRequest sreq;
            if (realTime) {
              sreq=req("wt","json","qt","/get","ids",Integer.toString(id));
            }
 else {
              sreq=req("wt","json","q","id:" + Integer.toString(id),"omitHeader","true");
            }
            String response=h.query(sreq);
            Map rsp=(Map)ObjectBuilder.fromJSON(response);
            List doclist=(List)(((Map)rsp.get("response")).get("docs"));
            if (doclist.size() == 0) {
            }
 else {
              assertEquals(1,doclist.size());
              long foundVal=(Long)(((Map)doclist.get(0)).get(field));
              long foundVer=(Long)(((Map)doclist.get(0)).get("_version_"));
              if (foundVer < Math.abs(info.version) || (foundVer == info.version && foundVal != info.val)) {
                verbose("ERROR, id=",id,"found=",response,"model",info);
                assertTrue(false);
              }
            }
          }
        }
 catch (        Throwable e) {
          operations.set(-1L);
          throw new RuntimeException(e);
        }
      }
    }
;
    threads.add(thread);
  }
  for (  Thread thread : threads) {
    thread.start();
  }
  for (  Thread thread : threads) {
    thread.join();
  }
}
