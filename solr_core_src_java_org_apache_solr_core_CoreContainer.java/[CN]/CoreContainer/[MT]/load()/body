{
  log.info("Loading cores into CoreContainer [instanceDir={}]",loader.getInstanceDir());
  String libDir=cfg.getSharedLibDirectory();
  if (libDir != null) {
    File f=FileUtils.resolvePath(new File(solrHome),libDir);
    log.info("loading shared library: " + f.getAbsolutePath());
    loader.addToClassLoader(libDir,null,false);
    loader.reloadLuceneSPI();
  }
  shardHandlerFactory=ShardHandlerFactory.newInstance(cfg.getShardHandlerFactoryPluginInfo(),loader);
  updateShardHandler=new UpdateShardHandler(cfg);
  solrCores.allocateLazyCores(cfg.getTransientCacheSize(),loader);
  logging=LogWatcher.newRegisteredLogWatcher(cfg.getLogWatcherConfig(),loader);
  hostName=cfg.getHost();
  log.info("Host Name: " + hostName);
  zkSys.initZooKeeper(this,solrHome,cfg);
  collectionsHandler=createHandler(cfg.getCollectionsHandlerClass(),CollectionsHandler.class);
  infoHandler=createHandler(cfg.getInfoHandlerClass(),InfoHandler.class);
  coreAdminHandler=createHandler(cfg.getCoreAdminHandlerClass(),CoreAdminHandler.class);
  coreConfigService=cfg.createCoreConfigService(loader,zkSys.getZkController());
  containerProperties=cfg.getSolrProperties("solr");
  ExecutorService coreLoadExecutor=Executors.newFixedThreadPool((zkSys.getZkController() == null ? cfg.getCoreLoadThreadCount() : Integer.MAX_VALUE),new DefaultSolrThreadFactory("coreLoadExecutor"));
  try {
    CompletionService<SolrCore> completionService=new ExecutorCompletionService<>(coreLoadExecutor);
    Set<Future<SolrCore>> pending=new HashSet<>();
    List<CoreDescriptor> cds=coresLocator.discover(this);
    checkForDuplicateCoreNames(cds);
    for (    final CoreDescriptor cd : cds) {
      final String name=cd.getName();
      try {
        if (cd.isTransient() || !cd.isLoadOnStartup()) {
          solrCores.putDynamicDescriptor(name,cd);
        }
        if (cd.isLoadOnStartup()) {
          Callable<SolrCore> task=new Callable<SolrCore>(){
            @Override public SolrCore call(){
              try {
                return create(cd,false);
              }
 catch (              Exception e) {
                SolrException.log(log,null,e);
                return null;
              }
            }
          }
;
          pending.add(completionService.submit(task));
        }
      }
 catch (      Exception e) {
        SolrException.log(log,null,e);
      }
    }
    while (pending != null && pending.size() > 0) {
      try {
        Future<SolrCore> future=completionService.take();
        if (future == null)         return;
        pending.remove(future);
        try {
          SolrCore c=future.get();
          if (c != null) {
            solrCores.putCoreToOrigName(c,c.getName());
          }
        }
 catch (        ExecutionException e) {
          SolrException.log(SolrCore.log,"Error loading core",e);
        }
      }
 catch (      InterruptedException e) {
        throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,"interrupted while loading core",e);
      }
    }
    backgroundCloser=new CloserThread(this,solrCores,cfg);
    backgroundCloser.start();
  }
  finally {
    if (coreLoadExecutor != null) {
      ExecutorUtil.shutdownNowAndAwaitTermination(coreLoadExecutor);
    }
  }
  if (isZooKeeperAware()) {
    Collection<SolrCore> cores=getCores();
    if (cores != null) {
      for (      SolrCore core : cores) {
        try {
          zkSys.registerInZk(core,true);
        }
 catch (        Throwable t) {
          SolrException.log(log,"Error registering SolrCore",t);
        }
      }
    }
    zkSys.getZkController().checkOverseerDesignate();
  }
}
