{
  super(label);
  this.min=minIn;
  this.max=maxIn;
  this.minInclusive=minInclusive;
  this.maxInclusive=maxInclusive;
  if (Double.isNaN(min)) {
    throw new IllegalArgumentException("min cannot be NaN");
  }
  if (!minInclusive) {
    minIn=Math.nextUp(minIn);
  }
  if (Double.isNaN(max)) {
    throw new IllegalArgumentException("max cannot be NaN");
  }
  if (!maxInclusive) {
    maxIn=Math.nextAfter(maxIn,Double.NEGATIVE_INFINITY);
  }
  if (minIn > maxIn) {
    failNoMatch();
  }
  this.minIncl=minIn;
  this.maxIncl=maxIn;
}
