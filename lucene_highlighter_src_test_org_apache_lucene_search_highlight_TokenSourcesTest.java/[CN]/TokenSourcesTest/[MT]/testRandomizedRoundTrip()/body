{
  final int distinct=TestUtil.nextInt(random(),1,10);
  String[] terms=new String[distinct];
  BytesRef[] termBytes=new BytesRef[distinct];
  for (int i=0; i < distinct; ++i) {
    terms[i]=TestUtil.randomRealisticUnicodeString(random());
    termBytes[i]=new BytesRef(terms[i]);
  }
  final BaseTermVectorsFormatTestCase.RandomTokenStream rTokenStream=new BaseTermVectorsFormatTestCase.RandomTokenStream(TestUtil.nextInt(random(),1,10),terms,termBytes,false);
  final boolean storeTermVectorPositions=random().nextBoolean();
  final int[] startOffsets=rTokenStream.getStartOffsets();
  final int[] positionsIncrements=rTokenStream.getPositionsIncrements();
  for (int i=1; i < positionsIncrements.length; i++) {
    if (storeTermVectorPositions && positionsIncrements[i] != 0) {
      continue;
    }
    if (startOffsets[i] == startOffsets[i - 1]) {
      if (VERBOSE)       System.out.println("Skipping test because can't easily validate random token-stream is correct.");
      return;
    }
  }
  assertTokenStreamContents(rTokenStream,rTokenStream.getTerms(),rTokenStream.getStartOffsets(),rTokenStream.getEndOffsets(),rTokenStream.getPositionsIncrements());
  Directory dir=newDirectory();
  RandomIndexWriter writer=new RandomIndexWriter(random(),dir);
  FieldType myFieldType=new FieldType(TextField.TYPE_NOT_STORED);
  myFieldType.setStoreTermVectors(true);
  myFieldType.setStoreTermVectorOffsets(true);
  myFieldType.setStoreTermVectorPositions(storeTermVectorPositions);
  myFieldType.setStoreTermVectorPayloads(storeTermVectorPositions && random().nextBoolean());
  Document doc=new Document();
  doc.add(new Field("field",rTokenStream,myFieldType));
  writer.addDocument(doc);
  IndexReader reader=writer.getReader();
  writer.close();
  assertEquals(1,reader.numDocs());
  TokenStream vectorTokenStream=TokenSources.getTermVectorTokenStreamOrNull("field",reader.getTermVectors(0),-1);
  PayloadAttribute payloadAttribute=null;
  if (myFieldType.storeTermVectorPayloads() && usually()) {
    payloadAttribute=vectorTokenStream.addAttribute(PayloadAttribute.class);
  }
  assertTokenStreamContents(vectorTokenStream,rTokenStream.getTerms(),rTokenStream.getStartOffsets(),rTokenStream.getEndOffsets(),myFieldType.storeTermVectorPositions() ? rTokenStream.getPositionsIncrements() : null);
  if (payloadAttribute != null) {
    vectorTokenStream.reset();
    for (int i=0; vectorTokenStream.incrementToken(); i++) {
      assertEquals(rTokenStream.getPayloads()[i],payloadAttribute.getPayload());
    }
  }
  reader.close();
  dir.close();
}
