{
  OpenBitSet resultBits=null;
  int minDocFreqFrom=Math.max(5,fromSearcher.maxDoc() >> 13);
  int minDocFreqTo=Math.max(5,toSearcher.maxDoc() >> 13);
  int maxSortedIntSize=Math.max(10,toSearcher.maxDoc() >> 10);
  DocSet fromSet=fromSearcher.getDocSet(q);
  fromSetSize=fromSet.size();
  List<DocSet> resultList=new ArrayList<DocSet>(10);
  DocSet fastForRandomSet=fromSet;
  if (minDocFreqFrom > 0 && fromSet instanceof SortedIntDocSet) {
    SortedIntDocSet sset=(SortedIntDocSet)fromSet;
    fastForRandomSet=new HashDocSet(sset.getDocs(),0,sset.size());
  }
  Fields fromFields=MultiFields.getFields(fromSearcher.getIndexReader());
  Fields toFields=fromSearcher == toSearcher ? fromFields : MultiFields.getFields(toSearcher.getIndexReader());
  if (fromFields == null)   return DocSet.EMPTY;
  Terms terms=fromFields.terms(fromField);
  Terms toTerms=toFields.terms(toField);
  if (terms == null || toTerms == null)   return DocSet.EMPTY;
  String prefixStr=TrieField.getMainValuePrefix(fromSearcher.getSchema().getFieldType(fromField));
  BytesRef prefix=prefixStr == null ? null : new BytesRef(prefixStr);
  BytesRef term=null;
  TermsEnum termsEnum=terms.iterator();
  TermsEnum toTermsEnum=toTerms.iterator();
  SolrIndexSearcher.DocsEnumState fromDeState=null;
  SolrIndexSearcher.DocsEnumState toDeState=null;
  if (prefix == null) {
    term=termsEnum.next();
  }
 else {
    if (termsEnum.seek(prefix,true) != TermsEnum.SeekStatus.END) {
      term=termsEnum.term();
    }
  }
  Bits fromDeletedDocs=MultiFields.getDeletedDocs(fromSearcher.getIndexReader());
  Bits toDeletedDocs=fromSearcher == toSearcher ? fromDeletedDocs : MultiFields.getDeletedDocs(toSearcher.getIndexReader());
  fromDeState=new SolrIndexSearcher.DocsEnumState();
  fromDeState.fieldName=StringHelper.intern(fromField);
  fromDeState.deletedDocs=fromDeletedDocs;
  fromDeState.termsEnum=termsEnum;
  fromDeState.docsEnum=null;
  fromDeState.minSetSizeCached=minDocFreqFrom;
  toDeState=new SolrIndexSearcher.DocsEnumState();
  toDeState.fieldName=StringHelper.intern(toField);
  toDeState.deletedDocs=toDeletedDocs;
  toDeState.termsEnum=toTermsEnum;
  toDeState.docsEnum=null;
  toDeState.minSetSizeCached=minDocFreqTo;
  while (term != null) {
    if (prefix != null && !term.startsWith(prefix))     break;
    fromTermCount++;
    boolean intersects=false;
    int freq=termsEnum.docFreq();
    fromTermTotalDf++;
    if (freq < minDocFreqFrom) {
      fromTermDirectCount++;
      fromDeState.docsEnum=fromDeState.termsEnum.docs(null,fromDeState.docsEnum);
      DocsEnum docsEnum=fromDeState.docsEnum;
      if (docsEnum instanceof MultiDocsEnum) {
        MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
        int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
        outer:         for (int subindex=0; subindex < numSubs; subindex++) {
          MultiDocsEnum.EnumWithSlice sub=subs[subindex];
          if (sub.docsEnum == null)           continue;
          DocsEnum.BulkReadResult bulk=sub.docsEnum.getBulkResult();
          int base=sub.slice.start;
          for (; ; ) {
            int nDocs=sub.docsEnum.read();
            if (nDocs == 0)             break;
            int[] docArr=bulk.docs.ints;
            int end=bulk.docs.offset + nDocs;
            for (int i=bulk.docs.offset; i < end; i++) {
              if (fastForRandomSet.exists(docArr[i] + base)) {
                intersects=true;
                break outer;
              }
            }
          }
        }
      }
 else {
        DocsEnum.BulkReadResult bulk=docsEnum.getBulkResult();
        outer:         for (; ; ) {
          int nDocs=docsEnum.read();
          if (nDocs == 0)           break;
          int[] docArr=bulk.docs.ints;
          int end=bulk.docs.offset + nDocs;
          for (int i=bulk.docs.offset; i < end; i++) {
            if (fastForRandomSet.exists(docArr[i])) {
              intersects=true;
              break outer;
            }
          }
        }
      }
    }
 else {
      DocSet fromTermSet=fromSearcher.getDocSet(fromDeState);
      intersects=fromSet.intersects(fromTermSet);
    }
    if (intersects) {
      fromTermHits++;
      fromTermHitsTotalDf++;
      TermsEnum.SeekStatus status=toTermsEnum.seek(term);
      if (status == TermsEnum.SeekStatus.END)       break;
      if (status == TermsEnum.SeekStatus.FOUND) {
        toTermHits++;
        int df=toTermsEnum.docFreq();
        toTermHitsTotalDf+=df;
        if (resultBits == null && df + resultListDocs > maxSortedIntSize && resultList.size() > 0) {
          resultBits=new OpenBitSet(toSearcher.maxDoc());
        }
        if (toTermsEnum.docFreq() >= minDocFreqTo || resultBits == null) {
          DocSet toTermSet=toSearcher.getDocSet(toDeState);
          resultListDocs+=toTermSet.size();
          if (resultBits != null) {
            toTermSet.setBitsOn(resultBits);
          }
 else {
            if (toTermSet instanceof BitDocSet) {
              resultBits=(OpenBitSet)((BitDocSet)toTermSet).bits.clone();
            }
 else {
              resultList.add(toTermSet);
            }
          }
        }
 else {
          toTermDirectCount++;
          toDeState.docsEnum=toDeState.termsEnum.docs(toDeState.deletedDocs,toDeState.docsEnum);
          DocsEnum docsEnum=toDeState.docsEnum;
          if (docsEnum instanceof MultiDocsEnum) {
            MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
            int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
            for (int subindex=0; subindex < numSubs; subindex++) {
              MultiDocsEnum.EnumWithSlice sub=subs[subindex];
              if (sub.docsEnum == null)               continue;
              DocsEnum.BulkReadResult bulk=sub.docsEnum.getBulkResult();
              int base=sub.slice.start;
              for (; ; ) {
                int nDocs=sub.docsEnum.read();
                if (nDocs == 0)                 break;
                resultListDocs+=nDocs;
                int[] docArr=bulk.docs.ints;
                int end=bulk.docs.offset + nDocs;
                for (int i=bulk.docs.offset; i < end; i++) {
                  resultBits.fastSet(docArr[i] + base);
                }
              }
            }
          }
 else {
            DocsEnum.BulkReadResult bulk=docsEnum.getBulkResult();
            for (; ; ) {
              int nDocs=docsEnum.read();
              if (nDocs == 0)               break;
              resultListDocs+=nDocs;
              int[] docArr=bulk.docs.ints;
              int end=bulk.docs.offset + nDocs;
              for (int i=bulk.docs.offset; i < end; i++) {
                resultBits.fastSet(docArr[i]);
              }
            }
          }
        }
      }
    }
    term=termsEnum.next();
  }
  smallSetsDeferred=resultList.size();
  if (resultBits != null) {
    for (    DocSet set : resultList) {
      set.setBitsOn(resultBits);
    }
    return new BitDocSet(resultBits);
  }
  if (resultList.size() == 0) {
    return DocSet.EMPTY;
  }
  if (resultList.size() == 1) {
    return resultList.get(0);
  }
  int sz=resultList.size();
  for (  DocSet set : resultList)   sz+=set.size();
  int[] docs=new int[sz];
  int pos=0;
  for (  DocSet set : resultList) {
    System.arraycopy(((SortedIntDocSet)set).getDocs(),0,docs,pos,set.size());
    pos+=set.size();
  }
  Arrays.sort(docs);
  int[] dedup=new int[sz];
  pos=0;
  int last=-1;
  for (  int doc : docs) {
    if (doc != last)     dedup[pos++]=doc;
    last=doc;
  }
  if (pos != dedup.length) {
    dedup=Arrays.copyOf(dedup,pos);
  }
  return new SortedIntDocSet(dedup,dedup.length);
}
