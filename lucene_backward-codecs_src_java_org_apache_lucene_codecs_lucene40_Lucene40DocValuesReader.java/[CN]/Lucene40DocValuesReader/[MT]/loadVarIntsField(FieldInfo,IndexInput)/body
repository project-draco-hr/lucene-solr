{
  CodecUtil.checkHeader(input,Lucene40DocValuesFormat.VAR_INTS_CODEC_NAME,Lucene40DocValuesFormat.VAR_INTS_VERSION_START,Lucene40DocValuesFormat.VAR_INTS_VERSION_CURRENT);
  byte header=input.readByte();
  if (header == Lucene40DocValuesFormat.VAR_INTS_FIXED_64) {
    int maxDoc=state.segmentInfo.getDocCount();
    final long values[]=new long[maxDoc];
    for (int i=0; i < values.length; i++) {
      values[i]=input.readLong();
    }
    long bytesUsed=RamUsageEstimator.sizeOf(values);
    instanceInfo.put(field.name,Accountables.namedAccountable("long array",bytesUsed));
    ramBytesUsed.addAndGet(bytesUsed);
    return new NumericDocValues(){
      @Override public long get(      int docID){
        return values[docID];
      }
    }
;
  }
 else   if (header == Lucene40DocValuesFormat.VAR_INTS_PACKED) {
    final long minValue=input.readLong();
    final long defaultValue=input.readLong();
    final PackedInts.Reader reader=PackedInts.getReader(input);
    instanceInfo.put(field.name,reader);
    ramBytesUsed.addAndGet(reader.ramBytesUsed());
    return new NumericDocValues(){
      @Override public long get(      int docID){
        final long value=reader.get(docID);
        if (value == defaultValue) {
          return 0;
        }
 else {
          return minValue + value;
        }
      }
    }
;
  }
 else {
    throw new CorruptIndexException("invalid VAR_INTS header byte: " + header,input);
  }
}
