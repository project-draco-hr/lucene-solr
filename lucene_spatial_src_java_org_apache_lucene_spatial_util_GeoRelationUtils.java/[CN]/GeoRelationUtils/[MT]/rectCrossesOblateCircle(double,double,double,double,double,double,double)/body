{
  double w=Math.abs(rMaxLon - rMinLon);
  final int segs=(int)Math.ceil(w / 45.0);
  w/=segs;
  short i=1;
  double p1=rMinLon;
  double maxLon, midLon;
  double[] pt=new double[2];
  do {
    maxLon=(i == segs) ? rMaxLon : p1 + w;
    final double d1, d2;
    if ((d1=GeoDistanceUtils.haversin(centerLat,centerLon,rMinLat,p1)) > radiusMeters || (d2=GeoDistanceUtils.haversin(centerLat,centerLon,rMinLat,maxLon)) > radiusMeters || GeoDistanceUtils.haversin(centerLat,centerLon,rMaxLat,p1) > radiusMeters || GeoDistanceUtils.haversin(centerLat,centerLon,rMaxLat,maxLon) > radiusMeters) {
      return true;
    }
    if ((rMaxLat > 88.0 || rMinLat < -88.0) && (pt=GeoProjectionUtils.pointFromLonLatBearingGreatCircle(p1,rMinLat,GeoProjectionUtils.bearingGreatCircle(p1,rMinLat,p1,rMaxLat),radiusMeters - d1,pt))[1] < rMinLat || pt[1] < rMaxLat || (pt=GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon,rMinLat,GeoProjectionUtils.bearingGreatCircle(maxLon,rMinLat,maxLon,rMaxLat),radiusMeters - d2,pt))[1] < rMinLat || pt[1] < rMaxLat || (pt=GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon,rMinLat,GeoProjectionUtils.bearingGreatCircle(maxLon,rMinLat,(midLon=p1 + 0.5 * (maxLon - p1)),rMaxLat),radiusMeters - GeoDistanceUtils.haversin(centerLat,centerLon,rMinLat,midLon),pt))[1] < rMinLat || pt[1] < rMaxLat == false) {
      return true;
    }
    p1+=w;
  }
 while (++i <= segs);
  return false;
}
