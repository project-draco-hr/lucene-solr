{
  double w=Math.abs(rMaxLon - rMinLon);
  final int segs=(int)Math.ceil(w / 45.0);
  w/=segs;
  short i=1;
  double p1=rMinLon;
  double maxLon, midLon;
  double[] pt=new double[2];
  do {
    maxLon=(i == segs) ? rMaxLon : p1 + w;
    final double d1, d2;
    if ((d1=SloppyMath.haversinMeters(centerLat,centerLon,rMinLat,p1)) > radiusMeters || (d2=SloppyMath.haversinMeters(centerLat,centerLon,rMinLat,maxLon)) > radiusMeters || SloppyMath.haversinMeters(centerLat,centerLon,rMaxLat,p1) > radiusMeters || SloppyMath.haversinMeters(centerLat,centerLon,rMaxLat,maxLon) > radiusMeters) {
      return true;
    }
    if ((rMaxLat > 88.0 || rMinLat < -88.0) && (pt=GeoProjectionUtils.pointFromLonLatBearingGreatCircle(rMinLat,p1,GeoProjectionUtils.bearingGreatCircle(rMinLat,p1,rMaxLat,p1),radiusMeters - d1,pt))[1] < rMinLat || pt[1] < rMaxLat || (pt=GeoProjectionUtils.pointFromLonLatBearingGreatCircle(rMinLat,maxLon,GeoProjectionUtils.bearingGreatCircle(rMinLat,maxLon,rMaxLat,maxLon),radiusMeters - d2,pt))[1] < rMinLat || pt[1] < rMaxLat || (pt=GeoProjectionUtils.pointFromLonLatBearingGreatCircle(rMinLat,maxLon,GeoProjectionUtils.bearingGreatCircle(rMinLat,maxLon,rMaxLat,(midLon=p1 + 0.5 * (maxLon - p1))),radiusMeters - SloppyMath.haversinMeters(centerLat,centerLon,rMinLat,midLon),pt))[1] < rMinLat || pt[1] < rMaxLat == false) {
      return true;
    }
    p1+=w;
  }
 while (++i <= segs);
  return false;
}
