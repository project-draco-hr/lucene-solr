{
  if (testPoint.isNumericallyIdentical(thePoint)) {
    return testPointInSet;
  }
  final double xDelta=Math.abs(thePoint.x - testPoint.x);
  final double yDelta=Math.abs(thePoint.y - testPoint.y);
  final double zDelta=Math.abs(thePoint.z - testPoint.z);
  if (testPointXZPlane.evaluateIsZero(thePoint)) {
    final LinearCrossingEdgeIterator crossingEdgeIterator=new LinearCrossingEdgeIterator(testPointXZPlane,testPointXZAbovePlane,testPointXZBelowPlane,testPoint,thePoint);
    if (!yTree.traverse(crossingEdgeIterator,testPoint.y,testPoint.y)) {
      return true;
    }
    return ((crossingEdgeIterator.crossingCount & 1) == 0) ? testPointInSet : !testPointInSet;
  }
 else   if (testPointYZPlane.evaluateIsZero(thePoint)) {
    final LinearCrossingEdgeIterator crossingEdgeIterator=new LinearCrossingEdgeIterator(testPointYZPlane,testPointYZAbovePlane,testPointYZBelowPlane,testPoint,thePoint);
    if (!xTree.traverse(crossingEdgeIterator,testPoint.x,testPoint.x)) {
      return true;
    }
    return ((crossingEdgeIterator.crossingCount & 1) == 0) ? testPointInSet : !testPointInSet;
  }
 else   if (testPointXYPlane.evaluateIsZero(thePoint)) {
    final LinearCrossingEdgeIterator crossingEdgeIterator=new LinearCrossingEdgeIterator(testPointXYPlane,testPointXYAbovePlane,testPointXYBelowPlane,testPoint,thePoint);
    if (!zTree.traverse(crossingEdgeIterator,testPoint.z,testPoint.z)) {
      return true;
    }
    return ((crossingEdgeIterator.crossingCount & 1) == 0) ? testPointInSet : !testPointInSet;
  }
 else {
    if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {
      final Plane travelPlane=new Plane(0.0,1.0,0.0,-thePoint.y);
      final DualCrossingEdgeIterator edgeIterator=new DualCrossingEdgeIterator(testPointYZPlane,testPointYZAbovePlane,testPointYZBelowPlane,travelPlane,testPoint,thePoint);
      if (!xTree.traverse(edgeIterator,testPoint.x,testPoint.x)) {
        return true;
      }
      edgeIterator.setSecondLeg();
      if (!yTree.traverse(edgeIterator,thePoint.y,thePoint.y)) {
        return true;
      }
      return ((edgeIterator.crossingCount & 1) == 0) ? testPointInSet : !testPointInSet;
    }
 else     if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {
      final Plane travelPlane=new Plane(1.0,0.0,0.0,-thePoint.x);
      final DualCrossingEdgeIterator edgeIterator=new DualCrossingEdgeIterator(testPointXYPlane,testPointXYAbovePlane,testPointXYBelowPlane,travelPlane,testPoint,thePoint);
      if (!zTree.traverse(edgeIterator,testPoint.z,testPoint.z)) {
        return true;
      }
      edgeIterator.setSecondLeg();
      if (!xTree.traverse(edgeIterator,thePoint.x,thePoint.x)) {
        return true;
      }
      return ((edgeIterator.crossingCount & 1) == 0) ? testPointInSet : !testPointInSet;
    }
 else     if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {
      final Plane travelPlane=new Plane(0.0,0.0,1.0,-thePoint.z);
      final DualCrossingEdgeIterator edgeIterator=new DualCrossingEdgeIterator(testPointXZPlane,testPointXZAbovePlane,testPointXZBelowPlane,travelPlane,testPoint,thePoint);
      if (!yTree.traverse(edgeIterator,testPoint.y,testPoint.y)) {
        return true;
      }
      edgeIterator.setSecondLeg();
      if (!zTree.traverse(edgeIterator,thePoint.z,thePoint.z)) {
        return true;
      }
      return ((edgeIterator.crossingCount & 1) == 0) ? testPointInSet : !testPointInSet;
    }
  }
  return false;
}
