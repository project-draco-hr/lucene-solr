{
  if (node == null) {
    final Node rval=new Node(newEdge,minimumValue,maximumValue);
    return rval;
  }
  int result=compareForAdd(node.minimumValue,node.maximumValue,minimumValue,maximumValue);
switch (result) {
case CONTAINED:
{
      final double lesserMaximum=Math.nextDown(node.minimumValue);
      final double greaterMinimum=Math.nextUp(node.maximumValue);
      node.lesser=addEdge(node.lesser,newEdge,minimumValue,lesserMaximum);
      node.greater=addEdge(node.greater,newEdge,greaterMinimum,maximumValue);
      return addEdge(node,newEdge,node.minimumValue,node.maximumValue);
    }
case EXACT:
  final Node rval=new Node(newEdge,minimumValue,maximumValue);
rval.within=node;
rval.lesser=node.lesser;
rval.greater=node.greater;
node.lesser=null;
node.greater=null;
return rval;
case WITHIN:
node.within=addEdge(node.within,newEdge,minimumValue,maximumValue);
return node;
case OVERLAPS_MINIMUM:
{
final double lesserMaximum=Math.nextDown(node.minimumValue);
node.lesser=addEdge(node.lesser,newEdge,minimumValue,lesserMaximum);
return addEdge(node,newEdge,node.minimumValue,maximumValue);
}
case OVERLAPS_MAXIMUM:
{
final double greaterMinimum=Math.nextUp(node.maximumValue);
node.greater=addEdge(node.greater,newEdge,greaterMinimum,maximumValue);
return addEdge(node,newEdge,minimumValue,node.maximumValue);
}
case LESS:
node.lesser=addEdge(node.lesser,newEdge,minimumValue,maximumValue);
return node;
case GREATER:
node.greater=addEdge(node.greater,newEdge,minimumValue,maximumValue);
return node;
default :
throw new RuntimeException("Unexpected comparison result: " + result);
}
}
