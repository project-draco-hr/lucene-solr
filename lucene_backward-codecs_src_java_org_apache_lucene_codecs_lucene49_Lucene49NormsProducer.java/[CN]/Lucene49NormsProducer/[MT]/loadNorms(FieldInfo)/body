{
  NormsEntry entry=norms.get(field.name);
switch (entry.format) {
case CONST_COMPRESSED:
    if (!merging) {
      instancesInfo.put(field.name,Accountables.namedAccountable("constant",8));
      ramBytesUsed.addAndGet(8);
    }
  final long v=entry.offset;
return new NumericDocValues(){
  @Override public long get(  int docID){
    return v;
  }
}
;
case UNCOMPRESSED:
data.seek(entry.offset);
final byte bytes[]=new byte[maxDoc];
data.readBytes(bytes,0,bytes.length);
if (!merging) {
ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(bytes));
instancesInfo.put(field.name,Accountables.namedAccountable("byte array",maxDoc));
}
return new NumericDocValues(){
@Override public long get(int docID){
return bytes[docID];
}
}
;
case DELTA_COMPRESSED:
data.seek(entry.offset);
int packedIntsVersion=data.readVInt();
int blockSize=data.readVInt();
final BlockPackedReader reader=new BlockPackedReader(data,packedIntsVersion,blockSize,maxDoc,false);
if (!merging) {
ramBytesUsed.addAndGet(reader.ramBytesUsed());
instancesInfo.put(field.name,Accountables.namedAccountable("delta compressed",reader));
}
return reader;
case TABLE_COMPRESSED:
data.seek(entry.offset);
int packedVersion=data.readVInt();
int size=data.readVInt();
if (size > 256) {
throw new CorruptIndexException("TABLE_COMPRESSED cannot have more than 256 distinct values, got=" + size,data);
}
final long decode[]=new long[size];
for (int i=0; i < decode.length; i++) {
decode[i]=data.readLong();
}
final int formatID=data.readVInt();
final int bitsPerValue=data.readVInt();
final PackedInts.Reader ordsReader=PackedInts.getReaderNoHeader(data,PackedInts.Format.byId(formatID),packedVersion,maxDoc,bitsPerValue);
if (!merging) {
ramBytesUsed.addAndGet(RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed());
instancesInfo.put(field.name,Accountables.namedAccountable("table compressed",ordsReader));
}
return new NumericDocValues(){
@Override public long get(int docID){
return decode[(int)ordsReader.get(docID)];
}
}
;
default :
throw new AssertionError();
}
}
