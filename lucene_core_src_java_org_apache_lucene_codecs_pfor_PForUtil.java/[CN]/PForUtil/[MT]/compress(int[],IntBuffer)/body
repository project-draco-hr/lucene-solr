{
  int numBits=getNumBits(data);
  if (numBits == 0) {
    return compressDuplicateBlock(data,intBuffer);
  }
  int size=data.length;
  int[] excValues=new int[size];
  int excNum=0, excLastPos=-1, excFirstPos=-1, excLastNonForcePos=-1;
  int excNumBase=0;
  int excBytes=1;
  int excByteOffset=0;
  long maxChainFirst=254;
  long maxChain=maxChainFirst + 1;
  boolean conValue, conForce, conEnd;
  int i=0;
  for (i=0; i < size; ++i) {
    conValue=((data[i] & MASK[numBits]) != data[i]);
    conForce=(i >= maxChain + excLastPos);
    if (conValue || conForce) {
      excValues[excNum++]=data[i];
      if (excLastPos == -1) {
        maxChain=1L << numBits;
        excFirstPos=i;
      }
      if (conValue) {
        excLastNonForcePos=i;
        excNumBase=excNum;
      }
      excLastPos=i;
    }
  }
  excNum=0;
  if (excFirstPos < 0) {
    for (i=0; i < size; ++i) {
      encodeNormalValue(intBuffer,i,data[i],numBits);
    }
    excLastPos=-1;
  }
 else {
    for (i=0; i < excFirstPos; ++i) {
      encodeNormalValue(intBuffer,i,data[i],numBits);
    }
    maxChain=1L << numBits;
    excLastPos=excFirstPos;
    excNum=i < size ? 1 : 0;
    for (i=excFirstPos + 1; i < size; ++i) {
      conValue=((data[i] & MASK[numBits]) != data[i]);
      conForce=(i >= maxChain + excLastPos);
      conEnd=(excNum == excNumBase);
      if ((!conValue && !conForce) || conEnd) {
        encodeNormalValue(intBuffer,i,data[i],numBits);
      }
 else {
        encodeNormalValue(intBuffer,excLastPos,i - excLastPos - 1,numBits);
        excNum++;
        excLastPos=i;
      }
    }
  }
  for (i=0; i < excNum; ++i) {
    if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {
      excBytes=2;
    }
    if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {
      excBytes=4;
    }
  }
  excByteOffset=(size * numBits + 7) / 8;
  encodeExcValues(intBuffer,excValues,excNum,excBytes,excByteOffset);
  int encodedSize=(excByteOffset + excBytes * excNum + 3) / 4;
  return getHeader(encodedSize,numBits,excNum,excFirstPos,excBytes);
}
