{
  FieldType ft=searcher.getSchema().getFieldType(field);
  NamedList res=new NamedList();
  DocSet docs=baseDocs;
  int baseSize=docs.size();
  int maxDoc=searcher.maxDoc();
  if (baseSize >= mincount) {
    final int[] index=this.index;
    final int[] counts=new int[numTermsInField];
    int startTerm=0;
    int endTerm=numTermsInField;
    NumberedTermEnum te=ti.getEnumerator(searcher.getReader());
    if (prefix != null && prefix.length() > 0) {
      te.skipTo(prefix);
      startTerm=te.getTermNumber();
      te.skipTo(prefix + "\uffff\uffff\uffff\uffff");
      endTerm=te.getTermNumber();
    }
    boolean doNegative=baseSize > maxDoc >> 1 && termInstances > 0 && startTerm == 0 && endTerm == numTermsInField && docs instanceof BitDocSet;
    if (doNegative) {
      OpenBitSet bs=(OpenBitSet)((BitDocSet)docs).getBits().clone();
      bs.flip(0,maxDoc);
      docs=new BitDocSet(bs,maxDoc - baseSize);
    }
    for (    TopTerm tt : bigTerms.values()) {
      if (tt.termNum >= startTerm && tt.termNum < endTerm) {
        counts[tt.termNum]=searcher.numDocs(new TermQuery(tt.term),docs);
      }
    }
    if (termInstances > 0) {
      DocIterator iter=docs.iterator();
      while (iter.hasNext()) {
        int doc=iter.nextDoc();
        int code=index[doc];
        if ((code & 0xff) == 1) {
          int pos=code >>> 8;
          int whichArray=(doc >>> 16) & 0xff;
          byte[] arr=tnums[whichArray];
          int tnum=0;
          for (; ; ) {
            int delta=0;
            for (; ; ) {
              byte b=arr[pos++];
              delta=(delta << 7) | (b & 0x7f);
              if ((b & 0x80) == 0)               break;
            }
            if (delta == 0)             break;
            tnum+=delta - TNUM_OFFSET;
            counts[tnum]++;
          }
        }
 else {
          int tnum=0;
          int delta=0;
          for (; ; ) {
            delta=(delta << 7) | (code & 0x7f);
            if ((code & 0x80) == 0) {
              if (delta == 0)               break;
              tnum+=delta - TNUM_OFFSET;
              counts[tnum]++;
              delta=0;
            }
            code>>>=8;
          }
        }
      }
    }
    int off=offset;
    int lim=limit >= 0 ? limit : Integer.MAX_VALUE;
    if (sort.equals(FacetParams.FACET_SORT_COUNT) || sort.equals(FacetParams.FACET_SORT_COUNT_LEGACY)) {
      int maxsize=limit > 0 ? offset + limit : Integer.MAX_VALUE - 1;
      maxsize=Math.min(maxsize,numTermsInField);
      final BoundedTreeSet<Long> queue=new BoundedTreeSet<Long>(maxsize);
      int min=mincount - 1;
      for (int i=startTerm; i < endTerm; i++) {
        int c=doNegative ? maxTermCounts[i] - counts[i] : counts[i];
        if (c > min) {
          long pair=(((long)-c) << 32) | i;
          queue.add(new Long(pair));
          if (queue.size() >= maxsize)           min=-(int)(queue.last().longValue() >>> 32);
        }
      }
      for (      Long p : queue) {
        if (--off >= 0)         continue;
        if (--lim < 0)         break;
        int c=-(int)(p.longValue() >>> 32);
        int tnum=(int)p.longValue();
        String label=ft.indexedToReadable(getTermText(te,tnum));
        res.add(label,c);
      }
    }
 else {
      int i=startTerm;
      if (mincount <= 0) {
        i=startTerm + off;
        off=0;
      }
      for (; i < endTerm; i++) {
        int c=doNegative ? maxTermCounts[i] - counts[i] : counts[i];
        if (c == 0) {
        }
        if (c < mincount || --off >= 0)         continue;
        if (--lim < 0)         break;
        String label=ft.indexedToReadable(getTermText(te,i));
        res.add(label,c);
      }
    }
    te.close();
  }
  if (missing) {
    res.add(null,SimpleFacets.getFieldMissingCount(searcher,baseDocs,field));
  }
  return res;
}
