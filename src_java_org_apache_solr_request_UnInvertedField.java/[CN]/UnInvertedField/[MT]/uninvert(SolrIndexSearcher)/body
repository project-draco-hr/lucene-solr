{
  long startTime=System.currentTimeMillis();
  IndexReader reader=searcher.getReader();
  int maxDoc=reader.maxDoc();
  int[] index=new int[maxDoc];
  this.index=index;
  final int[] lastTerm=new int[maxDoc];
  final byte[][] bytes=new byte[maxDoc][];
  maxTermCounts=new int[1024];
  NumberedTermEnum te=ti.getEnumerator(reader);
  int threshold=maxDoc / 20 + 2;
  int[] docs=new int[1000];
  int[] freqs=new int[1000];
  byte[] tempArr=new byte[12];
  for (; ; ) {
    Term t=te.term();
    if (t == null)     break;
    int termNum=te.getTermNumber();
    if (termNum >= maxTermCounts.length) {
      int[] newMaxTermCounts=new int[maxTermCounts.length + 4096];
      System.arraycopy(maxTermCounts,0,newMaxTermCounts,0,termNum);
      maxTermCounts=newMaxTermCounts;
    }
    int df=te.docFreq();
    if (df >= threshold) {
      TopTerm topTerm=new TopTerm();
      topTerm.term=t;
      topTerm.termNum=termNum;
      bigTerms.put(topTerm.termNum,topTerm);
      DocSet set=searcher.getDocSet(new TermQuery(topTerm.term));
      maxTermCounts[termNum]=set.size();
      te.next();
      continue;
    }
    termsInverted++;
    TermDocs td=te.getTermDocs();
    td.seek(te);
    for (; ; ) {
      int n=td.read(docs,freqs);
      if (n <= 0)       break;
      maxTermCounts[termNum]+=n;
      for (int i=0; i < n; i++) {
        termInstances++;
        int doc=docs[i];
        int delta=termNum - lastTerm[doc] + TNUM_OFFSET;
        lastTerm[doc]=termNum;
        int val=index[doc];
        if ((val & 0xff) == 1) {
          int pos=val >>> 8;
          int ilen=vIntSize(delta);
          byte[] arr=bytes[doc];
          int newend=pos + ilen;
          if (newend > arr.length) {
            int newLen=(newend + 3) & 0xfffffffc;
            byte[] newarr=new byte[newLen];
            System.arraycopy(arr,0,newarr,0,pos);
            arr=newarr;
            bytes[doc]=newarr;
          }
          pos=writeInt(delta,arr,pos);
          index[doc]=(pos << 8) | 1;
        }
 else {
          int ipos;
          if (val == 0) {
            ipos=0;
          }
 else           if ((val & 0x0000ff80) == 0) {
            ipos=1;
          }
 else           if ((val & 0x00ff8000) == 0) {
            ipos=2;
          }
 else           if ((val & 0xff800000) == 0) {
            ipos=3;
          }
 else {
            ipos=4;
          }
          int endPos=writeInt(delta,tempArr,ipos);
          if (endPos <= 4) {
            for (int j=ipos; j < endPos; j++) {
              val|=(tempArr[j] & 0xff) << (j << 3);
            }
            index[doc]=val;
          }
 else {
            for (int j=0; j < ipos; j++) {
              tempArr[j]=(byte)val;
              val>>>=8;
            }
            index[doc]=(endPos << 8) | 1;
            bytes[doc]=tempArr;
            tempArr=new byte[12];
          }
        }
      }
    }
    te.next();
  }
  numTermsInField=te.getTermNumber();
  te.close();
  long midPoint=System.currentTimeMillis();
  if (termInstances == 0) {
    index=this.index=null;
    tnums=null;
  }
 else {
    for (int pass=0; pass < 256; pass++) {
      byte[] target=tnums[pass];
      int pos=0;
      if (target != null) {
        pos=target.length;
      }
 else {
        target=new byte[4096];
      }
      for (int docbase=pass << 16; docbase < maxDoc; docbase+=(1 << 24)) {
        int lim=Math.min(docbase + (1 << 16),maxDoc);
        for (int doc=docbase; doc < lim; doc++) {
          int val=index[doc];
          if ((val & 0xff) == 1) {
            int len=val >>> 8;
            index[doc]=(pos << 8) | 1;
            if ((pos & 0xff000000) != 0) {
              throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"Too many values for UnInvertedField faceting on field " + field);
            }
            byte[] arr=bytes[doc];
            bytes[doc]=null;
            if (target.length <= pos + len) {
              int newlen=target.length;
              while (newlen <= pos + len)               newlen<<=1;
              byte[] newtarget=new byte[newlen];
              System.arraycopy(target,0,newtarget,0,pos);
              target=newtarget;
            }
            System.arraycopy(arr,0,target,pos,len);
            pos+=len + 1;
          }
        }
      }
      if (pos < target.length) {
        byte[] newtarget=new byte[pos];
        System.arraycopy(target,0,newtarget,0,pos);
        target=newtarget;
        if (target.length > (1 << 24) * .9) {
          SolrCore.log.warn("Approaching too many values for UnInvertedField faceting on field '" + field + "' : bucket size="+ target.length);
        }
      }
      tnums[pass]=target;
      if ((pass << 16) > maxDoc)       break;
    }
  }
  long endTime=System.currentTimeMillis();
  total_time=(int)(endTime - startTime);
  phase1_time=(int)(midPoint - startTime);
  SolrCore.log.info("UnInverted multi-valued field " + toString());
}
