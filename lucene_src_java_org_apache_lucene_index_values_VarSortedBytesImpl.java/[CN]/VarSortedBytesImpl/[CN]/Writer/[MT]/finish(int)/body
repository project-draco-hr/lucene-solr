{
  final int count=hash.size();
  final IndexOutput datOut=getDataOut();
  long offset=0;
  long lastOffset=0;
  final int[] index=new int[count];
  final long[] offsets=new long[count];
  boolean success=false;
  try {
    final int[] sortedEntries=hash.sort(comp);
    for (int i=0; i < count; i++) {
      final int e=sortedEntries[i];
      offsets[i]=offset;
      index[e]=1 + i;
      final BytesRef bytes=hash.get(e,new BytesRef());
      datOut.writeBytes(bytes.bytes,bytes.offset,bytes.length);
      lastOffset=offset;
      offset+=bytes.length;
    }
    success=true;
  }
  finally {
    IOUtils.closeSafely(!success,datOut);
    hash.close();
  }
  final IndexOutput idxOut=getIndexOut();
  success=false;
  try {
    idxOut.writeLong(offset);
    final PackedInts.Writer indexWriter=PackedInts.getWriter(idxOut,docCount,PackedInts.bitsRequired(count));
    final int limit=docCount > docToEntry.length ? docToEntry.length : docCount;
    for (int i=0; i < limit; i++) {
      final int e=docToEntry[i];
      indexWriter.add(e == -1 ? 0 : index[e]);
    }
    for (int i=limit; i < docCount; i++) {
      indexWriter.add(0);
    }
    indexWriter.finish();
    PackedInts.Writer offsetWriter=PackedInts.getWriter(idxOut,count,PackedInts.bitsRequired(lastOffset));
    for (int i=0; i < count; i++) {
      offsetWriter.add(offsets[i]);
    }
    offsetWriter.finish();
    success=true;
  }
  finally {
    bytesUsed.addAndGet((-docToEntry.length) * RamUsageEstimator.NUM_BYTES_INT);
    docToEntry=null;
    IOUtils.closeSafely(!success,idxOut);
  }
}
