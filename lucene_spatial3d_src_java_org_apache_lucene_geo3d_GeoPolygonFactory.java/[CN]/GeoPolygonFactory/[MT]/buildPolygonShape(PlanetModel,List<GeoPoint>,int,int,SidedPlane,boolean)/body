{
  final GeoCompositeMembershipShape rval=new GeoCompositeMembershipShape();
  final List<GeoPoint> recursionList=new ArrayList<GeoPoint>();
  final List<GeoPoint> currentList=new ArrayList<GeoPoint>();
  final BitSet internalEdgeList=new BitSet();
  final List<SidedPlane> currentPlanes=new ArrayList<SidedPlane>();
  currentList.add(pointsList.get(startPointIndex));
  currentList.add(pointsList.get(endPointIndex));
  internalEdgeList.set(currentPlanes.size(),isInternalEdge);
  currentPlanes.add(startingEdge);
  for (int i=0; i < pointsList.size() - 2; i++) {
    GeoPoint newPoint=pointsList.get(getLegalIndex(i + endPointIndex + 1,pointsList.size()));
    if (isWithin(newPoint,currentPlanes)) {
      SidedPlane newBoundary=new SidedPlane(currentList.get(currentList.size() - 2),newPoint,currentList.get(currentList.size() - 1));
      SidedPlane returnBoundary=new SidedPlane(currentList.get(currentList.size() - 1),currentList.get(0),newPoint);
      boolean pointInside=false;
      for (int j=i + 1; j < pointsList.size() - 2; j++) {
        GeoPoint checkPoint=pointsList.get(getLegalIndex(j + endPointIndex + 1,pointsList.size()));
        boolean isInside=true;
        if (isInside && !newBoundary.isWithin(checkPoint))         isInside=false;
        if (isInside && !returnBoundary.isWithin(checkPoint))         isInside=false;
        if (isInside) {
          for (          SidedPlane plane : currentPlanes) {
            if (!plane.isWithin(checkPoint)) {
              isInside=false;
              break;
            }
          }
        }
        if (isInside) {
          pointInside=true;
          break;
        }
      }
      if (!pointInside) {
        boolean isInternalBoundary=recursionList.size() > 0;
        if (isInternalBoundary) {
          recursionList.add(newPoint);
          recursionList.add(currentList.get(currentList.size() - 1));
          if (recursionList.size() == pointsList.size()) {
            throw new IllegalArgumentException("Polygon is illegal; cannot be decomposed into convex parts");
          }
          SidedPlane otherSideNewBoundary=new SidedPlane(newBoundary);
          rval.addShape(buildPolygonShape(planetModel,recursionList,recursionList.size() - 2,recursionList.size() - 1,otherSideNewBoundary,true));
          recursionList.clear();
        }
        currentList.add(newPoint);
        internalEdgeList.set(currentPlanes.size(),isInternalBoundary);
        currentPlanes.add(newBoundary);
      }
 else {
        recursionList.add(newPoint);
      }
    }
 else {
      recursionList.add(newPoint);
    }
  }
  boolean returnEdgeInternalBoundary=recursionList.size() > 0;
  if (returnEdgeInternalBoundary) {
    recursionList.add(currentList.get(0));
    recursionList.add(currentList.get(currentList.size() - 1));
    if (recursionList.size() == pointsList.size()) {
      throw new IllegalArgumentException("Polygon is illegal; cannot be decomposed into convex parts");
    }
    SidedPlane newBoundary=new SidedPlane(currentList.get(currentList.size() - 2),currentList.get(0),currentList.get(currentList.size() - 1));
    SidedPlane otherSideNewBoundary=new SidedPlane(newBoundary);
    rval.addShape(buildPolygonShape(planetModel,recursionList,recursionList.size() - 2,recursionList.size() - 1,otherSideNewBoundary,true));
    recursionList.clear();
  }
  rval.addShape(new GeoConvexPolygon(planetModel,currentList,internalEdgeList,returnEdgeInternalBoundary));
  return rval;
}
