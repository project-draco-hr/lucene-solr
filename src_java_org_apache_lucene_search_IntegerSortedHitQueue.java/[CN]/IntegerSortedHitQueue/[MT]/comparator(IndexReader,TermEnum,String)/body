{
  final String field=fieldname.intern();
  return new ScoreDocLookupComparator(){
    protected final int[] fieldOrder=generateSortIndex();
    private final int[] generateSortIndex() throws IOException {
      final int[] retArray=new int[reader.maxDoc()];
      if (retArray.length > 0) {
        TermDocs termDocs=reader.termDocs();
        try {
          if (enumerator.term() == null) {
            throw new RuntimeException("no terms in field " + field);
          }
          do {
            Term term=enumerator.term();
            if (term.field() != field)             break;
            int termval=Integer.parseInt(term.text());
            termDocs.seek(enumerator);
            while (termDocs.next()) {
              retArray[termDocs.doc()]=termval;
            }
          }
 while (enumerator.next());
        }
  finally {
          termDocs.close();
        }
      }
      return retArray;
    }
    public final int compare(    final ScoreDoc i,    final ScoreDoc j){
      final int fi=fieldOrder[i.doc];
      final int fj=fieldOrder[j.doc];
      if (fi < fj)       return -1;
      if (fi > fj)       return 1;
      return 0;
    }
    public final int compareReverse(    final ScoreDoc i,    final ScoreDoc j){
      final int fi=fieldOrder[i.doc];
      final int fj=fieldOrder[j.doc];
      if (fi > fj)       return -1;
      if (fi < fj)       return 1;
      return 0;
    }
    public final boolean sizeMatches(    final int n){
      return fieldOrder.length == n;
    }
    public Object sortValue(    final ScoreDoc i){
      return new Integer(fieldOrder[i.doc]);
    }
    public int sortType(){
      return SortField.INT;
    }
  }
;
}
