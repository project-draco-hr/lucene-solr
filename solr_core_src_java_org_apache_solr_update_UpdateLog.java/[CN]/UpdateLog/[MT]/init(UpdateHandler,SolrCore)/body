{
  if (dataDir == null || dataDir.length() == 0) {
    dataDir=core.getDataDir();
  }
  this.uhandler=uhandler;
  if (dataDir.equals(lastDataDir)) {
    if (debug) {
      log.debug("UpdateHandler init: tlogDir=" + tlogDir + ", next id="+ id," this is a reopen... nothing else to do.");
    }
    versionInfo.reload();
    return;
  }
  lastDataDir=dataDir;
  tlogDir=new File(dataDir,TLOG_NAME);
  tlogDir.mkdirs();
  tlogFiles=getLogList(tlogDir);
  id=getLastLogId() + 1;
  if (debug) {
    log.debug("UpdateHandler init: tlogDir=" + tlogDir + ", existing tlogs="+ Arrays.asList(tlogFiles)+ ", next id="+ id);
  }
  TransactionLog oldLog=null;
  for (  String oldLogName : tlogFiles) {
    File f=new File(tlogDir,oldLogName);
    try {
      oldLog=new TransactionLog(f,null,true);
      addOldLog(oldLog,false);
    }
 catch (    Exception e) {
      SolrException.log(log,"Failure to open existing log file (non fatal) " + f,e);
      deleteFile(f);
    }
  }
  for (  TransactionLog ll : logs) {
    newestLogsOnStartup.addFirst(ll);
    if (newestLogsOnStartup.size() >= 2)     break;
  }
  try {
    versionInfo=new VersionInfo(this,256);
  }
 catch (  SolrException e) {
    log.error("Unable to use updateLog: " + e.getMessage(),e);
    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Unable to use updateLog: " + e.getMessage(),e);
  }
  UpdateLog.RecentUpdates startingUpdates=getRecentUpdates();
  try {
    startingVersions=startingUpdates.getVersions(numRecordsToKeep);
    startingOperation=startingUpdates.getLatestOperation();
    for (int i=startingUpdates.deleteList.size() - 1; i >= 0; i--) {
      DeleteUpdate du=startingUpdates.deleteList.get(i);
      oldDeletes.put(new BytesRef(du.id),new LogPtr(-1,du.version));
    }
    for (int i=startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {
      Update update=startingUpdates.deleteByQueryList.get(i);
      List<Object> dbq=(List<Object>)update.log.lookup(update.pointer);
      long version=(Long)dbq.get(1);
      String q=(String)dbq.get(2);
      trackDeleteByQuery(q,version);
    }
  }
  finally {
    startingUpdates.close();
  }
}
