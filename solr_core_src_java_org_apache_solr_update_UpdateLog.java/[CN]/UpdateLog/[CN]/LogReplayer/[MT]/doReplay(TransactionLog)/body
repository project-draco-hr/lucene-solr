{
  try {
    loglog.warn("Starting log replay " + translog + " active="+ activeLog+ " starting pos="+ recoveryInfo.positionOfStart);
    long lastStatusTime=System.nanoTime();
    tlogReader=translog.getReader(recoveryInfo.positionOfStart);
    UpdateRequestProcessorChain processorChain=req.getCore().getUpdateProcessingChain(null);
    UpdateRequestProcessor proc=processorChain.createProcessor(req,rsp);
    long commitVersion=0;
    int operationAndFlags=0;
    long nextCount=0;
    for (; ; ) {
      Object o=null;
      if (cancelApplyBufferUpdate)       break;
      try {
        if (testing_logReplayHook != null)         testing_logReplayHook.run();
        if (nextCount++ % 1000 == 0) {
          long now=System.nanoTime();
          if (now - lastStatusTime > STATUS_TIME) {
            lastStatusTime=now;
            long cpos=tlogReader.currentPos();
            long csize=tlogReader.currentSize();
            loglog.info("log replay status {} active={} starting pos={} current pos={} current size={} % read={}",translog,activeLog,recoveryInfo.positionOfStart,cpos,csize,new DecimalFormat("###").format(cpos / (double)csize * 100));
          }
        }
        o=null;
        o=tlogReader.next();
        if (o == null && activeLog) {
          if (!finishing) {
            versionInfo.blockUpdates();
            finishing=true;
            o=tlogReader.next();
          }
 else {
          }
        }
      }
 catch (      InterruptedException e) {
        SolrException.log(log,e);
      }
catch (      IOException e) {
        SolrException.log(log,e);
      }
catch (      Exception e) {
        SolrException.log(log,e);
      }
      if (o == null)       break;
      try {
        List entry=(List)o;
        operationAndFlags=(Integer)entry.get(0);
        int oper=operationAndFlags & OPERATION_MASK;
        long version=(Long)entry.get(1);
switch (oper) {
case UpdateLog.ADD:
{
            recoveryInfo.adds++;
            SolrInputDocument sdoc=(SolrInputDocument)entry.get(entry.size() - 1);
            AddUpdateCommand cmd=new AddUpdateCommand(req);
            cmd.solrDoc=sdoc;
            cmd.setVersion(version);
            cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);
            if (debug)             log.debug("add " + cmd);
            proc.processAdd(cmd);
            break;
          }
case UpdateLog.DELETE:
{
          recoveryInfo.deletes++;
          byte[] idBytes=(byte[])entry.get(2);
          DeleteUpdateCommand cmd=new DeleteUpdateCommand(req);
          cmd.setIndexedId(new BytesRef(idBytes));
          cmd.setVersion(version);
          cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);
          if (debug)           log.debug("delete " + cmd);
          proc.processDelete(cmd);
          break;
        }
case UpdateLog.DELETE_BY_QUERY:
{
        recoveryInfo.deleteByQuery++;
        String query=(String)entry.get(2);
        DeleteUpdateCommand cmd=new DeleteUpdateCommand(req);
        cmd.query=query;
        cmd.setVersion(version);
        cmd.setFlags(UpdateCommand.REPLAY | UpdateCommand.IGNORE_AUTOCOMMIT);
        if (debug)         log.debug("deleteByQuery " + cmd);
        proc.processDelete(cmd);
        break;
      }
case UpdateLog.COMMIT:
{
      commitVersion=version;
      break;
    }
default :
  throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Unknown Operation! " + oper);
}
if (rsp.getException() != null) {
loglog.error("REPLAY_ERR: Exception replaying log",rsp.getException());
throw rsp.getException();
}
}
 catch (IOException ex) {
recoveryInfo.errors++;
loglog.warn("REYPLAY_ERR: IOException reading log",ex);
}
catch (ClassCastException cl) {
recoveryInfo.errors++;
loglog.warn("REPLAY_ERR: Unexpected log entry or corrupt log.  Entry=" + o,cl);
}
catch (SolrException ex) {
if (ex.code() == ErrorCode.SERVICE_UNAVAILABLE.code) {
throw ex;
}
recoveryInfo.errors++;
loglog.warn("REYPLAY_ERR: IOException reading log",ex);
}
catch (Exception ex) {
recoveryInfo.errors++;
loglog.warn("REPLAY_ERR: Exception replaying log",ex);
}
}
CommitUpdateCommand cmd=new CommitUpdateCommand(req,false);
cmd.setVersion(commitVersion);
cmd.softCommit=false;
cmd.waitSearcher=true;
cmd.setFlags(UpdateCommand.REPLAY);
try {
if (debug) log.debug("commit " + cmd);
uhandler.commit(cmd);
}
 catch (IOException ex) {
recoveryInfo.errors++;
loglog.error("Replay exception: final commit.",ex);
}
if (!activeLog) {
translog.writeCommit(cmd,operationFlags | (operationAndFlags & ~OPERATION_MASK));
}
try {
proc.finish();
}
 catch (IOException ex) {
recoveryInfo.errors++;
loglog.error("Replay exception: finish()",ex);
}
}
  finally {
if (tlogReader != null) tlogReader.close();
translog.decref();
}
}
