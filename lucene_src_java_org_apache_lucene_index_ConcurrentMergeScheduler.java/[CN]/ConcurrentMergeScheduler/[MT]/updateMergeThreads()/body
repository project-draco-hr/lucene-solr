{
  CollectionUtil.mergeSort(mergeThreads,compareByMergeDocCount);
  final int count=mergeThreads.size();
  int pri=mergeThreadPriority;
  for (int i=0; i < count; i++) {
    final MergeThread mergeThread=mergeThreads.get(i);
    final MergePolicy.OneMerge merge=mergeThread.getCurrentMerge();
    if (merge == null) {
      continue;
    }
    final boolean doPause;
    if (i < count - maxThreadCount) {
      doPause=true;
    }
 else {
      doPause=false;
    }
    if (verbose()) {
      if (doPause != merge.getPause()) {
        if (doPause) {
          message("pause thread " + mergeThread.getName());
        }
 else {
          message("unpause thread " + mergeThread.getName());
        }
      }
    }
    if (doPause != merge.getPause()) {
      merge.setPause(doPause);
    }
    if (!doPause) {
      if (verbose()) {
        message("set priority of merge thread " + mergeThread.getName() + " to "+ pri);
      }
      mergeThread.setThreadPriority(pri);
      pri=Math.min(Thread.MAX_PRIORITY,1 + pri);
    }
  }
}
