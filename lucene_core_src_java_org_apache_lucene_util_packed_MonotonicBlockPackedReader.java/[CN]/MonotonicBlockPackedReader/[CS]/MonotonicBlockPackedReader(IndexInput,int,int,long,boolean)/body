{
  this.valueCount=valueCount;
  blockShift=checkBlockSize(blockSize,MIN_BLOCK_SIZE,MAX_BLOCK_SIZE);
  blockMask=blockSize - 1;
  final int numBlocks=numBlocks(valueCount,blockSize);
  minValues=new long[numBlocks];
  averages=new float[numBlocks];
  subReaders=new PackedInts.Reader[numBlocks];
  for (int i=0; i < numBlocks; ++i) {
    if (packedIntsVersion < PackedInts.VERSION_MONOTONIC_WITHOUT_ZIGZAG) {
      minValues[i]=in.readVLong();
    }
 else {
      minValues[i]=zigZagDecode(in.readVLong());
    }
    averages[i]=Float.intBitsToFloat(in.readInt());
    final int bitsPerValue=in.readVInt();
    if (bitsPerValue > 64) {
      throw new IOException("Corrupted");
    }
    if (bitsPerValue == 0) {
      subReaders[i]=new PackedInts.NullReader(blockSize);
    }
 else {
      final int size=(int)Math.min(blockSize,valueCount - (long)i * blockSize);
      if (direct) {
        final long pointer=in.getFilePointer();
        subReaders[i]=PackedInts.getDirectReaderNoHeader(in,PackedInts.Format.PACKED,packedIntsVersion,size,bitsPerValue);
        in.seek(pointer + PackedInts.Format.PACKED.byteCount(packedIntsVersion,size,bitsPerValue));
      }
 else {
        subReaders[i]=PackedInts.getReaderNoHeader(in,PackedInts.Format.PACKED,packedIntsVersion,size,bitsPerValue);
      }
    }
  }
}
