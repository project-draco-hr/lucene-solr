{
  SortedSetEntry sortedSetEntry=sortedSets.get(field.name);
  if (sortedSetEntry.singleton) {
    return DocValues.singleton(getSorted(field));
  }
  final FSTEntry entry=fsts.get(field.name);
  if (entry.numOrds == 0) {
    return DocValues.emptySortedSet();
  }
  FST<Long> instance;
synchronized (this) {
    instance=fstInstances.get(field.name);
    if (instance == null) {
      IndexInput data=this.data.clone();
      data.seek(entry.offset);
      instance=new FST<>(data,PositiveIntOutputs.getSingleton());
      if (!merging) {
        ramBytesUsed.addAndGet(instance.ramBytesUsed());
        fstInstances.put(field.name,instance);
      }
    }
  }
  final LegacyBinaryDocValues docToOrds=getLegacyBinary(field);
  final FST<Long> fst=instance;
  final BytesReader in=fst.getBytesReader();
  final Arc<Long> firstArc=new Arc<>();
  final Arc<Long> scratchArc=new Arc<>();
  final IntsRefBuilder scratchInts=new IntsRefBuilder();
  final BytesRefFSTEnum<Long> fstEnum=new BytesRefFSTEnum<>(fst);
  final ByteArrayDataInput input=new ByteArrayDataInput();
  return new LegacySortedSetDocValuesWrapper(new LegacySortedSetDocValues(){
    final BytesRefBuilder term=new BytesRefBuilder();
    BytesRef ref;
    long currentOrd;
    @Override public long nextOrd(){
      if (input.eof()) {
        return NO_MORE_ORDS;
      }
 else {
        currentOrd+=input.readVLong();
        return currentOrd;
      }
    }
    @Override public void setDocument(    int docID){
      ref=docToOrds.get(docID);
      input.reset(ref.bytes,ref.offset,ref.length);
      currentOrd=0;
    }
    @Override public BytesRef lookupOrd(    long ord){
      try {
        in.setPosition(0);
        fst.getFirstArc(firstArc);
        IntsRef output=Util.getByOutput(fst,ord,in,firstArc,scratchArc,scratchInts);
        return Util.toBytesRef(output,term);
      }
 catch (      IOException bogus) {
        throw new RuntimeException(bogus);
      }
    }
    @Override public long lookupTerm(    BytesRef key){
      try {
        InputOutput<Long> o=fstEnum.seekCeil(key);
        if (o == null) {
          return -getValueCount() - 1;
        }
 else         if (o.input.equals(key)) {
          return o.output.intValue();
        }
 else {
          return -o.output - 1;
        }
      }
 catch (      IOException bogus) {
        throw new RuntimeException(bogus);
      }
    }
    @Override public long getValueCount(){
      return entry.numOrds;
    }
    @Override public TermsEnum termsEnum(){
      return new FSTTermsEnum(fst);
    }
  }
,maxDoc);
}
