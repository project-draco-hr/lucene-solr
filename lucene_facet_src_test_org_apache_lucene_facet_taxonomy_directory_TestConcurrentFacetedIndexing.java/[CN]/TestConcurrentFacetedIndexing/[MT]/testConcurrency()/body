{
  final AtomicInteger numDocs=new AtomicInteger(atLeast(10000));
  final Directory indexDir=newDirectory();
  final Directory taxoDir=newDirectory();
  final ConcurrentHashMap<String,String> values=new ConcurrentHashMap<String,String>();
  final IndexWriter iw=new IndexWriter(indexDir,newIndexWriterConfig(TEST_VERSION_CURRENT,null));
  final DirectoryTaxonomyWriter tw=new DirectoryTaxonomyWriter(taxoDir,OpenMode.CREATE,newTaxoWriterCache(numDocs.get()));
  final Thread[] indexThreads=new Thread[atLeast(4)];
  for (int i=0; i < indexThreads.length; i++) {
    indexThreads[i]=new Thread(){
      private final FacetFields facetFields=new FacetFields(tw);
      @Override public void run(){
        Random random=random();
        while (numDocs.decrementAndGet() > 0) {
          try {
            Document doc=new Document();
            int numCats=random.nextInt(3) + 1;
            List<CategoryPath> cats=new ArrayList<CategoryPath>(numCats);
            while (numCats-- > 0) {
              CategoryPath cp=newCategory();
              cats.add(cp);
              int level=cp.length;
              while (level > 0) {
                String s=cp.subpath(level).toString('/');
                values.put(s,s);
                --level;
              }
            }
            facetFields.addFields(doc,cats);
            iw.addDocument(doc);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
;
  }
  for (  Thread t : indexThreads)   t.start();
  for (  Thread t : indexThreads)   t.join();
  DirectoryTaxonomyReader tr=new DirectoryTaxonomyReader(tw);
  assertEquals("mismatch number of categories",values.size() + 1,tr.getSize());
  int[] parents=tr.getParallelTaxonomyArrays().parents();
  for (  String cat : values.keySet()) {
    CategoryPath cp=new CategoryPath(cat,'/');
    assertTrue("category not found " + cp,tr.getOrdinal(cp) > 0);
    int level=cp.length;
    int parentOrd=0;
    CategoryPath path=CategoryPath.EMPTY;
    for (int i=0; i < level; i++) {
      path=cp.subpath(i + 1);
      int ord=tr.getOrdinal(path);
      assertEquals("invalid parent for cp=" + path,parentOrd,parents[ord]);
      parentOrd=ord;
    }
  }
  tr.close();
  IOUtils.close(tw,iw,taxoDir,indexDir);
}
