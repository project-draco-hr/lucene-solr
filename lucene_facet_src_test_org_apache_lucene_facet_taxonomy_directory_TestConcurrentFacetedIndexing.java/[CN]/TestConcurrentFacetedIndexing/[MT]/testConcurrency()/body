{
  final AtomicInteger numDocs=new AtomicInteger(atLeast(10000));
  final Directory indexDir=newDirectory();
  final Directory taxoDir=newDirectory();
  final ConcurrentHashMap<String,String> values=new ConcurrentHashMap<String,String>();
  final IndexWriter iw=new IndexWriter(indexDir,newIndexWriterConfig(TEST_VERSION_CURRENT,null));
  final DirectoryTaxonomyWriter tw=new DirectoryTaxonomyWriter(taxoDir,OpenMode.CREATE,newTaxoWriterCache(numDocs.get()));
  final Thread[] indexThreads=new Thread[atLeast(4)];
  final FacetsConfig config=new FacetsConfig();
  for (int i=0; i < 10; i++) {
    config.setHierarchical("l1." + i,true);
    config.setMultiValued("l1." + i,true);
  }
  for (int i=0; i < indexThreads.length; i++) {
    indexThreads[i]=new Thread(){
      @Override public void run(){
        Random random=random();
        while (numDocs.decrementAndGet() > 0) {
          try {
            Document doc=new Document();
            int numCats=random.nextInt(3) + 1;
            while (numCats-- > 0) {
              FacetField ff=newCategory();
              doc.add(ff);
              FacetLabel label=new FacetLabel(ff.dim,ff.path);
              int level=label.length;
              while (level > 0) {
                String s=FacetsConfig.pathToString(label.components,level);
                values.put(s,s);
                --level;
              }
            }
            iw.addDocument(config.build(tw,doc));
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
    }
;
  }
  for (  Thread t : indexThreads)   t.start();
  for (  Thread t : indexThreads)   t.join();
  DirectoryTaxonomyReader tr=new DirectoryTaxonomyReader(tw);
  assertEquals("mismatch number of categories",values.size() + 1,tr.getSize());
  int[] parents=tr.getParallelTaxonomyArrays().parents();
  for (  String cat : values.keySet()) {
    FacetLabel cp=new FacetLabel(FacetsConfig.stringToPath(cat));
    assertTrue("category not found " + cp,tr.getOrdinal(cp) > 0);
    int level=cp.length;
    int parentOrd=0;
    FacetLabel path=new FacetLabel();
    for (int i=0; i < level; i++) {
      path=cp.subpath(i + 1);
      int ord=tr.getOrdinal(path);
      assertEquals("invalid parent for cp=" + path,parentOrd,parents[ord]);
      parentOrd=ord;
    }
  }
  IOUtils.close(tw,iw,tr,taxoDir,indexDir);
}
