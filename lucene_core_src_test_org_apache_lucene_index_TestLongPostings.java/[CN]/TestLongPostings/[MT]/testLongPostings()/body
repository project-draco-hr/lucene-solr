{
  Directory dir=newFSDirectory(_TestUtil.getTempDir("longpostings" + "." + random.nextLong()));
  final int NUM_DOCS=atLeast(2000);
  if (VERBOSE) {
    System.out.println("TEST: NUM_DOCS=" + NUM_DOCS);
  }
  final String s1=getRandomTerm(null);
  final String s2=getRandomTerm(s1);
  if (VERBOSE) {
    System.out.println("\nTEST: s1=" + s1 + " s2="+ s2);
  }
  final FixedBitSet isS1=new FixedBitSet(NUM_DOCS);
  for (int idx=0; idx < NUM_DOCS; idx++) {
    if (random.nextBoolean()) {
      isS1.set(idx);
    }
  }
  final IndexReader r;
  final IndexWriterConfig iwc=newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random)).setOpenMode(IndexWriterConfig.OpenMode.CREATE).setMergePolicy(newLogMergePolicy());
  iwc.setRAMBufferSizeMB(16.0 + 16.0 * random.nextDouble());
  iwc.setMaxBufferedDocs(-1);
  final RandomIndexWriter riw=new RandomIndexWriter(random,dir,iwc);
  for (int idx=0; idx < NUM_DOCS; idx++) {
    final Document doc=new Document();
    String s=isS1.get(idx) ? s1 : s2;
    final Field f=newField("field",s,TextField.TYPE_UNSTORED);
    final int count=_TestUtil.nextInt(random,1,4);
    for (int ct=0; ct < count; ct++) {
      doc.add(f);
    }
    riw.addDocument(doc);
  }
  r=riw.getReader();
  riw.close();
  assertEquals(NUM_DOCS,r.numDocs());
  assertTrue(r.docFreq(new Term("field",s1)) > 0);
  assertTrue(r.docFreq(new Term("field",s2)) > 0);
  int num=atLeast(1000);
  for (int iter=0; iter < num; iter++) {
    final String term;
    final boolean doS1;
    if (random.nextBoolean()) {
      term=s1;
      doS1=true;
    }
 else {
      term=s2;
      doS1=false;
    }
    if (VERBOSE) {
      System.out.println("\nTEST: iter=" + iter + " doS1="+ doS1);
    }
    final DocsAndPositionsEnum postings=MultiFields.getTermPositionsEnum(r,null,"field",new BytesRef(term),false);
    int docID=-1;
    while (docID < DocIdSetIterator.NO_MORE_DOCS) {
      final int what=random.nextInt(3);
      if (what == 0) {
        if (VERBOSE) {
          System.out.println("TEST: docID=" + docID + "; do next()");
        }
        int expected=docID + 1;
        while (true) {
          if (expected == NUM_DOCS) {
            expected=Integer.MAX_VALUE;
            break;
          }
 else           if (isS1.get(expected) == doS1) {
            break;
          }
 else {
            expected++;
          }
        }
        docID=postings.nextDoc();
        if (VERBOSE) {
          System.out.println("  got docID=" + docID);
        }
        assertEquals(expected,docID);
        if (docID == DocIdSetIterator.NO_MORE_DOCS) {
          break;
        }
        if (random.nextInt(6) == 3) {
          final int freq=postings.freq();
          assertTrue(freq >= 1 && freq <= 4);
          for (int pos=0; pos < freq; pos++) {
            assertEquals(pos,postings.nextPosition());
            if (random.nextBoolean() && postings.hasPayload()) {
              postings.getPayload();
            }
          }
        }
      }
 else {
        final int targetDocID;
        if (docID == -1) {
          targetDocID=random.nextInt(NUM_DOCS + 1);
        }
 else {
          targetDocID=docID + _TestUtil.nextInt(random,1,NUM_DOCS - docID);
        }
        if (VERBOSE) {
          System.out.println("TEST: docID=" + docID + "; do advance("+ targetDocID+ ")");
        }
        int expected=targetDocID;
        while (true) {
          if (expected == NUM_DOCS) {
            expected=Integer.MAX_VALUE;
            break;
          }
 else           if (isS1.get(expected) == doS1) {
            break;
          }
 else {
            expected++;
          }
        }
        docID=postings.advance(targetDocID);
        if (VERBOSE) {
          System.out.println("  got docID=" + docID);
        }
        assertEquals(expected,docID);
        if (docID == DocIdSetIterator.NO_MORE_DOCS) {
          break;
        }
        if (random.nextInt(6) == 3) {
          final int freq=postings.freq();
          assertTrue(freq >= 1 && freq <= 4);
          for (int pos=0; pos < freq; pos++) {
            assertEquals(pos,postings.nextPosition());
            if (random.nextBoolean() && postings.hasPayload()) {
              postings.getPayload();
            }
          }
        }
      }
    }
  }
  r.close();
  dir.close();
}
