{
  Rectangle box=Rectangle.fromPointDistance(latitude,longitude,radiusMeters);
  final byte minLat[]=new byte[Integer.BYTES];
  final byte maxLat[]=new byte[Integer.BYTES];
  final byte minLon[]=new byte[Integer.BYTES];
  final byte maxLon[]=new byte[Integer.BYTES];
  final byte minLon2[]=new byte[Integer.BYTES];
  NumericUtils.intToSortableBytes(encodeLatitude(box.minLat),minLat,0);
  NumericUtils.intToSortableBytes(encodeLatitude(box.maxLat),maxLat,0);
  if (box.crossesDateline()) {
    NumericUtils.intToSortableBytes(Integer.MIN_VALUE,minLon,0);
    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon),maxLon,0);
    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon),minLon2,0);
  }
 else {
    NumericUtils.intToSortableBytes(encodeLongitude(box.minLon),minLon,0);
    NumericUtils.intToSortableBytes(encodeLongitude(box.maxLon),maxLon,0);
    NumericUtils.intToSortableBytes(Integer.MAX_VALUE,minLon2,0);
  }
  final double sortKey=sortKey(radiusMeters);
  final double axisLat=Rectangle.axisLat(latitude,radiusMeters);
  return new ConstantScoreWeight(this){
    @Override public Scorer scorer(    LeafReaderContext context) throws IOException {
      LeafReader reader=context.reader();
      PointValues values=reader.getPointValues();
      if (values == null) {
        return null;
      }
      FieldInfo fieldInfo=reader.getFieldInfos().fieldInfo(field);
      if (fieldInfo == null) {
        return null;
      }
      LatLonPoint.checkCompatible(fieldInfo);
      MatchingPoints result=new MatchingPoints(reader,field);
      values.intersect(field,new IntersectVisitor(){
        @Override public void visit(        int docID){
          result.add(docID);
        }
        @Override public void visit(        int docID,        byte[] packedValue){
          if (StringHelper.compare(Integer.BYTES,packedValue,0,maxLat,0) > 0 || StringHelper.compare(Integer.BYTES,packedValue,0,minLat,0) < 0) {
            return;
          }
          if ((StringHelper.compare(Integer.BYTES,packedValue,Integer.BYTES,maxLon,0) > 0 || StringHelper.compare(Integer.BYTES,packedValue,Integer.BYTES,minLon,0) < 0) && StringHelper.compare(Integer.BYTES,packedValue,Integer.BYTES,minLon2,0) < 0) {
            return;
          }
          double docLatitude=decodeLatitude(packedValue,0);
          double docLongitude=decodeLongitude(packedValue,Integer.BYTES);
          if (SloppyMath.haversinSortKey(latitude,longitude,docLatitude,docLongitude) <= sortKey) {
            result.add(docID);
          }
        }
        @Override public Relation compare(        byte[] minPackedValue,        byte[] maxPackedValue){
          if (StringHelper.compare(Integer.BYTES,minPackedValue,0,maxLat,0) > 0 || StringHelper.compare(Integer.BYTES,maxPackedValue,0,minLat,0) < 0) {
            return Relation.CELL_OUTSIDE_QUERY;
          }
          if ((StringHelper.compare(Integer.BYTES,minPackedValue,Integer.BYTES,maxLon,0) > 0 || StringHelper.compare(Integer.BYTES,maxPackedValue,Integer.BYTES,minLon,0) < 0) && StringHelper.compare(Integer.BYTES,maxPackedValue,Integer.BYTES,minLon2,0) < 0) {
            return Relation.CELL_OUTSIDE_QUERY;
          }
          double latMin=decodeLatitude(minPackedValue,0);
          double lonMin=decodeLongitude(minPackedValue,Integer.BYTES);
          double latMax=decodeLatitude(maxPackedValue,0);
          double lonMax=decodeLongitude(maxPackedValue,Integer.BYTES);
          if ((longitude < lonMin || longitude > lonMax) && (axisLat + Rectangle.AXISLAT_ERROR < latMin || axisLat - Rectangle.AXISLAT_ERROR > latMax)) {
            if (SloppyMath.haversinSortKey(latitude,longitude,latMin,lonMin) > sortKey && SloppyMath.haversinSortKey(latitude,longitude,latMin,lonMax) > sortKey && SloppyMath.haversinSortKey(latitude,longitude,latMax,lonMin) > sortKey && SloppyMath.haversinSortKey(latitude,longitude,latMax,lonMax) > sortKey) {
              return Relation.CELL_OUTSIDE_QUERY;
            }
          }
          if (lonMax - longitude < 90 && longitude - lonMin < 90 && SloppyMath.haversinSortKey(latitude,longitude,latMin,lonMin) <= sortKey && SloppyMath.haversinSortKey(latitude,longitude,latMin,lonMax) <= sortKey && SloppyMath.haversinSortKey(latitude,longitude,latMax,lonMin) <= sortKey && SloppyMath.haversinSortKey(latitude,longitude,latMax,lonMax) <= sortKey) {
            return Relation.CELL_INSIDE_QUERY;
          }
 else {
            return Relation.CELL_CROSSES_QUERY;
          }
        }
      }
);
      return new ConstantScoreScorer(this,score(),result.iterator());
    }
  }
;
}
