{
  ensureOpen();
  flush(true,true);
  if (infoStream.isEnabled("IW")) {
    infoStream.message("IW","forceMergeDeletes: index now " + segString());
  }
  final MergePolicy mergePolicy=config.getMergePolicy();
  MergePolicy.MergeSpecification spec;
  boolean newMergesFound=false;
synchronized (this) {
    spec=mergePolicy.findForcedDeletesMerges(segmentInfos,this);
    newMergesFound=spec != null;
    if (newMergesFound) {
      final int numMerges=spec.merges.size();
      for (int i=0; i < numMerges; i++)       registerMerge(spec.merges.get(i));
    }
  }
  mergeScheduler.merge(this,MergeTrigger.EXPLICIT,newMergesFound);
  if (spec != null && doWait) {
    final int numMerges=spec.merges.size();
synchronized (this) {
      boolean running=true;
      while (running) {
        if (hitOOM) {
          throw new IllegalStateException("this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes");
        }
        running=false;
        for (int i=0; i < numMerges; i++) {
          final MergePolicy.OneMerge merge=spec.merges.get(i);
          if (pendingMerges.contains(merge) || runningMerges.contains(merge)) {
            running=true;
          }
          Throwable t=merge.getException();
          if (t != null) {
            throw new IOException("background merge hit exception: " + merge.segString(directory),t);
          }
        }
        if (running)         doWait();
      }
    }
  }
}
