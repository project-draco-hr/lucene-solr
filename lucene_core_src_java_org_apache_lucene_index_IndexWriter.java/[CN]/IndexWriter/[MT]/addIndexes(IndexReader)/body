{
  ensureOpen();
  int numDocs=0;
  try {
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","flush at addIndexes(IndexReader...)");
    }
    flush(false,true);
    String mergedName=newSegmentName();
    final List<AtomicReader> mergeReaders=new ArrayList<>();
    for (    IndexReader indexReader : readers) {
      numDocs+=indexReader.numDocs();
      for (      AtomicReaderContext ctx : indexReader.leaves()) {
        mergeReaders.add(ctx.reader());
      }
    }
    reserveDocs(numDocs);
    final IOContext context=new IOContext(new MergeInfo(numDocs,-1,true,-1));
    TrackingDirectoryWrapper trackingDir=new TrackingDirectoryWrapper(directory);
    SegmentInfo info=new SegmentInfo(directory,Version.LATEST,mergedName,-1,false,codec,null,StringHelper.randomId());
    SegmentMerger merger=new SegmentMerger(mergeReaders,info,infoStream,trackingDir,MergeState.CheckAbort.NONE,globalFieldNumberMap,context,config.getCheckIntegrityAtMerge());
    if (!merger.shouldMerge()) {
      return;
    }
    MergeState mergeState;
    boolean success=false;
    try {
      mergeState=merger.merge();
      success=true;
    }
  finally {
      if (!success) {
synchronized (this) {
          deleter.refresh(info.name);
        }
      }
    }
    SegmentCommitInfo infoPerCommit=new SegmentCommitInfo(info,0,-1L,-1L,-1L);
    info.setFiles(new HashSet<>(trackingDir.getCreatedFiles()));
    trackingDir.getCreatedFiles().clear();
    setDiagnostics(info,SOURCE_ADDINDEXES_READERS);
    final MergePolicy mergePolicy=config.getMergePolicy();
    boolean useCompoundFile;
synchronized (this) {
      if (stopMerges) {
        deleter.deleteNewFiles(infoPerCommit.files());
        return;
      }
      ensureOpen();
      useCompoundFile=mergePolicy.useCompoundFile(segmentInfos,infoPerCommit,this);
    }
    if (useCompoundFile) {
      Collection<String> filesToDelete=infoPerCommit.files();
      try {
        createCompoundFile(infoStream,directory,MergeState.CheckAbort.NONE,info,context);
      }
  finally {
synchronized (this) {
          deleter.deleteNewFiles(filesToDelete);
        }
      }
      info.setUseCompoundFile(true);
    }
    success=false;
    try {
      codec.segmentInfoFormat().getSegmentInfoWriter().write(trackingDir,info,mergeState.fieldInfos,context);
      success=true;
    }
  finally {
      if (!success) {
synchronized (this) {
          deleter.refresh(info.name);
        }
      }
    }
    info.addFiles(trackingDir.getCreatedFiles());
synchronized (this) {
      if (stopMerges) {
        deleter.deleteNewFiles(info.files());
        return;
      }
      ensureOpen();
      segmentInfos.add(infoPerCommit);
      checkpoint();
    }
  }
 catch (  OutOfMemoryError oom) {
    handleOOM(oom,"addIndexes(IndexReader...)");
  }
  maybeMerge();
}
