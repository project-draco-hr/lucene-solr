{
  ensureOpen();
  int numDocs=0;
  try {
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","flush at addIndexes(IndexReader...)");
    }
    flush(false,true);
    String mergedName=newSegmentName();
    final List<AtomicReader> mergeReaders=new ArrayList<AtomicReader>();
    for (    IndexReader indexReader : readers) {
      if (indexReader.numDocs() > 0) {
        numDocs+=indexReader.numDocs();
        for (        AtomicReaderContext ctx : indexReader.leaves()) {
          if (ctx.reader().numDocs() > 0) {
            mergeReaders.add(ctx.reader());
          }
        }
      }
    }
    if (mergeReaders.isEmpty()) {
      return;
    }
    final IOContext context=new IOContext(new MergeInfo(numDocs,-1,true,-1));
    TrackingDirectoryWrapper trackingDir=new TrackingDirectoryWrapper(directory);
    SegmentInfo info=new SegmentInfo(directory,Constants.LUCENE_MAIN_VERSION,mergedName,-1,false,codec,null,null);
    SegmentMerger merger=new SegmentMerger(mergeReaders,info,infoStream,trackingDir,config.getTermIndexInterval(),MergeState.CheckAbort.NONE,globalFieldNumberMap,context);
    MergeState mergeState;
    boolean success=false;
    try {
      mergeState=merger.merge();
      success=true;
    }
  finally {
      if (!success) {
synchronized (this) {
          deleter.refresh(info.name);
        }
      }
    }
    SegmentInfoPerCommit infoPerCommit=new SegmentInfoPerCommit(info,0,-1L);
    info.setFiles(new HashSet<String>(trackingDir.getCreatedFiles()));
    trackingDir.getCreatedFiles().clear();
    setDiagnostics(info,SOURCE_ADDINDEXES_READERS);
    boolean useCompoundFile;
synchronized (this) {
      if (stopMerges) {
        deleter.deleteNewFiles(infoPerCommit.files());
        return;
      }
      ensureOpen();
      useCompoundFile=mergePolicy.useCompoundFile(segmentInfos,infoPerCommit);
    }
    if (useCompoundFile) {
      Collection<String> filesToDelete=infoPerCommit.files();
      try {
        createCompoundFile(infoStream,directory,MergeState.CheckAbort.NONE,info,context);
      }
  finally {
synchronized (this) {
          deleter.deleteNewFiles(filesToDelete);
        }
      }
      info.setUseCompoundFile(true);
    }
    success=false;
    try {
      codec.segmentInfoFormat().getSegmentInfoWriter().write(trackingDir,info,mergeState.fieldInfos,context);
      success=true;
    }
  finally {
      if (!success) {
synchronized (this) {
          deleter.refresh(info.name);
        }
      }
    }
    info.addFiles(trackingDir.getCreatedFiles());
synchronized (this) {
      if (stopMerges) {
        deleter.deleteNewFiles(info.files());
        return;
      }
      ensureOpen();
      segmentInfos.add(infoPerCommit);
      checkpoint();
    }
  }
 catch (  OutOfMemoryError oom) {
    handleOOM(oom,"addIndexes(IndexReader...)");
  }
}
