{
  ensureOpen();
  final long tStart=System.currentTimeMillis();
  if (infoStream.isEnabled("IW")) {
    infoStream.message("IW","flush at getReader");
  }
  poolReaders=true;
  DirectoryReader r=null;
  doBeforeFlush();
  boolean anySegmentFlushed=false;
  boolean success2=false;
  try {
synchronized (fullFlushLock) {
      boolean success=false;
      try {
        anySegmentFlushed=docWriter.flushAllThreads(this);
        if (!anySegmentFlushed) {
          flushCount.incrementAndGet();
        }
        success=true;
synchronized (this) {
          maybeApplyDeletes(applyAllDeletes);
          r=StandardDirectoryReader.open(this,segmentInfos,applyAllDeletes);
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW","return reader version=" + r.getVersion() + " reader="+ r);
          }
        }
      }
 catch (      OutOfMemoryError oom) {
        handleOOM(oom,"getReader");
        return null;
      }
 finally {
        if (!success) {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW","hit exception during NRT reader");
          }
        }
        docWriter.finishFullFlush(success);
        processEvents(false,true);
        doAfterFlush();
      }
    }
    if (anySegmentFlushed) {
      maybeMerge(MergeTrigger.FULL_FLUSH,UNBOUNDED_MAX_MERGE_SEGMENTS);
    }
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","getReader took " + (System.currentTimeMillis() - tStart) + " msec");
    }
    success2=true;
  }
  finally {
    if (!success2) {
      IOUtils.closeWhileHandlingException(r);
    }
  }
  return r;
}
