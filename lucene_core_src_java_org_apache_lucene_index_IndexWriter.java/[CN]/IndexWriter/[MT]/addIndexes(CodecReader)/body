{
  ensureOpen();
  long numDocs=0;
  Sort indexSort=config.getIndexSort();
  long seqNo;
  try {
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","flush at addIndexes(CodecReader...)");
    }
    flush(false,true);
    String mergedName=newSegmentName();
    for (    CodecReader leaf : readers) {
      numDocs+=leaf.numDocs();
      Sort leafIndexSort=leaf.getIndexSort();
      if (indexSort != null && leafIndexSort != null && indexSort.equals(leafIndexSort) == false) {
        throw new IllegalArgumentException("cannot change index sort from " + leafIndexSort + " to "+ indexSort);
      }
    }
    testReserveDocs(numDocs);
    final IOContext context=new IOContext(new MergeInfo(Math.toIntExact(numDocs),-1,false,UNBOUNDED_MAX_MERGE_SEGMENTS));
    TrackingDirectoryWrapper trackingDir=new TrackingDirectoryWrapper(directory);
    SegmentInfo info=new SegmentInfo(directoryOrig,Version.LATEST,mergedName,-1,false,codec,Collections.emptyMap(),StringHelper.randomId(),new HashMap<>(),config.getIndexSort());
    SegmentMerger merger=new SegmentMerger(Arrays.asList(readers),info,infoStream,trackingDir,globalFieldNumberMap,context);
    rateLimiters.set(new MergeRateLimiter(null));
    if (!merger.shouldMerge()) {
      return docWriter.deleteQueue.getNextSequenceNumber();
    }
    merger.merge();
    SegmentCommitInfo infoPerCommit=new SegmentCommitInfo(info,0,-1L,-1L,-1L);
    info.setFiles(new HashSet<>(trackingDir.getCreatedFiles()));
    trackingDir.clearCreatedFiles();
    setDiagnostics(info,SOURCE_ADDINDEXES_READERS);
    final MergePolicy mergePolicy=config.getMergePolicy();
    boolean useCompoundFile;
synchronized (this) {
      if (stopMerges) {
        deleteNewFiles(infoPerCommit.files());
        return docWriter.deleteQueue.getNextSequenceNumber();
      }
      ensureOpen();
      useCompoundFile=mergePolicy.useCompoundFile(segmentInfos,infoPerCommit,this);
    }
    if (useCompoundFile) {
      Collection<String> filesToDelete=infoPerCommit.files();
      TrackingDirectoryWrapper trackingCFSDir=new TrackingDirectoryWrapper(mergeDirectory);
      try {
        createCompoundFile(infoStream,trackingCFSDir,info,context);
      }
  finally {
        deleteNewFiles(filesToDelete);
      }
      info.setUseCompoundFile(true);
    }
    codec.segmentInfoFormat().write(trackingDir,info,context);
    info.addFiles(trackingDir.getCreatedFiles());
synchronized (this) {
      if (stopMerges) {
        deleteNewFiles(infoPerCommit.files());
        return docWriter.deleteQueue.getNextSequenceNumber();
      }
      ensureOpen();
      reserveDocs(numDocs);
      segmentInfos.add(infoPerCommit);
      seqNo=docWriter.deleteQueue.getNextSequenceNumber();
      checkpoint();
    }
  }
 catch (  VirtualMachineError tragedy) {
    tragicEvent(tragedy,"addIndexes(CodecReader...)");
    seqNo=-1;
  }
  maybeMerge();
  return seqNo;
}
