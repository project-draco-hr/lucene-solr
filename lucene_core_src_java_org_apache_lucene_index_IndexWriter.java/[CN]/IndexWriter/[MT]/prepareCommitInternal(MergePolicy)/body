{
  startCommitTime=System.nanoTime();
synchronized (commitLock) {
    ensureOpen(false);
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","prepareCommit: flush");
      infoStream.message("IW","  index before flush " + segString());
    }
    if (tragedy != null) {
      throw new IllegalStateException("this writer hit an unrecoverable error; cannot commit",tragedy);
    }
    if (pendingCommit != null) {
      throw new IllegalStateException("prepareCommit was already called with no corresponding call to commit");
    }
    doBeforeFlush();
    testPoint("startDoFlush");
    SegmentInfos toCommit=null;
    boolean anySegmentsFlushed=false;
    long seqNo;
    try {
synchronized (fullFlushLock) {
        boolean flushSuccess=false;
        boolean success=false;
        try {
          seqNo=docWriter.flushAllThreads();
          if (seqNo < 0) {
            anySegmentsFlushed=true;
            seqNo=-seqNo;
          }
          if (!anySegmentsFlushed) {
            flushCount.incrementAndGet();
          }
          processEvents(false,true);
          flushSuccess=true;
synchronized (this) {
            maybeApplyDeletes(true);
            readerPool.commit(segmentInfos);
            if (changeCount.get() != lastCommitChangeCount) {
              changeCount.incrementAndGet();
              segmentInfos.changed();
            }
            toCommit=segmentInfos.clone();
            pendingCommitChangeCount=changeCount.get();
            filesToCommit=toCommit.files(false);
            deleter.incRef(filesToCommit);
          }
          success=true;
        }
  finally {
          if (!success) {
            if (infoStream.isEnabled("IW")) {
              infoStream.message("IW","hit exception during prepareCommit");
            }
          }
          docWriter.finishFullFlush(this,flushSuccess);
          doAfterFlush();
        }
      }
    }
 catch (    AbortingException|VirtualMachineError tragedy) {
      tragicEvent(tragedy,"prepareCommit");
      seqNo=-1;
    }
    boolean success=false;
    try {
      if (anySegmentsFlushed) {
        maybeMerge(mergePolicy,MergeTrigger.FULL_FLUSH,UNBOUNDED_MAX_MERGE_SEGMENTS);
      }
      startCommit(toCommit);
      success=true;
      if (pendingCommit == null) {
        return -1;
      }
 else {
        return seqNo;
      }
    }
  finally {
      if (!success) {
synchronized (this) {
          if (filesToCommit != null) {
            deleter.decRefWhileHandlingException(filesToCommit);
            filesToCommit=null;
          }
        }
      }
    }
  }
}
