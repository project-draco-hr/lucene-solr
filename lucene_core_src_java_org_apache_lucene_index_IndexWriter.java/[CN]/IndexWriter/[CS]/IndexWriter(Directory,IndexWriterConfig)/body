{
  conf.setIndexWriter(this);
  config=conf;
  infoStream=config.getInfoStream();
  writeLock=d.obtainLock(WRITE_LOCK_NAME);
  boolean success=false;
  try {
    directoryOrig=d;
    directory=new LockValidatingDirectoryWrapper(d,writeLock);
    mergeDirectory=addMergeRateLimiters(directory);
    analyzer=config.getAnalyzer();
    mergeScheduler=config.getMergeScheduler();
    mergeScheduler.setInfoStream(infoStream);
    codec=config.getCodec();
    bufferedUpdatesStream=new BufferedUpdatesStream(infoStream);
    poolReaders=config.getReaderPooling();
    OpenMode mode=config.getOpenMode();
    boolean create;
    if (mode == OpenMode.CREATE) {
      create=true;
    }
 else     if (mode == OpenMode.APPEND) {
      create=false;
    }
 else {
      create=!DirectoryReader.indexExists(directory);
    }
    boolean initialIndexExists=true;
    if (create) {
      SegmentInfos sis=null;
      try {
        sis=SegmentInfos.readLatestCommit(directory);
        sis.clear();
      }
 catch (      IOException e) {
        initialIndexExists=false;
        sis=new SegmentInfos();
      }
      segmentInfos=sis;
      changed();
    }
 else {
      String[] files=directory.listAll();
      String lastSegmentsFile=SegmentInfos.getLastCommitSegmentsFileName(files);
      if (lastSegmentsFile == null) {
        throw new IndexNotFoundException("no segments* file found in " + directory + ": files: "+ Arrays.toString(files));
      }
      segmentInfos=SegmentInfos.readCommit(directoryOrig,lastSegmentsFile);
      IndexCommit commit=config.getIndexCommit();
      if (commit != null) {
        if (commit.getDirectory() != directoryOrig)         throw new IllegalArgumentException("IndexCommit's directory doesn't match my directory, expected=" + directoryOrig + ", got="+ commit.getDirectory());
        SegmentInfos oldInfos=SegmentInfos.readCommit(directoryOrig,commit.getSegmentsFileName());
        segmentInfos.replace(oldInfos);
        changed();
        if (infoStream.isEnabled("IW")) {
          infoStream.message("IW","init: loaded commit \"" + commit.getSegmentsFileName() + "\"");
        }
      }
    }
    rollbackSegments=segmentInfos.createBackupSegmentInfos();
    pendingNumDocs.set(segmentInfos.totalMaxDoc());
    globalFieldNumberMap=getFieldNumberMap();
    config.getFlushPolicy().init(config);
    docWriter=new DocumentsWriter(this,config,directoryOrig,directory);
    eventQueue=docWriter.eventQueue();
synchronized (this) {
      deleter=new IndexFileDeleter(directoryOrig,directory,config.getIndexDeletionPolicy(),segmentInfos,infoStream,this,initialIndexExists);
    }
    if (deleter.startingCommitDeleted) {
      changed();
    }
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","init: create=" + create);
      messageState();
    }
    success=true;
  }
  finally {
    if (!success) {
      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW","init: hit exception on init; releasing write lock");
      }
      IOUtils.closeWhileHandlingException(writeLock);
      writeLock=null;
    }
  }
}
