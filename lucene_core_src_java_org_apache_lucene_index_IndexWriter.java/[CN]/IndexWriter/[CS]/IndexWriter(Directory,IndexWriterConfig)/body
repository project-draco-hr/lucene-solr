{
  conf.setIndexWriter(this);
  config=conf;
  directory=d;
  mergeDirectory=addMergeRateLimiters(d);
  analyzer=config.getAnalyzer();
  infoStream=config.getInfoStream();
  mergeScheduler=config.getMergeScheduler();
  mergeScheduler.setInfoStream(infoStream);
  codec=config.getCodec();
  bufferedUpdatesStream=new BufferedUpdatesStream(infoStream);
  poolReaders=config.getReaderPooling();
  writeLock=directory.makeLock(WRITE_LOCK_NAME);
  if (!writeLock.obtain(config.getWriteLockTimeout()))   throw new LockObtainFailedException("Index locked for write: " + writeLock);
  boolean success=false;
  try {
    OpenMode mode=config.getOpenMode();
    boolean create;
    if (mode == OpenMode.CREATE) {
      create=true;
    }
 else     if (mode == OpenMode.APPEND) {
      create=false;
    }
 else {
      create=!DirectoryReader.indexExists(directory);
    }
    boolean initialIndexExists=true;
    if (create) {
      SegmentInfos sis=null;
      try {
        sis=SegmentInfos.readLatestCommit(directory);
        sis.clear();
      }
 catch (      IOException e) {
        initialIndexExists=false;
        sis=new SegmentInfos();
      }
      segmentInfos=sis;
      changed();
    }
 else {
      String[] files=directory.listAll();
      String lastSegmentsFile=SegmentInfos.getLastCommitSegmentsFileName(files);
      if (lastSegmentsFile == null) {
        throw new IndexNotFoundException("no segments* file found in " + directory + ": files: "+ Arrays.toString(files));
      }
      segmentInfos=SegmentInfos.readCommit(directory,lastSegmentsFile);
      IndexCommit commit=config.getIndexCommit();
      if (commit != null) {
        if (commit.getDirectory() != directory)         throw new IllegalArgumentException("IndexCommit's directory doesn't match my directory");
        SegmentInfos oldInfos=SegmentInfos.readCommit(directory,commit.getSegmentsFileName());
        segmentInfos.replace(oldInfos);
        changed();
        if (infoStream.isEnabled("IW")) {
          infoStream.message("IW","init: loaded commit \"" + commit.getSegmentsFileName() + "\"");
        }
      }
    }
    rollbackSegments=segmentInfos.createBackupSegmentInfos();
    pendingNumDocs.set(segmentInfos.totalDocCount());
    globalFieldNumberMap=getFieldNumberMap();
    config.getFlushPolicy().init(config);
    docWriter=new DocumentsWriter(this,config,directory);
    eventQueue=docWriter.eventQueue();
synchronized (this) {
      deleter=new IndexFileDeleter(directory,config.getIndexDeletionPolicy(),segmentInfos,infoStream,this,initialIndexExists);
    }
    if (deleter.startingCommitDeleted) {
      changed();
    }
    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW","init: create=" + create);
      messageState();
    }
    success=true;
  }
  finally {
    if (!success) {
      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW","init: hit exception on init; releasing write lock");
      }
      IOUtils.closeWhileHandlingException(writeLock);
      writeLock=null;
    }
  }
}
