{
  int docCount=state.segmentInfo.getDocCount();
  DocValuesConsumer dvConsumer=null;
  boolean success=false;
  try {
    for (int i=0; i < fieldHash.length; i++) {
      PerField perField=fieldHash[i];
      while (perField != null) {
        if (perField.docValuesWriter != null) {
          if (perField.fieldInfo.getDocValuesType() == DocValuesType.NONE) {
            throw new AssertionError("segment=" + state.segmentInfo + ": field=\""+ perField.fieldInfo.name+ "\" has no docValues but wrote them");
          }
          if (dvConsumer == null) {
            DocValuesFormat fmt=state.segmentInfo.getCodec().docValuesFormat();
            dvConsumer=fmt.fieldsConsumer(state);
          }
          perField.docValuesWriter.finish(docCount);
          perField.docValuesWriter.flush(state,dvConsumer);
          perField.docValuesWriter=null;
        }
 else         if (perField.fieldInfo.getDocValuesType() != DocValuesType.NONE) {
          throw new AssertionError("segment=" + state.segmentInfo + ": field=\""+ perField.fieldInfo.name+ "\" has docValues but did not write them");
        }
        perField=perField.next;
      }
    }
    success=true;
  }
  finally {
    if (success) {
      IOUtils.close(dvConsumer);
    }
 else {
      IOUtils.closeWhileHandlingException(dvConsumer);
    }
  }
  if (state.fieldInfos.hasDocValues() == false) {
    if (dvConsumer != null) {
      throw new AssertionError("segment=" + state.segmentInfo + ": fieldInfos has no docValues but wrote them");
    }
  }
 else   if (dvConsumer == null) {
    throw new AssertionError("segment=" + state.segmentInfo + ": fieldInfos has docValues but did not wrote them");
  }
}
