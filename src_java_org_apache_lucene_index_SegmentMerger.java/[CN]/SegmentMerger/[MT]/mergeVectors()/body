{
  TermVectorsWriter termVectorsWriter=new TermVectorsWriter(directory,segment,fieldInfos);
  try {
    int idx=0;
    for (Iterator iter=readers.iterator(); iter.hasNext(); ) {
      final SegmentReader matchingSegmentReader=matchingSegmentReaders[idx++];
      TermVectorsReader matchingVectorsReader=null;
      if (matchingSegmentReader != null) {
        TermVectorsReader vectorsReader=matchingSegmentReader.getTermVectorsReaderOrig();
        if (vectorsReader != null && vectorsReader.canReadRawDocs()) {
          matchingVectorsReader=vectorsReader;
        }
      }
      final IndexReader reader=(IndexReader)iter.next();
      if (reader.hasDeletions()) {
        copyVectorsWithDeletions(termVectorsWriter,matchingVectorsReader,reader);
      }
 else {
        copyVectorsNoDeletions(termVectorsWriter,matchingVectorsReader,reader);
      }
    }
  }
  finally {
    termVectorsWriter.close();
  }
  final long tvxSize=directory.fileLength(segment + "." + IndexFileNames.VECTORS_INDEX_EXTENSION);
  if (4 + ((long)mergedDocs) * 16 != tvxSize)   throw new RuntimeException("mergeVectors produced an invalid result: mergedDocs is " + mergedDocs + " but tvx size is "+ tvxSize+ "; now aborting this merge to prevent index corruption");
}
