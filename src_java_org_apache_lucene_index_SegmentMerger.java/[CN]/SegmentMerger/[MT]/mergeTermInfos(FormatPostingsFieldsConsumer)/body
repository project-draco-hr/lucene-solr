{
  int base=0;
  final int readerCount=readers.size();
  for (int i=0; i < readerCount; i++) {
    IndexReader reader=(IndexReader)readers.get(i);
    TermEnum termEnum=reader.terms();
    SegmentMergeInfo smi=new SegmentMergeInfo(base,termEnum,reader);
    int[] docMap=smi.getDocMap();
    if (docMap != null) {
      if (docMaps == null) {
        docMaps=new int[readerCount][];
        delCounts=new int[readerCount];
      }
      docMaps[i]=docMap;
      delCounts[i]=smi.reader.maxDoc() - smi.reader.numDocs();
    }
    base+=reader.numDocs();
    if (smi.next())     queue.put(smi);
 else     smi.close();
  }
  SegmentMergeInfo[] match=new SegmentMergeInfo[readers.size()];
  String currentField=null;
  FormatPostingsTermsConsumer termsConsumer=null;
  while (queue.size() > 0) {
    int matchSize=0;
    match[matchSize++]=(SegmentMergeInfo)queue.pop();
    Term term=match[0].term;
    SegmentMergeInfo top=(SegmentMergeInfo)queue.top();
    while (top != null && term.compareTo(top.term) == 0) {
      match[matchSize++]=(SegmentMergeInfo)queue.pop();
      top=(SegmentMergeInfo)queue.top();
    }
    if (currentField != term.field) {
      currentField=term.field;
      if (termsConsumer != null)       termsConsumer.finish();
      final FieldInfo fieldInfo=fieldInfos.fieldInfo(currentField);
      termsConsumer=consumer.addField(fieldInfo);
      omitTermFreqAndPositions=fieldInfo.omitTermFreqAndPositions;
    }
    int df=appendPostings(termsConsumer,match,matchSize);
    if (checkAbort != null)     checkAbort.work(df / 3.0);
    while (matchSize > 0) {
      SegmentMergeInfo smi=match[--matchSize];
      if (smi.next())       queue.put(smi);
 else       smi.close();
    }
  }
}
