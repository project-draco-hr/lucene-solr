{
  SolrParams localParams=getLocalParams();
  SolrParams params=getParams();
  solrParams=SolrParams.wrapDefaults(localParams,params);
  final String minShouldMatch=DisMaxQParser.parseMinShouldMatch(req.getSchema(),solrParams);
  userFields=new UserFields(U.parseFieldBoosts(solrParams.getParams(DMP.UF)));
  queryFields=DisMaxQParser.parseQueryFields(req.getSchema(),solrParams);
  int pslop[]=new int[4];
  pslop[0]=solrParams.getInt(DisMaxParams.PS,0);
  pslop[2]=solrParams.getInt(DisMaxParams.PS2,pslop[0]);
  pslop[3]=solrParams.getInt(DisMaxParams.PS3,pslop[0]);
  List<FieldParams> phraseFields=U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF),0,pslop[0]);
  List<FieldParams> phraseFields2=U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF2),2,pslop[2]);
  List<FieldParams> phraseFields3=U.parseFieldBoostsAndSlop(solrParams.getParams(DMP.PF3),3,pslop[3]);
  float tiebreaker=solrParams.getFloat(DisMaxParams.TIE,0.0f);
  int qslop=solrParams.getInt(DisMaxParams.QS,0);
  boolean stopwords=solrParams.getBool("stopwords",true);
  BooleanQuery query=new BooleanQuery(true);
  parsedUserQuery=null;
  String userQuery=getString();
  altUserQuery=null;
  if (userQuery == null || userQuery.trim().length() == 0) {
    String altQ=solrParams.get(DisMaxParams.ALTQ);
    if (altQ != null) {
      altQParser=subQuery(altQ,null);
      altUserQuery=altQParser.getQuery();
      query.add(altUserQuery,BooleanClause.Occur.MUST);
    }
 else {
      return null;
    }
  }
 else {
    boolean lowercaseOperators=solrParams.getBool("lowercaseOperators",true);
    String mainUserQuery=userQuery;
    ExtendedSolrQueryParser up=new ExtendedSolrQueryParser(this,IMPOSSIBLE_FIELD_NAME);
    up.addAlias(IMPOSSIBLE_FIELD_NAME,tiebreaker,queryFields);
    addAliasesFromRequest(up,tiebreaker);
    up.setPhraseSlop(qslop);
    up.setAllowLeadingWildcard(true);
    List<Clause> clauses=null;
    int numPluses=0;
    int numMinuses=0;
    int numOR=0;
    int numNOT=0;
    clauses=splitIntoClauses(userQuery,false);
    for (    Clause clause : clauses) {
      if (clause.must == '+')       numPluses++;
      if (clause.must == '-')       numMinuses++;
      if (clause.isBareWord()) {
        String s=clause.val;
        if ("OR".equals(s)) {
          numOR++;
        }
 else         if ("NOT".equals(s)) {
          numNOT++;
        }
 else         if (lowercaseOperators && "or".equals(s)) {
          numOR++;
        }
      }
    }
    StringBuilder sb=new StringBuilder();
    for (int i=0; i < clauses.size(); i++) {
      Clause clause=clauses.get(i);
      String s=clause.raw;
      if (lowercaseOperators && i > 0 && i + 1 < clauses.size()) {
        if ("AND".equalsIgnoreCase(s)) {
          s="AND";
        }
 else         if ("OR".equalsIgnoreCase(s)) {
          s="OR";
        }
      }
      sb.append(s);
      sb.append(' ');
    }
    mainUserQuery=sb.toString();
    boolean doMinMatched=(numOR + numNOT + numPluses+ numMinuses) == 0;
    try {
      up.setRemoveStopFilter(!stopwords);
      up.exceptions=true;
      parsedUserQuery=up.parse(mainUserQuery);
      if (stopwords && isEmpty(parsedUserQuery)) {
        up.setRemoveStopFilter(true);
        parsedUserQuery=up.parse(mainUserQuery);
      }
    }
 catch (    Exception e) {
      up.exceptions=false;
    }
    if (parsedUserQuery != null && doMinMatched) {
      if (parsedUserQuery instanceof BooleanQuery) {
        SolrPluginUtils.setMinShouldMatch((BooleanQuery)parsedUserQuery,minShouldMatch);
      }
    }
    if (parsedUserQuery == null) {
      sb=new StringBuilder();
      for (      Clause clause : clauses) {
        boolean doQuote=clause.isPhrase;
        String s=clause.val;
        if (!clause.isPhrase && ("OR".equals(s) || "AND".equals(s) || "NOT".equals(s))) {
          doQuote=true;
        }
        if (clause.must != 0) {
          sb.append(clause.must);
        }
        if (clause.field != null) {
          sb.append(clause.field);
          sb.append(':');
        }
        if (doQuote) {
          sb.append('"');
        }
        sb.append(clause.val);
        if (doQuote) {
          sb.append('"');
        }
        if (clause.field != null) {
          Float boost=userFields.getBoost(clause.field);
          if (boost != null)           sb.append("^").append(boost);
        }
        sb.append(' ');
      }
      String escapedUserQuery=sb.toString();
      parsedUserQuery=up.parse(escapedUserQuery);
      if (parsedUserQuery instanceof BooleanQuery) {
        BooleanQuery t=new BooleanQuery();
        SolrPluginUtils.flattenBooleanQuery(t,(BooleanQuery)parsedUserQuery);
        SolrPluginUtils.setMinShouldMatch(t,minShouldMatch);
        parsedUserQuery=t;
      }
    }
    query.add(parsedUserQuery,BooleanClause.Occur.MUST);
    List<FieldParams> allPhraseFields=new ArrayList<FieldParams>();
    allPhraseFields.addAll(phraseFields);
    allPhraseFields.addAll(phraseFields2);
    allPhraseFields.addAll(phraseFields3);
    if (allPhraseFields.size() > 0) {
      List<Clause> normalClauses=new ArrayList<Clause>(clauses.size());
      for (      Clause clause : clauses) {
        if (clause.field != null || clause.isPhrase)         continue;
        if (clause.isBareWord()) {
          String s=clause.val.toString();
          if ("OR".equals(s) || "AND".equals(s) || "NOT".equals(s)|| "TO".equals(s))           continue;
        }
        normalClauses.add(clause);
      }
      for (      FieldParams phraseField : allPhraseFields) {
        Map<String,Float> pf=new HashMap<String,Float>(1);
        pf.put(phraseField.getField(),phraseField.getBoost());
        addShingledPhraseQueries(query,normalClauses,pf,phraseField.getWordGrams(),tiebreaker,phraseField.getSlop());
      }
    }
  }
  boostParams=solrParams.getParams(DisMaxParams.BQ);
  boostQueries=null;
  if (boostParams != null && boostParams.length > 0) {
    boostQueries=new ArrayList<Query>();
    for (    String qs : boostParams) {
      if (qs.trim().length() == 0)       continue;
      Query q=subQuery(qs,null).getQuery();
      boostQueries.add(q);
    }
  }
  if (null != boostQueries) {
    for (    Query f : boostQueries) {
      query.add(f,BooleanClause.Occur.SHOULD);
    }
  }
  String[] boostFuncs=solrParams.getParams(DisMaxParams.BF);
  if (null != boostFuncs && 0 != boostFuncs.length) {
    for (    String boostFunc : boostFuncs) {
      if (null == boostFunc || "".equals(boostFunc))       continue;
      Map<String,Float> ff=SolrPluginUtils.parseFieldBoosts(boostFunc);
      for (      String f : ff.keySet()) {
        Query fq=subQuery(f,FunctionQParserPlugin.NAME).getQuery();
        Float b=ff.get(f);
        if (null != b) {
          fq.setBoost(b);
        }
        query.add(fq,BooleanClause.Occur.SHOULD);
      }
    }
  }
  Query topQuery=query;
  multBoosts=solrParams.getParams("boost");
  if (multBoosts != null && multBoosts.length > 0) {
    List<ValueSource> boosts=new ArrayList<ValueSource>();
    for (    String boostStr : multBoosts) {
      if (boostStr == null || boostStr.length() == 0)       continue;
      Query boost=subQuery(boostStr,FunctionQParserPlugin.NAME).getQuery();
      ValueSource vs;
      if (boost instanceof FunctionQuery) {
        vs=((FunctionQuery)boost).getValueSource();
      }
 else {
        vs=new QueryValueSource(boost,1.0f);
      }
      boosts.add(vs);
    }
    if (boosts.size() > 1) {
      ValueSource prod=new ProductFloatFunction(boosts.toArray(new ValueSource[boosts.size()]));
      topQuery=new BoostedQuery(query,prod);
    }
 else     if (boosts.size() == 1) {
      topQuery=new BoostedQuery(query,boosts.get(0));
    }
  }
  return topQuery;
}
