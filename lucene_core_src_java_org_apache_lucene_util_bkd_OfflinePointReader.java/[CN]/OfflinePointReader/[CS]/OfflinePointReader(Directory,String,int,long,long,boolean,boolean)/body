{
  this.singleValuePerDoc=singleValuePerDoc;
  int bytesPerDoc=packedBytesLength + Integer.BYTES;
  if (singleValuePerDoc == false) {
    if (longOrds) {
      bytesPerDoc+=Long.BYTES;
    }
 else {
      bytesPerDoc+=Integer.BYTES;
    }
  }
  this.bytesPerDoc=bytesPerDoc;
  if ((start + length) * bytesPerDoc + CodecUtil.footerLength() > tempDir.fileLength(tempFileName)) {
    throw new IllegalArgumentException("requested slice is beyond the length of this file: start=" + start + " length="+ length+ " bytesPerDoc="+ bytesPerDoc+ " fileLength="+ tempDir.fileLength(tempFileName)+ " tempFileName="+ tempFileName);
  }
  if (start == 0 && length * bytesPerDoc == tempDir.fileLength(tempFileName) - CodecUtil.footerLength()) {
    in=tempDir.openChecksumInput(tempFileName,IOContext.READONCE);
  }
 else {
    in=tempDir.openInput(tempFileName,IOContext.READONCE);
  }
  name=tempFileName;
  long seekFP=start * bytesPerDoc;
  in.seek(seekFP);
  countLeft=length;
  packedValue=new byte[packedBytesLength];
  this.longOrds=longOrds;
}
