{
  log.info("Reading Solr Schema from " + resourceName);
  try {
    Config schemaConf=new Config(loader,SCHEMA,is,SLASH + SCHEMA + SLASH);
    Document document=schemaConf.getDocument();
    final XPath xpath=schemaConf.getXPath();
    String expression=stepsToPath(SCHEMA,AT + NAME);
    Node nd=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    StringBuilder sb=new StringBuilder();
    sb.append("[");
    if (loader.getCoreProperties() != null) {
      sb.append(loader.getCoreProperties().getProperty(SOLR_CORE_NAME));
    }
 else {
      sb.append("null");
    }
    sb.append("] ");
    if (nd == null) {
      sb.append("schema has no name!");
      log.warn(sb.toString());
    }
 else {
      name=nd.getNodeValue();
      sb.append("Schema ");
      sb.append(NAME);
      sb.append("=");
      sb.append(name);
      log.info(sb.toString());
    }
    expression=stepsToPath(SCHEMA,AT + VERSION);
    version=schemaConf.getFloat(expression,1.0f);
    final FieldTypePluginLoader typeLoader=new FieldTypePluginLoader(this,fieldTypes,schemaAware);
    expression=stepsToPath(SCHEMA,TYPES,FIELD_TYPE.toLowerCase(Locale.ROOT)) + XPATH_OR + stepsToPath(SCHEMA,TYPES,FIELD_TYPE);
    NodeList nodes=(NodeList)xpath.evaluate(expression,document,XPathConstants.NODESET);
    typeLoader.load(loader,nodes);
    Map<String,Boolean> explicitRequiredProp=loadFields(document,xpath);
    expression=stepsToPath(SCHEMA,SIMILARITY);
    Node node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    similarityFactory=readSimilarity(loader,node);
    if (similarityFactory == null) {
      similarityFactory=new DefaultSimilarityFactory();
      final NamedList similarityParams=new NamedList();
      Version luceneVersion=getDefaultLuceneMatchVersion();
      if (!luceneVersion.onOrAfter(Version.LUCENE_47)) {
        similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS,false);
      }
      similarityFactory.init(SolrParams.toSolrParams(similarityParams));
    }
 else {
      isExplicitSimilarity=true;
    }
    if (!(similarityFactory instanceof SolrCoreAware)) {
      for (      FieldType ft : fieldTypes.values()) {
        if (null != ft.getSimilarity()) {
          String msg="FieldType '" + ft.getTypeName() + "' is configured with a similarity, but the global similarity does not support it: "+ similarityFactory.getClass();
          log.error(msg);
          throw new SolrException(ErrorCode.SERVER_ERROR,msg);
        }
      }
    }
    expression=stepsToPath(SCHEMA,DEFAULT_SEARCH_FIELD,TEXT_FUNCTION);
    node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (node == null) {
      log.debug("no default search field specified in schema.");
    }
 else {
      defaultSearchFieldName=node.getNodeValue().trim();
      if (defaultSearchFieldName != null) {
        SchemaField defaultSearchField=getFields().get(defaultSearchFieldName);
        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {
          String msg="default search field '" + defaultSearchFieldName + "' not defined or not indexed";
          throw new SolrException(ErrorCode.SERVER_ERROR,msg);
        }
      }
      log.info("default search field in schema is " + defaultSearchFieldName);
    }
    expression=stepsToPath(SCHEMA,SOLR_QUERY_PARSER,AT + DEFAULT_OPERATOR);
    node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (node == null) {
      log.debug("using default query parser operator (OR)");
    }
 else {
      isExplicitQueryParserDefaultOperator=true;
      queryParserDefaultOperator=node.getNodeValue().trim();
      log.info("query parser default operator is " + queryParserDefaultOperator);
    }
    expression=stepsToPath(SCHEMA,UNIQUE_KEY,TEXT_FUNCTION);
    node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (node == null) {
      log.warn("no " + UNIQUE_KEY + " specified in schema.");
    }
 else {
      uniqueKeyField=getIndexedField(node.getNodeValue().trim());
      if (null != uniqueKeyField.getDefaultValue()) {
        String msg=UNIQUE_KEY + " field (" + uniqueKeyFieldName+ ") can not be configured with a default value ("+ uniqueKeyField.getDefaultValue()+ ")";
        log.error(msg);
        throw new SolrException(ErrorCode.SERVER_ERROR,msg);
      }
      if (!uniqueKeyField.stored()) {
        log.warn(UNIQUE_KEY + " is not stored - distributed search and MoreLikeThis will not work");
      }
      if (uniqueKeyField.multiValued()) {
        String msg=UNIQUE_KEY + " field (" + uniqueKeyFieldName+ ") can not be configured to be multivalued";
        log.error(msg);
        throw new SolrException(ErrorCode.SERVER_ERROR,msg);
      }
      uniqueKeyFieldName=uniqueKeyField.getName();
      uniqueKeyFieldType=uniqueKeyField.getType();
      log.info("unique key field: " + uniqueKeyFieldName);
      if (Boolean.FALSE != explicitRequiredProp.get(uniqueKeyFieldName)) {
        uniqueKeyField.required=true;
        requiredFields.add(uniqueKeyField);
      }
    }
    dynamicCopyFields=new DynamicCopy[]{};
    expression="//" + COPY_FIELD;
    nodes=(NodeList)xpath.evaluate(expression,document,XPathConstants.NODESET);
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      NamedNodeMap attrs=node.getAttributes();
      String source=DOMUtil.getAttr(attrs,SOURCE,COPY_FIELD + " definition");
      String dest=DOMUtil.getAttr(attrs,DESTINATION,COPY_FIELD + " definition");
      String maxChars=DOMUtil.getAttr(attrs,MAX_CHARS);
      int maxCharsInt=CopyField.UNLIMITED;
      if (maxChars != null) {
        try {
          maxCharsInt=Integer.parseInt(maxChars);
        }
 catch (        NumberFormatException e) {
          log.warn("Couldn't parse " + MAX_CHARS + " attribute for "+ COPY_FIELD+ " from "+ source+ " to "+ dest+ " as integer. The whole field will be copied.");
        }
      }
      if (dest.equals(uniqueKeyFieldName)) {
        String msg=UNIQUE_KEY + " field (" + uniqueKeyFieldName+ ") can not be the "+ DESTINATION+ " of a "+ COPY_FIELD+ "("+ SOURCE+ "="+ source+ ")";
        log.error(msg);
        throw new SolrException(ErrorCode.SERVER_ERROR,msg);
      }
      registerCopyField(source,dest,maxCharsInt);
    }
    for (    Map.Entry<SchemaField,Integer> entry : copyFieldTargetCounts.entrySet()) {
      if (entry.getValue() > 1 && !entry.getKey().multiValued()) {
        log.warn("Field " + entry.getKey().name + " is not multivalued "+ "and destination for multiple "+ COPY_FIELDS+ " ("+ entry.getValue()+ ")");
      }
    }
    for (    SchemaAware aware : schemaAware) {
      aware.inform(this);
    }
  }
 catch (  SolrException e) {
    throw new SolrException(ErrorCode.getErrorCode(e.code()),e.getMessage() + ". Schema file is " + loader.getInstanceDir()+ resourceName,e);
  }
catch (  Exception e) {
    throw new SolrException(ErrorCode.SERVER_ERROR,"Schema Parsing Failed: " + e.getMessage() + ". Schema file is "+ loader.getInstanceDir()+ resourceName,e);
  }
  refreshAnalyzers();
}
