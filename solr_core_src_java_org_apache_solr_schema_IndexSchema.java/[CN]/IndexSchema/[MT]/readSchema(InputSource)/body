{
  log.info("Reading Solr Schema");
  try {
    Config schemaConf=new Config(loader,SCHEMA,is,SLASH + SCHEMA + SLASH);
    Document document=schemaConf.getDocument();
    final XPath xpath=schemaConf.getXPath();
    final List<SchemaAware> schemaAware=new ArrayList<SchemaAware>();
    String expression=stepsToPath(SCHEMA,AT + NAME);
    Node nd=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (nd == null) {
      log.warn("schema has no name!");
    }
 else {
      name=nd.getNodeValue();
      log.info("Schema " + NAME + "="+ name);
    }
    expression=stepsToPath(SCHEMA,AT + VERSION);
    version=schemaConf.getFloat(expression,1.0f);
    final FieldTypePluginLoader typeLoader=new FieldTypePluginLoader(this,fieldTypes,schemaAware);
    expression=stepsToPath(SCHEMA,TYPES,FIELD_TYPE.toLowerCase(Locale.ROOT)) + XPATH_OR + stepsToPath(SCHEMA,TYPES,FIELD_TYPE);
    NodeList nodes=(NodeList)xpath.evaluate(expression,document,XPathConstants.NODESET);
    typeLoader.load(loader,nodes);
    Map<String,Boolean> explicitRequiredProp=new HashMap<String,Boolean>();
    ArrayList<DynamicField> dFields=new ArrayList<DynamicField>();
    expression=stepsToPath(SCHEMA,FIELDS,FIELD) + XPATH_OR + stepsToPath(SCHEMA,FIELDS,DYNAMIC_FIELD);
    nodes=(NodeList)xpath.evaluate(expression,document,XPathConstants.NODESET);
    for (int i=0; i < nodes.getLength(); i++) {
      Node node=nodes.item(i);
      NamedNodeMap attrs=node.getAttributes();
      String name=DOMUtil.getAttr(attrs,NAME,"field definition");
      log.trace("reading field def " + name);
      String type=DOMUtil.getAttr(attrs,TYPE,"field " + name);
      FieldType ft=fieldTypes.get(type);
      if (ft == null) {
        throw new SolrException(ErrorCode.BAD_REQUEST,"Unknown " + FIELD_TYPE + " '"+ type+ "' specified on field "+ name);
      }
      Map<String,String> args=DOMUtil.toMapExcept(attrs,NAME,TYPE);
      if (null != args.get(REQUIRED)) {
        explicitRequiredProp.put(name,Boolean.valueOf(args.get(REQUIRED)));
      }
      SchemaField f=SchemaField.create(name,ft,args);
      if (node.getNodeName().equals(FIELD)) {
        SchemaField old=fields.put(f.getName(),f);
        if (old != null) {
          String msg="[schema.xml] Duplicate field definition for '" + f.getName() + "' [[["+ old.toString()+ "]]] and [[["+ f.toString()+ "]]]";
          throw new SolrException(ErrorCode.SERVER_ERROR,msg);
        }
        log.debug("field defined: " + f);
        if (f.getDefaultValue() != null) {
          log.debug(name + " contains default value: " + f.getDefaultValue());
          fieldsWithDefaultValue.add(f);
        }
        if (f.isRequired()) {
          log.debug(name + " is required in this schema");
          requiredFields.add(f);
        }
      }
 else       if (node.getNodeName().equals(DYNAMIC_FIELD)) {
        if (isValidFieldGlob(name)) {
          addDynamicField(dFields,f);
        }
 else {
          String msg="Dynamic field name '" + name + "' should have either a leading or a trailing asterisk, and no others.";
          throw new SolrException(ErrorCode.SERVER_ERROR,msg);
        }
      }
 else {
        throw new RuntimeException("Unknown field type");
      }
    }
    requiredFields.addAll(getFieldsWithDefaultValue());
    Collections.sort(dFields);
    log.trace("Dynamic Field Ordering:" + dFields);
    dynamicFields=dFields.toArray(new DynamicField[dFields.size()]);
    expression=stepsToPath(SCHEMA,SIMILARITY);
    Node node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    similarityFactory=readSimilarity(loader,node);
    if (similarityFactory == null) {
      similarityFactory=new DefaultSimilarityFactory();
    }
 else {
      isExplicitSimilarity=true;
    }
    if (similarityFactory instanceof SchemaAware) {
      ((SchemaAware)similarityFactory).inform(this);
    }
 else {
      for (      FieldType ft : fieldTypes.values()) {
        if (null != ft.getSimilarity()) {
          String msg="FieldType '" + ft.getTypeName() + "' is configured with a similarity, but the global similarity does not support it: "+ similarityFactory.getClass();
          log.error(msg);
          throw new SolrException(ErrorCode.SERVER_ERROR,msg);
        }
      }
    }
    similarity=similarityFactory.getSimilarity();
    expression=stepsToPath(SCHEMA,DEFAULT_SEARCH_FIELD,TEXT_FUNCTION);
    node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (node == null) {
      log.debug("no default search field specified in schema.");
    }
 else {
      defaultSearchFieldName=node.getNodeValue().trim();
      if (defaultSearchFieldName != null) {
        SchemaField defaultSearchField=getFields().get(defaultSearchFieldName);
        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {
          String msg="default search field '" + defaultSearchFieldName + "' not defined or not indexed";
          throw new SolrException(ErrorCode.SERVER_ERROR,msg);
        }
      }
      log.info("default search field in schema is " + defaultSearchFieldName);
    }
    expression=stepsToPath(SCHEMA,SOLR_QUERY_PARSER,AT + DEFAULT_OPERATOR);
    node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (node == null) {
      log.debug("using default query parser operator (OR)");
    }
 else {
      isExplicitQueryParserDefaultOperator=true;
      queryParserDefaultOperator=node.getNodeValue().trim();
      log.info("query parser default operator is " + queryParserDefaultOperator);
    }
    expression=stepsToPath(SCHEMA,UNIQUE_KEY,TEXT_FUNCTION);
    node=(Node)xpath.evaluate(expression,document,XPathConstants.NODE);
    if (node == null) {
      log.warn("no " + UNIQUE_KEY + " specified in schema.");
    }
 else {
      uniqueKeyField=getIndexedField(node.getNodeValue().trim());
      if (null != uniqueKeyField.getDefaultValue()) {
        String msg=UNIQUE_KEY + " field (" + uniqueKeyFieldName+ ") can not be configured with a default value ("+ uniqueKeyField.getDefaultValue()+ ")";
        log.error(msg);
        throw new SolrException(ErrorCode.SERVER_ERROR,msg);
      }
      if (!uniqueKeyField.stored()) {
        log.warn(UNIQUE_KEY + " is not stored - distributed search and MoreLikeThis will not work");
      }
      if (uniqueKeyField.multiValued()) {
        String msg=UNIQUE_KEY + " field (" + uniqueKeyFieldName+ ") can not be configured to be multivalued";
        log.error(msg);
        throw new SolrException(ErrorCode.SERVER_ERROR,msg);
      }
      uniqueKeyFieldName=uniqueKeyField.getName();
      uniqueKeyFieldType=uniqueKeyField.getType();
      log.info("unique key field: " + uniqueKeyFieldName);
      if (Boolean.FALSE != explicitRequiredProp.get(uniqueKeyFieldName)) {
        uniqueKeyField.required=true;
        requiredFields.add(uniqueKeyField);
      }
    }
    dynamicCopyFields=new DynamicCopy[]{};
    expression="//" + COPY_FIELD;
    nodes=(NodeList)xpath.evaluate(expression,document,XPathConstants.NODESET);
    for (int i=0; i < nodes.getLength(); i++) {
      node=nodes.item(i);
      NamedNodeMap attrs=node.getAttributes();
      String source=DOMUtil.getAttr(attrs,SOURCE,COPY_FIELD + " definition");
      String dest=DOMUtil.getAttr(attrs,DESTINATION,COPY_FIELD + " definition");
      String maxChars=DOMUtil.getAttr(attrs,MAX_CHARS);
      int maxCharsInt=CopyField.UNLIMITED;
      if (maxChars != null) {
        try {
          maxCharsInt=Integer.parseInt(maxChars);
        }
 catch (        NumberFormatException e) {
          log.warn("Couldn't parse " + MAX_CHARS + " attribute for "+ COPY_FIELD+ " from "+ source+ " to "+ dest+ " as integer. The whole field will be copied.");
        }
      }
      if (dest.equals(uniqueKeyFieldName)) {
        String msg=UNIQUE_KEY + " field (" + uniqueKeyFieldName+ ") can not be the "+ DESTINATION+ " of a "+ COPY_FIELD+ "("+ SOURCE+ "="+ source+ ")";
        log.error(msg);
        throw new SolrException(ErrorCode.SERVER_ERROR,msg);
      }
      registerCopyField(source,dest,maxCharsInt);
    }
    for (    Map.Entry<SchemaField,Integer> entry : copyFieldTargetCounts.entrySet()) {
      if (entry.getValue() > 1 && !entry.getKey().multiValued()) {
        log.warn("Field " + entry.getKey().name + " is not multivalued "+ "and destination for multiple "+ COPY_FIELDS+ " ("+ entry.getValue()+ ")");
      }
    }
    for (    SchemaAware aware : schemaAware) {
      aware.inform(this);
    }
  }
 catch (  SolrException e) {
    throw e;
  }
catch (  Exception e) {
    throw new SolrException(ErrorCode.SERVER_ERROR,"Schema Parsing Failed: " + e.getMessage(),e);
  }
  refreshAnalyzers();
}
