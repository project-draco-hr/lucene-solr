{
  final SolrParams required=new RequiredSolrParams(params);
  final NamedList resOuter=new SimpleOrderedMap();
  final String[] fields=params.getParams(SolrParams.FACET_DATE);
  final Date NOW=new Date();
  if (null == fields || 0 == fields.length)   return resOuter;
  final IndexSchema schema=searcher.getSchema();
  for (  String f : fields) {
    final NamedList resInner=new SimpleOrderedMap();
    resOuter.add(f,resInner);
    final FieldType trash=schema.getFieldType(f);
    if (!(trash instanceof DateField)) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"Can not date facet on a field which is not a DateField: " + f);
    }
    final DateField ft=(DateField)trash;
    final String startS=required.getFieldParam(f,SolrParams.FACET_DATE_START);
    final Date start;
    try {
      start=ft.parseMath(NOW,startS);
    }
 catch (    SolrException e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"date facet 'start' is not a valid Date string: " + startS,e);
    }
    final String endS=required.getFieldParam(f,SolrParams.FACET_DATE_END);
    Date end;
    try {
      end=ft.parseMath(NOW,endS);
    }
 catch (    SolrException e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"date facet 'end' is not a valid Date string: " + endS,e);
    }
    if (end.before(start)) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"date facet 'end' comes before 'start': " + endS + " < "+ startS);
    }
    final String gap=required.getFieldParam(f,SolrParams.FACET_DATE_GAP);
    final DateMathParser dmp=new DateMathParser(ft.UTC,Locale.US);
    dmp.setNow(NOW);
    try {
      Date low=start;
      while (low.before(end)) {
        dmp.setNow(low);
        final String lowI=ft.toInternal(low);
        final String label=ft.indexedToReadable(lowI);
        Date high=dmp.parseMath(gap);
        if (end.before(high)) {
          if (params.getFieldBool(f,SolrParams.FACET_DATE_HARD_END,false)) {
            high=end;
          }
 else {
            end=high;
          }
        }
        if (high.before(low)) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"date facet infinite loop (is gap negative?)");
        }
        final String highI=ft.toInternal(high);
        resInner.add(label,rangeCount(f,lowI,highI,true,true));
        low=high;
      }
    }
 catch (    java.text.ParseException e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,"date facet 'gap' is not a valid Date Math string: " + gap,e);
    }
    resInner.add("gap",gap);
    resInner.add("end",end);
    final String[] othersP=params.getFieldParams(f,SolrParams.FACET_DATE_OTHER);
    if (null != othersP && 0 < othersP.length) {
      Set<FacetDateOther> others=EnumSet.noneOf(FacetDateOther.class);
      for (      final String o : othersP) {
        others.add(FacetDateOther.get(o));
      }
      if (!others.contains(FacetDateOther.NONE)) {
        final String startI=ft.toInternal(start);
        final String endI=ft.toInternal(end);
        boolean all=others.contains(FacetDateOther.ALL);
        if (all || others.contains(FacetDateOther.BEFORE)) {
          resInner.add(FacetDateOther.BEFORE.toString(),rangeCount(f,null,startI,false,false));
        }
        if (all || others.contains(FacetDateOther.AFTER)) {
          resInner.add(FacetDateOther.AFTER.toString(),rangeCount(f,endI,null,false,false));
        }
        if (all || others.contains(FacetDateOther.BETWEEN)) {
          resInner.add(FacetDateOther.BETWEEN.toString(),rangeCount(f,startI,endI,true,true));
        }
      }
    }
  }
  return resOuter;
}
