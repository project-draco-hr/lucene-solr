SUPPORTED_BITS_PER_VALUE = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 16, 21, 32]
HEADER = ('// This file has been automatically generated, DO NOT EDIT\n\npackage org.apache.lucene.util.packed;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to You under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport org.apache.lucene.store.DataInput;\nimport org.apache.lucene.util.RamUsageEstimator;\n\n/**\n * This class is similar to {@link Packed64} except that it trades space for\n * speed by ensuring that a single block needs to be read/written in order to\n * read/write a value.\n */\nabstract class Packed64SingleBlock extends PackedInts.MutableImpl {\n\n  public static final int MAX_SUPPORTED_BITS_PER_VALUE = %d;\n  private static final int[] SUPPORTED_BITS_PER_VALUE = new int[] {%s};\n\n  public static boolean isSupported(int bitsPerValue) {\n    return Arrays.binarySearch(SUPPORTED_BITS_PER_VALUE, bitsPerValue) >= 0;\n  }\n\n  private static int requiredCapacity(int valueCount, int valuesPerBlock) {\n    return valueCount / valuesPerBlock\n        + (valueCount %% valuesPerBlock == 0 ? 0 : 1);\n  }\n\n  final long[] blocks;\n\n  Packed64SingleBlock(int valueCount, int bitsPerValue) {\n    super(valueCount, bitsPerValue);\n    assert isSupported(bitsPerValue);\n    final int valuesPerBlock = 64 / bitsPerValue;\n    blocks = new long[requiredCapacity(valueCount, valuesPerBlock)];\n  }\n\n  @Override\n  public void clear() {\n    Arrays.fill(blocks, 0L);\n  }\n\n  @Override\n  public long ramBytesUsed() {\n    return RamUsageEstimator.alignObjectSize(\n        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER\n        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue\n        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // blocks ref\n        + RamUsageEstimator.sizeOf(blocks);\n  }\n\n  @Override\n  public int get(int index, long[] arr, int off, int len) {\n    assert len > 0 : "len must be > 0 (got " + len + ")";\n    assert index >= 0 && index < valueCount;\n    len = Math.min(len, valueCount - index);\n    assert off + len <= arr.length;\n\n    final int originalIndex = index;\n\n    // go to the next block boundary\n    final int valuesPerBlock = 64 / bitsPerValue;\n    final int offsetInBlock = index %% valuesPerBlock;\n    if (offsetInBlock != 0) {\n      for (int i = offsetInBlock; i < valuesPerBlock && len > 0; ++i) {\n        arr[off++] = get(index++);\n        --len;\n      }\n      if (len == 0) {\n        return index - originalIndex;\n      }\n    }\n\n    // bulk get\n    assert index %% valuesPerBlock == 0;\n    final PackedInts.Decoder decoder = BulkOperation.of(PackedInts.Format.PACKED_SINGLE_BLOCK, bitsPerValue);\n    assert decoder.longBlockCount() == 1;\n    assert decoder.longValueCount() == valuesPerBlock;\n    final int blockIndex = index / valuesPerBlock;\n    final int nblocks = (index + len) / valuesPerBlock - blockIndex;\n    decoder.decode(blocks, blockIndex, arr, off, nblocks);\n    final int diff = nblocks * valuesPerBlock;\n    index += diff; len -= diff;\n\n    if (index > originalIndex) {\n      // stay at the block boundary\n      return index - originalIndex;\n    } else {\n      // no progress so far => already at a block boundary but no full block to\n      // get\n      assert index == originalIndex;\n      return super.get(index, arr, off, len);\n    }\n  }\n\n  @Override\n  public int set(int index, long[] arr, int off, int len) {\n    assert len > 0 : "len must be > 0 (got " + len + ")";\n    assert index >= 0 && index < valueCount;\n    len = Math.min(len, valueCount - index);\n    assert off + len <= arr.length;\n\n    final int originalIndex = index;\n\n    // go to the next block boundary\n    final int valuesPerBlock = 64 / bitsPerValue;\n    final int offsetInBlock = index %% valuesPerBlock;\n    if (offsetInBlock != 0) {\n      for (int i = offsetInBlock; i < valuesPerBlock && len > 0; ++i) {\n        set(index++, arr[off++]);\n        --len;\n      }\n      if (len == 0) {\n        return index - originalIndex;\n      }\n    }\n\n    // bulk set\n    assert index %% valuesPerBlock == 0;\n    final BulkOperation op = BulkOperation.of(PackedInts.Format.PACKED_SINGLE_BLOCK, bitsPerValue);\n    assert op.longBlockCount() == 1;\n    assert op.longValueCount() == valuesPerBlock;\n    final int blockIndex = index / valuesPerBlock;\n    final int nblocks = (index + len) / valuesPerBlock - blockIndex;\n    op.encode(arr, off, blocks, blockIndex, nblocks);\n    final int diff = nblocks * valuesPerBlock;\n    index += diff; len -= diff;\n\n    if (index > originalIndex) {\n      // stay at the block boundary\n      return index - originalIndex;\n    } else {\n      // no progress so far => already at a block boundary but no full block to\n      // set\n      assert index == originalIndex;\n      return super.set(index, arr, off, len);\n    }\n  }\n\n  @Override\n  public void fill(int fromIndex, int toIndex, long val) {\n    assert fromIndex >= 0;\n    assert fromIndex <= toIndex;\n    assert PackedInts.unsignedBitsRequired(val) <= bitsPerValue;\n\n    final int valuesPerBlock = 64 / bitsPerValue;\n    if (toIndex - fromIndex <= valuesPerBlock << 1) {\n      // there needs to be at least one full block to set for the block\n      // approach to be worth trying\n      super.fill(fromIndex, toIndex, val);\n      return;\n    }\n\n    // set values naively until the next block start\n    int fromOffsetInBlock = fromIndex %% valuesPerBlock;\n    if (fromOffsetInBlock != 0) {\n      for (int i = fromOffsetInBlock; i < valuesPerBlock; ++i) {\n        set(fromIndex++, val);\n      }\n      assert fromIndex %% valuesPerBlock == 0;\n    }\n\n    // bulk set of the inner blocks\n    final int fromBlock = fromIndex / valuesPerBlock;\n    final int toBlock = toIndex / valuesPerBlock;\n    assert fromBlock * valuesPerBlock == fromIndex;\n\n    long blockValue = 0L;\n    for (int i = 0; i < valuesPerBlock; ++i) {\n      blockValue = blockValue | (val << (i * bitsPerValue));\n    }\n    Arrays.fill(blocks, fromBlock, toBlock, blockValue);\n\n    // fill the gap\n    for (int i = valuesPerBlock * toBlock; i < toIndex; ++i) {\n      set(i, val);\n    }\n  }\n\n  @Override\n  protected PackedInts.Format getFormat() {\n    return PackedInts.Format.PACKED_SINGLE_BLOCK;\n  }\n\n  @Override\n  public String toString() {\n    return getClass().getSimpleName() + "(bitsPerValue=" + bitsPerValue\n        + ",size=" + size() + ",blocks=" + blocks.length + ")";\n  }\n\n  public static Packed64SingleBlock create(DataInput in,\n      int valueCount, int bitsPerValue) throws IOException {\n    Packed64SingleBlock reader = create(valueCount, bitsPerValue);\n    for (int i = 0; i < reader.blocks.length; ++i) {\n      reader.blocks[i] = in.readLong();\n    }\n    return reader;\n  }\n\n' % (SUPPORTED_BITS_PER_VALUE[(-1)], ', '.join(map(str, SUPPORTED_BITS_PER_VALUE))))
FOOTER = '}'
if (__name__ == '__main__'):
    f = open('Packed64SingleBlock.java', 'w')
    f.write(HEADER)
    f.write('  public static Packed64SingleBlock create(int valueCount, int bitsPerValue) {\n')
    f.write('    switch (bitsPerValue) {\n')
    for bpv in SUPPORTED_BITS_PER_VALUE:
        f.write(('      case %d:\n' % bpv))
        f.write(('        return new Packed64SingleBlock%d(valueCount);\n' % bpv))
    f.write('      default:\n')
    f.write(('        throw new IllegalArgumentException("Unsupported number of bits per value: " + %d);\n' % bpv))
    f.write('    }\n')
    f.write('  }\n\n')
    for bpv in SUPPORTED_BITS_PER_VALUE:
        log_2 = 0
        while ((1 << log_2) < bpv):
            log_2 = (log_2 + 1)
        if ((1 << log_2) != bpv):
            log_2 = None
        f.write(('  static class Packed64SingleBlock%d extends Packed64SingleBlock {\n\n' % bpv))
        f.write(('    Packed64SingleBlock%d(int valueCount) {\n' % bpv))
        f.write(('      super(valueCount, %d);\n' % bpv))
        f.write('    }\n\n')
        f.write('    @Override\n')
        f.write('    public long get(int index) {\n')
        if (log_2 is not None):
            f.write(('      final int o = index >>> %d;\n' % (6 - log_2)))
            f.write(('      final int b = index & %d;\n' % ((1 << (6 - log_2)) - 1)))
            f.write(('      final int shift = b << %d;\n' % log_2))
        else:
            f.write(('      final int o = index / %d;\n' % (64 / bpv)))
            f.write(('      final int b = index %% %d;\n' % (64 / bpv)))
            f.write(('      final int shift = b * %d;\n' % bpv))
        f.write(('      return (blocks[o] >>> shift) & %dL;\n' % ((1 << bpv) - 1)))
        f.write('    }\n\n')
        f.write('    @Override\n')
        f.write('    public void set(int index, long value) {\n')
        if (log_2 is not None):
            f.write(('      final int o = index >>> %d;\n' % (6 - log_2)))
            f.write(('      final int b = index & %d;\n' % ((1 << (6 - log_2)) - 1)))
            f.write(('      final int shift = b << %d;\n' % log_2))
        else:
            f.write(('      final int o = index / %d;\n' % (64 / bpv)))
            f.write(('      final int b = index %% %d;\n' % (64 / bpv)))
            f.write(('      final int shift = b * %d;\n' % bpv))
        f.write(('      blocks[o] = (blocks[o] & ~(%dL << shift)) | (value << shift);\n' % ((1 << bpv) - 1)))
        f.write('    }\n\n')
        f.write('  }\n\n')
    f.write(FOOTER)
    f.close()
