{
  String metaName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,metaExtension);
  this.maxDoc=state.segmentInfo.getDocCount();
  merging=false;
  int version=-1;
  int numFields=-1;
  try (ChecksumIndexInput in=state.directory.openChecksumInput(metaName,state.context)){
    Throwable priorE=null;
    try {
      version=CodecUtil.checkHeader(in,metaCodec,Lucene49DocValuesFormat.VERSION_START,Lucene49DocValuesFormat.VERSION_CURRENT);
      numFields=readFields(in,state.fieldInfos);
    }
 catch (    Throwable exception) {
      priorE=exception;
    }
 finally {
      CodecUtil.checkFooter(in,priorE);
    }
  }
   this.numFields=numFields;
  String dataName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,dataExtension);
  this.data=state.directory.openInput(dataName,state.context);
  boolean success=false;
  try {
    final int version2=CodecUtil.checkHeader(data,dataCodec,Lucene49DocValuesFormat.VERSION_START,Lucene49DocValuesFormat.VERSION_CURRENT);
    if (version != version2) {
      throw new CorruptIndexException("Format versions mismatch: meta=" + version + ", data="+ version2,data);
    }
    CodecUtil.retrieveChecksum(data);
    success=true;
  }
  finally {
    if (!success) {
      IOUtils.closeWhileHandlingException(this.data);
    }
  }
  ramBytesUsed=new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));
}
