{
  if (terms.size() == 0)   return null;
  DocsAndPositionsEnum[] postings=new DocsAndPositionsEnum[terms.size()];
  final Bits delDocs=MultiFields.getDeletedDocs(reader);
  for (int i=0; i < terms.size(); i++) {
    final Term t=terms.get(i);
    final BytesRef text=new BytesRef(t.text());
    DocsAndPositionsEnum postingsEnum=MultiFields.getTermPositionsEnum(reader,delDocs,t.field(),text);
    if (postingsEnum == null) {
      if (MultiFields.getTermDocsEnum(reader,delDocs,t.field(),text) != null) {
        throw new IllegalStateException("field \"" + t.field() + "\" was indexed with Field.omitTermFreqAndPositions=true; cannot run PhraseQuery (term="+ t.text()+ ")");
      }
 else {
        return null;
      }
    }
    postings[i]=postingsEnum;
  }
  if (slop == 0)   return new ExactPhraseScorer(this,postings,getPositions(),similarity,reader.norms(field));
 else   return new SloppyPhraseScorer(this,postings,getPositions(),similarity,slop,reader.norms(field));
}
