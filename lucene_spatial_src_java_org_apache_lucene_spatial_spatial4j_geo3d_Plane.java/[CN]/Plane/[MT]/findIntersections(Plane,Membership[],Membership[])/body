{
  Vector lineVector=new Vector(this,q);
  if (lineVector.x == 0.0 && lineVector.y == 0.0 && lineVector.z == 0.0) {
    return new GeoPoint[0];
  }
  double x0;
  double y0;
  double z0;
  double denomYZ=this.y * q.z - this.z * q.y;
  double denomXZ=this.x * q.z - this.z * q.x;
  double denomXY=this.x * q.y - this.y * q.x;
  if (Math.abs(denomYZ) >= Math.abs(denomXZ) && Math.abs(denomYZ) >= Math.abs(denomXY)) {
    if (Math.abs(denomYZ) < 1.0e-35)     return new GeoPoint[0];
    double denom=1.0 / denomYZ;
    x0=0.0;
    y0=(-this.D * q.z - this.z * -q.D) * denom;
    z0=(this.y * -q.D + this.D * q.y) * denom;
  }
 else   if (Math.abs(denomXZ) >= Math.abs(denomXY) && Math.abs(denomXZ) >= Math.abs(denomYZ)) {
    if (Math.abs(denomXZ) < 1.0e-35)     return new GeoPoint[0];
    double denom=1.0 / denomXZ;
    x0=(-this.D * q.z - this.z * -q.D) * denom;
    y0=0.0;
    z0=(this.x * -q.D + this.D * q.x) * denom;
  }
 else {
    if (Math.abs(denomXY) < 1.0e-35)     return new GeoPoint[0];
    double denom=1.0 / denomXY;
    x0=(-this.D * q.y - this.y * -q.D) * denom;
    y0=(this.x * -q.D + this.D * q.x) * denom;
    z0=0.0;
  }
  double A=lineVector.x * lineVector.x + lineVector.y * lineVector.y + lineVector.z * lineVector.z;
  double B=2.0 * (lineVector.x * x0 + lineVector.y * y0 + lineVector.z * z0);
  double C=x0 * x0 + y0 * y0 + z0 * z0 - 1.0;
  double BsquaredMinus=B * B - 4.0 * A * C;
  if (BsquaredMinus < 0.0)   return new GeoPoint[0];
  double inverse2A=1.0 / (2.0 * A);
  if (BsquaredMinus == 0.0) {
    double t=-B * inverse2A;
    GeoPoint point=new GeoPoint(lineVector.x * t + x0,lineVector.y * t + y0,lineVector.z * t + z0);
    if (point.isWithin(bounds,moreBounds))     return new GeoPoint[]{point};
    return new GeoPoint[0];
  }
 else {
    double sqrtTerm=Math.sqrt(BsquaredMinus);
    double t1=(-B + sqrtTerm) * inverse2A;
    double t2=(-B - sqrtTerm) * inverse2A;
    GeoPoint point1=new GeoPoint(lineVector.x * t1 + x0,lineVector.y * t1 + y0,lineVector.z * t1 + z0);
    GeoPoint point2=new GeoPoint(lineVector.x * t2 + x0,lineVector.y * t2 + y0,lineVector.z * t2 + z0);
    if (point1.isWithin(bounds,moreBounds)) {
      if (point2.isWithin(bounds,moreBounds))       return new GeoPoint[]{point1,point2};
      return new GeoPoint[]{point1};
    }
    if (point2.isWithin(bounds,moreBounds))     return new GeoPoint[]{point2};
    return new GeoPoint[0];
  }
}
