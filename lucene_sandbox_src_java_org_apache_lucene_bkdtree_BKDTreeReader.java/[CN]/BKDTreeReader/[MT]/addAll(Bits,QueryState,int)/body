{
  if (nodeID >= leafNodeOffset) {
    long fp=leafBlockFPs[nodeID - leafNodeOffset];
    if (fp == 0) {
      return 0;
    }
    state.in.seek(fp);
    int count=state.in.readVInt();
    if (state.latLonFilter != null) {
      int hitCount=0;
      for (int i=0; i < count; i++) {
        int docID=state.in.readInt();
        if (acceptDocs == null || acceptDocs.get(docID)) {
          state.sndv.setDocument(docID);
          int docValueCount=state.sndv.count();
          for (int j=0; j < docValueCount; j++) {
            long enc=state.sndv.valueAt(j);
            int latEnc=(int)((enc >> 32) & 0xffffffffL);
            int lonEnc=(int)(enc & 0xffffffffL);
            if (state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc),BKDTreeWriter.decodeLon(lonEnc))) {
              state.bits.set(docID);
              hitCount++;
              break;
            }
          }
        }
      }
      return hitCount;
    }
 else     if (acceptDocs != null) {
      for (int i=0; i < count; i++) {
        int docID=state.in.readInt();
        if (acceptDocs.get(docID)) {
          state.bits.set(docID);
        }
      }
    }
 else {
      for (int i=0; i < count; i++) {
        int docID=state.in.readInt();
        state.bits.set(docID);
      }
    }
    return count;
  }
 else {
    int splitValue=splitValues[nodeID];
    if (splitValue == Integer.MAX_VALUE) {
      return 0;
    }
    int count=0;
    count+=addAll(acceptDocs,state,2 * nodeID);
    count+=addAll(acceptDocs,state,2 * nodeID + 1);
    return count;
  }
}
