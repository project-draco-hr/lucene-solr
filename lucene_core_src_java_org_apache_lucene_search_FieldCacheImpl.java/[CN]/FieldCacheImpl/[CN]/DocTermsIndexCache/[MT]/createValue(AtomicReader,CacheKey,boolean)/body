{
  final int maxDoc=reader.maxDoc();
  SortedDocValues valuesIn=reader.getSortedDocValues(key.field);
  if (valuesIn != null) {
    final SortedDocValues ramInstance=valuesIn.newRAMInstance();
    return new DocTermsIndex(){
      @Override public BytesRef lookup(      int ord,      BytesRef reuse){
        ramInstance.lookupOrd(ord,reuse);
        return reuse;
      }
      @Override public int getOrd(      int docID){
        return ramInstance.getOrd(docID);
      }
      @Override public int numOrd(){
        return ramInstance.getValueCount();
      }
      @Override public int size(){
        return ramInstance.size();
      }
      @Override public TermsEnum getTermsEnum(){
        return null;
      }
      @Override public Reader getDocToOrd(){
        return null;
      }
    }
;
  }
 else {
    Terms terms=reader.terms(key.field);
    final float acceptableOverheadRatio=((Float)key.custom).floatValue();
    final PagedBytes bytes=new PagedBytes(15);
    int startBytesBPV;
    int startTermsBPV;
    int startNumUniqueTerms;
    final int termCountHardLimit;
    if (maxDoc == Integer.MAX_VALUE) {
      termCountHardLimit=Integer.MAX_VALUE;
    }
 else {
      termCountHardLimit=maxDoc + 1;
    }
    if (terms != null) {
      long numUniqueTerms=terms.size();
      if (numUniqueTerms != -1L) {
        if (numUniqueTerms > termCountHardLimit) {
          numUniqueTerms=termCountHardLimit;
        }
        startBytesBPV=PackedInts.bitsRequired(numUniqueTerms * 4);
        startTermsBPV=PackedInts.bitsRequired(numUniqueTerms);
        startNumUniqueTerms=(int)numUniqueTerms;
      }
 else {
        startBytesBPV=1;
        startTermsBPV=1;
        startNumUniqueTerms=1;
      }
    }
 else {
      startBytesBPV=1;
      startTermsBPV=1;
      startNumUniqueTerms=1;
    }
    GrowableWriter termOrdToBytesOffset=new GrowableWriter(startBytesBPV,1 + startNumUniqueTerms,acceptableOverheadRatio);
    final GrowableWriter docToTermOrd=new GrowableWriter(startTermsBPV,maxDoc,acceptableOverheadRatio);
    bytes.copyUsingLengthPrefix(new BytesRef());
    int termOrd=1;
    if (terms != null) {
      final TermsEnum termsEnum=terms.iterator(null);
      DocsEnum docs=null;
      while (true) {
        final BytesRef term=termsEnum.next();
        if (term == null) {
          break;
        }
        if (termOrd >= termCountHardLimit) {
          break;
        }
        if (termOrd == termOrdToBytesOffset.size()) {
          termOrdToBytesOffset=termOrdToBytesOffset.resize(ArrayUtil.oversize(1 + termOrd,1));
        }
        termOrdToBytesOffset.set(termOrd,bytes.copyUsingLengthPrefix(term));
        docs=termsEnum.docs(null,docs,0);
        while (true) {
          final int docID=docs.nextDoc();
          if (docID == DocIdSetIterator.NO_MORE_DOCS) {
            break;
          }
          docToTermOrd.set(docID,termOrd);
        }
        termOrd++;
      }
      if (termOrdToBytesOffset.size() > termOrd) {
        termOrdToBytesOffset=termOrdToBytesOffset.resize(termOrd);
      }
    }
    return new DocTermsIndexImpl(bytes.freeze(true),termOrdToBytesOffset.getMutable(),docToTermOrd.getMutable(),termOrd);
  }
}
