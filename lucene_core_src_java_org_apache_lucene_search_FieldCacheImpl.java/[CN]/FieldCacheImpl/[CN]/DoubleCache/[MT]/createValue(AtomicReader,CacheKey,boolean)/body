{
  int maxDoc=reader.maxDoc();
  final double[] values;
  NumericDocValues valuesIn=reader.getNumericDocValues(key.field);
  if (valuesIn != null) {
    values=new double[maxDoc];
    for (int docID=0; docID < maxDoc; docID++) {
      values[docID]=Double.longBitsToDouble(valuesIn.get(docID));
    }
  }
 else {
    final DoubleParser parser=(DoubleParser)key.custom;
    if (parser == null) {
      try {
        return wrapper.getDoubles(reader,key.field,DEFAULT_DOUBLE_PARSER,setDocsWithField);
      }
 catch (      NumberFormatException ne) {
        return wrapper.getDoubles(reader,key.field,NUMERIC_UTILS_DOUBLE_PARSER,setDocsWithField);
      }
    }
    values=new double[reader.maxDoc()];
    Uninvert u=new Uninvert(){
      private double currentValue;
      @Override public void visitTerm(      BytesRef term){
        currentValue=parser.parseDouble(term);
      }
      @Override public void visitDoc(      int docID){
        values[docID]=currentValue;
      }
    }
;
    u.uninvert(reader,key.field,setDocsWithField);
    if (setDocsWithField) {
      wrapper.setDocsWithField(reader,key.field,u.docsWithField);
    }
  }
  return new DoublesFromArray(values);
}
