{
  Directory dir=newDirectory();
  final AtomicBoolean mayMerge=new AtomicBoolean(true);
  final MergeScheduler mergeScheduler=new SerialMergeScheduler(){
    @Override synchronized public void merge(    IndexWriter writer,    MergeTrigger trigger,    boolean newMergesFound) throws IOException {
      if (!mayMerge.get() && writer.getNextMerge() != null) {
        throw new AssertionError();
      }
      super.merge(writer,trigger,newMergesFound);
    }
  }
;
  IndexWriter writer=new IndexWriter(dir,newIndexWriterConfig(new MockAnalyzer(random())).setMergeScheduler(mergeScheduler).setMergePolicy(mergePolicy()));
  writer.getConfig().getMergePolicy().setNoCFSRatio(random().nextBoolean() ? 0 : 1);
  final int numSegments=TestUtil.nextInt(random(),2,20);
  for (int i=0; i < numSegments; ++i) {
    final int numDocs=TestUtil.nextInt(random(),1,5);
    for (int j=0; j < numDocs; ++j) {
      writer.addDocument(new Document());
    }
    writer.getReader().close();
  }
  for (int i=5; i >= 0; --i) {
    final int segmentCount=writer.getSegmentCount();
    final int maxNumSegments=i == 0 ? 1 : TestUtil.nextInt(random(),1,10);
    mayMerge.set(segmentCount > maxNumSegments);
    writer.forceMerge(maxNumSegments);
  }
  writer.shutdown();
  dir.close();
}
