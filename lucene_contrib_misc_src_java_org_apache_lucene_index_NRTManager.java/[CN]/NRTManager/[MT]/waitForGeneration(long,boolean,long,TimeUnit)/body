{
  try {
    reopenLock.lockInterruptibly();
    try {
      if (targetGen > getCurrentSearchingGen(requireDeletes)) {
        for (        WaitingListener listener : waitingListeners) {
          listener.waiting(requireDeletes,targetGen);
        }
        while (targetGen > getCurrentSearchingGen(requireDeletes)) {
          if (!waitOnGenCondition(time,unit)) {
            return getSearcherManager(requireDeletes);
          }
        }
      }
    }
  finally {
      reopenLock.unlock();
    }
  }
 catch (  InterruptedException ie) {
    throw new ThreadInterruptedException(ie);
  }
  return getSearcherManager(requireDeletes);
}
