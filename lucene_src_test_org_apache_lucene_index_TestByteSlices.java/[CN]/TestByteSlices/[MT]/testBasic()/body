{
  ByteBlockPool pool=new ByteBlockPool(new ByteBlockAllocator());
  final int NUM_STREAM=25;
  ByteSliceWriter writer=new ByteSliceWriter(pool);
  int[] starts=new int[NUM_STREAM];
  int[] uptos=new int[NUM_STREAM];
  int[] counters=new int[NUM_STREAM];
  Random r=newRandom();
  ByteSliceReader reader=new ByteSliceReader();
  for (int ti=0; ti < 100; ti++) {
    for (int stream=0; stream < NUM_STREAM; stream++) {
      starts[stream]=-1;
      counters[stream]=0;
    }
    for (int iter=0; iter < 10000 * _TestUtil.getRandomMultiplier(); iter++) {
      int stream=r.nextInt(NUM_STREAM);
      if (VERBOSE)       System.out.println("write stream=" + stream);
      if (starts[stream] == -1) {
        final int spot=pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);
        starts[stream]=uptos[stream]=spot + pool.byteOffset;
        if (VERBOSE)         System.out.println("  init to " + starts[stream]);
      }
      writer.init(uptos[stream]);
      int numValue=r.nextInt(20);
      for (int j=0; j < numValue; j++) {
        if (VERBOSE)         System.out.println("    write " + (counters[stream] + j));
        writer.writeVInt(counters[stream] + j);
      }
      counters[stream]+=numValue;
      uptos[stream]=writer.getAddress();
      if (VERBOSE)       System.out.println("    addr now " + uptos[stream]);
    }
    for (int stream=0; stream < NUM_STREAM; stream++) {
      if (VERBOSE)       System.out.println("  stream=" + stream + " count="+ counters[stream]);
      if (starts[stream] != uptos[stream]) {
        reader.init(pool,starts[stream],uptos[stream]);
        for (int j=0; j < counters[stream]; j++)         assertEquals(j,reader.readVInt());
      }
    }
    pool.reset();
  }
}
