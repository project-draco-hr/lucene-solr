{
  final int numTerms=1 + this.nextInt(NUM_TERMS_RAND);
  final TermData[] terms=new TermData[numTerms];
  final HashSet<String> termsSeen=new HashSet<String>();
  for (int i=0; i < numTerms; i++) {
    char[] text;
    String text2;
    while (true) {
      text=this.getRandomText();
      text2=new String(text,0,text.length - 1);
      if (!termsSeen.contains(text2)) {
        termsSeen.add(text2);
        break;
      }
    }
    final int docFreq=1 + this.nextInt(DOC_FREQ_RAND);
    final int[] docs=new int[docFreq];
    PositionData[][] positions;
    if (!omitTF)     positions=new PositionData[docFreq][];
 else     positions=null;
    int docID=0;
    for (int j=0; j < docFreq; j++) {
      docID+=this.nextInt(1,10);
      docs[j]=docID;
      if (!omitTF) {
        final int termFreq=1 + this.nextInt(TERM_DOC_FREQ_RAND);
        positions[j]=new PositionData[termFreq];
        int position=0;
        for (int k=0; k < termFreq; k++) {
          position+=this.nextInt(1,10);
          final BytesRef payload;
          if (storePayloads && this.nextInt(4) == 0) {
            final byte[] bytes=new byte[1 + this.nextInt(5)];
            for (int l=0; l < bytes.length; l++) {
              bytes[l]=(byte)this.nextInt(255);
            }
            payload=new BytesRef(bytes);
          }
 else {
            payload=null;
          }
          positions[j][k]=new PositionData(position,payload);
        }
      }
    }
    terms[i]=new TermData(text2,docs,positions);
  }
  return terms;
}
