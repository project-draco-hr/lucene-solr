{
  DocValues.Type[] values=DocValues.Type.values();
  DocValues.Type type=values[random.nextInt(values.length)];
  String name="random_" + type.name() + ""+ docValuesFieldPrefix;
  if ("Lucene3x".equals(codec.getName()) || doc.getField(name) != null)   return;
  FieldType ft=new FieldType();
  ft.setDocValueType(type);
  ft.freeze();
  final Field f;
switch (type) {
case BYTES_FIXED_DEREF:
case BYTES_FIXED_STRAIGHT:
case BYTES_FIXED_SORTED:
    final String randomUnicodeString=_TestUtil.randomFixedByteLengthUnicodeString(random,fixedBytesLength);
  BytesRef fixedRef=new BytesRef(randomUnicodeString);
if (fixedRef.length > fixedBytesLength) {
  fixedRef=new BytesRef(fixedRef.bytes,0,fixedBytesLength);
}
 else {
  fixedRef.grow(fixedBytesLength);
  fixedRef.length=fixedBytesLength;
}
f=new Field(name,fixedRef,ft);
break;
case BYTES_VAR_DEREF:
case BYTES_VAR_STRAIGHT:
case BYTES_VAR_SORTED:
f=new Field(name,new BytesRef(_TestUtil.randomUnicodeString(random,200)),ft);
break;
case FLOAT_32:
f=new Field(name,random.nextFloat(),ft);
break;
case FLOAT_64:
f=new Field(name,random.nextDouble(),ft);
break;
case VAR_INTS:
f=new Field(name,random.nextLong(),ft);
break;
case FIXED_INTS_16:
f=new Field(name,random.nextInt(Short.MAX_VALUE),ft);
break;
case FIXED_INTS_32:
f=new Field(name,random.nextInt(),ft);
break;
case FIXED_INTS_64:
f=new Field(name,random.nextLong(),ft);
break;
case FIXED_INTS_8:
f=new Field(name,random.nextInt(128),ft);
break;
default :
throw new IllegalArgumentException("no such type: " + type);
}
doc.add(f);
}
