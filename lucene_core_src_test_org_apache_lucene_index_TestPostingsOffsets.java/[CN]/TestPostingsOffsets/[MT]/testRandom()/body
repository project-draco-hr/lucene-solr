{
  final Map<String,Map<Integer,List<Token>>> actualTokens=new HashMap<String,Map<Integer,List<Token>>>();
  Directory dir=newDirectory();
  RandomIndexWriter w=new RandomIndexWriter(random(),dir,iwc);
  final int numDocs=atLeast(20);
  FieldType ft=new FieldType(TextField.TYPE_NOT_STORED);
  ft.setIndexOptions(FieldInfo.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
  if (random().nextBoolean()) {
    ft.setStoreTermVectors(true);
    ft.setStoreTermVectorOffsets(random().nextBoolean());
    ft.setStoreTermVectorPositions(random().nextBoolean());
  }
  for (int docCount=0; docCount < numDocs; docCount++) {
    Document doc=new Document();
    doc.add(new IntField("id",docCount,Field.Store.NO));
    List<Token> tokens=new ArrayList<Token>();
    final int numTokens=atLeast(100);
    int pos=-1;
    int offset=0;
    for (int tokenCount=0; tokenCount < numTokens; tokenCount++) {
      final String text;
      if (random().nextBoolean()) {
        text="a";
      }
 else       if (random().nextBoolean()) {
        text="b";
      }
 else       if (random().nextBoolean()) {
        text="c";
      }
 else {
        text="d";
      }
      int posIncr=random().nextBoolean() ? 1 : random().nextInt(5);
      if (tokenCount == 0 && posIncr == 0) {
        posIncr=1;
      }
      final int offIncr=random().nextBoolean() ? 0 : random().nextInt(5);
      final int tokenOffset=random().nextInt(5);
      final Token token=makeToken(text,posIncr,offset + offIncr,offset + offIncr + tokenOffset);
      if (!actualTokens.containsKey(text)) {
        actualTokens.put(text,new HashMap<Integer,List<Token>>());
      }
      final Map<Integer,List<Token>> postingsByDoc=actualTokens.get(text);
      if (!postingsByDoc.containsKey(docCount)) {
        postingsByDoc.put(docCount,new ArrayList<Token>());
      }
      postingsByDoc.get(docCount).add(token);
      tokens.add(token);
      pos+=posIncr;
      token.setType("" + pos);
      offset+=offIncr + tokenOffset;
    }
    doc.add(new Field("content",new CannedTokenStream(tokens.toArray(new Token[tokens.size()])),ft));
    w.addDocument(doc);
  }
  final DirectoryReader r=w.getReader();
  w.close();
  final String[] terms=new String[]{"a","b","c","d"};
  for (  AtomicReaderContext ctx : r.leaves()) {
    AtomicReader sub=ctx.reader();
    final TermsEnum termsEnum=sub.fields().terms("content").iterator(null);
    DocsEnum docs=null;
    DocsAndPositionsEnum docsAndPositions=null;
    DocsAndPositionsEnum docsAndPositionsAndOffsets=null;
    final int docIDToID[]=FieldCache.DEFAULT.getInts(sub,"id",false);
    for (    String term : terms) {
      if (termsEnum.seekExact(new BytesRef(term),random().nextBoolean())) {
        docs=termsEnum.docs(null,docs);
        assertNotNull(docs);
        int doc;
        while ((doc=docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          final List<Token> expected=actualTokens.get(term).get(docIDToID[doc]);
          assertNotNull(expected);
          assertEquals(expected.size(),docs.freq());
        }
        docsAndPositions=termsEnum.docsAndPositions(null,docsAndPositions,DocsAndPositionsEnum.FLAG_PAYLOADS);
        assertNotNull(docsAndPositions);
        while ((doc=docsAndPositions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          final List<Token> expected=actualTokens.get(term).get(docIDToID[doc]);
          assertNotNull(expected);
          assertEquals(expected.size(),docsAndPositions.freq());
          for (          Token token : expected) {
            int pos=Integer.parseInt(token.type());
            assertEquals(pos,docsAndPositions.nextPosition());
          }
        }
        docsAndPositionsAndOffsets=termsEnum.docsAndPositions(null,docsAndPositions);
        assertNotNull(docsAndPositionsAndOffsets);
        while ((doc=docsAndPositionsAndOffsets.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          final List<Token> expected=actualTokens.get(term).get(docIDToID[doc]);
          assertNotNull(expected);
          assertEquals(expected.size(),docsAndPositionsAndOffsets.freq());
          for (          Token token : expected) {
            int pos=Integer.parseInt(token.type());
            assertEquals(pos,docsAndPositionsAndOffsets.nextPosition());
            assertEquals(token.startOffset(),docsAndPositionsAndOffsets.startOffset());
            assertEquals(token.endOffset(),docsAndPositionsAndOffsets.endOffset());
          }
        }
      }
    }
  }
  r.close();
  dir.close();
}
