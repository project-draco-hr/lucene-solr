{
  final IndexReader[] subs=reader.getSequentialSubReaders();
  if (readers.isEmpty()) {
    this.maxDoc=reader.maxDoc();
    this.numDocs=reader.numDocs();
    childSizes=new int[subs.length];
    for (int i=0; i < subs.length; i++) {
      childSizes[i]=subs[i].maxDoc();
    }
    final AtomicReaderContext[] leaves=reader.getTopReaderContext().leaves();
    leaveSizes=new int[leaves.length];
    for (int i=0; i < leaves.length; i++) {
      leaveSizes[i]=leaves[i].reader().maxDoc();
    }
  }
 else {
    if (reader.maxDoc() != maxDoc)     throw new IllegalArgumentException("All readers must have same maxDoc: " + maxDoc + "!="+ reader.maxDoc());
    if (reader.numDocs() != numDocs)     throw new IllegalArgumentException("All readers must have same numDocs: " + numDocs + "!="+ reader.numDocs());
    if (subs.length != childSizes.length)     throw new IllegalArgumentException("All readers must have same number of subReaders");
    for (int i=0; i < subs.length; i++) {
      if (subs[i].maxDoc() != childSizes[i])       throw new IllegalArgumentException("All readers must have same subReader maxDoc");
    }
    final AtomicReaderContext[] leaves=reader.getTopReaderContext().leaves();
    if (leaves.length != leaveSizes.length)     throw new IllegalArgumentException("All readers must have same number of atomic leaves");
    for (int i=0; i < leaves.length; i++) {
      if (leaves[i].reader().maxDoc() != leaveSizes[i])       throw new IllegalArgumentException("All readers must have atomic leaves with same maxDoc");
    }
  }
  ignoreStoredFieldsSet.set(readers.size(),ignoreStoredFields);
  readers.add(reader);
  return this;
}
