{
  Directory dir=newDirectory();
  final Random random=random();
  IndexWriterConfig conf=newIndexWriterConfig(new MockAnalyzer(random));
  LogMergePolicy lmp=newLogMergePolicy();
  lmp.setMergeFactor(3);
  conf.setMergePolicy(lmp);
  IndexWriter writer=new IndexWriter(dir,conf);
  final boolean isNRT=random.nextBoolean();
  DirectoryReader reader;
  if (isNRT) {
    reader=DirectoryReader.open(writer,true);
  }
 else {
    writer.commit();
    reader=DirectoryReader.open(dir);
  }
  final int numFields=random.nextInt(4) + 3;
  final int numNDVFields=random.nextInt(numFields / 2) + 1;
  final long[] fieldValues=new long[numFields];
  for (int i=0; i < fieldValues.length; i++) {
    fieldValues[i]=1;
  }
  int numRounds=atLeast(15);
  int docID=0;
  for (int i=0; i < numRounds; i++) {
    int numDocs=atLeast(5);
    for (int j=0; j < numDocs; j++) {
      Document doc=new Document();
      doc.add(new StringField("id","doc-" + docID,Store.NO));
      doc.add(new StringField("key","all",Store.NO));
      for (int f=0; f < fieldValues.length; f++) {
        if (f < numNDVFields) {
          doc.add(new NumericDocValuesField("f" + f,fieldValues[f]));
        }
 else {
          doc.add(new BinaryDocValuesField("f" + f,TestBinaryDocValuesUpdates.toBytes(fieldValues[f])));
        }
      }
      writer.addDocument(doc);
      ++docID;
    }
    int fieldIdx=random.nextInt(fieldValues.length);
    String updateField="f" + fieldIdx;
    if (fieldIdx < numNDVFields) {
      writer.updateNumericDocValue(new Term("key","all"),updateField,++fieldValues[fieldIdx]);
    }
 else {
      writer.updateBinaryDocValue(new Term("key","all"),updateField,TestBinaryDocValuesUpdates.toBytes(++fieldValues[fieldIdx]));
    }
    if (random.nextDouble() < 0.2) {
      int deleteDoc=random.nextInt(docID);
      writer.deleteDocuments(new Term("id","doc-" + deleteDoc));
    }
    if (!isNRT) {
      writer.commit();
    }
    DirectoryReader newReader=DirectoryReader.openIfChanged(reader);
    assertNotNull(newReader);
    reader.close();
    reader=newReader;
    assertTrue(reader.numDocs() > 0);
    for (    AtomicReaderContext context : reader.leaves()) {
      AtomicReader r=context.reader();
      Bits liveDocs=r.getLiveDocs();
      for (int field=0; field < fieldValues.length; field++) {
        String f="f" + field;
        BinaryDocValues bdv=r.getBinaryDocValues(f);
        NumericDocValues ndv=r.getNumericDocValues(f);
        Bits docsWithField=r.getDocsWithField(f);
        if (field < numNDVFields) {
          assertNotNull(ndv);
          assertNull(bdv);
        }
 else {
          assertNull(ndv);
          assertNotNull(bdv);
        }
        int maxDoc=r.maxDoc();
        for (int doc=0; doc < maxDoc; doc++) {
          if (liveDocs == null || liveDocs.get(doc)) {
            assertTrue(docsWithField.get(doc));
            if (field < numNDVFields) {
              assertEquals("invalid value for doc=" + doc + ", field="+ f+ ", reader="+ r,fieldValues[field],ndv.get(doc));
            }
 else {
              assertEquals("invalid value for doc=" + doc + ", field="+ f+ ", reader="+ r,fieldValues[field],TestBinaryDocValuesUpdates.getValue(bdv,doc));
            }
          }
        }
      }
    }
  }
  writer.close();
  IOUtils.close(reader,dir);
}
