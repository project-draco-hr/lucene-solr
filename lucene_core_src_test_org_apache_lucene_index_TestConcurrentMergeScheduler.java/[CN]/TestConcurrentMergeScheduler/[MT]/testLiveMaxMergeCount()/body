{
  Directory d=newDirectory();
  IndexWriterConfig iwc=new IndexWriterConfig(new MockAnalyzer(random()));
  TieredMergePolicy tmp=new TieredMergePolicy();
  tmp.setSegmentsPerTier(1000);
  tmp.setMaxMergeAtOnce(1000);
  tmp.setMaxMergeAtOnceExplicit(10);
  iwc.setMergePolicy(tmp);
  iwc.setMaxBufferedDocs(2);
  iwc.setRAMBufferSizeMB(-1);
  final AtomicInteger maxRunningMergeCount=new AtomicInteger();
  ConcurrentMergeScheduler cms=new ConcurrentMergeScheduler(){
    final AtomicInteger runningMergeCount=new AtomicInteger();
    @Override public void doMerge(    IndexWriter writer,    MergePolicy.OneMerge merge) throws IOException {
      int count=runningMergeCount.incrementAndGet();
synchronized (this) {
        if (count > maxRunningMergeCount.get()) {
          maxRunningMergeCount.set(count);
        }
      }
      try {
        super.doMerge(writer,merge);
      }
  finally {
        runningMergeCount.decrementAndGet();
      }
    }
  }
;
  assertEquals(ConcurrentMergeScheduler.AUTO_DETECT_MERGES_AND_THREADS,cms.getMaxMergeCount());
  assertEquals(ConcurrentMergeScheduler.AUTO_DETECT_MERGES_AND_THREADS,cms.getMaxThreadCount());
  cms.setMaxMergesAndThreads(5,3);
  iwc.setMergeScheduler(cms);
  IndexWriter w=new IndexWriter(d,iwc);
  for (int i=0; i < 200; i++) {
    w.addDocument(new Document());
  }
  assertEquals(0,maxRunningMergeCount.get());
  w.forceMerge(1);
  assertTrue("maxRunningMergeCount=" + maxRunningMergeCount,maxRunningMergeCount.get() <= 5);
  maxRunningMergeCount.set(0);
  for (int i=0; i < 200; i++) {
    w.addDocument(new Document());
  }
  ((ConcurrentMergeScheduler)w.getConfig().getMergeScheduler()).setMaxMergesAndThreads(1,1);
  w.forceMerge(1);
  assertEquals(1,maxRunningMergeCount.get());
  w.close();
  d.close();
}
