{
  final OpenBitSet bits=useBitSet ? new OpenBitSet(upper - lower + 1) : null;
  TrieUtils.splitLongRange(new TrieUtils.LongRangeBuilder(){
    public void addRange(    long min,    long max,    int shift){
      assertTrue("min, max should be inside bounds",min >= lower && min <= upper && max >= lower && max <= upper);
      if (useBitSet)       for (long l=min; l <= max; l++) {
        assertFalse("ranges should not overlap",bits.getAndSet(l - lower));
      }
      min^=0x8000000000000000L;
      max^=0x8000000000000000L;
      assertEquals("inner min bound",((Long)neededBounds.next()).longValue(),min >>> shift);
      assertEquals("inner max bound",((Long)neededBounds.next()).longValue(),max >>> shift);
    }
  }
,precisionStep,lower,upper);
  if (useBitSet) {
    bits.flip(0,upper - lower + 1);
    assertTrue("The sub-range concenated should match the whole range",bits.isEmpty());
  }
}
