{
  matches++;
  filler.fillValue(doc);
  SearchGroup group=groupMap.get(mval);
  if (group == null) {
    int num=groupMap.size();
    if (groupMap.size() < nGroups) {
      SearchGroup sg=new SearchGroup();
      sg.groupValue=mval.duplicate();
      sg.comparatorSlot=num++;
      sg.matches=1;
      sg.topDoc=docBase + doc;
      for (      FieldComparator fc : comparators)       fc.copy(sg.comparatorSlot,doc);
      groupMap.put(sg.groupValue,sg);
      return;
    }
    if (orderedGroups == null) {
      buildSet();
    }
    for (int i=0; ; i++) {
      final int c=reversed[i] * comparators[i].compareBottom(doc);
      if (c < 0) {
        return;
      }
 else       if (c > 0) {
        break;
      }
 else       if (i == comparators.length - 1) {
        return;
      }
    }
    SearchGroup smallest=orderedGroups.pollLast();
    groupMap.remove(smallest.groupValue);
    smallest.groupValue.copy(mval);
    smallest.matches=1;
    smallest.topDoc=docBase + doc;
    for (    FieldComparator fc : comparators)     fc.copy(smallest.comparatorSlot,doc);
    groupMap.put(smallest.groupValue,smallest);
    orderedGroups.add(smallest);
    for (    FieldComparator fc : comparators)     fc.setBottom(orderedGroups.last().comparatorSlot);
    return;
  }
  group.matches++;
  for (int i=0; ; i++) {
    FieldComparator fc=comparators[i];
    fc.copy(spareSlot,doc);
    final int c=reversed[i] * fc.compare(group.comparatorSlot,spareSlot);
    if (c < 0) {
      return;
    }
 else     if (c > 0) {
      for (int j=i + 1; j < comparators.length; j++)       comparators[j].copy(spareSlot,doc);
      break;
    }
 else     if (i == comparators.length - 1) {
      return;
    }
  }
  if (orderedGroups != null)   orderedGroups.remove(group);
  group.topDoc=docBase + doc;
  int tmp=spareSlot;
  spareSlot=group.comparatorSlot;
  group.comparatorSlot=tmp;
  if (orderedGroups != null)   orderedGroups.add(group);
}
