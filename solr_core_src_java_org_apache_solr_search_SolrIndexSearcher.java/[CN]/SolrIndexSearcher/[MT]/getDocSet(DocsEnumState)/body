{
  int largestPossible=deState.termsEnum.docFreq();
  boolean useCache=filterCache != null && largestPossible >= deState.minSetSizeCached;
  TermQuery key=null;
  if (useCache) {
    key=new TermQuery(new Term(deState.fieldName,BytesRef.deepCopyOf(deState.termsEnum.term())));
    DocSet result=filterCache.get(key);
    if (result != null)     return result;
  }
  int smallSetSize=maxDoc() >> 6;
  int scratchSize=Math.min(smallSetSize,largestPossible);
  if (deState.scratch == null || deState.scratch.length < scratchSize)   deState.scratch=new int[scratchSize];
  final int[] docs=deState.scratch;
  int upto=0;
  int bitsSet=0;
  OpenBitSet obs=null;
  DocsEnum docsEnum=deState.termsEnum.docs(deState.liveDocs,deState.docsEnum,false);
  if (deState.docsEnum == null) {
    deState.docsEnum=docsEnum;
  }
  if (docsEnum instanceof MultiDocsEnum) {
    MultiDocsEnum.EnumWithSlice[] subs=((MultiDocsEnum)docsEnum).getSubs();
    int numSubs=((MultiDocsEnum)docsEnum).getNumSubs();
    for (int subindex=0; subindex < numSubs; subindex++) {
      MultiDocsEnum.EnumWithSlice sub=subs[subindex];
      if (sub.docsEnum == null)       continue;
      int base=sub.slice.start;
      int docid;
      if (largestPossible > docs.length) {
        if (obs == null)         obs=new OpenBitSet(maxDoc());
        while ((docid=sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          obs.fastSet(docid + base);
          bitsSet++;
        }
      }
 else {
        while ((docid=sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          docs[upto++]=docid + base;
        }
      }
    }
  }
 else {
    int docid;
    if (largestPossible > docs.length) {
      if (obs == null)       obs=new OpenBitSet(maxDoc());
      while ((docid=docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
        obs.fastSet(docid);
        bitsSet++;
      }
    }
 else {
      while ((docid=docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
        docs[upto++]=docid;
      }
    }
  }
  DocSet result;
  if (obs != null) {
    for (int i=0; i < upto; i++) {
      obs.fastSet(docs[i]);
    }
    bitsSet+=upto;
    result=new BitDocSet(obs,bitsSet);
  }
 else {
    result=upto == 0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs,upto));
  }
  if (useCache) {
    filterCache.put(key,result);
  }
  return result;
}
