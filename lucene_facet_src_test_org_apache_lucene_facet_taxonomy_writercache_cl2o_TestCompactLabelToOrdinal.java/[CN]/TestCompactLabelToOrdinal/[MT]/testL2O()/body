{
  LabelToOrdinal map=new LabelToOrdinalMap();
  CompactLabelToOrdinal compact=new CompactLabelToOrdinal(2000000,0.15f,3);
  final int n=atLeast(10 * 1000);
  final int numUniqueValues=50 * 1000;
  String[] uniqueValues=new String[numUniqueValues];
  byte[] buffer=new byte[50];
  Random random=random();
  for (int i=0; i < numUniqueValues; ) {
    random.nextBytes(buffer);
    int size=1 + random.nextInt(buffer.length);
    CharsetDecoder decoder=IOUtils.CHARSET_UTF_8.newDecoder().onUnmappableCharacter(CodingErrorAction.REPLACE).onMalformedInput(CodingErrorAction.REPLACE);
    uniqueValues[i]=decoder.decode(ByteBuffer.wrap(buffer,0,size)).toString();
    if (uniqueValues[i].indexOf(CompactLabelToOrdinal.TERMINATOR_CHAR) == -1) {
      i++;
    }
  }
  File tmpDir=_TestUtil.getTempDir("testLableToOrdinal");
  File f=new File(tmpDir,"CompactLabelToOrdinalTest.tmp");
  int flushInterval=10;
  for (int i=0; i < n; i++) {
    if (i > 0 && i % flushInterval == 0) {
      compact.flush(f);
      compact=CompactLabelToOrdinal.open(f,0.15f,3);
      assertTrue(f.delete());
      if (flushInterval < (n / 10)) {
        flushInterval*=10;
      }
    }
    int index=random.nextInt(numUniqueValues);
    CategoryPath label=new CategoryPath(uniqueValues[index],'/');
    int ord1=map.getOrdinal(label);
    int ord2=compact.getOrdinal(label);
    assertEquals(ord1,ord2);
    if (ord1 == LabelToOrdinal.INVALID_ORDINAL) {
      ord1=compact.getNextOrdinal();
      map.addLabel(label,ord1);
      compact.addLabel(label,ord1);
    }
  }
  for (int i=0; i < numUniqueValues; i++) {
    CategoryPath label=new CategoryPath(uniqueValues[i],'/');
    int ord1=map.getOrdinal(label);
    int ord2=compact.getOrdinal(label);
    assertEquals(ord1,ord2);
  }
}
