{
  if (endIdx < beginIdx) {
    return;
  }
  int middleIdxb=beginIdx;
  int middleIdxe=beginIdx;
  int begin=(beginIdx == 0) ? -1 : percentiles[beginIdx - 1];
  int end=(endIdx == percentiles.length - 1) ? list.size() : percentiles[endIdx + 1];
  double middle=(begin + end) / 2.0;
  for (int i=beginIdx; i <= endIdx; i++) {
    double value=Math.abs(percentiles[i] - middle) - Math.abs(percentiles[middleIdxb] - middle);
    if (percentiles[i] == percentiles[middleIdxb]) {
      middleIdxe=i;
    }
 else     if (value < 0) {
      middleIdxb=i;
      do {
        middleIdxe=i;
        i++;
      }
 while (i <= endIdx && percentiles[middleIdxb] == percentiles[i]);
      break;
    }
  }
  int middlePlace=percentiles[middleIdxb];
  int beginPlace=begin + 1;
  int endPlace=end - 1;
  select(list,middlePlace,beginPlace,endPlace);
  distributeAndFind(list,percentiles,beginIdx,middleIdxb - 1);
  distributeAndFind(list,percentiles,middleIdxe + 1,endIdx);
}
