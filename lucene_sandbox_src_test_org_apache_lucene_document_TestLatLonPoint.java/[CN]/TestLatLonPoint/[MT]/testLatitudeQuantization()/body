{
  Random random=random();
  for (int i=0; i < 10000; i++) {
    int encoded=random.nextInt();
    double min=-90.0 + (encoded - (long)Integer.MIN_VALUE) * LatLonPoint.LATITUDE_DECODE;
    double decoded=LatLonPoint.decodeLatitude(encoded);
    assertEquals(min,decoded,0.0D);
    assertEquals(encoded,LatLonPoint.encodeLatitude(decoded));
    assertEquals(encoded,LatLonPoint.encodeLatitudeCeil(decoded));
    if (i != Integer.MAX_VALUE) {
      double max=min + LatLonPoint.LATITUDE_DECODE;
      assertEquals(max,LatLonPoint.decodeLatitude(encoded + 1),0.0D);
      assertEquals(encoded + 1,LatLonPoint.encodeLatitude(max));
      assertEquals(encoded + 1,LatLonPoint.encodeLatitudeCeil(max));
      double minEdge=Math.nextUp(min);
      double maxEdge=Math.nextDown(max);
      assertEquals(encoded,LatLonPoint.encodeLatitude(minEdge));
      assertEquals(encoded + 1,LatLonPoint.encodeLatitudeCeil(minEdge));
      assertEquals(encoded,LatLonPoint.encodeLatitude(maxEdge));
      assertEquals(encoded + 1,LatLonPoint.encodeLatitudeCeil(maxEdge));
      long minBits=NumericUtils.doubleToSortableLong(minEdge);
      long maxBits=NumericUtils.doubleToSortableLong(maxEdge);
      for (int j=0; j < 100; j++) {
        double value=NumericUtils.sortableLongToDouble(TestUtil.nextLong(random,minBits,maxBits));
        assertEquals(encoded,LatLonPoint.encodeLatitude(value));
        assertEquals(encoded + 1,LatLonPoint.encodeLatitudeCeil(value));
      }
    }
  }
}
