{
  final NumericTokenStream stream=new NumericTokenStream().setIntValue(ivalue);
  final TermToBytesRefAttribute bytesAtt=stream.getAttribute(TermToBytesRefAttribute.class);
  final TypeAttribute typeAtt=stream.getAttribute(TypeAttribute.class);
  final NumericTokenStream.NumericTermAttribute numericAtt=stream.getAttribute(NumericTokenStream.NumericTermAttribute.class);
  final BytesRef bytes=new BytesRef();
  stream.reset();
  assertEquals(32,numericAtt.getValueSize());
  for (int shift=0; shift < 32; shift+=NumericUtils.PRECISION_STEP_DEFAULT) {
    assertTrue("New token is available",stream.incrementToken());
    assertEquals("Shift value wrong",shift,numericAtt.getShift());
    final int hash=bytesAtt.toBytesRef(bytes);
    assertEquals("Hash incorrect",bytes.hashCode(),hash);
    assertEquals("Term is incorrectly encoded",ivalue & ~((1 << shift) - 1),NumericUtils.prefixCodedToInt(bytes));
    assertEquals("Term raw value is incorrectly encoded",((long)ivalue) & ~((1L << shift) - 1L),numericAtt.getRawValue());
    assertEquals("Type incorrect",(shift == 0) ? NumericTokenStream.TOKEN_TYPE_FULL_PREC : NumericTokenStream.TOKEN_TYPE_LOWER_PREC,typeAtt.type());
  }
  assertFalse("More tokens available",stream.incrementToken());
  stream.end();
  stream.close();
}
