{
  final NumericTokenStream stream=new NumericTokenStream().setLongValue(lvalue);
  final TermToBytesRefAttribute bytesAtt=stream.getAttribute(TermToBytesRefAttribute.class);
  final TypeAttribute typeAtt=stream.getAttribute(TypeAttribute.class);
  final NumericTokenStream.NumericTermAttribute numericAtt=stream.getAttribute(NumericTokenStream.NumericTermAttribute.class);
  final BytesRef bytes=new BytesRef();
  stream.reset();
  assertEquals(64,numericAtt.getValueSize());
  assertEquals(lvalue,numericAtt.getRawValue());
  for (int shift=0; shift < 64; shift+=NumericUtils.PRECISION_STEP_DEFAULT) {
    assertTrue("New token is available",stream.incrementToken());
    assertEquals("Shift value wrong",shift,numericAtt.getShift());
    final int hash=bytesAtt.toBytesRef(bytes);
    assertEquals("Hash incorrect",bytes.hashCode(),hash);
    assertEquals("Term is incorrectly encoded",lvalue & ~((1L << shift) - 1L),NumericUtils.prefixCodedToLong(bytes));
    assertEquals("Type incorrect",(shift == 0) ? NumericTokenStream.TOKEN_TYPE_FULL_PREC : NumericTokenStream.TOKEN_TYPE_LOWER_PREC,typeAtt.type());
  }
  assertFalse("More tokens available",stream.incrementToken());
  stream.end();
  stream.close();
}
