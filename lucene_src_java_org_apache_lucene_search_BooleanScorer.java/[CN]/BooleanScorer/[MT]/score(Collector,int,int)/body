{
  boolean more;
  Bucket tmp;
  BucketScorer bs=new BucketScorer(weight);
  collector.setScorer(bs);
  do {
    bucketTable.first=null;
    while (current != null) {
      if ((current.bits & prohibitedMask) == 0) {
        if (current.doc >= max) {
          tmp=current;
          current=current.next;
          tmp.next=bucketTable.first;
          bucketTable.first=tmp;
          continue;
        }
        if (current.coord >= minNrShouldMatch) {
          bs.score=current.score * coordFactors[current.coord];
          bs.doc=current.doc;
          bs.freq=current.coord;
          collector.collect(current.doc);
        }
      }
      current=current.next;
    }
    if (bucketTable.first != null) {
      current=bucketTable.first;
      bucketTable.first=current.next;
      return true;
    }
    more=false;
    end+=BucketTable.SIZE;
    for (SubScorer sub=scorers; sub != null; sub=sub.next) {
      int subScorerDocID=sub.scorer.docID();
      if (subScorerDocID != NO_MORE_DOCS) {
        more|=sub.scorer.score(sub.collector,end,subScorerDocID);
      }
    }
    current=bucketTable.first;
  }
 while (current != null || more);
  return false;
}
