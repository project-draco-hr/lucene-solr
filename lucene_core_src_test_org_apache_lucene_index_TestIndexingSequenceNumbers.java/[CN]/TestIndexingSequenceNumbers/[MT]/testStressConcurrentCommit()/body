{
  final int opCount=atLeast(10000);
  final int idCount=TestUtil.nextInt(random(),10,1000);
  Directory dir=newDirectory();
  IndexWriterConfig iwc=newIndexWriterConfig();
  iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);
  final IndexWriter w=new IndexWriter(dir,iwc);
  final int numThreads=TestUtil.nextInt(random(),2,10);
  Thread[] threads=new Thread[numThreads];
  final CountDownLatch startingGun=new CountDownLatch(1);
  List<List<Operation>> threadOps=new ArrayList<>();
  Object commitLock=new Object();
  final List<Operation> commits=new ArrayList<>();
  for (int i=0; i < threads.length; i++) {
    final List<Operation> ops=new ArrayList<>();
    threadOps.add(ops);
    final int threadID=i;
    threads[i]=new Thread(){
      @Override public void run(){
        try {
          startingGun.await();
          for (int i=0; i < opCount; i++) {
            Operation op=new Operation();
            op.threadID=threadID;
            if (random().nextInt(500) == 17) {
              op.what=2;
synchronized (commitLock) {
                op.seqNo=w.commit();
                if (op.seqNo != -1) {
                  commits.add(op);
                }
              }
            }
 else {
              op.id=random().nextInt(idCount);
              Term idTerm=new Term("id","" + op.id);
              if (random().nextInt(10) == 1) {
                op.what=1;
                if (random().nextBoolean()) {
                  op.seqNo=w.deleteDocuments(idTerm);
                }
 else {
                  op.seqNo=w.deleteDocuments(new TermQuery(idTerm));
                }
              }
 else {
                Document doc=new Document();
                doc.add(new StoredField("thread",threadID));
                doc.add(new StringField("id","" + op.id,Field.Store.NO));
                if (random().nextBoolean()) {
                  List<Document> docs=new ArrayList<>();
                  docs.add(doc);
                  op.seqNo=w.updateDocuments(idTerm,docs);
                }
 else {
                  op.seqNo=w.updateDocument(idTerm,doc);
                }
                op.what=2;
              }
              ops.add(op);
            }
          }
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    threads[i].start();
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  Operation commitOp=new Operation();
  commitOp.seqNo=w.commit();
  if (commitOp.seqNo != -1) {
    commits.add(commitOp);
  }
  List<IndexCommit> indexCommits=DirectoryReader.listCommits(dir);
  assertEquals(commits.size(),indexCommits.size());
  int[] expectedThreadIDs=new int[idCount];
  long[] seqNos=new long[idCount];
  for (int i=0; i < commits.size(); i++) {
    long commitSeqNo=commits.get(i).seqNo;
    Arrays.fill(expectedThreadIDs,-1);
    Arrays.fill(seqNos,0);
    for (int threadID=0; threadID < threadOps.size(); threadID++) {
      long lastSeqNo=0;
      for (      Operation op : threadOps.get(threadID)) {
        if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {
          seqNos[op.id]=op.seqNo;
          if (op.what == 2) {
            expectedThreadIDs[op.id]=threadID;
          }
 else {
            expectedThreadIDs[op.id]=-1;
          }
        }
        assertTrue(op.seqNo > lastSeqNo);
        lastSeqNo=op.seqNo;
      }
    }
    DirectoryReader r=DirectoryReader.open(indexCommits.get(i));
    IndexSearcher s=new IndexSearcher(r);
    for (int id=0; id < idCount; id++) {
      TopDocs hits=s.search(new TermQuery(new Term("id","" + id)),1);
      if (expectedThreadIDs[id] != -1) {
        assertEquals(1,hits.totalHits);
        Document doc=r.document(hits.scoreDocs[0].doc);
        int actualThreadID=doc.getField("thread").numericValue().intValue();
        if (expectedThreadIDs[id] != actualThreadID) {
          System.out.println("FAIL: id=" + id + " expectedThreadID="+ expectedThreadIDs[id]+ " vs actualThreadID="+ actualThreadID+ " commitSeqNo="+ commitSeqNo+ " numThreads="+ numThreads);
          for (int threadID=0; threadID < threadOps.size(); threadID++) {
            for (            Operation op : threadOps.get(threadID)) {
              if (id == op.id) {
                System.out.println("  threadID=" + threadID + " seqNo="+ op.seqNo+ " "+ (op.what == 2 ? "updated" : "deleted"));
              }
            }
          }
          assertEquals("id=" + id,expectedThreadIDs[id],actualThreadID);
        }
      }
 else       if (hits.totalHits != 0) {
        System.out.println("FAIL: id=" + id + " expectedThreadID="+ expectedThreadIDs[id]+ " vs totalHits="+ hits.totalHits+ " commitSeqNo="+ commitSeqNo+ " numThreads="+ numThreads);
        for (int threadID=0; threadID < threadOps.size(); threadID++) {
          for (          Operation op : threadOps.get(threadID)) {
            if (id == op.id) {
              System.out.println("  threadID=" + threadID + " seqNo="+ op.seqNo+ " "+ (op.what == 2 ? "updated" : "del"));
            }
          }
        }
        assertEquals(0,hits.totalHits);
      }
    }
    w.close();
    r.close();
  }
  dir.close();
}
