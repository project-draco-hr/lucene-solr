{
  final int opCount=atLeast(10000);
  final int idCount=TestUtil.nextInt(random(),10,1000);
  Directory dir=newDirectory();
  IndexWriterConfig iwc=newIndexWriterConfig();
  iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);
  final IndexWriter w=new IndexWriter(dir,iwc);
  final int numThreads=TestUtil.nextInt(random(),2,5);
  Thread[] threads=new Thread[numThreads];
  final CountDownLatch startingGun=new CountDownLatch(1);
  List<List<Operation>> threadOps=new ArrayList<>();
  Object commitLock=new Object();
  final List<Operation> commits=new ArrayList<>();
  for (int i=0; i < threads.length; i++) {
    final List<Operation> ops=new ArrayList<>();
    threadOps.add(ops);
    final int threadID=i;
    threads[i]=new Thread(){
      @Override public void run(){
        try {
          startingGun.await();
          for (int i=0; i < opCount; i++) {
            Operation op=new Operation();
            op.threadID=threadID;
            if (random().nextInt(500) == 17) {
              op.what=2;
synchronized (commitLock) {
                op.seqNo=w.commit();
                if (op.seqNo != -1) {
                  commits.add(op);
                }
              }
            }
 else {
              op.id=random().nextInt(idCount);
              Term idTerm=new Term("id","" + op.id);
              if (random().nextInt(10) == 1) {
                op.what=1;
                if (random().nextBoolean()) {
                  op.seqNo=w.deleteDocuments(idTerm);
                }
 else {
                  op.seqNo=w.deleteDocuments(new TermQuery(idTerm));
                }
              }
 else {
                Document doc=new Document();
                doc.add(new StoredField("thread",threadID));
                doc.add(new StringField("id","" + op.id,Field.Store.NO));
                if (random().nextBoolean()) {
                  List<Document> docs=new ArrayList<>();
                  docs.add(doc);
                  op.seqNo=w.addDocuments(docs);
                }
 else {
                  op.seqNo=w.addDocument(doc);
                }
                op.what=3;
              }
              ops.add(op);
            }
          }
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    threads[i].start();
  }
  startingGun.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  Operation commitOp=new Operation();
  commitOp.seqNo=w.commit();
  if (commitOp.seqNo != -1) {
    commits.add(commitOp);
  }
  List<IndexCommit> indexCommits=DirectoryReader.listCommits(dir);
  assertEquals(commits.size(),indexCommits.size());
  int[] expectedCounts=new int[idCount];
  long[] lastDelSeqNos=new long[idCount];
  for (int i=0; i < commits.size(); i++) {
    long commitSeqNo=commits.get(i).seqNo;
    Arrays.fill(lastDelSeqNos,-1);
    for (int threadID=0; threadID < threadOps.size(); threadID++) {
      long lastSeqNo=0;
      for (      Operation op : threadOps.get(threadID)) {
        if (op.what == 1 && op.seqNo <= commitSeqNo && op.seqNo > lastDelSeqNos[op.id]) {
          lastDelSeqNos[op.id]=op.seqNo;
        }
        assertTrue(op.seqNo > lastSeqNo);
        lastSeqNo=op.seqNo;
      }
    }
    Arrays.fill(expectedCounts,0);
    for (int threadID=0; threadID < threadOps.size(); threadID++) {
      for (      Operation op : threadOps.get(threadID)) {
        if (op.what == 3 && op.seqNo <= commitSeqNo && op.seqNo > lastDelSeqNos[op.id]) {
          expectedCounts[op.id]++;
        }
      }
    }
    DirectoryReader r=DirectoryReader.open(indexCommits.get(i));
    IndexSearcher s=new IndexSearcher(r);
    for (int id=0; id < idCount; id++) {
      assertEquals(expectedCounts[id],s.count(new TermQuery(new Term("id","" + id))));
    }
    w.close();
    r.close();
  }
  dir.close();
}
