{
  final IndexReader[] subs=r.getSequentialSubReaders();
  if (subs == null) {
    return puller.pull(r,field);
  }
 else   if (subs.length == 0) {
    return null;
  }
 else   if (subs.length == 1) {
    return getDocValues(subs[0],field,puller);
  }
 else {
    final List<DocValuesSlice> slices=new ArrayList<DocValuesSlice>();
    final TypePromoter promotedType[]=new TypePromoter[1];
    promotedType[0]=TypePromoter.getIdentityPromoter();
    new ReaderUtil.Gather(r){
      @Override protected void add(      int base,      IndexReader r) throws IOException {
        final DocValues d=puller.pull(r,field);
        if (d != null) {
          TypePromoter incoming=TypePromoter.create(d.type(),d.getValueSize());
          promotedType[0]=promotedType[0].promote(incoming);
        }
        slices.add(new DocValuesSlice(d,base,r.maxDoc()));
      }
    }
.run();
    if (promotedType[0] == TypePromoter.getIdentityPromoter()) {
      return null;
    }
    int starts[]=new int[slices.size()];
    for (int i=0; i < slices.size(); i++) {
      DocValuesSlice slice=slices.get(i);
      starts[i]=slice.start;
      if (slice.docValues == null) {
        Type promoted=promotedType[0].type();
switch (promoted) {
case BYTES_FIXED_DEREF:
case BYTES_FIXED_STRAIGHT:
          slice.docValues=new EmptyFixedDocValues(slice.length,promoted,promotedType[0].getValueSize());
        break;
default :
      slice.docValues=new EmptyDocValues(slice.length,promoted);
  }
}
}
return new MultiDocValues(slices.toArray(new DocValuesSlice[slices.size()]),starts,promotedType[0]);
}
}
