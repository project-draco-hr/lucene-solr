{
  if (query instanceof BooleanQuery) {
    BooleanClause[] queryClauses=((BooleanQuery)query).getClauses();
    Map booleanTerms=new PositionCheckingMap();
    for (int i=0; i < queryClauses.length; i++) {
      if (!queryClauses[i].isProhibited()) {
        extract(queryClauses[i].getQuery(),booleanTerms);
      }
    }
    terms.putAll(booleanTerms);
  }
 else   if (query instanceof PhraseQuery) {
    Term[] phraseQueryTerms=((PhraseQuery)query).getTerms();
    SpanQuery[] clauses=new SpanQuery[phraseQueryTerms.length];
    for (int i=0; i < phraseQueryTerms.length; i++) {
      clauses[i]=new SpanTermQuery(phraseQueryTerms[i]);
    }
    int slop=((PhraseQuery)query).getSlop();
    boolean inorder=false;
    if (slop == 0) {
      inorder=true;
    }
    SpanNearQuery sp=new SpanNearQuery(clauses,slop,inorder);
    sp.setBoost(query.getBoost());
    extractWeightedSpanTerms(terms,sp);
  }
 else   if (query instanceof TermQuery) {
    extractWeightedTerms(terms,query);
  }
 else   if (query instanceof SpanQuery) {
    extractWeightedSpanTerms(terms,(SpanQuery)query);
  }
 else   if (query instanceof FilteredQuery) {
    extract(((FilteredQuery)query).getQuery(),terms);
  }
 else   if (query instanceof DisjunctionMaxQuery) {
    Map disjunctTerms=new PositionCheckingMap();
    for (Iterator iterator=((DisjunctionMaxQuery)query).iterator(); iterator.hasNext(); ) {
      extract((Query)iterator.next(),disjunctTerms);
    }
    terms.putAll(disjunctTerms);
  }
 else   if (query instanceof MultiTermQuery && (highlightCnstScrRngQuery || expandMultiTermQuery)) {
    MultiTermQuery mtq=((MultiTermQuery)query);
    if (mtq.getConstantScoreRewrite()) {
      mtq=copyMultiTermQuery(mtq);
      mtq.setConstantScoreRewrite(false);
      query=mtq;
    }
    String field;
    if (mtq instanceof TermRangeQuery) {
      field=((TermRangeQuery)mtq).getField();
    }
 else {
      field=mtq.getTerm().field();
    }
    IndexReader ir=getReaderForField(field);
    extract(query.rewrite(ir),terms);
  }
 else   if (query instanceof MultiPhraseQuery) {
    final MultiPhraseQuery mpq=(MultiPhraseQuery)query;
    final List termArrays=mpq.getTermArrays();
    final int[] positions=mpq.getPositions();
    if (positions.length > 0) {
      int maxPosition=positions[positions.length - 1];
      for (int i=0; i < positions.length - 1; ++i) {
        if (positions[i] > maxPosition) {
          maxPosition=positions[i];
        }
      }
      final List[] disjunctLists=new List[maxPosition + 1];
      int distinctPositions=0;
      for (int i=0; i < termArrays.size(); ++i) {
        final Term[] termArray=(Term[])termArrays.get(i);
        List disjuncts=disjunctLists[positions[i]];
        if (disjuncts == null) {
          disjuncts=(disjunctLists[positions[i]]=new ArrayList(termArray.length));
          ++distinctPositions;
        }
        for (int j=0; j < termArray.length; ++j) {
          disjuncts.add(new SpanTermQuery(termArray[j]));
        }
      }
      int positionGaps=0;
      int position=0;
      final SpanQuery[] clauses=new SpanQuery[distinctPositions];
      for (int i=0; i < disjunctLists.length; ++i) {
        List disjuncts=disjunctLists[i];
        if (disjuncts != null) {
          clauses[position++]=new SpanOrQuery((SpanQuery[])disjuncts.toArray(new SpanQuery[disjuncts.size()]));
        }
 else {
          ++positionGaps;
        }
      }
      final int slop=mpq.getSlop();
      final boolean inorder=(slop == 0);
      SpanNearQuery sp=new SpanNearQuery(clauses,slop + positionGaps,inorder);
      sp.setBoost(query.getBoost());
      extractWeightedSpanTerms(terms,sp);
    }
  }
}
