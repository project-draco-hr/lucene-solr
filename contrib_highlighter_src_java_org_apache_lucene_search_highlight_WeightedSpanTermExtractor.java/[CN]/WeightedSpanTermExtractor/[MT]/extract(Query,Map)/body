{
  if (query instanceof BooleanQuery) {
    BooleanClause[] queryClauses=((BooleanQuery)query).getClauses();
    Map booleanTerms=new HashMap();
    for (int i=0; i < queryClauses.length; i++) {
      if (!queryClauses[i].isProhibited()) {
        extract(queryClauses[i].getQuery(),booleanTerms);
      }
    }
    terms.putAll(booleanTerms);
  }
 else   if (query instanceof PhraseQuery) {
    Term[] phraseQueryTerms=((PhraseQuery)query).getTerms();
    SpanQuery[] clauses=new SpanQuery[phraseQueryTerms.length];
    for (int i=0; i < phraseQueryTerms.length; i++) {
      clauses[i]=new SpanTermQuery(phraseQueryTerms[i]);
    }
    int slop=((PhraseQuery)query).getSlop();
    boolean inorder=false;
    if (slop == 0) {
      inorder=true;
    }
    SpanNearQuery sp=new SpanNearQuery(clauses,slop,inorder);
    sp.setBoost(query.getBoost());
    extractWeightedSpanTerms(terms,sp);
  }
 else   if (query instanceof TermQuery) {
    extractWeightedTerms(terms,query);
  }
 else   if (query instanceof SpanQuery) {
    extractWeightedSpanTerms(terms,(SpanQuery)query);
  }
 else   if (query instanceof FilteredQuery) {
    extract(((FilteredQuery)query).getQuery(),terms);
  }
 else   if (query instanceof DisjunctionMaxQuery) {
    Map disjunctTerms=new HashMap();
    for (Iterator iterator=((DisjunctionMaxQuery)query).iterator(); iterator.hasNext(); ) {
      extract((Query)iterator.next(),disjunctTerms);
    }
    terms.putAll(disjunctTerms);
  }
 else   if (query instanceof MultiPhraseQuery) {
    final MultiPhraseQuery mpq=(MultiPhraseQuery)query;
    final List termArrays=mpq.getTermArrays();
    final int[] positions=mpq.getPositions();
    if (positions.length > 0) {
      int maxPosition=positions[positions.length - 1];
      for (int i=0; i < positions.length - 1; ++i) {
        if (positions[i] > maxPosition) {
          maxPosition=positions[i];
        }
      }
      final List[] disjunctLists=new List[maxPosition + 1];
      int distinctPositions=0;
      for (int i=0; i < termArrays.size(); ++i) {
        final Term[] termArray=(Term[])termArrays.get(i);
        List disjuncts=disjunctLists[positions[i]];
        if (disjuncts == null) {
          disjuncts=(disjunctLists[positions[i]]=new ArrayList(termArray.length));
          ++distinctPositions;
        }
        for (int j=0; j < termArray.length; ++j) {
          disjuncts.add(new SpanTermQuery(termArray[j]));
        }
      }
      int positionGaps=0;
      int position=0;
      final SpanQuery[] clauses=new SpanQuery[distinctPositions];
      for (int i=0; i < disjunctLists.length; ++i) {
        List disjuncts=disjunctLists[i];
        if (disjuncts != null) {
          clauses[position++]=new SpanOrQuery((SpanQuery[])disjuncts.toArray(new SpanQuery[disjuncts.size()]));
        }
 else {
          ++positionGaps;
        }
      }
      final int slop=mpq.getSlop();
      final boolean inorder=(slop == 0);
      SpanNearQuery sp=new SpanNearQuery(clauses,slop + positionGaps,inorder);
      sp.setBoost(query.getBoost());
      extractWeightedSpanTerms(terms,sp);
    }
  }
 else   if (query instanceof ConstantScoreRangeQuery) {
    ConstantScoreRangeQuery q=(ConstantScoreRangeQuery)query;
    Term lower=new Term(fieldName,q.getLowerVal());
    Term upper=new Term(fieldName,q.getUpperVal());
    FilterIndexReader fir=new FilterIndexReader(getReaderForField(fieldName));
    try {
      TermEnum te=fir.terms(lower);
      BooleanQuery bq=new BooleanQuery();
      do {
        Term term=te.term();
        if (term != null && upper.compareTo(term) >= 0) {
          bq.add(new BooleanClause(new TermQuery(term),BooleanClause.Occur.SHOULD));
        }
 else {
          break;
        }
      }
 while (te.next());
      extract(bq,terms);
    }
  finally {
      fir.close();
    }
  }
}
