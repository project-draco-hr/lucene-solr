{
  final int minShouldMatch=BooleanQuery.this.getMinimumNumberShouldMatch();
  Explanation sumExpl=new Explanation();
  sumExpl.setDescription("sum of:");
  int coord=0;
  int maxCoord=0;
  float sum=0.0f;
  boolean fail=false;
  int shouldMatchCount=0;
  for (int i=0; i < weights.size(); i++) {
    BooleanClause c=(BooleanClause)clauses.elementAt(i);
    Weight w=(Weight)weights.elementAt(i);
    Explanation e=w.explain(reader,doc);
    if (!c.isProhibited())     maxCoord++;
    if (e.getValue() > 0) {
      if (!c.isProhibited()) {
        sumExpl.addDetail(e);
        sum+=e.getValue();
        coord++;
      }
 else {
        Explanation r=new Explanation(0.0f,"match on prohibited clause");
        r.addDetail(e);
        sumExpl.addDetail(r);
        fail=true;
      }
      if (c.getOccur().equals(Occur.SHOULD))       shouldMatchCount++;
    }
 else     if (c.isRequired()) {
      Explanation r=new Explanation(0.0f,"no match on required clause");
      r.addDetail(e);
      sumExpl.addDetail(r);
      fail=true;
    }
  }
  if (fail) {
    sumExpl.setValue(0.0f);
    sumExpl.setDescription("Failure to meet condition(s) of required/prohibited clause(s)");
    return sumExpl;
  }
 else   if (shouldMatchCount < minShouldMatch) {
    sumExpl.setValue(0.0f);
    sumExpl.setDescription("Failure to match minimum number " + "of optional clauses: " + minShouldMatch);
    return sumExpl;
  }
  sumExpl.setValue(sum);
  float coordFactor=similarity.coord(coord,maxCoord);
  if (coordFactor == 1.0f)   return sumExpl;
 else {
    Explanation result=new Explanation();
    result.setDescription("product of:");
    result.addDetail(sumExpl);
    result.addDetail(new Explanation(coordFactor,"coord(" + coord + "/"+ maxCoord+ ")"));
    result.setValue(sum * coordFactor);
    return result;
  }
}
