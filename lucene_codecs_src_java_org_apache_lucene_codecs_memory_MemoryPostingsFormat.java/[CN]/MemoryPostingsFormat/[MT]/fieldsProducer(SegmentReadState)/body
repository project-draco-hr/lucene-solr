{
  final String fileName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,EXTENSION);
  final ChecksumIndexInput in=state.directory.openChecksumInput(fileName,IOContext.READONCE);
  final SortedMap<String,TermsReader> fields=new TreeMap<>();
  try {
    CodecUtil.checkHeader(in,CODEC_NAME,VERSION_START,VERSION_CURRENT);
    while (true) {
      final int termCount=in.readVInt();
      if (termCount == 0) {
        break;
      }
      final TermsReader termsReader=new TermsReader(state.fieldInfos,in,termCount);
      fields.put(termsReader.field.name,termsReader);
    }
    CodecUtil.checkFooter(in);
  }
  finally {
    in.close();
  }
  return new FieldsProducer(){
    @Override public Iterator<String> iterator(){
      return Collections.unmodifiableSet(fields.keySet()).iterator();
    }
    @Override public Terms terms(    String field){
      return fields.get(field);
    }
    @Override public int size(){
      return fields.size();
    }
    @Override public void close(){
      for (      TermsReader termsReader : fields.values()) {
        termsReader.fst=null;
      }
    }
    @Override public long ramBytesUsed(){
      long sizeInBytes=0;
      for (      Map.Entry<String,TermsReader> entry : fields.entrySet()) {
        sizeInBytes+=(entry.getKey().length() * RamUsageEstimator.NUM_BYTES_CHAR);
        sizeInBytes+=entry.getValue().ramBytesUsed();
      }
      return sizeInBytes;
    }
    @Override public void checkIntegrity() throws IOException {
    }
  }
;
}
