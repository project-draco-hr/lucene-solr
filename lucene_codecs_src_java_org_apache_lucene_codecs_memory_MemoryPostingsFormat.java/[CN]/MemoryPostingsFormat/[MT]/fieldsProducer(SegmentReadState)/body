{
  final String fileName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,EXTENSION);
  final SortedMap<String,TermsReader> fields=new TreeMap<>();
  try (ChecksumIndexInput in=state.directory.openChecksumInput(fileName,IOContext.READONCE)){
    Throwable priorE=null;
    try {
      CodecUtil.checkSegmentHeader(in,CODEC_NAME,VERSION_START,VERSION_CURRENT,state.segmentInfo.getId(),state.segmentSuffix);
      while (true) {
        final int termCount=in.readVInt();
        if (termCount == 0) {
          break;
        }
        final TermsReader termsReader=new TermsReader(state.fieldInfos,in,termCount);
        fields.put(termsReader.field.name,termsReader);
      }
    }
 catch (    Throwable exception) {
      priorE=exception;
    }
 finally {
      CodecUtil.checkFooter(in,priorE);
    }
  }
   return new FieldsProducer(){
    @Override public Iterator<String> iterator(){
      return Collections.unmodifiableSet(fields.keySet()).iterator();
    }
    @Override public Terms terms(    String field){
      return fields.get(field);
    }
    @Override public int size(){
      return fields.size();
    }
    @Override public void close(){
      for (      TermsReader termsReader : fields.values()) {
        termsReader.fst=null;
      }
    }
    @Override public long ramBytesUsed(){
      long sizeInBytes=0;
      for (      Map.Entry<String,TermsReader> entry : fields.entrySet()) {
        sizeInBytes+=(entry.getKey().length() * RamUsageEstimator.NUM_BYTES_CHAR);
        sizeInBytes+=entry.getValue().ramBytesUsed();
      }
      return sizeInBytes;
    }
    @Override public Iterable<? extends Accountable> getChildResources(){
      return Accountables.namedAccountables("field",fields);
    }
    @Override public String toString(){
      return "MemoryPostings(fields=" + fields.size() + ")";
    }
    @Override public void checkIntegrity() throws IOException {
    }
  }
;
}
