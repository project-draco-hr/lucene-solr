{
  SolrParams params=rb.req.getParams();
  if (!params.getBool(TermsParams.TERMS,false))   return;
  String[] fields=params.getParams(TermsParams.TERMS_FIELD);
  NamedList<Object> termsResult=new SimpleOrderedMap<Object>();
  rb.rsp.add("terms",termsResult);
  if (fields == null || fields.length == 0)   return;
  int limit=params.getInt(TermsParams.TERMS_LIMIT,10);
  if (limit < 0) {
    limit=Integer.MAX_VALUE;
  }
  String lowerStr=params.get(TermsParams.TERMS_LOWER);
  String upperStr=params.get(TermsParams.TERMS_UPPER);
  boolean upperIncl=params.getBool(TermsParams.TERMS_UPPER_INCLUSIVE,false);
  boolean lowerIncl=params.getBool(TermsParams.TERMS_LOWER_INCLUSIVE,true);
  boolean sort=!TermsParams.TERMS_SORT_INDEX.equals(params.get(TermsParams.TERMS_SORT,TermsParams.TERMS_SORT_COUNT));
  int freqmin=params.getInt(TermsParams.TERMS_MINCOUNT,1);
  int freqmax=params.getInt(TermsParams.TERMS_MAXCOUNT,UNLIMITED_MAX_COUNT);
  if (freqmax < 0) {
    freqmax=Integer.MAX_VALUE;
  }
  String prefix=params.get(TermsParams.TERMS_PREFIX_STR);
  String regexp=params.get(TermsParams.TERMS_REGEXP_STR);
  Pattern pattern=regexp != null ? Pattern.compile(regexp,resolveRegexpFlags(params)) : null;
  boolean raw=params.getBool(TermsParams.TERMS_RAW,false);
  final IndexReader indexReader=rb.req.getSearcher().getTopReaderContext().reader;
  Fields lfields=MultiFields.getFields(indexReader);
  for (  String field : fields) {
    NamedList<Integer> fieldTerms=new NamedList<Integer>();
    termsResult.add(field,fieldTerms);
    Terms terms=lfields == null ? null : lfields.terms(field);
    if (terms == null) {
      continue;
    }
    FieldType ft=raw ? null : rb.req.getSchema().getFieldTypeNoEx(field);
    if (ft == null)     ft=new StrField();
    BytesRef prefixBytes=prefix == null ? null : new BytesRef(prefix);
    BytesRef upperBytes=null;
    if (upperStr != null) {
      upperBytes=new BytesRef();
      ft.readableToIndexed(upperStr,upperBytes);
    }
    BytesRef lowerBytes;
    if (lowerStr == null) {
      lowerBytes=prefixBytes;
    }
 else {
      lowerBytes=new BytesRef();
      if (raw) {
        lowerBytes=new BytesRef(lowerStr);
      }
 else {
        lowerBytes=new BytesRef();
        ft.readableToIndexed(lowerStr,lowerBytes);
      }
    }
    TermsEnum termsEnum=terms.iterator(null);
    BytesRef term=null;
    if (lowerBytes != null) {
      if (termsEnum.seekCeil(lowerBytes,true) == TermsEnum.SeekStatus.END) {
        termsEnum=null;
      }
 else {
        term=termsEnum.term();
        if (lowerIncl == false && term.equals(lowerBytes)) {
          term=termsEnum.next();
        }
      }
    }
 else {
      term=termsEnum.next();
    }
    int i=0;
    BoundedTreeSet<CountPair<BytesRef,Integer>> queue=(sort ? new BoundedTreeSet<CountPair<BytesRef,Integer>>(limit) : null);
    CharsRef external=new CharsRef();
    while (term != null && (i < limit || sort)) {
      boolean externalized=false;
      if (prefixBytes != null && !term.startsWith(prefixBytes))       break;
      if (pattern != null) {
        ft.indexedToReadable(term,external);
        externalized=true;
        if (!pattern.matcher(external).matches()) {
          term=termsEnum.next();
          continue;
        }
      }
      if (upperBytes != null) {
        int upperCmp=term.compareTo(upperBytes);
        if (upperCmp > 0 || (upperCmp == 0 && !upperIncl))         break;
      }
      int docFreq=termsEnum.docFreq();
      if (docFreq >= freqmin && docFreq <= freqmax) {
        if (sort) {
          queue.add(new CountPair<BytesRef,Integer>(new BytesRef(term),docFreq));
        }
 else {
          if (!externalized) {
            ft.indexedToReadable(term,external);
          }
          fieldTerms.add(external.toString(),docFreq);
          i++;
        }
      }
      term=termsEnum.next();
    }
    if (sort) {
      for (      CountPair<BytesRef,Integer> item : queue) {
        if (i >= limit)         break;
        ft.indexedToReadable(item.key,external);
        fieldTerms.add(external.toString(),item.val);
        i++;
      }
    }
  }
}
