{
  if (ulog == null) {
    return PeerSyncResult.failure();
  }
  MDCLoggingContext.setCore(core);
  try {
    log.info(msg() + "START replicas=" + replicas+ " nUpdates="+ nUpdates);
    if (debug) {
      if (startingVersions != null) {
        log.debug(msg() + "startingVersions=" + startingVersions.size()+ " "+ startingVersions);
      }
    }
    if (doFingerprint && alreadyInSync()) {
      return PeerSyncResult.success();
    }
    for (    String replica : replicas) {
      requestVersions(replica);
    }
    try (UpdateLog.RecentUpdates recentUpdates=ulog.getRecentUpdates()){
      ourUpdates=recentUpdates.getVersions(nUpdates);
    }
     Collections.sort(ourUpdates,absComparator);
    if (startingVersions != null) {
      if (startingVersions.size() == 0) {
        log.warn("no frame of reference to tell if we've missed updates");
        return PeerSyncResult.failure();
      }
      Collections.sort(startingVersions,absComparator);
      ourLowThreshold=percentile(startingVersions,0.8f);
      ourHighThreshold=percentile(startingVersions,0.2f);
      long smallestNewUpdate=Math.abs(ourUpdates.get(ourUpdates.size() - 1));
      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {
        log.warn(msg() + "too many updates received since start - startingUpdates no longer overlaps with our currentUpdates");
        return PeerSyncResult.failure();
      }
      List<Long> newList=new ArrayList<>(ourUpdates);
      for (      Long ver : startingVersions) {
        if (Math.abs(ver) < smallestNewUpdate) {
          newList.add(ver);
        }
      }
      ourUpdates=newList;
      Collections.sort(ourUpdates,absComparator);
    }
 else {
      if (ourUpdates.size() > 0) {
        ourLowThreshold=percentile(ourUpdates,0.8f);
        ourHighThreshold=percentile(ourUpdates,0.2f);
      }
 else {
        log.info(msg() + "DONE.  We have no versions.  sync failed.");
        for (; ; ) {
          ShardResponse srsp=shardHandler.takeCompletedOrError();
          if (srsp == null)           break;
          if (srsp.getException() == null) {
            List<Long> otherVersions=(List<Long>)srsp.getSolrResponse().getResponse().get("versions");
            if (otherVersions != null && !otherVersions.isEmpty()) {
              return PeerSyncResult.failure(true);
            }
          }
        }
        return PeerSyncResult.failure(false);
      }
    }
    ourHighest=ourUpdates.get(0);
    ourUpdateSet=new HashSet<>(ourUpdates);
    requestedUpdateSet=new HashSet<>();
    for (; ; ) {
      ShardResponse srsp=shardHandler.takeCompletedOrError();
      if (srsp == null)       break;
      boolean success=handleResponse(srsp);
      if (!success) {
        log.info(msg() + "DONE. sync failed");
        shardHandler.cancelAll();
        return PeerSyncResult.failure();
      }
    }
    boolean success=true;
    for (    SyncShardRequest sreq : requests) {
      if (sreq.doFingerprintComparison) {
        success=compareFingerprint(sreq);
        if (!success)         break;
      }
    }
    log.info(msg() + "DONE. sync " + (success ? "succeeded" : "failed"));
    return success ? PeerSyncResult.success() : PeerSyncResult.failure();
  }
  finally {
    MDCLoggingContext.clear();
  }
}
