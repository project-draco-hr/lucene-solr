{
  if (ulog == null) {
    return false;
  }
  for (  String replica : replicas) {
    requestVersions(replica);
  }
  recentUpdates=ulog.getRecentUpdates();
  try {
    ourUpdates=recentUpdates.getVersions(nUpdates);
  }
  finally {
    recentUpdates.close();
  }
  Collections.sort(ourUpdates,absComparator);
  if (startingVersions != null) {
    if (startingVersions.size() == 0) {
      return false;
    }
    Collections.sort(startingVersions,absComparator);
    ourLowThreshold=percentile(startingVersions,0.8f);
    ourHighThreshold=percentile(startingVersions,0.2f);
    long smallestNewUpdate=Math.abs(ourUpdates.get(ourUpdates.size() - 1));
    if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {
      log.warn("PeerSync: too many updates received since start - startingUpdates no longer overlaps with cour urrentUpdates");
      return false;
    }
    List<Long> newList=new ArrayList(ourUpdates);
    for (    Long ver : startingVersions) {
      if (Math.abs(ver) < smallestNewUpdate) {
        newList.add(ver);
      }
    }
    ourUpdates=newList;
  }
 else {
    if (ourUpdates.size() > 0) {
      ourLowThreshold=percentile(ourUpdates,0.8f);
      ourHighThreshold=percentile(ourUpdates,0.2f);
    }
 else {
      return false;
    }
  }
  ourUpdateSet=new HashSet<Long>(ourUpdates);
  requestedUpdateSet=new HashSet<Long>(ourUpdates);
  for (; ; ) {
    ShardResponse srsp=shardHandler.takeCompletedOrError();
    if (srsp == null)     break;
    boolean success=handleResponse(srsp);
    if (!success) {
      shardHandler.cancelAll();
      return false;
    }
  }
  return true;
}
