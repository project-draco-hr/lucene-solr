{
  int minShouldMatch=query.getMinimumNumberShouldMatch();
  List<Scorer> required=new ArrayList<>();
  List<Scorer> requiredScoring=new ArrayList<>();
  List<Scorer> prohibited=new ArrayList<>();
  List<Scorer> optional=new ArrayList<>();
  Iterator<BooleanClause> cIter=query.iterator();
  for (  Weight w : weights) {
    BooleanClause c=cIter.next();
    Scorer subScorer=w.scorer(context);
    if (subScorer == null) {
      if (c.isRequired()) {
        return null;
      }
    }
 else     if (c.isRequired()) {
      required.add(subScorer);
      if (c.isScoring()) {
        requiredScoring.add(subScorer);
      }
    }
 else     if (c.isProhibited()) {
      prohibited.add(subScorer);
    }
 else {
      optional.add(subScorer);
    }
  }
  if (optional.size() == minShouldMatch) {
    required.addAll(optional);
    requiredScoring.addAll(optional);
    optional.clear();
    minShouldMatch=0;
  }
  if (required.isEmpty() && optional.isEmpty()) {
    return null;
  }
 else   if (optional.size() < minShouldMatch) {
    return null;
  }
  if (!needsScores && minShouldMatch == 0 && required.size() > 0) {
    optional.clear();
  }
  if (optional.isEmpty()) {
    return excl(req(required,requiredScoring),prohibited);
  }
  if (required.isEmpty()) {
    return excl(opt(optional,minShouldMatch),prohibited);
  }
  Scorer req=excl(req(required,requiredScoring),prohibited);
  Scorer opt=opt(optional,minShouldMatch);
  if (minShouldMatch > 0) {
    return new ConjunctionScorer(this,Arrays.asList(req,opt),Arrays.asList(req,opt));
  }
 else {
    return new ReqOptSumScorer(req,opt);
  }
}
