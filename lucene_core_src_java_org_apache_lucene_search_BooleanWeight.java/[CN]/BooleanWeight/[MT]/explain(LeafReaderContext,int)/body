{
  final int minShouldMatch=query.getMinimumNumberShouldMatch();
  List<Explanation> subs=new ArrayList<>();
  float sum=0.0f;
  boolean fail=false;
  int matchCount=0;
  int shouldMatchCount=0;
  Iterator<BooleanClause> cIter=query.iterator();
  for (Iterator<Weight> wIter=weights.iterator(); wIter.hasNext(); ) {
    Weight w=wIter.next();
    BooleanClause c=cIter.next();
    Explanation e=w.explain(context,doc);
    if (e.isMatch()) {
      if (c.isScoring()) {
        subs.add(e);
        sum+=e.getValue();
      }
 else       if (c.isRequired()) {
        subs.add(Explanation.match(0f,"match on required clause, product of:",Explanation.match(0f,Occur.FILTER + " clause"),e));
      }
 else       if (c.isProhibited()) {
        subs.add(Explanation.noMatch("match on prohibited clause (" + c.getQuery().toString() + ")",e));
        fail=true;
      }
      if (!c.isProhibited()) {
        matchCount++;
      }
      if (c.getOccur() == Occur.SHOULD) {
        shouldMatchCount++;
      }
    }
 else     if (c.isRequired()) {
      subs.add(Explanation.noMatch("no match on required clause (" + c.getQuery().toString() + ")",e));
      fail=true;
    }
  }
  if (fail) {
    return Explanation.noMatch("Failure to meet condition(s) of required/prohibited clause(s)",subs);
  }
 else   if (matchCount == 0) {
    return Explanation.noMatch("No matching clauses",subs);
  }
 else   if (shouldMatchCount < minShouldMatch) {
    return Explanation.noMatch("Failure to match minimum number of optional clauses: " + minShouldMatch,subs);
  }
 else {
    return Explanation.match(sum,"sum of:",subs);
  }
}
