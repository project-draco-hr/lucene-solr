{
  final int minShouldMatch=query.getMinimumNumberShouldMatch();
  ComplexExplanation sumExpl=new ComplexExplanation();
  sumExpl.setDescription("sum of:");
  int coord=0;
  float sum=0.0f;
  boolean fail=false;
  int matchCount=0;
  int shouldMatchCount=0;
  Iterator<BooleanClause> cIter=query.clauses().iterator();
  for (Iterator<Weight> wIter=weights.iterator(); wIter.hasNext(); ) {
    Weight w=wIter.next();
    BooleanClause c=cIter.next();
    if (w.scorer(context,context.reader().getLiveDocs()) == null) {
      if (c.isRequired()) {
        fail=true;
        Explanation r=new Explanation(0.0f,"no match on required clause (" + c.getQuery().toString() + ")");
        sumExpl.addDetail(r);
      }
      continue;
    }
    Explanation e=w.explain(context,doc);
    if (e.isMatch()) {
      if (c.isScoring()) {
        sumExpl.addDetail(e);
        sum+=e.getValue();
        coord++;
      }
 else       if (c.isRequired()) {
        Explanation r=new Explanation(0f,"match on required clause, product of:");
        r.addDetail(new Explanation(0f,Occur.FILTER + " clause"));
        r.addDetail(e);
        sumExpl.addDetail(r);
      }
 else       if (c.isProhibited()) {
        Explanation r=new Explanation(0.0f,"match on prohibited clause (" + c.getQuery().toString() + ")");
        r.addDetail(e);
        sumExpl.addDetail(r);
        fail=true;
      }
      if (!c.isProhibited()) {
        matchCount++;
      }
      if (c.getOccur() == Occur.SHOULD) {
        shouldMatchCount++;
      }
    }
 else     if (c.isRequired()) {
      Explanation r=new Explanation(0.0f,"no match on required clause (" + c.getQuery().toString() + ")");
      r.addDetail(e);
      sumExpl.addDetail(r);
      fail=true;
    }
  }
  if (fail) {
    sumExpl.setMatch(Boolean.FALSE);
    sumExpl.setValue(0.0f);
    sumExpl.setDescription("Failure to meet condition(s) of required/prohibited clause(s)");
    return sumExpl;
  }
 else   if (shouldMatchCount < minShouldMatch) {
    sumExpl.setMatch(Boolean.FALSE);
    sumExpl.setValue(0.0f);
    sumExpl.setDescription("Failure to match minimum number " + "of optional clauses: " + minShouldMatch);
    return sumExpl;
  }
  sumExpl.setMatch(0 < matchCount);
  sumExpl.setValue(sum);
  final float coordFactor=disableCoord ? 1.0f : coord(coord,maxCoord);
  if (coordFactor == 1.0f) {
    return sumExpl;
  }
 else {
    ComplexExplanation result=new ComplexExplanation(sumExpl.isMatch(),sum * coordFactor,"product of:");
    result.addDetail(sumExpl);
    result.addDetail(new Explanation(coordFactor,"coord(" + coord + "/"+ maxCoord+ ")"));
    return result;
  }
}
