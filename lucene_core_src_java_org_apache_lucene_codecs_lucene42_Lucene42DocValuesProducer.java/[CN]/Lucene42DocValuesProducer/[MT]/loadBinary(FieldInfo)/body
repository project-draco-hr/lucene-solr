{
  BinaryEntry entry=binaries.get(field.number);
  data.seek(entry.offset);
  PagedBytes bytes=new PagedBytes(16);
  bytes.copy(data,entry.numBytes);
  final PagedBytes.Reader bytesReader=bytes.freeze(true);
  if (entry.minLength == entry.maxLength) {
    final int fixedLength=entry.minLength;
    ramBytesUsed.addAndGet(bytes.ramBytesUsed());
    return new BinaryDocValues(){
      @Override public BytesRef get(      int docID){
        final BytesRef term=new BytesRef();
        bytesReader.fillSlice(term,fixedLength * (long)docID,fixedLength);
        return term;
      }
    }
;
  }
 else {
    final MonotonicBlockPackedReader addresses=MonotonicBlockPackedReader.of(data,entry.packedIntsVersion,entry.blockSize,maxDoc,false);
    ramBytesUsed.addAndGet(bytes.ramBytesUsed() + addresses.ramBytesUsed());
    return new BinaryDocValues(){
      @Override public BytesRef get(      int docID){
        long startAddress=docID == 0 ? 0 : addresses.get(docID - 1);
        long endAddress=addresses.get(docID);
        final BytesRef term=new BytesRef();
        bytesReader.fillSlice(term,startAddress,(int)(endAddress - startAddress));
        return term;
      }
    }
;
  }
}
