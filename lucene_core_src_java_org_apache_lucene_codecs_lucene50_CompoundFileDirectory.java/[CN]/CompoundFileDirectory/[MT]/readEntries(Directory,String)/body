{
  ChecksumIndexInput entriesStream=null;
  Map<String,FileEntry> mapping=null;
  boolean success=false;
  try {
    final String entriesFileName=IndexFileNames.segmentFileName(IndexFileNames.stripExtension(name),"",IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION);
    entriesStream=dir.openChecksumInput(entriesFileName,IOContext.READONCE);
    version=CodecUtil.checkHeader(entriesStream,CompoundFileWriter.ENTRY_CODEC,CompoundFileWriter.VERSION_START,CompoundFileWriter.VERSION_CURRENT);
    if (version >= CompoundFileWriter.VERSION_SEGMENTHEADER) {
      byte id[]=new byte[StringHelper.ID_LENGTH];
      entriesStream.readBytes(id,0,id.length);
      if (segmentID != null && !Arrays.equals(id,segmentID)) {
        throw new CorruptIndexException("file mismatch, expected segment id=" + StringHelper.idToString(segmentID) + ", got="+ StringHelper.idToString(id),entriesStream);
      }
      byte suffixLength=entriesStream.readByte();
      if (suffixLength != 0) {
        throw new CorruptIndexException("unexpected segment suffix, expected zero-length, got=" + (suffixLength & 0xFF),entriesStream);
      }
    }
    final int numEntries=entriesStream.readVInt();
    mapping=new HashMap<>(numEntries);
    for (int i=0; i < numEntries; i++) {
      final FileEntry fileEntry=new FileEntry();
      final String id=entriesStream.readString();
      FileEntry previous=mapping.put(id,fileEntry);
      if (previous != null) {
        throw new CorruptIndexException("Duplicate cfs entry id=" + id + " in CFS ",entriesStream);
      }
      fileEntry.offset=entriesStream.readLong();
      fileEntry.length=entriesStream.readLong();
    }
    if (version >= CompoundFileWriter.VERSION_CHECKSUM) {
      CodecUtil.checkFooter(entriesStream);
    }
 else {
      CodecUtil.checkEOF(entriesStream);
    }
    success=true;
  }
  finally {
    if (success) {
      IOUtils.close(entriesStream);
    }
 else {
      IOUtils.closeWhileHandlingException(entriesStream);
    }
  }
  return mapping;
}
