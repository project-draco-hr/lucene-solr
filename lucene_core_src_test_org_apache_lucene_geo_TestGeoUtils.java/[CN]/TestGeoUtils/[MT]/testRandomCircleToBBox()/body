{
  int iters=atLeast(1000);
  for (int iter=0; iter < iters; iter++) {
    double centerLat=GeoTestUtil.nextLatitude();
    double centerLon=GeoTestUtil.nextLongitude();
    final double radiusMeters;
    if (random().nextBoolean()) {
      radiusMeters=random().nextDouble() * 444000;
    }
 else {
      radiusMeters=random().nextDouble() * 50000000;
    }
    Rectangle bbox=Rectangle.fromPointDistance(centerLat,centerLon,radiusMeters);
    int numPointsToTry=1000;
    for (int i=0; i < numPointsToTry; i++) {
      double point[]=GeoTestUtil.nextPointNear(bbox);
      double lat=point[0];
      double lon=point[1];
      double distanceMeters=SloppyMath.haversinMeters(centerLat,centerLon,lat,lon);
      boolean haversinSays=distanceMeters <= radiusMeters;
      boolean bboxSays;
      if (bbox.crossesDateline()) {
        if (lat >= bbox.minLat && lat <= bbox.maxLat) {
          bboxSays=lon <= bbox.maxLon || lon >= bbox.minLon;
        }
 else {
          bboxSays=false;
        }
      }
 else {
        bboxSays=lat >= bbox.minLat && lat <= bbox.maxLat && lon >= bbox.minLon && lon <= bbox.maxLon;
      }
      if (haversinSays) {
        if (bboxSays == false) {
          System.out.println("centerLat=" + centerLat + " centerLon="+ centerLon+ " radiusMeters="+ radiusMeters);
          System.out.println("  bbox: lat=" + bbox.minLat + " to "+ bbox.maxLat+ " lon="+ bbox.minLon+ " to "+ bbox.maxLon);
          System.out.println("  point: lat=" + lat + " lon="+ lon);
          System.out.println("  haversin: " + distanceMeters);
          fail("point was within the distance according to haversin, but the bbox doesn't contain it");
        }
      }
 else {
      }
    }
  }
}
