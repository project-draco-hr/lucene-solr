{
  BytesRef flagsScratch=new BytesRef();
  IntsRef scratchInts=new IntsRef();
  StringBuilder sb=new StringBuilder();
  File unsorted=File.createTempFile("unsorted","dat",tempDir);
  try (ByteSequencesWriter writer=new ByteSequencesWriter(unsorted)){
    for (    InputStream dictionary : dictionaries) {
      BufferedReader lines=new BufferedReader(new InputStreamReader(dictionary,decoder));
      String line=lines.readLine();
      while ((line=lines.readLine()) != null) {
        line=unescapeEntry(line);
        if (needsInputCleaning) {
          int flagSep=line.lastIndexOf(FLAG_SEPARATOR);
          if (flagSep == -1) {
            CharSequence cleansed=cleanInput(line,sb);
            writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));
          }
 else {
            String text=line.substring(0,flagSep);
            CharSequence cleansed=cleanInput(text,sb);
            if (cleansed != sb) {
              sb.setLength(0);
              sb.append(cleansed);
            }
            sb.append(line.substring(flagSep));
            writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));
          }
        }
 else {
          writer.write(line.getBytes(StandardCharsets.UTF_8));
        }
      }
    }
  }
   File sorted=File.createTempFile("sorted","dat",tempDir);
  OfflineSorter sorter=new OfflineSorter(new Comparator<BytesRef>(){
    BytesRef scratch1=new BytesRef();
    BytesRef scratch2=new BytesRef();
    @Override public int compare(    BytesRef o1,    BytesRef o2){
      scratch1.bytes=o1.bytes;
      scratch1.offset=o1.offset;
      scratch1.length=o1.length;
      for (int i=scratch1.length - 1; i >= 0; i--) {
        if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR) {
          scratch1.length=i;
          break;
        }
      }
      scratch2.bytes=o2.bytes;
      scratch2.offset=o2.offset;
      scratch2.length=o2.length;
      for (int i=scratch2.length - 1; i >= 0; i--) {
        if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR) {
          scratch2.length=i;
          break;
        }
      }
      int cmp=scratch1.compareTo(scratch2);
      if (cmp == 0) {
        return o1.compareTo(o2);
      }
 else {
        return cmp;
      }
    }
  }
);
  sorter.sort(unsorted,sorted);
  unsorted.delete();
  ByteSequencesReader reader=new ByteSequencesReader(sorted);
  BytesRef scratchLine=new BytesRef();
  String currentEntry=null;
  IntsRef currentOrds=new IntsRef();
  String line;
  while (reader.read(scratchLine)) {
    line=scratchLine.utf8ToString();
    String entry;
    char wordForm[];
    int flagSep=line.lastIndexOf(FLAG_SEPARATOR);
    if (flagSep == -1) {
      wordForm=NOFLAGS;
      entry=line;
    }
 else {
      int end=line.indexOf('\t',flagSep);
      if (end == -1)       end=line.length();
      int end2=line.indexOf(' ',flagSep);
      if (end2 == -1)       end2=line.length();
      end=Math.min(end,end2);
      String flagPart=line.substring(flagSep + 1,end);
      if (aliasCount > 0) {
        flagPart=getAliasValue(Integer.parseInt(flagPart));
      }
      wordForm=flagParsingStrategy.parseFlags(flagPart);
      Arrays.sort(wordForm);
      entry=line.substring(0,flagSep);
    }
    int cmp=currentEntry == null ? 1 : entry.compareTo(currentEntry);
    if (cmp < 0) {
      throw new IllegalArgumentException("out of order: " + entry + " < "+ currentEntry);
    }
 else {
      encodeFlags(flagsScratch,wordForm);
      int ord=flagLookup.add(flagsScratch);
      if (ord < 0) {
        ord=(-ord) - 1;
      }
      if (cmp > 0 && currentEntry != null) {
        Util.toUTF32(currentEntry,scratchInts);
        words.add(scratchInts,currentOrds);
      }
      if (cmp > 0 || currentEntry == null) {
        currentEntry=entry;
        currentOrds=new IntsRef();
      }
      currentOrds.grow(currentOrds.length + 1);
      currentOrds.ints[currentOrds.length++]=ord;
    }
  }
  Util.toUTF32(currentEntry,scratchInts);
  words.add(scratchInts,currentOrds);
  reader.close();
  sorted.delete();
}
