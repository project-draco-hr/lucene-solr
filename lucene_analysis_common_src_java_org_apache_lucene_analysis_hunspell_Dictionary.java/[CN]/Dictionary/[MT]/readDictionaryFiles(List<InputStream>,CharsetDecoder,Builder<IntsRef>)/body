{
  BytesRefBuilder flagsScratch=new BytesRefBuilder();
  IntsRefBuilder scratchInts=new IntsRefBuilder();
  StringBuilder sb=new StringBuilder();
  File unsorted=File.createTempFile("unsorted","dat",tempDir);
  try (ByteSequencesWriter writer=new ByteSequencesWriter(unsorted)){
    for (    InputStream dictionary : dictionaries) {
      BufferedReader lines=new BufferedReader(new InputStreamReader(dictionary,decoder));
      String line=lines.readLine();
      while ((line=lines.readLine()) != null) {
        if (line.isEmpty() || line.charAt(0) == '/' || line.charAt(0) == '#' || line.charAt(0) == '\t') {
          continue;
        }
        line=unescapeEntry(line);
        if (hasStemExceptions == false) {
          int morphStart=line.indexOf(MORPH_SEPARATOR);
          if (morphStart >= 0 && morphStart < line.length()) {
            hasStemExceptions=parseStemException(line.substring(morphStart + 1)) != null;
          }
        }
        if (needsInputCleaning) {
          int flagSep=line.indexOf(FLAG_SEPARATOR);
          if (flagSep == -1) {
            flagSep=line.indexOf(MORPH_SEPARATOR);
          }
          if (flagSep == -1) {
            CharSequence cleansed=cleanInput(line,sb);
            writer.write(cleansed.toString().getBytes(StandardCharsets.UTF_8));
          }
 else {
            String text=line.substring(0,flagSep);
            CharSequence cleansed=cleanInput(text,sb);
            if (cleansed != sb) {
              sb.setLength(0);
              sb.append(cleansed);
            }
            sb.append(line.substring(flagSep));
            writer.write(sb.toString().getBytes(StandardCharsets.UTF_8));
          }
        }
 else {
          writer.write(line.getBytes(StandardCharsets.UTF_8));
        }
      }
    }
  }
   File sorted=File.createTempFile("sorted","dat",tempDir);
  OfflineSorter sorter=new OfflineSorter(new Comparator<BytesRef>(){
    BytesRef scratch1=new BytesRef();
    BytesRef scratch2=new BytesRef();
    @Override public int compare(    BytesRef o1,    BytesRef o2){
      scratch1.bytes=o1.bytes;
      scratch1.offset=o1.offset;
      scratch1.length=o1.length;
      for (int i=scratch1.length - 1; i >= 0; i--) {
        if (scratch1.bytes[scratch1.offset + i] == FLAG_SEPARATOR || scratch1.bytes[scratch1.offset + i] == MORPH_SEPARATOR) {
          scratch1.length=i;
          break;
        }
      }
      scratch2.bytes=o2.bytes;
      scratch2.offset=o2.offset;
      scratch2.length=o2.length;
      for (int i=scratch2.length - 1; i >= 0; i--) {
        if (scratch2.bytes[scratch2.offset + i] == FLAG_SEPARATOR || scratch2.bytes[scratch2.offset + i] == MORPH_SEPARATOR) {
          scratch2.length=i;
          break;
        }
      }
      int cmp=scratch1.compareTo(scratch2);
      if (cmp == 0) {
        return o1.compareTo(o2);
      }
 else {
        return cmp;
      }
    }
  }
);
  sorter.sort(unsorted,sorted);
  unsorted.delete();
  ByteSequencesReader reader=new ByteSequencesReader(sorted);
  BytesRefBuilder scratchLine=new BytesRefBuilder();
  String currentEntry=null;
  IntsRefBuilder currentOrds=new IntsRefBuilder();
  String line;
  while (reader.read(scratchLine)) {
    line=scratchLine.get().utf8ToString();
    String entry;
    char wordForm[];
    int end;
    int flagSep=line.indexOf(FLAG_SEPARATOR);
    if (flagSep == -1) {
      wordForm=NOFLAGS;
      end=line.indexOf(MORPH_SEPARATOR);
      entry=line.substring(0,end);
    }
 else {
      end=line.indexOf(MORPH_SEPARATOR);
      String flagPart=line.substring(flagSep + 1,end);
      if (aliasCount > 0) {
        flagPart=getAliasValue(Integer.parseInt(flagPart));
      }
      wordForm=flagParsingStrategy.parseFlags(flagPart);
      Arrays.sort(wordForm);
      entry=line.substring(0,flagSep);
    }
    int stemExceptionID=0;
    if (hasStemExceptions && end + 1 < line.length()) {
      String stemException=parseStemException(line.substring(end + 1));
      if (stemException != null) {
        if (stemExceptionCount == stemExceptions.length) {
          int newSize=ArrayUtil.oversize(stemExceptionCount + 1,RamUsageEstimator.NUM_BYTES_OBJECT_REF);
          stemExceptions=Arrays.copyOf(stemExceptions,newSize);
        }
        stemExceptionID=stemExceptionCount + 1;
        stemExceptions[stemExceptionCount++]=stemException;
      }
    }
    int cmp=currentEntry == null ? 1 : entry.compareTo(currentEntry);
    if (cmp < 0) {
      throw new IllegalArgumentException("out of order: " + entry + " < "+ currentEntry);
    }
 else {
      encodeFlags(flagsScratch,wordForm);
      int ord=flagLookup.add(flagsScratch.get());
      if (ord < 0) {
        ord=(-ord) - 1;
      }
      if (cmp > 0 && currentEntry != null) {
        Util.toUTF32(currentEntry,scratchInts);
        words.add(scratchInts.get(),currentOrds.get());
      }
      if (cmp > 0 || currentEntry == null) {
        currentEntry=entry;
        currentOrds=new IntsRefBuilder();
      }
      if (hasStemExceptions) {
        currentOrds.append(ord);
        currentOrds.append(stemExceptionID);
      }
 else {
        currentOrds.append(ord);
      }
    }
  }
  Util.toUTF32(currentEntry,scratchInts);
  words.add(scratchInts.get(),currentOrds.get());
  reader.close();
  sorted.delete();
}
