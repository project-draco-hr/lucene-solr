{
  final double L=StrictMath.toRadians(lonB - lonA);
  final double oF=1 - GeoProjectionUtils.FLATTENING;
  final double U1=StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latA)));
  final double U2=StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latB)));
  final double sU1=StrictMath.sin(U1);
  final double cU1=StrictMath.cos(U1);
  final double sU2=StrictMath.sin(U2);
  final double cU2=StrictMath.cos(U2);
  double sigma, sinSigma, cosSigma;
  double sinAlpha, cos2Alpha, cos2SigmaM;
  double lambda=L;
  double lambdaP;
  double iters=100;
  double sinLambda, cosLambda, c;
  do {
    sinLambda=StrictMath.sin(lambda);
    cosLambda=Math.cos(lambda);
    sinSigma=Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda) * (cU1 * sU2 - sU1 * cU2 * cosLambda));
    if (sinSigma == 0) {
      return 0;
    }
    cosSigma=sU1 * sU2 + cU1 * cU2 * cosLambda;
    sigma=Math.atan2(sinSigma,cosSigma);
    sinAlpha=cU1 * cU2 * sinLambda / sinSigma;
    cos2Alpha=1 - sinAlpha * sinAlpha;
    cos2SigmaM=cosSigma - 2 * sU1 * sU2 / cos2Alpha;
    c=GeoProjectionUtils.FLATTENING / 16 * cos2Alpha * (4 + GeoProjectionUtils.FLATTENING * (4 - 3 * cos2Alpha));
    lambdaP=lambda;
    lambda=L + (1 - c) * GeoProjectionUtils.FLATTENING * sinAlpha* (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  }
 while (StrictMath.abs(lambda - lambdaP) > 1E-12 && --iters > 0);
  if (iters == 0) {
    return 0;
  }
  final double uSq=cos2Alpha * (GeoProjectionUtils.SEMIMAJOR_AXIS2 - GeoProjectionUtils.SEMIMINOR_AXIS2) / (GeoProjectionUtils.SEMIMINOR_AXIS2);
  final double A=1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  final double B=uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  final double deltaSigma=B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
  return (GeoProjectionUtils.SEMIMINOR_AXIS * A * (sigma - deltaSigma));
}
