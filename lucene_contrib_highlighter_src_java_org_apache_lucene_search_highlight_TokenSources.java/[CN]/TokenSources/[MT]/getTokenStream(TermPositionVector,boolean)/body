{
  if (!tokenPositionsGuaranteedContiguous && tpv.getTermPositions(0) != null) {
    return new TokenStreamFromTermPositionVector(tpv);
  }
class StoredTokenStream extends TokenStream {
    Token tokens[];
    int currentToken=0;
    TermAttribute termAtt;
    OffsetAttribute offsetAtt;
    StoredTokenStream(    Token tokens[]){
      this.tokens=tokens;
      termAtt=addAttribute(TermAttribute.class);
      offsetAtt=addAttribute(OffsetAttribute.class);
    }
    @Override public boolean incrementToken() throws IOException {
      if (currentToken >= tokens.length) {
        return false;
      }
      Token token=tokens[currentToken++];
      clearAttributes();
      termAtt.setTermBuffer(token.term());
      offsetAtt.setOffset(token.startOffset(),token.endOffset());
      return true;
    }
  }
  String[] terms=tpv.getTerms();
  int[] freq=tpv.getTermFrequencies();
  int totalTokens=0;
  for (int t=0; t < freq.length; t++) {
    totalTokens+=freq[t];
  }
  Token tokensInOriginalOrder[]=new Token[totalTokens];
  ArrayList<Token> unsortedTokens=null;
  for (int t=0; t < freq.length; t++) {
    TermVectorOffsetInfo[] offsets=tpv.getOffsets(t);
    if (offsets == null) {
      throw new IllegalArgumentException("Required TermVector Offset information was not found");
    }
    int[] pos=null;
    if (tokenPositionsGuaranteedContiguous) {
      pos=tpv.getTermPositions(t);
    }
    if (pos == null) {
      if (unsortedTokens == null) {
        unsortedTokens=new ArrayList<Token>();
      }
      for (int tp=0; tp < offsets.length; tp++) {
        Token token=new Token(offsets[tp].getStartOffset(),offsets[tp].getEndOffset());
        token.setTermBuffer(terms[t]);
        unsortedTokens.add(token);
      }
    }
 else {
      for (int tp=0; tp < pos.length; tp++) {
        Token token=new Token(terms[t],offsets[tp].getStartOffset(),offsets[tp].getEndOffset());
        tokensInOriginalOrder[pos[tp]]=token;
      }
    }
  }
  if (unsortedTokens != null) {
    tokensInOriginalOrder=unsortedTokens.toArray(new Token[unsortedTokens.size()]);
    Arrays.sort(tokensInOriginalOrder,new Comparator<Token>(){
      public int compare(      Token t1,      Token t2){
        if (t1.startOffset() > t2.endOffset())         return 1;
        if (t1.startOffset() < t2.startOffset())         return -1;
        return 0;
      }
    }
);
  }
  return new StoredTokenStream(tokensInOriginalOrder);
}
