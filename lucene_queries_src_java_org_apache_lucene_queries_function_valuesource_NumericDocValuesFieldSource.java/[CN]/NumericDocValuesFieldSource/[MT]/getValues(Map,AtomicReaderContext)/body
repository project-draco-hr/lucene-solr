{
  final DocValues.Source source=getSource(readerContext.reader(),DocValues.Type.FLOAT_64);
  final Bits liveDocs=readerContext.reader().getLiveDocs();
switch (source.getType()) {
case FIXED_INTS_8:
case FIXED_INTS_16:
case FIXED_INTS_32:
case FIXED_INTS_64:
case VAR_INTS:
    if (source.hasArray()) {
      final Object valuesArr=source.getArray();
      if (valuesArr instanceof long[]) {
        final long[] values=(long[])source.getArray();
        return new DVLongValues(this,source,liveDocs){
          @Override public long longVal(          int doc){
            return values[doc];
          }
        }
;
      }
 else       if (valuesArr instanceof int[]) {
        final int[] values=(int[])source.getArray();
        return new DVIntValues(this,source,liveDocs){
          @Override public int intVal(          int doc){
            return values[doc];
          }
        }
;
      }
 else       if (valuesArr instanceof short[]) {
        final short[] values=(short[])source.getArray();
        return new DVIntValues(this,source,liveDocs){
          @Override public int intVal(          int doc){
            return values[doc];
          }
          @Override public Object objectVal(          int doc){
            return shortVal(doc);
          }
        }
;
      }
 else       if (valuesArr instanceof byte[]) {
        final byte[] values=(byte[])source.getArray();
        return new DVIntValues(this,source,liveDocs){
          @Override public int intVal(          int doc){
            return values[doc];
          }
          @Override public Object objectVal(          int doc){
            return byteVal(doc);
          }
        }
;
      }
    }
  return new DVLongValues(this,source,liveDocs){
    @Override public Object objectVal(    int doc){
switch (source.getType()) {
case FIXED_INTS_8:
        return byteVal(doc);
case FIXED_INTS_16:
      return shortVal(doc);
case FIXED_INTS_32:
    return intVal(doc);
case FIXED_INTS_64:
case VAR_INTS:
  return longVal(doc);
default :
throw new AssertionError();
}
}
}
;
case FLOAT_32:
case FLOAT_64:
if (source.hasArray()) {
final Object valuesArr=source.getArray();
if (valuesArr instanceof float[]) {
final float[] values=(float[])valuesArr;
return new FloatDocValues(this){
@Override public boolean exists(int doc){
return liveDocs == null || liveDocs.get(doc);
}
@Override public boolean bytesVal(int doc,BytesRef target){
source.getBytes(doc,target);
return true;
}
@Override public float floatVal(int doc){
return values[doc];
}
}
;
}
 else if (valuesArr instanceof double[]) {
final double[] values=(double[])valuesArr;
return new DVDoubleValues(this,source,liveDocs){
@Override public double doubleVal(int doc){
return values[doc];
}
}
;
}
}
return new DVDoubleValues(this,source,liveDocs){
@Override public Object objectVal(int doc){
switch (source.getType()) {
case FLOAT_32:
return floatVal(doc);
case FLOAT_64:
return doubleVal(doc);
default :
throw new AssertionError();
}
}
}
;
default :
throw new IllegalStateException(getClass().getSimpleName() + " only works with numeric types, not " + source.getType());
}
}
