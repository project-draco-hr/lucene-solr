{
  Directory store=newDirectory();
  RandomIndexWriter writer=new RandomIndexWriter(random(),store,newIndexWriterConfig(TEST_VERSION_CURRENT,new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
  Field f1=newTextField("field","word",Field.Store.YES);
  Field f2=newTextField("field","word",Field.Store.YES);
  f2.setBoost(2.0f);
  Document d1=new Document();
  Document d2=new Document();
  d1.add(f1);
  d2.add(f2);
  writer.addDocument(d1);
  writer.addDocument(d2);
  IndexReader reader=writer.getReader();
  writer.close();
  final float[] scores=new float[4];
  IndexSearcher searcher=newSearcher(reader);
  searcher.search(new TermQuery(new Term("field","word")),new SimpleCollector(){
    private int base=0;
    private Scorer scorer;
    @Override public void setScorer(    Scorer scorer){
      this.scorer=scorer;
    }
    @Override public final void collect(    int doc) throws IOException {
      scores[doc + base]=scorer.score();
    }
    @Override protected void doSetNextReader(    AtomicReaderContext context) throws IOException {
      base=context.docBase;
    }
    @Override public boolean acceptsDocsOutOfOrder(){
      return true;
    }
  }
);
  float lastScore=0.0f;
  for (int i=0; i < 2; i++) {
    if (VERBOSE) {
      System.out.println(searcher.explain(new TermQuery(new Term("field","word")),i));
    }
    assertTrue("score: " + scores[i] + " should be > lastScore: "+ lastScore,scores[i] > lastScore);
    lastScore=scores[i];
  }
  reader.close();
  store.close();
}
