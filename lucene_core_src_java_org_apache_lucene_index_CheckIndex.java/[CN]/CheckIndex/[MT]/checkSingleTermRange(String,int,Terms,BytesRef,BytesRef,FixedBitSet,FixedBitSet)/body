{
  TermsEnum termsEnum=terms.iterator(null);
  TermsEnum.SeekStatus status=termsEnum.seekCeil(minTerm);
  if (status != TermsEnum.SeekStatus.FOUND) {
    throw new RuntimeException("failed to seek to existing term field=" + field + " term="+ minTerm);
  }
  long normalTermCount=getDocsFromTermRange(field,maxDoc,termsEnum,normalDocs,minTerm,maxTerm,false);
  long intersectTermCount=getDocsFromTermRange(field,maxDoc,terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm,true,maxTerm,false),true,false,Integer.MAX_VALUE,true),null),intersectDocs,minTerm,maxTerm,true);
  if (intersectTermCount > normalTermCount) {
    throw new RuntimeException("intersect returned too many terms: field=" + field + " intersectTermCount="+ intersectTermCount+ " normalTermCount="+ normalTermCount);
  }
  if (normalDocs.equals(intersectDocs) == false) {
    throw new RuntimeException("intersect visited different docs than straight terms enum: " + normalDocs.cardinality() + " for straight enum, vs "+ intersectDocs.cardinality()+ " for intersect, minTerm="+ minTerm+ " maxTerm="+ maxTerm);
  }
  return intersectTermCount != normalTermCount;
}
