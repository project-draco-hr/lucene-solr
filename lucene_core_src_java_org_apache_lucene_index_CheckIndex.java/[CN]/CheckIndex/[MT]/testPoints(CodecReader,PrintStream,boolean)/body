{
  FieldInfos fieldInfos=reader.getFieldInfos();
  Status.PointsStatus status=new Status.PointsStatus();
  try {
    if (fieldInfos.hasPointValues()) {
      PointReader values=reader.getPointReader();
      if (values == null) {
        throw new RuntimeException("there are fields with points, but reader.getPointReader() is null");
      }
      for (      FieldInfo fieldInfo : fieldInfos) {
        if (fieldInfo.getPointDimensionCount() > 0) {
          FixedBitSet docsSeen=new FixedBitSet(reader.maxDoc());
          status.totalValueFields++;
          int dimCount=fieldInfo.getPointDimensionCount();
          int bytesPerDim=fieldInfo.getPointNumBytes();
          int packedBytesCount=dimCount * bytesPerDim;
          byte[] lastMinPackedValue=new byte[packedBytesCount];
          byte[] lastMaxPackedValue=new byte[packedBytesCount];
          BytesRef scratch=new BytesRef();
          scratch.length=bytesPerDim;
          byte[] lastPackedValue=new byte[packedBytesCount];
          long[] pointCountSeen=new long[1];
          byte[] globalMinPackedValue=values.getMinPackedValue(fieldInfo.name);
          long size=values.size(fieldInfo.name);
          int docCount=values.getDocCount(fieldInfo.name);
          if (docCount > size) {
            throw new RuntimeException("point values for field \"" + fieldInfo.name + "\" claims to have size="+ size+ " points and inconsistent docCount="+ docCount);
          }
          if (docCount > reader.maxDoc()) {
            throw new RuntimeException("point values for field \"" + fieldInfo.name + "\" claims to have docCount="+ docCount+ " but that's greater than maxDoc="+ reader.maxDoc());
          }
          if (globalMinPackedValue == null) {
            if (size != 0) {
              throw new RuntimeException("getMinPackedValue is null points for field \"" + fieldInfo.name + "\" yet size="+ size);
            }
          }
 else           if (globalMinPackedValue.length != packedBytesCount) {
            throw new RuntimeException("getMinPackedValue for field \"" + fieldInfo.name + "\" return length="+ globalMinPackedValue.length+ " array, but should be "+ packedBytesCount);
          }
          byte[] globalMaxPackedValue=values.getMaxPackedValue(fieldInfo.name);
          if (globalMaxPackedValue == null) {
            if (size != 0) {
              throw new RuntimeException("getMaxPackedValue is null points for field \"" + fieldInfo.name + "\" yet size="+ size);
            }
          }
 else           if (globalMaxPackedValue.length != packedBytesCount) {
            throw new RuntimeException("getMaxPackedValue for field \"" + fieldInfo.name + "\" return length="+ globalMaxPackedValue.length+ " array, but should be "+ packedBytesCount);
          }
          values.intersect(fieldInfo.name,new PointValues.IntersectVisitor(){
            private int lastDocID=-1;
            @Override public void visit(            int docID){
              throw new RuntimeException("codec called IntersectVisitor.visit without a packed value for docID=" + docID);
            }
            @Override public void visit(            int docID,            byte[] packedValue){
              checkPackedValue("packed value",packedValue,docID);
              pointCountSeen[0]++;
              docsSeen.set(docID);
              for (int dim=0; dim < dimCount; dim++) {
                int offset=bytesPerDim * dim;
                if (StringHelper.compare(bytesPerDim,packedValue,offset,lastMinPackedValue,offset) < 0) {
                  throw new RuntimeException("packed points value " + Arrays.toString(packedValue) + " for docID="+ docID+ " is out-of-bounds of the last cell min="+ Arrays.toString(lastMinPackedValue)+ " max="+ Arrays.toString(lastMaxPackedValue)+ " dim="+ dim);
                }
                if (StringHelper.compare(bytesPerDim,packedValue,offset,lastMaxPackedValue,offset) > 0) {
                  throw new RuntimeException("packed points value " + Arrays.toString(packedValue) + " for docID="+ docID+ " is out-of-bounds of the last cell min="+ Arrays.toString(lastMinPackedValue)+ " max="+ Arrays.toString(lastMaxPackedValue)+ " dim="+ dim);
                }
              }
              if (dimCount == 1) {
                int cmp=StringHelper.compare(bytesPerDim,lastPackedValue,0,packedValue,0);
                if (cmp > 0) {
                  throw new RuntimeException("packed points value " + Arrays.toString(packedValue) + " for docID="+ docID+ " is out-of-order vs the previous document's value "+ Arrays.toString(lastPackedValue));
                }
 else                 if (cmp == 0) {
                  if (docID < lastDocID) {
                    throw new RuntimeException("packed points value is the same, but docID=" + docID + " is out of order vs previous docID="+ lastDocID);
                  }
                }
                System.arraycopy(packedValue,0,lastPackedValue,0,bytesPerDim);
                lastDocID=docID;
              }
              status.totalValuePoints++;
            }
            @Override public PointValues.Relation compare(            byte[] minPackedValue,            byte[] maxPackedValue){
              checkPackedValue("min packed value",minPackedValue,-1);
              System.arraycopy(minPackedValue,0,lastMinPackedValue,0,packedBytesCount);
              checkPackedValue("max packed value",maxPackedValue,-1);
              System.arraycopy(maxPackedValue,0,lastMaxPackedValue,0,packedBytesCount);
              for (int dim=0; dim < dimCount; dim++) {
                int offset=bytesPerDim * dim;
                if (StringHelper.compare(bytesPerDim,minPackedValue,offset,globalMinPackedValue,offset) < 0) {
                  throw new RuntimeException("packed points cell minPackedValue " + Arrays.toString(minPackedValue) + " is out-of-bounds of the global minimum "+ Arrays.toString(globalMinPackedValue)+ " dim="+ dim);
                }
                if (StringHelper.compare(bytesPerDim,maxPackedValue,offset,globalMinPackedValue,offset) < 0) {
                  throw new RuntimeException("packed points cell maxPackedValue " + Arrays.toString(minPackedValue) + " is out-of-bounds of the global minimum "+ Arrays.toString(globalMinPackedValue)+ " dim="+ dim);
                }
                if (StringHelper.compare(bytesPerDim,minPackedValue,offset,globalMaxPackedValue,offset) > 0) {
                  throw new RuntimeException("packed points cell minPackedValue " + Arrays.toString(minPackedValue) + " is out-of-bounds of the global maximum "+ Arrays.toString(globalMaxPackedValue)+ " dim="+ dim);
                }
                if (StringHelper.compare(bytesPerDim,maxPackedValue,offset,globalMaxPackedValue,offset) > 0) {
                  throw new RuntimeException("packed points cell maxPackedValue " + Arrays.toString(maxPackedValue) + " is out-of-bounds of the global maximum "+ Arrays.toString(globalMaxPackedValue)+ " dim="+ dim);
                }
              }
              return PointValues.Relation.CELL_CROSSES_QUERY;
            }
            private void checkPackedValue(            String desc,            byte[] packedValue,            int docID){
              if (packedValue == null) {
                throw new RuntimeException(desc + " is null for docID=" + docID);
              }
              if (packedValue.length != packedBytesCount) {
                throw new RuntimeException(desc + " has incorrect length=" + packedValue.length+ " vs expected="+ packedBytesCount+ " for docID="+ docID);
              }
            }
          }
);
          if (pointCountSeen[0] != size) {
            throw new RuntimeException("point values for field \"" + fieldInfo.name + "\" claims to have size="+ size+ " points, but in fact has "+ pointCountSeen[0]);
          }
          if (docsSeen.cardinality() != docCount) {
            throw new RuntimeException("point values for field \"" + fieldInfo.name + "\" claims to have docCount="+ docCount+ " but in fact has "+ docsSeen.cardinality());
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    if (failFast) {
      IOUtils.reThrow(e);
    }
    msg(infoStream,"ERROR: " + e);
    status.error=e;
    if (infoStream != null) {
      e.printStackTrace(infoStream);
    }
  }
  return status;
}
