{
  if (dv == null) {
    return;
  }
  checkBinaryDocValues(fieldName,reader,dv);
  final int maxOrd=dv.getValueCount() - 1;
  FixedBitSet seenOrds=new FixedBitSet(dv.getValueCount());
  int maxOrd2=-1;
  for (int i=0; i < reader.maxDoc(); i++) {
    int ord=dv.getOrd(i);
    if (ord < 0 || ord > maxOrd) {
      throw new RuntimeException("ord out of bounds: " + ord);
    }
    maxOrd2=Math.max(maxOrd2,ord);
    seenOrds.set(ord);
  }
  if (maxOrd != maxOrd2) {
    throw new RuntimeException("dv for field: " + fieldName + " reports wrong maxOrd="+ maxOrd+ " but this is not the case: "+ maxOrd2);
  }
  if (seenOrds.cardinality() != dv.getValueCount()) {
    throw new RuntimeException("dv for field: " + fieldName + " has holes in its ords, valueCount="+ dv.getValueCount()+ " but only used: "+ seenOrds.cardinality());
  }
  BytesRef lastValue=null;
  BytesRef scratch=new BytesRef();
  for (int i=0; i <= maxOrd; i++) {
    dv.lookupOrd(i,scratch);
    if (lastValue != null) {
      if (scratch.compareTo(lastValue) <= 0) {
        throw new RuntimeException("dv for field: " + fieldName + " has ords out of order: "+ lastValue+ " >="+ scratch);
      }
    }
    lastValue=BytesRef.deepCopyOf(scratch);
  }
}
