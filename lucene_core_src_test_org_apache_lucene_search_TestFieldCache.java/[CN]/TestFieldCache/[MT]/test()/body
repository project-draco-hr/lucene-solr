{
  FieldCache cache=FieldCache.DEFAULT;
  FieldCache.Doubles doubles=cache.getDoubles(reader,"theDouble",random().nextBoolean());
  assertSame("Second request to cache return same array",doubles,cache.getDoubles(reader,"theDouble",random().nextBoolean()));
  assertSame("Second request with explicit parser return same array",doubles,cache.getDoubles(reader,"theDouble",FieldCache.DEFAULT_DOUBLE_PARSER,random().nextBoolean()));
  for (int i=0; i < NUM_DOCS; i++) {
    assertTrue(doubles.get(i) + " does not equal: " + (Double.MAX_VALUE - i),doubles.get(i) == (Double.MAX_VALUE - i));
  }
  FieldCache.Longs longs=cache.getLongs(reader,"theLong",random().nextBoolean());
  assertSame("Second request to cache return same array",longs,cache.getLongs(reader,"theLong",random().nextBoolean()));
  assertSame("Second request with explicit parser return same array",longs,cache.getLongs(reader,"theLong",FieldCache.DEFAULT_LONG_PARSER,random().nextBoolean()));
  for (int i=0; i < NUM_DOCS; i++) {
    assertTrue(longs.get(i) + " does not equal: " + (Long.MAX_VALUE - i)+ " i="+ i,longs.get(i) == (Long.MAX_VALUE - i));
  }
  FieldCache.Bytes bytes=cache.getBytes(reader,"theByte",random().nextBoolean());
  assertSame("Second request to cache return same array",bytes,cache.getBytes(reader,"theByte",random().nextBoolean()));
  assertSame("Second request with explicit parser return same array",bytes,cache.getBytes(reader,"theByte",FieldCache.DEFAULT_BYTE_PARSER,random().nextBoolean()));
  for (int i=0; i < NUM_DOCS; i++) {
    assertTrue(bytes.get(i) + " does not equal: " + (Byte.MAX_VALUE - i),bytes.get(i) == (byte)(Byte.MAX_VALUE - i));
  }
  FieldCache.Shorts shorts=cache.getShorts(reader,"theShort",random().nextBoolean());
  assertSame("Second request to cache return same array",shorts,cache.getShorts(reader,"theShort",random().nextBoolean()));
  assertSame("Second request with explicit parser return same array",shorts,cache.getShorts(reader,"theShort",FieldCache.DEFAULT_SHORT_PARSER,random().nextBoolean()));
  for (int i=0; i < NUM_DOCS; i++) {
    assertTrue(shorts.get(i) + " does not equal: " + (Short.MAX_VALUE - i),shorts.get(i) == (short)(Short.MAX_VALUE - i));
  }
  FieldCache.Ints ints=cache.getInts(reader,"theInt",random().nextBoolean());
  assertSame("Second request to cache return same array",ints,cache.getInts(reader,"theInt",random().nextBoolean()));
  assertSame("Second request with explicit parser return same array",ints,cache.getInts(reader,"theInt",FieldCache.DEFAULT_INT_PARSER,random().nextBoolean()));
  for (int i=0; i < NUM_DOCS; i++) {
    assertTrue(ints.get(i) + " does not equal: " + (Integer.MAX_VALUE - i),ints.get(i) == (Integer.MAX_VALUE - i));
  }
  FieldCache.Floats floats=cache.getFloats(reader,"theFloat",random().nextBoolean());
  assertSame("Second request to cache return same array",floats,cache.getFloats(reader,"theFloat",random().nextBoolean()));
  assertSame("Second request with explicit parser return same array",floats,cache.getFloats(reader,"theFloat",FieldCache.DEFAULT_FLOAT_PARSER,random().nextBoolean()));
  for (int i=0; i < NUM_DOCS; i++) {
    assertTrue(floats.get(i) + " does not equal: " + (Float.MAX_VALUE - i),floats.get(i) == (Float.MAX_VALUE - i));
  }
  Bits docsWithField=cache.getDocsWithField(reader,"theLong");
  assertSame("Second request to cache return same array",docsWithField,cache.getDocsWithField(reader,"theLong"));
  assertTrue("docsWithField(theLong) must be class Bits.MatchAllBits",docsWithField instanceof Bits.MatchAllBits);
  assertTrue("docsWithField(theLong) Size: " + docsWithField.length() + " is not: "+ NUM_DOCS,docsWithField.length() == NUM_DOCS);
  for (int i=0; i < docsWithField.length(); i++) {
    assertTrue(docsWithField.get(i));
  }
  docsWithField=cache.getDocsWithField(reader,"sparse");
  assertSame("Second request to cache return same array",docsWithField,cache.getDocsWithField(reader,"sparse"));
  assertFalse("docsWithField(sparse) must not be class Bits.MatchAllBits",docsWithField instanceof Bits.MatchAllBits);
  assertTrue("docsWithField(sparse) Size: " + docsWithField.length() + " is not: "+ NUM_DOCS,docsWithField.length() == NUM_DOCS);
  for (int i=0; i < docsWithField.length(); i++) {
    assertEquals(i % 2 == 0,docsWithField.get(i));
  }
  SortedDocValues termsIndex=cache.getTermsIndex(reader,"theRandomUnicodeString");
  assertSame("Second request to cache return same array",termsIndex,cache.getTermsIndex(reader,"theRandomUnicodeString"));
  final BytesRef br=new BytesRef();
  for (int i=0; i < NUM_DOCS; i++) {
    final BytesRef term;
    final int ord=termsIndex.getOrd(i);
    if (ord == -1) {
      term=null;
    }
 else {
      termsIndex.lookupOrd(ord,br);
      term=br;
    }
    final String s=term == null ? null : term.utf8ToString();
    assertTrue("for doc " + i + ": "+ s+ " does not equal: "+ unicodeStrings[i],unicodeStrings[i] == null || unicodeStrings[i].equals(s));
  }
  int nTerms=termsIndex.getValueCount();
  TermsEnum tenum=new SortedDocValuesTermsEnum(termsIndex);
  BytesRef val=new BytesRef();
  for (int i=0; i < nTerms; i++) {
    BytesRef val1=tenum.next();
    termsIndex.lookupOrd(i,val);
    assertEquals(val,val1);
  }
  int num=atLeast(100);
  for (int i=0; i < num; i++) {
    int k=_TestUtil.nextInt(random(),1,nTerms - 1);
    termsIndex.lookupOrd(k,val);
    assertEquals(TermsEnum.SeekStatus.FOUND,tenum.seekCeil(val));
    assertEquals(val,tenum.term());
  }
  termsIndex=cache.getTermsIndex(reader,"bogusfield");
  BinaryDocValues terms=cache.getTerms(reader,"theRandomUnicodeString");
  assertSame("Second request to cache return same array",terms,cache.getTerms(reader,"theRandomUnicodeString"));
  for (int i=0; i < NUM_DOCS; i++) {
    terms.get(i,br);
    final BytesRef term;
    if (br.bytes == BinaryDocValues.MISSING) {
      term=null;
    }
 else {
      term=br;
    }
    final String s=term == null ? null : term.utf8ToString();
    assertTrue("for doc " + i + ": "+ s+ " does not equal: "+ unicodeStrings[i],unicodeStrings[i] == null || unicodeStrings[i].equals(s));
  }
  terms=cache.getTerms(reader,"bogusfield");
  DocTermOrds termOrds=cache.getDocTermOrds(reader,"theRandomUnicodeMultiValuedField");
  TermsEnum termsEnum=termOrds.getOrdTermsEnum(reader);
  assertSame("Second request to cache return same DocTermOrds",termOrds,cache.getDocTermOrds(reader,"theRandomUnicodeMultiValuedField"));
  DocTermOrds.TermOrdsIterator reuse=null;
  for (int i=0; i < NUM_DOCS; i++) {
    reuse=termOrds.lookup(i,reuse);
    final int[] buffer=new int[5];
    List<BytesRef> values=new ArrayList<BytesRef>(new LinkedHashSet<BytesRef>(Arrays.asList(multiValued[i])));
    for (; ; ) {
      int chunk=reuse.read(buffer);
      if (chunk == 0) {
        for (int ord=0; ord < values.size(); ord++) {
          BytesRef term=values.get(ord);
          assertNull(String.format(Locale.ROOT,"Document[%d] misses field must be null. Has value %s for ord %d",i,term,ord),term);
        }
        break;
      }
      for (int idx=0; idx < chunk; idx++) {
        int key=buffer[idx];
        termsEnum.seekExact((long)key);
        String actual=termsEnum.term().utf8ToString();
        String expected=values.get(idx).utf8ToString();
        if (!expected.equals(actual)) {
          reuse=termOrds.lookup(i,reuse);
          reuse.read(buffer);
        }
        assertTrue(String.format(Locale.ROOT,"Expected value %s for doc %d and ord %d, but was %s",expected,i,idx,actual),expected.equals(actual));
      }
      if (chunk <= buffer.length) {
        break;
      }
    }
  }
  termOrds=cache.getDocTermOrds(reader,"bogusfield");
  FieldCache.DEFAULT.purge(reader);
}
