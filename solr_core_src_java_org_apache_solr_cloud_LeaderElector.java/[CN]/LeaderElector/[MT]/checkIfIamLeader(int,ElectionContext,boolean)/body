{
  context.checkIfIamLeaderFired();
  final String holdElectionPath=context.electionPath + ELECTION_NODE;
  List<String> seqs=zkClient.getChildren(holdElectionPath,null,true);
  sortSeqs(seqs);
  List<Integer> intSeqs=getSeqs(seqs);
  if (intSeqs.size() == 0) {
    log.warn("Our node is no longer in line to be leader");
    return;
  }
  if (seq <= intSeqs.get(0)) {
    if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + "/" + seqs.get(0))) {
      log.info("was going be leader {} , seq(0) {}",context.leaderSeqPath,holdElectionPath + "/" + seqs.get(0));
      retryElection(context,false);
      return;
    }
    try {
      zkClient.delete(context.leaderPath,-1,true);
    }
 catch (    KeeperException.NoNodeException nne) {
    }
catch (    InterruptedException e) {
      throw e;
    }
catch (    Exception e) {
      log.error("leader elect delete error",e);
      retryElection(context,false);
      return;
    }
    try {
      runIamLeaderProcess(context,replacement);
    }
 catch (    KeeperException.NodeExistsException e) {
      log.error("node exists",e);
      retryElection(context,false);
      return;
    }
  }
 else {
    int i=1;
    for (; i < intSeqs.size(); i++) {
      int s=intSeqs.get(i);
      if (seq < s) {
        break;
      }
    }
    int index=i - 2;
    if (index < 0) {
      log.warn("Our node is no longer in line to be leader");
      return;
    }
    try {
      String watchedNode=holdElectionPath + "/" + seqs.get(index);
      zkClient.getData(watchedNode,watcher=new ElectionWatcher(context.leaderSeqPath,watchedNode,seq,context),null,true);
    }
 catch (    KeeperException.SessionExpiredException e) {
      throw e;
    }
catch (    KeeperException e) {
      log.warn("Failed setting watch",e);
      checkIfIamLeader(seq,context,true);
    }
  }
}
