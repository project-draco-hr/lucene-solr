{
  a.determinize();
  if (a.initial.numTransitions == 1) {
    Transition t=a.initial.transitionsArray[0];
    if (t.to == a.initial && t.min == Character.MIN_CODE_POINT && t.max == Character.MAX_CODE_POINT)     return;
  }
  a.totalize();
  final int[] sigma=a.getStartPoints();
  final State[] states=a.getNumberedStates();
  final int sigmaLen=sigma.length, statesLen=states.length;
  @SuppressWarnings("unchecked") final LinkedList<State>[][] reverse=(LinkedList<State>[][])new LinkedList[statesLen][sigmaLen];
  @SuppressWarnings("unchecked") final LinkedList<State>[] partition=(LinkedList<State>[])new LinkedList[statesLen];
  @SuppressWarnings("unchecked") final ArrayList<State>[] splitblock=(ArrayList<State>[])new ArrayList[statesLen];
  final int[] block=new int[statesLen];
  final StateList[][] active=new StateList[statesLen][sigmaLen];
  final StateListNode[][] active2=new StateListNode[statesLen][sigmaLen];
  final LinkedList<IntPair> pending=new LinkedList<IntPair>();
  final boolean[][] pending2=new boolean[sigmaLen][statesLen];
  final ArrayList<State> split=new ArrayList<State>();
  final boolean[] split2=new boolean[statesLen];
  final ArrayList<Integer> refine=new ArrayList<Integer>();
  final boolean[] refine2=new boolean[statesLen];
  for (int q=0; q < statesLen; q++) {
    splitblock[q]=new ArrayList<State>();
    partition[q]=new LinkedList<State>();
    for (int x=0; x < sigmaLen; x++) {
      active[q][x]=new StateList();
    }
  }
  for (int q=0; q < statesLen; q++) {
    final State qq=states[q];
    final int j=qq.accept ? 0 : 1;
    partition[j].add(qq);
    block[qq.number]=j;
    for (int x=0; x < sigmaLen; x++) {
      final LinkedList<State>[] r=reverse[qq.step(sigma[x]).number];
      if (r[x] == null)       r[x]=new LinkedList<State>();
      r[x].add(qq);
    }
  }
  for (int j=0; j <= 1; j++)   for (int x=0; x < sigmaLen; x++)   for (  State qq : partition[j])   if (reverse[qq.number][x] != null)   active2[qq.number][x]=active[j][x].add(qq);
  for (int x=0; x < sigmaLen; x++) {
    final int j=(active[0][x].size <= active[1][x].size) ? 0 : 1;
    pending.add(new IntPair(j,x));
    pending2[x][j]=true;
  }
  int k=2;
  while (!pending.isEmpty()) {
    IntPair ip=pending.removeFirst();
    final int p=ip.n1;
    final int x=ip.n2;
    pending2[x][p]=false;
    for (StateListNode m=active[p][x].first; m != null; m=m.next) {
      final LinkedList<State> r=reverse[m.q.number][x];
      if (r != null)       for (      State s : r) {
        if (!split2[s.number]) {
          split2[s.number]=true;
          split.add(s);
          final int j=block[s.number];
          splitblock[j].add(s);
          if (!refine2[j]) {
            refine2[j]=true;
            refine.add(j);
          }
        }
      }
    }
    for (    int j : refine) {
      if (splitblock[j].size() < partition[j].size()) {
        final LinkedList<State> b1=partition[j];
        final LinkedList<State> b2=partition[k];
        for (        State s : splitblock[j]) {
          b1.remove(s);
          b2.add(s);
          block[s.number]=k;
          for (int c=0; c < sigmaLen; c++) {
            final StateListNode sn=active2[s.number][c];
            if (sn != null && sn.sl == active[j][c]) {
              sn.remove();
              active2[s.number][c]=active[k][c].add(s);
            }
          }
        }
        for (int c=0; c < sigmaLen; c++) {
          final int aj=active[j][c].size;
          final int ak=active[k][c].size;
          if (!pending2[c][j] && 0 < aj && aj <= ak) {
            pending2[c][j]=true;
            pending.add(new IntPair(j,c));
          }
 else {
            pending2[c][k]=true;
            pending.add(new IntPair(k,c));
          }
        }
        k++;
      }
      for (      State s : splitblock[j])       split2[s.number]=false;
      refine2[j]=false;
      splitblock[j].clear();
    }
    split.clear();
    refine.clear();
  }
  State[] newstates=new State[k];
  for (int n=0; n < newstates.length; n++) {
    final State s=new State();
    newstates[n]=s;
    for (    State q : partition[n]) {
      if (q == a.initial)       a.initial=s;
      s.accept=q.accept;
      s.number=q.number;
      q.number=n;
    }
  }
  for (int n=0; n < newstates.length; n++) {
    final State s=newstates[n];
    s.accept=states[s.number].accept;
    for (    Transition t : states[s.number].getTransitions())     s.addTransition(new Transition(t.min,t.max,newstates[t.to.number]));
  }
  a.clearNumberedStates();
  a.removeDeadTransitions();
}
