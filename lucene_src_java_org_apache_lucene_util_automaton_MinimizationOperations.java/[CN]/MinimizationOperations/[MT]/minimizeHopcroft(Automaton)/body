{
  a.determinize();
  Set<Transition> tr=a.initial.getTransitions();
  if (tr.size() == 1) {
    Transition t=tr.iterator().next();
    if (t.to == a.initial && t.min == Character.MIN_VALUE && t.max == Character.MAX_VALUE)     return;
  }
  a.totalize();
  Set<State> ss=a.getStates();
  State[] states=new State[ss.size()];
  int number=0;
  for (  State q : ss) {
    states[number]=q;
    q.number=number++;
  }
  char[] sigma=a.getStartPoints();
  ArrayList<ArrayList<LinkedList<State>>> reverse=new ArrayList<ArrayList<LinkedList<State>>>();
  for (int q=0; q < states.length; q++) {
    ArrayList<LinkedList<State>> v=new ArrayList<LinkedList<State>>();
    initialize(v,sigma.length);
    reverse.add(v);
  }
  boolean[][] reverse_nonempty=new boolean[states.length][sigma.length];
  ArrayList<LinkedList<State>> partition=new ArrayList<LinkedList<State>>();
  initialize(partition,states.length);
  int[] block=new int[states.length];
  StateList[][] active=new StateList[states.length][sigma.length];
  StateListNode[][] active2=new StateListNode[states.length][sigma.length];
  LinkedList<IntPair> pending=new LinkedList<IntPair>();
  boolean[][] pending2=new boolean[sigma.length][states.length];
  ArrayList<State> split=new ArrayList<State>();
  boolean[] split2=new boolean[states.length];
  ArrayList<Integer> refine=new ArrayList<Integer>();
  boolean[] refine2=new boolean[states.length];
  ArrayList<ArrayList<State>> splitblock=new ArrayList<ArrayList<State>>();
  initialize(splitblock,states.length);
  for (int q=0; q < states.length; q++) {
    splitblock.set(q,new ArrayList<State>());
    partition.set(q,new LinkedList<State>());
    for (int x=0; x < sigma.length; x++) {
      reverse.get(q).set(x,new LinkedList<State>());
      active[q][x]=new StateList();
    }
  }
  for (int q=0; q < states.length; q++) {
    State qq=states[q];
    int j;
    if (qq.accept)     j=0;
 else     j=1;
    partition.get(j).add(qq);
    block[qq.number]=j;
    for (int x=0; x < sigma.length; x++) {
      char y=sigma[x];
      State p=qq.step(y);
      reverse.get(p.number).get(x).add(qq);
      reverse_nonempty[p.number][x]=true;
    }
  }
  for (int j=0; j <= 1; j++)   for (int x=0; x < sigma.length; x++)   for (  State qq : partition.get(j))   if (reverse_nonempty[qq.number][x])   active2[qq.number][x]=active[j][x].add(qq);
  for (int x=0; x < sigma.length; x++) {
    int a0=active[0][x].size;
    int a1=active[1][x].size;
    int j;
    if (a0 <= a1)     j=0;
 else     j=1;
    pending.add(new IntPair(j,x));
    pending2[x][j]=true;
  }
  int k=2;
  while (!pending.isEmpty()) {
    IntPair ip=pending.removeFirst();
    int p=ip.n1;
    int x=ip.n2;
    pending2[x][p]=false;
    for (StateListNode m=active[p][x].first; m != null; m=m.next)     for (    State s : reverse.get(m.q.number).get(x))     if (!split2[s.number]) {
      split2[s.number]=true;
      split.add(s);
      int j=block[s.number];
      splitblock.get(j).add(s);
      if (!refine2[j]) {
        refine2[j]=true;
        refine.add(j);
      }
    }
    for (    int j : refine) {
      if (splitblock.get(j).size() < partition.get(j).size()) {
        LinkedList<State> b1=partition.get(j);
        LinkedList<State> b2=partition.get(k);
        for (        State s : splitblock.get(j)) {
          b1.remove(s);
          b2.add(s);
          block[s.number]=k;
          for (int c=0; c < sigma.length; c++) {
            StateListNode sn=active2[s.number][c];
            if (sn != null && sn.sl == active[j][c]) {
              sn.remove();
              active2[s.number][c]=active[k][c].add(s);
            }
          }
        }
        for (int c=0; c < sigma.length; c++) {
          int aj=active[j][c].size;
          int ak=active[k][c].size;
          if (!pending2[c][j] && 0 < aj && aj <= ak) {
            pending2[c][j]=true;
            pending.add(new IntPair(j,c));
          }
 else {
            pending2[c][k]=true;
            pending.add(new IntPair(k,c));
          }
        }
        k++;
      }
      for (      State s : splitblock.get(j))       split2[s.number]=false;
      refine2[j]=false;
      splitblock.get(j).clear();
    }
    split.clear();
    refine.clear();
  }
  State[] newstates=new State[k];
  for (int n=0; n < newstates.length; n++) {
    State s=new State();
    newstates[n]=s;
    for (    State q : partition.get(n)) {
      if (q == a.initial)       a.initial=s;
      s.accept=q.accept;
      s.number=q.number;
      q.number=n;
    }
  }
  for (int n=0; n < newstates.length; n++) {
    State s=newstates[n];
    s.accept=states[s.number].accept;
    for (    Transition t : states[s.number].transitions)     s.transitions.add(new Transition(t.min,t.max,newstates[t.to.number]));
  }
  a.removeDeadTransitions();
}
