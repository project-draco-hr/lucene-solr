{
  final FixedBitSet bits=useBitSet ? new FixedBitSet(upper - lower + 1) : null;
  final Iterator<Integer> neededBounds=(expectedBounds == null) ? null : expectedBounds.iterator();
  final Iterator<Integer> neededShifts=(expectedShifts == null) ? null : expectedShifts.iterator();
  LegacyNumericUtils.splitIntRange(new LegacyNumericUtils.IntRangeBuilder(){
    @Override public void addRange(    int min,    int max,    int shift){
      assertTrue("min, max should be inside bounds",min >= lower && min <= upper && max >= lower && max <= upper);
      if (useBitSet)       for (int i=min; i <= max; i++) {
        assertFalse("ranges should not overlap",bits.getAndSet(i - lower));
        if (i == max)         break;
      }
      if (neededBounds == null)       return;
      min^=0x80000000;
      max^=0x80000000;
      assertEquals("shift",neededShifts.next().intValue(),shift);
      assertEquals("inner min bound",neededBounds.next().intValue(),min >>> shift);
      assertEquals("inner max bound",neededBounds.next().intValue(),max >>> shift);
    }
  }
,precisionStep,lower,upper);
  if (useBitSet) {
    bits.flip(0,upper - lower + 1);
    assertEquals("The sub-range concenated should match the whole range",0,bits.cardinality());
  }
}
